@Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) return false; if (getClass() != obj.getClass()) return false; SortedIntArray other = (SortedIntArray) obj; if (length != other.length) return false; for (int i = 0; i < length; i++) { if (a[i] != other.a[i]) return false; } return true; }
@Override public ItemStatus execute(WorkerParameters params, HandlerIO ioParam) { checkMandatoryParameters(params); handlerIO = ioParam; final ItemStatus globalCompositeItemStatus = new ItemStatus(HANDLER_ID); UnitType workflowUnitType = getUnitType(); try (LogbookLifeCyclesClient lifeCycleClient = handlerIO.getLifecyclesClient()) { if (asyncIO) { handlerIO.enableAsync(true); } checkMandatoryIOParameter(ioParam); globalSedaParametersFile = handlerIO.getNewLocalFile(handlerIO.getOutput(GLOBAL_SEDA_PARAMETERS_FILE_IO_RANK).getPath()); unmarshaller = jaxbContext.createUnmarshaller(); listener = new ArchiveUnitListener(handlerIO, archiveUnitTree, unitIdToGuid, guidToUnitId, unitIdToGroupId, objectGroupIdToUnitId, dataObjectIdToObjectGroupId, dataObjectIdWithoutObjectGroupId, guidToLifeCycleParameters, existingUnitGuids, params.getLogbookTypeProcess(), params.getContainerName(), metaDataClientFactory, objectGroupIdToGuid, dataObjectIdToGuid, unitIdToSetOfRuleId, workflowUnitType, originatingAgencies, existingGOTs, existingUnitIdWithExistingObjectGroup, isThereManifestRelatedReferenceRemained, existingGOTGUIDToNewGotGUIDInAttachment, adminManagementClientFactory); unmarshaller.setListener(listener); ObjectNode evDetData = extractSEDA(lifeCycleClient, params, globalCompositeItemStatus, workflowUnitType); if (!existingUnitGuids.isEmpty()) { evDetData.set(ATTACHMENT_IDS, JsonHandler.toJsonNode(existingUnitGuids)); } globalCompositeItemStatus.setEvDetailData(JsonHandler.unprettyPrint(evDetData)); globalCompositeItemStatus.setMasterData(LogbookParameterName.eventDetailData.name(), JsonHandler.unprettyPrint(evDetData)); globalCompositeItemStatus.increment(StatusCode.OK); if (asyncIO) { handlerIO.enableAsync(false); } ObjectNode agIdExt = JsonHandler.createObjectNode(); if (originatingAgency != null) { LOGGER.debug("supplier service is: " + originatingAgency); agIdExt.put(ORIGIN_ANGENCY_NAME, originatingAgency); } if (transferringAgency != null) { LOGGER.debug("Find a transfAgency: " + transferringAgency); agIdExt.put(TRANSFER_AGENCY, transferringAgency); } if (archivalAgency != null) { LOGGER.debug("Find a archivalAgency: " + archivalAgency); agIdExt.put(ARCHIVAL_AGENCY, archivalAgency); } if (submissionAgencyIdentifier != null) { LOGGER.debug("Find a submissionAgencyIdentifier: " + submissionAgencyIdentifier); agIdExt.put(ORIGIN_ANGENCY_SUBMISSION, submissionAgencyIdentifier); } if (agIdExt.size() > 0) { globalCompositeItemStatus.setMasterData(LogbookMongoDbName.agIdExt.getDbname(), agIdExt.toString()); globalCompositeItemStatus.setData(LogbookMongoDbName.agIdExt.getDbname(), agIdExt.toString()); } ObjectNode rightsStatementIdentifier = JsonHandler.createObjectNode(); if (ingestContract != null) { LOGGER.debug("contract name is: " + ingestContract.getIdentifier()); rightsStatementIdentifier.put(ARCHIVAl_AGREEMENT, ingestContract.getIdentifier()); } if (archivalProfile != null) { LOGGER.debug("archivalProfile is: " + archivalProfile); rightsStatementIdentifier.put(ARCHIVAl_PROFIL, archivalProfile); } extractOntology(); if (rightsStatementIdentifier.size() > 0) { globalCompositeItemStatus.setData(LogbookMongoDbName.rightsStatementIdentifier.getDbname(), rightsStatementIdentifier.toString()); globalCompositeItemStatus .setMasterData(LogbookMongoDbName.rightsStatementIdentifier.getDbname(), rightsStatementIdentifier.toString()); ObjectNode data; data = (ObjectNode) JsonHandler.getFromString(globalCompositeItemStatus.getEvDetailData()); data.set(LogbookMongoDbName.rightsStatementIdentifier.getDbname(), rightsStatementIdentifier); globalCompositeItemStatus.setEvDetailData(data.toString()); globalCompositeItemStatus.setData(LogbookMongoDbName.rightsStatementIdentifier.getDbname(), rightsStatementIdentifier.toString()); } } catch (final ProcessingDuplicatedVersionException e) { LOGGER.debug("ProcessingException: duplicated version", e); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingNotFoundException e) { LOGGER.debug("ProcessingException : " + e.getType() + " not found", e); String message; if (e.getType() == ExceptionType.UNIT) { message = getMessageItemStatusAUNotFound(e.getManifestId(), e.getGuid(), e.isValidGuid()); } else { message = getMessageItemStatusOGNotFound(e.getManifestId(), e.getGuid(), e.isValidGuid()); } updateDetailItemStatus(globalCompositeItemStatus, message, e.getTaskKey()); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingTooManyUnitsFoundException e) { LOGGER.debug("ProcessingException : multiple units found", e); updateDetailItemStatus(globalCompositeItemStatus, getMessageItemStatusAUNotFound(e.getUnitId(), e.getUnitGuid(), e.isValidGuid()), SUBTASK_TOO_MANY_FOUND_ATTACHMENT); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingTooManyVersionsByUsageException e) { LOGGER.debug("ProcessingException :", e); updateDetailItemStatus(globalCompositeItemStatus, JsonHandler.unprettyPrint(JsonHandler.createObjectNode().put("MsgError", e.getMessage())), SUBTASK_TOO_MANY_VERSION_BY_USAGE); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingMalformedDataException e) { LOGGER.debug("ProcessingException : Missing or malformed data in the manifest", e); ObjectNode error = JsonHandler.createObjectNode(); error.put("error", e.getMessage()); updateDetailItemStatus(globalCompositeItemStatus, JsonHandler.unprettyPrint(error), SUBTASK_MALFORMED); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingObjectReferenceException e) { LOGGER.error("ProcessingObjectReferenceException: archive unit references more than one got"); ObjectNode error = JsonHandler.createObjectNode(); error.put("error", e.getMessage()); updateDetailItemStatus(globalCompositeItemStatus, JsonHandler.unprettyPrint(error), AU_REFRENCES_MULTIPLE_GOT); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingManifestReferenceException e) { LOGGER.debug("ProcessingException : reference incorrect in Manifest", e); updateItemStatusForManifestReferenceException(globalCompositeItemStatus, e); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final MissingFieldException e) { LOGGER.debug("MissingFieldException", e); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingObjectGroupMasterMandatoryException e) { globalCompositeItemStatus.increment(StatusCode.KO); updateDetailItemStatus(globalCompositeItemStatus, getMessageItemStatusGOTMasterMandatory(e.getObjectGroupId()), MASTER_MANDATORY_REQUIRED); } catch (ProcessingObjectGroupEveryDataObjectVersionException e) { globalCompositeItemStatus.increment(StatusCode.KO); updateDetailItemStatus(globalCompositeItemStatus, getMessageItemStatusGOTEveryDataObjectVersion(e.getUnitId(), e.getObjectGroupId()), ATTACHMENT_OBJECTGROUP); } catch (final ArchiveUnitContainDataObjectException e) { LOGGER.debug("ProcessingException: archive unit contain an data object declared object group.", e); globalCompositeItemStatus.setEvDetailData(e.getEventDetailData()); updateDetailItemStatus(globalCompositeItemStatus, getMessageItemStatusAUDeclaringObject(e.getUnitId(), e.getBdoId(), e.getGotId()), EXISTING_OG_NOT_DECLARED); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ArchiveUnitContainSpecialCharactersException e) { LOGGER.debug("ProcessingException: archive unit contains special characters.", e); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingUnitLinkingException e) { LOGGER.debug("ProcessingException: Linking FILING_UNIT or HOLDING_UNIT to INGEST Unauthorized", e); updateDetailItemStatus(globalCompositeItemStatus, getMessageItemStatusAULinkingException(e), SUBTASK_UNAUTHORIZED_ATTACHMENT); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingAttachmentUnauthorizedException e) { updateDetailItemStatus(globalCompositeItemStatus, e.getMessage(), SUBTASK_UNAUTHORIZED_ATTACHMENT_BY_CONTRACT); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingNotValidLinkingException e) { updateDetailItemStatus(globalCompositeItemStatus, e.getMessage(), SUBTASK_UNAUTHORIZED_ATTACHMENT_BY_BAD_SP); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingAttachmentRequiredException e) { updateDetailItemStatus(globalCompositeItemStatus, e.getMessage(), SUBTASK_ATTACHMENT_REQUIRED); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingObjectGroupLinkingException e) { updateDetailItemStatus(globalCompositeItemStatus, getMessageItemStatusGOTLinkingException(e.getUnitId(), e.getObjectGroupId()), SUBTASK_UNAUTHORIZED_ATTACHMENT); globalCompositeItemStatus.increment(StatusCode.KO); } catch (final ProcessingException | WorkerspaceQueueException | InvalidParseOperationException e) { LOGGER.debug("ProcessingException ", e); globalCompositeItemStatus.increment(StatusCode.FATAL); } catch (final CycleFoundException e) { LOGGER.debug("ProcessingException: cycle found", e); globalCompositeItemStatus.setEvDetailData(e.getEventDetailData()); updateDetailItemStatus(globalCompositeItemStatus, e.getCycle(), SUBTASK_LOOP); globalCompositeItemStatus.increment(StatusCode.KO); } catch (JAXBException e) { LOGGER.error("unable to create ExtractSeda handler, unmarshaller failed", e); globalCompositeItemStatus.increment(StatusCode.FATAL); } finally { unitIdToGuid.clear(); guidToUnitId.clear(); dataObjectIdWithoutObjectGroupId.clear(); objectGroupIdToDataObjectId.clear(); guidToLifeCycleParameters.clear(); objectGuidToDataObject.clear(); dataObjectIdToDetailDataObject.clear(); existingGOTs.clear(); } return new ItemStatus(HANDLER_ID).setItemsStatus(HANDLER_ID, globalCompositeItemStatus); }
public long getCardinality() { traversePlan(queryPlan.getRoot()); long cardinality = joinEstimator.getCardinality(); if (cardinality == 0) { cardinality = filterEstimator.getCardinality(); } double selectivity = filterEstimator.getSelectivity(); return Math.round(cardinality * selectivity); }
@Override public void afterError(Request<?> request, Response<?> response, Exception e) { ApiCallMonitoringEvent event = generateApiCallMonitoringEvent(request, e); handToMonitoringListeners(event); }
protected void processForDocumentListPresenter(HistoryToken token) { if (!equal(token.getDocFilterExact(), currentHistoryState.getDocFilterExact()) || !equal(token.getDocFilterText(), currentHistoryState.getDocFilterText()) || !equal(token.isDocFilterCaseSensitive(), currentHistoryState.isDocFilterCaseSensitive())) { Log.info("[gwt-history] document list filter has changed"); documentListPresenter .updateFilterAndRun(token.getDocFilterText(), token.getDocFilterExact(), token.isDocFilterCaseSensitive()); } }
public static String format(final VType value, final FormatOption option, int precision, final boolean show_units) { precision = actualPrecision(value, precision); if (value == null) return "<null>"; if (value instanceof VNumber) { final VNumber number = (VNumber) value; final String text = formatNumber(number.getValue(), number.getDisplay(), option, precision); if (show_units && !number.getDisplay().getUnit().isEmpty()) return text + " " + number.getDisplay().getUnit(); return text; } else if (value instanceof VString) return ((VString)value).getValue(); else if (value instanceof VEnum) return formatEnum((VEnum) value, option); else if (value instanceof VBoolean) return formatBoolean((VBoolean)value); else if (value instanceof VNumberArray) { final VNumberArray array = (VNumberArray) value; if (option == FormatOption.STRING) return LongString.fromArray(array); final ListNumber data = array.getData(); if (data.size() <= 0) return "[]"; final StringBuilder buf = new StringBuilder("["); buf.append(formatNumber(data.getDouble(0), array.getDisplay(), option, precision)); final int show = Math.min(data.size(), Preferences.max_array_formatting); for (int i=1; i<show; ++i) { buf.append(", "); buf.append(formatNumber(data.getDouble(i), array.getDisplay(), option, precision)); } if (data.size() > show) buf.append(", ..."); buf.append("]"); if (show_units && !array.getDisplay().getUnit().isEmpty()) buf.append(" ").append(array.getDisplay().getUnit()); return buf.toString(); } else if (value instanceof VEnumArray) { final List<String> labels = ((VEnumArray)value).getDisplay().getChoices(); final StringBuilder buf = new StringBuilder("["); for (int i=0; i<labels.size(); ++i) { if (i > 0) buf.append(", "); buf.append(labels.get(i)); } buf.append("]"); return buf.toString(); } else if (value instanceof VStringArray) return StringList.join(((VStringArray)value).getData()); else if (value instanceof VImage) { final VImage image = (VImage) value; return "VImage(" + image.getWidth() + " x " + image.getHeight() + ")"; } else if (value instanceof VTable) return formatTable((VTable) value); return "<" + value.getClass().getName() + ">"; }
public String getTrack1() { return track1; }
@Override public Container flip(char x) { if (this.contains(x)) { return this.remove(x); } else { return this.add(x); } }
public Set<Card> deal(Deque<Card> deque, int count) { Set<Card> hand = new HashSet<>(); for (int i = 0; i < count; i++) { hand.add(deque.pop()); } return hand; }
@Override public int compare(Statement first, Statement second) { if (first == second) { return EQUAL; } if (first.getSubject().equals(second.getSubject())) { if (first.getPredicate().equals(second.getPredicate())) { if (first.getObject().equals(second.getObject())) { if (first.getContext() == null) { if (second.getContext() == null) { return EQUAL; } else { return BEFORE; } } else if (second.getContext() == null) { return AFTER; } else { return ValueComparator.getInstance().compare(first.getContext(), second.getContext()); } } else { return ValueComparator.getInstance().compare(first.getObject(), second.getObject()); } } else { return ValueComparator.getInstance().compare(first.getPredicate(), second.getPredicate()); } } else { return ValueComparator.getInstance().compare(first.getSubject(), second.getSubject()); } }
@Override public List filterResults(List results) { for (int i = 0; i < results.size(); i++) { Object result = results.get(i); if (result instanceof String) { results.set(i, this.documentReferenceResolver.resolve((String) result)); } else if (result instanceof Object[]) { Object[] row = (Object[]) result; if (row.length > 0 && row[0] instanceof String) { row[0] = this.documentReferenceResolver.resolve((String) row[0]); } } } return results; }
public Record parse (XmlReader reader) throws XmlReaderException { HeaderParser headerParser = new HeaderParser(); reader.next(elementName(localPart(equalTo("header")))); Record record = new Record() .withHeader(headerParser.parse(reader)); if (!record.getHeader().isDeleted()) { reader.next(elementName(localPart(equalTo("metadata")))).next(aStartElement()); String content = reader.retrieveCurrentAsString(); ByteArrayInputStream inputStream = new ByteArrayInputStream(content.getBytes()); XSLPipeline pipeline = new XSLPipeline(inputStream, true) .apply(context.getMetadataTransformer(metadataPrefix)); if (context.hasTransformer()) pipeline.apply(context.getTransformer()); try { record.withMetadata(new Metadata(new MetadataParser().parse(pipeline.process()))); } catch (TransformerException e) { throw new InternalHarvestException("Unable to process transformer"); } } if (reader.next(aboutElement(), endOfRecord()).current(aboutElement())) { reader.next(aStartElement()); record.withAbout(new About(reader.retrieveCurrentAsString())); } return record; }
@Override public ListIdentifiers handle(OAICompiledRequest parameters) throws OAIException, HandlerException { ListIdentifiers result = new ListIdentifiers(); if (parameters.hasSet() && !getRepository().getSetRepository().supportSets()) throw new DoesNotSupportSetsException(); PreconditionHelper.checkMetadataFormat(getContext(), parameters.getMetadataPrefix()); int length = getRepository().getConfiguration().getMaxListIdentifiers(); int offset = getOffset(parameters); ListItemIdentifiersResult listItemIdentifiersResult; if (!parameters.hasSet()) { if (parameters.hasFrom() && !parameters.hasUntil()) listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiers(getContext(), offset, length, parameters.getMetadataPrefix(), parameters.getFrom()); else if (!parameters.hasFrom() && parameters.hasUntil()) listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiersUntil(getContext(), offset, length, parameters.getMetadataPrefix(), parameters.getUntil()); else if (parameters.hasFrom() && parameters.hasUntil()) listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiers(getContext(), offset, length, parameters.getMetadataPrefix(), parameters.getFrom(), parameters.getUntil()); else listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiers(getContext(), offset, length, parameters.getMetadataPrefix()); } else { if (!getRepository().getSetRepository().exists(parameters.getSet()) && !getContext().hasSet(parameters.getSet())) throw new NoMatchesException(); if (parameters.hasFrom() && !parameters.hasUntil()) listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiers(getContext(), offset, length, parameters.getMetadataPrefix(), parameters.getSet(), parameters.getFrom()); else if (!parameters.hasFrom() && parameters.hasUntil()) listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiersUntil(getContext(), offset, length, parameters.getMetadataPrefix(), parameters.getSet(), parameters.getUntil()); else if (parameters.hasFrom() && parameters.hasUntil()) listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiers(getContext(), offset, length, parameters.getMetadataPrefix(), parameters.getSet(), parameters.getFrom(), parameters.getUntil()); else listItemIdentifiersResult = itemRepositoryHelper.getItemIdentifiers(getContext(), offset, length, parameters.getMetadataPrefix(), parameters.getSet()); } List<ItemIdentifier> itemIdentifiers = listItemIdentifiersResult.getResults(); if (itemIdentifiers.isEmpty()) throw new NoMatchesException(); for (ItemIdentifier itemIdentifier : itemIdentifiers) result.getHeaders().add(createHeader(parameters, itemIdentifier)); ResumptionToken.Value currentResumptionToken = new ResumptionToken.Value(); if (parameters.hasResumptionToken()) { currentResumptionToken = parameters.getResumptionToken(); } else if (listItemIdentifiersResult.hasMore()) { currentResumptionToken = parameters.extractResumptionToken(); } ResumptionTokenHelper resumptionTokenHelper = new ResumptionTokenHelper(currentResumptionToken, getRepository().getConfiguration().getMaxListIdentifiers()); result.withResumptionToken(resumptionTokenHelper.resolve(listItemIdentifiersResult.hasMore())); return result; }
public void saveProject( Project project ) { entityManager.persist(project); }
public void decode(ByteBuf buffer) { boolean last; int statusCode; while (true) { switch(state) { case READ_COMMON_HEADER: if (buffer.readableBytes() < SPDY_HEADER_SIZE) { return; } int frameOffset = buffer.readerIndex(); int flagsOffset = frameOffset + SPDY_HEADER_FLAGS_OFFSET; int lengthOffset = frameOffset + SPDY_HEADER_LENGTH_OFFSET; buffer.skipBytes(SPDY_HEADER_SIZE); boolean control = (buffer.getByte(frameOffset) & 0x80) != 0; int version; int type; if (control) { version = getUnsignedShort(buffer, frameOffset) & 0x7FFF; type = getUnsignedShort(buffer, frameOffset + SPDY_HEADER_TYPE_OFFSET); streamId = 0; } else { version = spdyVersion; type = SPDY_DATA_FRAME; streamId = getUnsignedInt(buffer, frameOffset); } flags = buffer.getByte(flagsOffset); length = getUnsignedMedium(buffer, lengthOffset); if (version != spdyVersion) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SPDY Version"); } else if (!isValidFrameHeader(streamId, type, flags, length)) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid Frame Error"); } else { state = getNextState(type, length); } break; case READ_DATA_FRAME: if (length == 0) { state = State.READ_COMMON_HEADER; delegate.readDataFrame(streamId, hasFlag(flags, SPDY_DATA_FLAG_FIN), Unpooled.buffer(0)); break; } int dataLength = Math.min(maxChunkSize, length); if (buffer.readableBytes() < dataLength) { return; } ByteBuf data = buffer.alloc().buffer(dataLength); data.writeBytes(buffer, dataLength); length -= dataLength; if (length == 0) { state = State.READ_COMMON_HEADER; } last = length == 0 && hasFlag(flags, SPDY_DATA_FLAG_FIN); delegate.readDataFrame(streamId, last, data); break; case READ_SYN_STREAM_FRAME: if (buffer.readableBytes() < 10) { return; } int offset = buffer.readerIndex(); streamId = getUnsignedInt(buffer, offset); int associatedToStreamId = getUnsignedInt(buffer, offset + 4); byte priority = (byte) (buffer.getByte(offset + 8) >> 5 & 0x07); last = hasFlag(flags, SPDY_FLAG_FIN); boolean unidirectional = hasFlag(flags, SPDY_FLAG_UNIDIRECTIONAL); buffer.skipBytes(10); length -= 10; if (streamId == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SYN_STREAM Frame"); } else { state = State.READ_HEADER_BLOCK; delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, last, unidirectional); } break; case READ_SYN_REPLY_FRAME: if (buffer.readableBytes() < 4) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); last = hasFlag(flags, SPDY_FLAG_FIN); buffer.skipBytes(4); length -= 4; if (streamId == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SYN_REPLY Frame"); } else { state = State.READ_HEADER_BLOCK; delegate.readSynReplyFrame(streamId, last); } break; case READ_RST_STREAM_FRAME: if (buffer.readableBytes() < 8) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); statusCode = getSignedInt(buffer, buffer.readerIndex() + 4); buffer.skipBytes(8); if (streamId == 0 || statusCode == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid RST_STREAM Frame"); } else { state = State.READ_COMMON_HEADER; delegate.readRstStreamFrame(streamId, statusCode); } break; case READ_SETTINGS_FRAME: if (buffer.readableBytes() < 4) { return; } boolean clear = hasFlag(flags, SPDY_SETTINGS_CLEAR); numSettings = getUnsignedInt(buffer, buffer.readerIndex()); buffer.skipBytes(4); length -= 4; if ((length & 0x07) != 0 || length >> 3 != numSettings) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SETTINGS Frame"); } else { state = State.READ_SETTING; delegate.readSettingsFrame(clear); } break; case READ_SETTING: if (numSettings == 0) { state = State.READ_COMMON_HEADER; delegate.readSettingsEnd(); break; } if (buffer.readableBytes() < 8) { return; } byte settingsFlags = buffer.getByte(buffer.readerIndex()); int id = getUnsignedMedium(buffer, buffer.readerIndex() + 1); int value = getSignedInt(buffer, buffer.readerIndex() + 4); boolean persistValue = hasFlag(settingsFlags, SPDY_SETTINGS_PERSIST_VALUE); boolean persisted = hasFlag(settingsFlags, SPDY_SETTINGS_PERSISTED); buffer.skipBytes(8); --numSettings; delegate.readSetting(id, value, persistValue, persisted); break; case READ_PING_FRAME: if (buffer.readableBytes() < 4) { return; } int pingId = getSignedInt(buffer, buffer.readerIndex()); buffer.skipBytes(4); state = State.READ_COMMON_HEADER; delegate.readPingFrame(pingId); break; case READ_GOAWAY_FRAME: if (buffer.readableBytes() < 8) { return; } int lastGoodStreamId = getUnsignedInt(buffer, buffer.readerIndex()); statusCode = getSignedInt(buffer, buffer.readerIndex() + 4); buffer.skipBytes(8); state = State.READ_COMMON_HEADER; delegate.readGoAwayFrame(lastGoodStreamId, statusCode); break; case READ_HEADERS_FRAME: if (buffer.readableBytes() < 4) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); last = hasFlag(flags, SPDY_FLAG_FIN); buffer.skipBytes(4); length -= 4; if (streamId == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid HEADERS Frame"); } else { state = State.READ_HEADER_BLOCK; delegate.readHeadersFrame(streamId, last); } break; case READ_WINDOW_UPDATE_FRAME: if (buffer.readableBytes() < 8) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); int deltaWindowSize = getUnsignedInt(buffer, buffer.readerIndex() + 4); buffer.skipBytes(8); if (deltaWindowSize == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid WINDOW_UPDATE Frame"); } else { state = State.READ_COMMON_HEADER; delegate.readWindowUpdateFrame(streamId, deltaWindowSize); } break; case READ_HEADER_BLOCK: if (length == 0) { state = State.READ_COMMON_HEADER; delegate.readHeaderBlockEnd(); break; } if (!buffer.isReadable()) { return; } int compressedBytes = Math.min(buffer.readableBytes(), length); ByteBuf headerBlock = buffer.alloc().buffer(compressedBytes); headerBlock.writeBytes(buffer, compressedBytes); length -= compressedBytes; delegate.readHeaderBlock(headerBlock); break; case DISCARD_FRAME: int numBytes = Math.min(buffer.readableBytes(), length); buffer.skipBytes(numBytes); length -= numBytes; if (length == 0) { state = State.READ_COMMON_HEADER; break; } return; case FRAME_ERROR: buffer.skipBytes(buffer.readableBytes()); return; default: throw new Error("Shouldn't reach here."); } } }
public List<CompletableFuture<Response>> execute( final List<ParsecAsyncHttpRequest> requests ) throws ExecutionException { List<CompletableFuture<Response>> futures = new ArrayList<>(); for (ParsecAsyncHttpRequest request : requests) { futures.add(execute(request)); } return futures; }
Evaluator<?> newInstance(PredicateLeaf predicateLeaf) { TypeInfo typeInfo = structTypeInfo.getStructFieldTypeInfo(predicateLeaf.getColumnName()); if (typeInfo.getCategory() != Category.PRIMITIVE) { throw new IllegalArgumentException("Unsupported column type: " + typeInfo.getCategory()); } PrimitiveCategory category = ((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory(); if (category == PrimitiveCategory.BINARY) { throw new IllegalArgumentException("Unsupported column type: " + category); } switch (predicateLeaf.getOperator()) { case EQUALS: case NULL_SAFE_EQUALS: return equalsEvaluator(predicateLeaf, category); case LESS_THAN: case LESS_THAN_EQUALS: return lessThanEvaluator(predicateLeaf, category); case IN: return inEvaluator(predicateLeaf, category); case BETWEEN: return betweenEvaluator(predicateLeaf, category); case IS_NULL: return isNullEvaluator(predicateLeaf); default: throw new IllegalArgumentException("Unsupported operator: " + predicateLeaf.getOperator()); } }
public static synchronized <T> T invokeMethod(Object instance, Object... arguments) throws Exception { return WhiteboxImpl.invokeMethod(instance, arguments); }
static String prefix(String input) { return "Talk: " + input; }
protected void setupRequest( InvocationRequest req, InvokerLogger bridge, String additionalArguments ) throws MavenExecutorException { try { String[] args = CommandLineUtils.translateCommandline( additionalArguments ); CommandLine cli = new PosixParser().parse( OPTIONS, args ); if ( cli.hasOption( SET_SYSTEM_PROPERTY ) ) { String[] properties = cli.getOptionValues( SET_SYSTEM_PROPERTY ); Properties props = new Properties(); for ( int i = 0; i < properties.length; i++ ) { String property = properties[i]; String name, value; int sep = property.indexOf( "=" ); if ( sep <= 0 ) { name = property.trim(); value = "true"; } else { name = property.substring( 0, sep ).trim(); value = property.substring( sep + 1 ).trim(); } props.setProperty( name, value ); } req.setProperties( props ); } if ( cli.hasOption( OFFLINE ) ) { req.setOffline( true ); } if ( cli.hasOption( QUIET ) ) { req.setDebug( false ); } else if ( cli.hasOption( DEBUG ) ) { req.setDebug( true ); } else if ( cli.hasOption( ERRORS ) ) { req.setShowErrors( true ); } if ( cli.hasOption( REACTOR ) ) { req.setRecursive( true ); } else if ( cli.hasOption( NON_RECURSIVE ) ) { req.setRecursive( false ); } if ( cli.hasOption( UPDATE_SNAPSHOTS ) ) { req.setUpdateSnapshots( true ); } if ( cli.hasOption( ACTIVATE_PROFILES ) ) { String[] profiles = cli.getOptionValues( ACTIVATE_PROFILES ); if ( profiles != null ) { req.setProfiles( Arrays.asList( profiles ) ); } } if ( cli.hasOption( CHECKSUM_FAILURE_POLICY ) ) { req.setGlobalChecksumPolicy( InvocationRequest.CHECKSUM_POLICY_FAIL ); } else if ( cli.hasOption( CHECKSUM_WARNING_POLICY ) ) { req.setGlobalChecksumPolicy( InvocationRequest.CHECKSUM_POLICY_WARN ); } if ( cli.hasOption( ALTERNATE_USER_SETTINGS ) ) { req.setUserSettingsFile( new File( cli.getOptionValue( ALTERNATE_USER_SETTINGS ) ) ); } if ( cli.hasOption( ALTERNATE_GLOBAL_SETTINGS ) ) { req.setGlobalSettingsFile( new File( cli.getOptionValue( ALTERNATE_GLOBAL_SETTINGS ) ) ); } if ( cli.hasOption( FAIL_AT_END ) ) { req.setFailureBehavior( InvocationRequest.REACTOR_FAIL_AT_END ); } else if ( cli.hasOption( FAIL_FAST ) ) { req.setFailureBehavior( InvocationRequest.REACTOR_FAIL_FAST ); } if ( cli.hasOption( FAIL_NEVER ) ) { req.setFailureBehavior( InvocationRequest.REACTOR_FAIL_NEVER ); } if ( cli.hasOption( ALTERNATE_POM_FILE ) ) { if ( req.getPomFileName() != null ) { getLogger().info( "pomFileName is already set, ignoring the -f argument" ); } else { req.setPomFileName( cli.getOptionValue( ALTERNATE_POM_FILE ) ); } } if ( cli.hasOption( THREADS ) ) { req.setThreads( cli.getOptionValue( THREADS ) ); } if ( cli.hasOption( BATCH_MODE ) ) { req.setInteractive( false ); } if ( cli.hasOption( ALTERNATE_USER_TOOLCHAINS ) ) { req.setToolchainsFile( new File( cli.getOptionValue( ALTERNATE_USER_TOOLCHAINS ) ) ); } } catch ( Exception e ) { throw new MavenExecutorException( "Failed to re-parse additional arguments for Maven invocation.", e ); } }
public UseToken getUseToken() { return useToken; }
@SuppressWarnings({ "unchecked", "PMD.CollapsibleIfStatements" }) public static <T> Class<T> getType(final Object object) { if (object instanceof Double || object instanceof Float) { return (Class<T>) Double.class; } else if (object instanceof Number) { return (Class<T>) Long.class; } else if (object instanceof Boolean) { return (Class<T>) Boolean.class; } else if (object instanceof String) { if (JSON_DATE.matcher((String) object).matches()) { return (Class<T>) Date.class; } } else if(object instanceof Calendar) { return (Class<T>) Calendar.class; } else if(object instanceof Date) { return (Class<T>) Date.class; } return (Class<T>) String.class; }
@Override public void configure(Context context) { configureSsl(context); Configurables.ensureRequiredNonNull(context, PORT_KEY, BIND_KEY); port = context.getInteger(PORT_KEY); bindAddress = context.getString(BIND_KEY); compressionType = context.getString(COMPRESSION_TYPE, "none"); try { maxThreads = context.getInteger(THREADS, 0); } catch (NumberFormatException e) { logger.warn("AVRO source\'s \"threads\" property must specify an integer value.", context.getString(THREADS)); } enableIpFilter = context.getBoolean(IP_FILTER_KEY, false); if (enableIpFilter) { patternRuleConfigDefinition = context.getString(IP_FILTER_RULES_KEY); if (patternRuleConfigDefinition == null || patternRuleConfigDefinition.trim().isEmpty()) { throw new FlumeException( "ipFilter is configured with true but ipFilterRules is not defined:" + " "); } String[] patternRuleDefinitions = patternRuleConfigDefinition.split( ","); rules = new ArrayList<IpFilterRule>(patternRuleDefinitions.length); for (String patternRuleDefinition : patternRuleDefinitions) { rules.add(generateRule(patternRuleDefinition)); } } if (sourceCounter == null) { sourceCounter = new SourceCounter(getName()); } }
public Object evaluate(Object obj) { Object[] array = new Object[getParameters().size()]; for (int count = 0; count < getParameters().size(); count++) { array[count] = getExpression(count).evaluate(obj); } return array; }
@Override public GetTransUnitListResult execute(GetTransUnitList action, ExecutionContext context) throws ActionException { identity.checkLoggedIn(); HLocale hLocale = validateAndGetLocale(action); log.info("action: {}", action); int targetOffset = action.getOffset(); int targetPageIndex = targetOffset / action.getCount(); GetTransUnitsNavigationResult navigationResult = null; EditorFilter editorFilter = action.getEditorFilter(); FilterConstraints constraints = FilterConstraints.builder() .filterBy(editorFilter.getTextInContent()) .lastModifiedBy(editorFilter.getLastModifiedByUser()) .targetChangedBefore(parseQueryDate( editorFilter.getLastModifiedBefore())) .targetChangedAfter( parseQueryDate(editorFilter.getLastModifiedAfter())) .resourceIdIs(editorFilter.getResId()) .msgContext(editorFilter.getMsgContext()) .sourceCommentContains(editorFilter.getSourceComment()) .targetCommentContains(editorFilter.getTransComment()) .caseSensitive(false).checkInSource(true).checkInTarget(true) .includeMT(action.isFilterMT()) .includeStates(action.getFilterStates()).build(); if (action.isNeedReloadIndex()) { GetTransUnitsNavigation getTransUnitsNavigation = new GetTransUnitsNavigation(action.getDocumentId(), action.getFilterStates(), action.getEditorFilter(), constraints); log.debug("get trans unit navigation action: {}", getTransUnitsNavigation); navigationResult = getTransUnitsNavigationService .getNavigationIndexes(getTransUnitsNavigation, hLocale); int totalPageIndex = getTotalPageIndex(navigationResult.getIdIndexList().size(), action.getCount()); if (targetPageIndex > totalPageIndex) { targetPageIndex = totalPageIndex; targetOffset = action.getCount() * targetPageIndex; } if (action.getTargetTransUnitId() != null) { int targetIndexInDoc = navigationResult.getIdIndexList() .indexOf(action.getTargetTransUnitId()); targetPageIndex = targetIndexInDoc / action.getCount(); targetOffset = action.getCount() * targetPageIndex; } } List<HTextFlow> textFlows = getTextFlows(action, hLocale, targetOffset, constraints); GetTransUnitListResult result = transformToTransUnits(action, hLocale, textFlows, targetOffset, targetPageIndex); result.setNavigationIndex(navigationResult); return result; }
@Override public int compareTo(final Object o) { if (o == null || getClass() != o.getClass()) { return 1; } final DecisionNavigatorItem that = (DecisionNavigatorItem) o; if (this.equals(that)) { return 0; } else { return getOrderingName().compareTo(that.getOrderingName()); } }
@Override public DefaultPlaceholderId withTag(String k, String v) { return withTagFactory(new ConstantTagFactory(new BasicTag(k, v))); }
public static CoordinateCoverage get3DCoordinateCoverage(IAtomContainer container) { if (container == null || container.getAtomCount() == 0) return CoordinateCoverage.NONE; int count = 0; for (IAtom atom : container.atoms()) { count += atom != null && atom.getPoint3d() != null ? 1 : 0; } return count == 0 ? CoordinateCoverage.NONE : count == container.getAtomCount() ? CoordinateCoverage.FULL : CoordinateCoverage.PARTIAL; }
public String generateParagraphsFullHtml(int quantity, boolean startWithLorem) { String prefix = "<html>" + LINE_SEPARATOR + "<header>" + LINE_SEPARATOR + "<title>Lorem Ipsum</title>" + LINE_SEPARATOR + "</header>" + LINE_SEPARATOR + LINE_SEPARATOR + "<body>"; String postfix = "</body>" + LINE_SEPARATOR + "</html>" + LINE_SEPARATOR; return generateMarkupParagraphs(prefix + LINE_SEPARATOR + "<p>" + LINE_SEPARATOR + "\t", LINE_SEPARATOR + "</p>" + LINE_SEPARATOR + postfix, LINE_SEPARATOR + "</p>" + LINE_SEPARATOR + "<p>" + LINE_SEPARATOR + "\t", quantity, startWithLorem); }
@SneakyThrows @Override public <T, E extends Throwable> T doInTransaction(TransactionCallback<T, E> action) throws E { return execute(callableOf(action)); }
public ObjectNode verifyAndReplaceFields(JsonNode jsonNode) throws MetadataValidationException { ObjectNode transformedJsonNode = jsonNode.deepCopy(); List<OntologyModel> ontologyModels = ontologyLoader.loadOntologies(); Map<String, OntologyModel> ontologyModelMap = ontologyModels.stream().collect(Collectors.toMap(OntologyModel::getIdentifier, oM -> oM)); List<String> errors = new ArrayList<>(); Iterator<Map.Entry<String, JsonNode>> iterator = transformedJsonNode.fields(); while (iterator.hasNext()) { Map.Entry<String, JsonNode> entry = iterator.next(); verifyLine(transformedJsonNode, ontologyModelMap, errors, entry); } if (!errors.isEmpty()) { String error = "Archive unit contains fields declared in ontology with a wrong format : " + CollectionUtils.join(errors, ","); throw new MetadataValidationException(MetadataValidationErrorCode.ONTOLOGY_VALIDATION_FAILURE, error); } return transformedJsonNode; }
@PermitAll @Override public ResourceHost getResourceHostById( final String hostId ) throws HostNotFoundException { Preconditions.checkNotNull( hostId, "Resource host id is null" ); for ( ResourceHost resourceHost : getResourceHosts() ) { if ( resourceHost.getId().equals( hostId ) ) { return resourceHost; } } throw new HostNotFoundException( String.format( "Resource host not found by id %s", hostId ) ); }
public static Expression exp(String expressionString, Object... parameters) { Expression e = fromString(expressionString); if (parameters != null && parameters.length > 0) { e.inPlaceParamsArray(parameters); } return e; }
@Override public MCRDigitalObjectIdentifier generate(MCRBase mcrObject, String additional) throws MCRPersistentIdentifierException { final MCRObjectID objectId = mcrObject.getId(); return Optional.ofNullable(getProperties().get("Prefix." + objectId.getBase())) .map(prefix -> { final int objectIdNumberAsInteger = objectId.getNumberAsInteger(); return prefix.contains("/") ? prefix + objectIdNumberAsInteger : prefix + '/' + objectIdNumberAsInteger; }) .flatMap(mcrdoiParser::parse).map(MCRDigitalObjectIdentifier.class::cast) .orElseThrow(() -> new MCRPersistentIdentifierException("Prefix." + objectId.getBase() + " is not defined in " + generatorID + ".")); }
public void cancel(long jobId) throws JobDoesNotExistException { PlanCoordinator planCoordinator = mPlanTracker.getCoordinator(jobId); if (planCoordinator == null) { if (!mWorkflowTracker.cancel(jobId)) { throw new JobDoesNotExistException(ExceptionMessage.JOB_DOES_NOT_EXIST.getMessage(jobId)); } return; } planCoordinator.cancel(); }
protected MicroPipelineValidationResult validateComponent(final MicroPipelineComponentConfiguration componentCfg, final Set<String> queueIdentifiers, final Set<String> componentIdentifiers) { if(componentCfg == null) return MicroPipelineValidationResult.MISSING_COMPONENT_CONFIGURATION; if(StringUtils.isBlank(componentCfg.getId())) return MicroPipelineValidationResult.MISSING_COMPONENT_ID; if(StringUtils.isBlank(componentCfg.getName())) return MicroPipelineValidationResult.MISSING_COMPONENT_NAME; if(StringUtils.isBlank(componentCfg.getVersion())) return MicroPipelineValidationResult.MISSING_COMPONENT_VERSION; if(componentCfg.getType() == null) return MicroPipelineValidationResult.MISSING_COMPONENT_TYPE; String tempId = StringUtils.lowerCase(StringUtils.trim(componentCfg.getId())); if(componentIdentifiers.contains(tempId)) return MicroPipelineValidationResult.NON_UNIQUE_COMPONENT_ID; if(componentCfg.getType() == MicroPipelineComponentType.SOURCE) { if(StringUtils.isNotBlank(componentCfg.getFromQueue())) return MicroPipelineValidationResult.NOT_PERMITTED_SOURCE_QUEUE_REF; if(StringUtils.isBlank(componentCfg.getToQueue())) return MicroPipelineValidationResult.MISSING_DESTINATION_QUEUE; String destinationQueueId = StringUtils.lowerCase(StringUtils.trim(componentCfg.getToQueue())); if(!queueIdentifiers.contains(destinationQueueId)) return MicroPipelineValidationResult.UNKNOWN_DESTINATION_QUEUE; } else if(componentCfg.getType() == MicroPipelineComponentType.DIRECT_RESPONSE_OPERATOR || componentCfg.getType() == MicroPipelineComponentType.DELAYED_RESPONSE_OPERATOR) { if(StringUtils.isBlank(componentCfg.getFromQueue())) return MicroPipelineValidationResult.MISSING_SOURCE_QUEUE; if(StringUtils.isBlank(componentCfg.getToQueue())) return MicroPipelineValidationResult.MISSING_DESTINATION_QUEUE; String sourceQueueId = StringUtils.lowerCase(StringUtils.trim(componentCfg.getFromQueue())); if(!queueIdentifiers.contains(sourceQueueId)) return MicroPipelineValidationResult.UNKNOWN_SOURCE_QUEUE; String destinationQueueId = StringUtils.lowerCase(StringUtils.trim(componentCfg.getToQueue())); if(!queueIdentifiers.contains(destinationQueueId)) return MicroPipelineValidationResult.UNKNOWN_DESTINATION_QUEUE; } else if(componentCfg.getType() == MicroPipelineComponentType.EMITTER) { if(StringUtils.isNotBlank(componentCfg.getToQueue())) return MicroPipelineValidationResult.NOT_PERMITTED_DESTINATION_QUEUE_REF; if(StringUtils.isBlank(componentCfg.getFromQueue())) return MicroPipelineValidationResult.MISSING_SOURCE_QUEUE; String destinationQueueId = StringUtils.lowerCase(StringUtils.trim(componentCfg.getFromQueue())); if(!queueIdentifiers.contains(destinationQueueId)) return MicroPipelineValidationResult.UNKNOWN_SOURCE_QUEUE; } return MicroPipelineValidationResult.OK; }
public ObjectMapper mapper() { return mapper; }
@Deprecated float getMinimumDipsInZigZag() { return mCurrentThresholdInDips; }
static List<Integer> expandComponent(String component) { List<Integer> retList = new LinkedList<>(); if (SOLO_PATTERN.matcher(component).matches()) { retList.add(Integer.parseInt(component)); } else if (RANGE_PATTERN.matcher(component).matches()) { String strippedComponent = component.replaceAll("\\[|]", ""); String[] range = strippedComponent.split("-"); int lo = Integer.parseInt(range[0]); int hi = Integer.parseInt(range[1]); for (int i = lo; i <= hi; i++) { retList.add(i); } } else if (LIST_PATTERN.matcher(component).matches()) { String strippedComponent = component.replaceAll("\\[|]", ""); String[] list = strippedComponent.split(","); Arrays.stream(list).forEach(i -> retList.add(Integer.parseInt(i))); } else { throw new IllegalArgumentException("Unknown pattern for component " + component); } return retList; }
@Override final void onHttp2FrameStreamException(ChannelHandlerContext ctx, Http2FrameStreamException cause) { Http2FrameStream stream = cause.stream(); DefaultHttp2StreamChannel childChannel = ((Http2MultiplexCodecStream) stream).channel; try { childChannel.pipeline().fireExceptionCaught(cause.getCause()); } finally { childChannel.unsafe().closeForcibly(); } }
public ResponseEntity<String> createSTSRole(AWSStsRole awsStsRole, String token){ String jsonStr = JSONUtil.getJSON(awsStsRole); Response response = reqProcessor.process("/auth/aws/config/sts/create",jsonStr, token); if(response.getHttpstatus().equals(HttpStatus.NO_CONTENT)){ return ResponseEntity.status(HttpStatus.OK).body("{\"messages\":[\"STS Role created successfully \"]}"); }else{ return ResponseEntity.status(response.getHttpstatus()).body(response.getResponse()); } }
@Override public final void run() { if (!check.isEnabled()) { return; } try { Map<String, Optional<BigDecimal>> targetValues = targetChecker.check(check); DateTime now = new DateTime(); BigDecimal warn = check.getWarn(); BigDecimal error = check.getError(); AlertType worstState; if (check.isAllowNoData()) { worstState = AlertType.OK; } else { worstState = AlertType.UNKNOWN; } List<Alert> interestingAlerts = new ArrayList<Alert>(); for (Entry<String, Optional<BigDecimal>> entry : targetValues.entrySet()) { String target = entry.getKey(); Optional<BigDecimal> value = entry.getValue(); if (!value.isPresent()) { if (!check.isAllowNoData()) { LOGGER.warn("No value present for {} and check must have data", target); } continue; } BigDecimal currentValue = value.get(); Alert lastAlert = alertsStore.getLastAlertForTargetOfCheck(target, check.getId()); AlertType lastState; if (lastAlert == null) { lastState = AlertType.OK; } else { lastState = lastAlert.getToType(); } AlertType currentState = valueChecker.checkValue(currentValue, warn, error); if (currentState.isWorseThan(worstState)) { worstState = currentState; } if (isStillOk(lastState, currentState)) { continue; } Alert alert = createAlert(target, currentValue, warn, error, lastState, currentState, now); alertsStore.createAlert(check.getId(), alert); if (stateIsTheSame(lastState, currentState)) { continue; } interestingAlerts.add(alert); } Check updatedCheck = checksStore.updateStateAndLastCheck(check.getId(), worstState, DateTime.now()); if (interestingAlerts.isEmpty()) { return; } for (Subscription subscription : updatedCheck.getSubscriptions()) { if (!subscription.shouldNotify(now, worstState)) { continue; } for (NotificationService notificationService : notificationServices) { if (notificationService.canHandle(subscription.getType())) { try { notificationService.sendNotification(updatedCheck, subscription, interestingAlerts); } catch (Exception e) { LOGGER.warn("Notifying {} by {} failed.", subscription.getTarget(), subscription.getType(), e); } } } } } catch (Exception e) { LOGGER.warn("{} failed", check.getName(), e); } }
@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) { return this.delegate.scheduleAtFixedRate(new RunnableWithTracing(command), initialDelay, period, unit); }
public void range(int value, int from, int to, String component) { that(value >= from && value <= to, component + " must be within the " + from + ".." + to + " range."); }
public String getID() { return this.id; }
boolean matchesStatus(BgpSessionStatus status) { return _expandedStatuses.contains(status); }
@Override public void connectFailed(URI uri, SocketAddress socketAddress, IOException ioException) { Preconditions.checkNotNull(uri, "Uri can not be null"); Preconditions.checkNotNull(socketAddress, "SocketAddress can not be null"); Preconditions.checkNotNull(ioException, "IOException can not be null"); }
@Override public void process(Set<Class<?>> classes, ServletContext context) throws ServletException { Collection<? extends ServletRegistration> registrations = context .getServletRegistrations().values(); ServletRegistration vaadinServletRegistration = null; for (ServletRegistration registration : registrations) { if (registration.getClassName() != null && isVaadinServletSubClass(registration.getClassName())) { vaadinServletRegistration = registration; break; } } DeploymentConfiguration config; if (vaadinServletRegistration != null) { config = StubServletConfig.createDeploymentConfiguration(context, vaadinServletRegistration, VaadinServlet.class); } else { config = StubServletConfig.createDeploymentConfiguration(context, VaadinServlet.class); } initDevModeHandler(classes, context, config); setDevModeStarted(context); }
public void setEntryPointName( String entryPointName ) { this.entryPointName = entryPointName; }
public boolean saveDescriptor(WikiDescriptor descriptor) { XWikiContext context = xcontextProvider.get(); boolean isAllowed; try { WikiDescriptor oldDescriptor = wikiDescriptorManager.getById(descriptor.getId()); WikiReference wikiReference = descriptor.getReference(); if (oldDescriptor != null) { DocumentReference descriptorDocument = wikiDescriptorDocumentHelper.getDocumentReferenceFromId(oldDescriptor.getId()); isAllowed = authorizationManager.hasAccess(Right.EDIT, context.getUserReference(), descriptorDocument); String currentOwner = oldDescriptor.getOwnerId(); if (!isAllowed) { isAllowed = entityReferenceSerializer.serialize(context.getUserReference()).equals(currentOwner); } if (!isAllowed) { String newOwner = descriptor.getOwnerId(); isAllowed = authorizationManager.hasAccess(Right.ADMIN, context.getUserReference(), wikiReference) && StringUtils.equals(newOwner, currentOwner); } } else { isAllowed = authorizationManager.hasAccess(Right.ADMIN, context.getUserReference(), new WikiReference( wikiDescriptorManager.getMainWikiId())); } if (!isAllowed) { throw new AccessDeniedException(context.getUserReference(), wikiReference); } else { wikiDescriptorManager.saveDescriptor(descriptor); } return true; } catch (Exception e) { error(e); return false; } }
public void validate(StreamSource xmlSource) throws WecubeCoreException { try { validator.validate(xmlSource); } catch (SAXException | IOException ex) { if (logger.isDebugEnabled()) logger.debug(xmlSource.toString()); throw new WecubeCoreException("XML validation failed: " + ex.getMessage()); } }
GraphComputeResponse.GraphComputeAction getGraphComputeAction() { return GraphComputeResponse.GraphComputeAction.UNIT; }
@Override public String path() { return OASUtils.getRelationshipsPath(metaResource, metaResourceField); }
@Override public Long convertToDatabaseColumn(EntityId entityId) { if (entityId == null) { return null; } return entityId.getId(); }
public static OffsetTime truncateOffsetToMinutes( OffsetTime value ) { int offsetMinutes = value.getOffset().getTotalSeconds() / 60; ZoneOffset truncatedOffset = ZoneOffset.ofTotalSeconds( offsetMinutes * 60 ); return value.withOffsetSameInstant( truncatedOffset ); }
public static void changePassword(File file, byte[] oldPassword, DerivedKey newKey) throws IOException, GeneralSecurityException, PasswordException { InputStream inputStream = null; byte[] decryptedData = null; try { inputStream = new EncryptedInputStream(new FileInputStream(file), oldPassword); decryptedData = Util.readBytes(inputStream); } finally { if (inputStream != null) inputStream.close(); } OutputStream outputStream = null; try { outputStream = new EncryptedOutputStream(new FileOutputStream(file), newKey); outputStream.write(decryptedData); } finally { if (outputStream != null) outputStream.close(); } }
@Override public void shutdown() { LOG.info("Shutting down FederationInterceptor for {}", this.attemptId); try { this.uamPool.shutDownConnections(); } catch (YarnException e) { LOG.error("Error shutting down all UAM clients without killing them", e); } if (this.threadpool != null) { try { this.threadpool.shutdown(); } catch (Throwable ex) { } this.threadpool = null; } this.homeHeartbeartHandler.shutdown(); this.homeRMRelayer.shutdown(); super.shutdown(); }
@Override public void update(double[] x, int y) { propagate(x); setTarget(labels.indexOf(y)); backpropagate(x); update(); }
@Override public String format(Object value) { if (value == null) { return null; } return value.toString(); }
@Override public List<String> getChildrenKeys(final String key) { return null; }
CloseableHttpClient getHttpClient(final ProxyConfiguration proxyConfiguration, final HttpClientConfiguration httpClientConfiguration) throws SmartlingApiException { HttpClientBuilder httpClientBuilder = getHttpClientBuilder(); if (hasActiveProxyConfiguration(proxyConfiguration)) { HttpHost proxyHost = new HttpHost(proxyConfiguration.getHost(), proxyConfiguration.getPort()); httpClientBuilder.setProxy(proxyHost); if (proxyAuthenticationRequired(proxyConfiguration)) { CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); credentialsProvider.setCredentials( new AuthScope(proxyConfiguration.getHost(), proxyConfiguration.getPort()), new UsernamePasswordCredentials(proxyConfiguration.getUsername(), proxyConfiguration.getPassword())); httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider); } } httpClientBuilder.setSSLContext(getSSLConfig()); if (httpConfigurationRequired(httpClientConfiguration)) { final RequestConfig defaultRequestConfig = RequestConfig.custom() .setSocketTimeout(httpClientConfiguration.getSocketTimeout()) .setConnectTimeout(httpClientConfiguration.getConnectionTimeout()) .setConnectionRequestTimeout(httpClientConfiguration.getConnectionRequestTimeout()) .build(); httpClientBuilder.setDefaultRequestConfig(defaultRequestConfig); } return httpClientBuilder.build(); }
@Override @Transactional public CmsResponse<Boolean> updatePaymentCancellationTppRedirectUri(@NotNull String encryptedPaymentId, @NotNull TppRedirectUri tppRedirectUri) { Optional<String> decryptIdOptional = securityDataService.decryptId(encryptedPaymentId); if (decryptIdOptional.isEmpty()) { log.info("Encrypted Payment ID [{}]. Update cancellation payment tpp redirect URIs by id failed, couldn't decrypt payment id", encryptedPaymentId); return CmsResponse.<Boolean>builder() .error(TECHNICAL_ERROR) .build(); } return updatePaymentStatusAfterSpiService.updatePaymentCancellationTppRedirectUri(decryptIdOptional.get(), tppRedirectUri); }
@Override public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) { requireNonNull(address); return defer(() -> new ARecordPublisher(true, address, newDiscoveryObserver(address)) .flatMapConcatIterable(identity())); }
@Override public ErrorDescriptor build(ConstraintViolation violation) { return QUERY_WHERE_PARAMETERS_EXPRESSION_NOT_VALID.createDescriptor(); }
@Override public <T> T resolve(final Object... args) throws ResolveDependencyStrategyException { try { Object chainId = args[CHAIN_ID_ARG_INDEX]; IObject description = (IObject) args[DESCRIPTION_ARG_INDEX]; IChainStorage chainStorage = (IChainStorage) args[STORAGE_ARG_INDEX]; IRouter router = (IRouter) args[ROUTER_ARG_INDEX]; IKey fieldNameKey = Keys.getOrAdd("info.smart_tools.smartactors.iobject.ifield_name.IFieldName"); IKey receiverIdKey = Keys.getOrAdd("receiver_id_from_iobject"); IKey chainIdKey = Keys.getOrAdd("chain_id"); IFieldName stepsFieldName = IOC.resolve(fieldNameKey, "steps"); IFieldName exceptionalChainsFieldName = IOC.resolve(fieldNameKey, "exceptional"); IFieldName exceptionClassFieldName = IOC.resolve(fieldNameKey, "class"); IFieldName exceptionChainFieldName = IOC.resolve(fieldNameKey, "chain"); IFieldName exceptionAfterFieldName = IOC.resolve(fieldNameKey, "after"); List chainSteps = (List) description.getValue(stepsFieldName); List exceptionalChains = (List) description.getValue(exceptionalChainsFieldName); IMessageReceiver[] receivers = new IMessageReceiver[chainSteps.size()]; IObject[] arguments = new IObject[chainSteps.size()]; for (int i = 0; i < chainSteps.size(); i++) { IObject step = (IObject) chainSteps.get(i); receivers[i] = router.route(IOC.resolve(receiverIdKey, step)); arguments[i] = step; } LinkedHashMap<Class<? extends Throwable>, IObject> exceptionalChainsMap = new LinkedHashMap<>(); for (Object chainDesc : exceptionalChains) { IObject desc = (IObject) chainDesc; Class<?> clazz = this.getClass().getClassLoader().loadClass(String.valueOf(desc.getValue(exceptionClassFieldName))); IReceiverChain chain = chainStorage.resolve(IOC.resolve(chainIdKey, desc.getValue(exceptionChainFieldName))); IAction<IMessageProcessingSequence> afterExceptionAction = IOC.resolve( IOC.resolve(IOC.getKeyForKeyStorage(), "afterExceptionAction#" + desc.getValue(exceptionAfterFieldName)) ); IObject chainAndEnv = IOC.resolve(IOC.resolve(IOC.getKeyForKeyStorage(), "info.smart_tools.smartactors.iobject.iobject.IObject")); chainAndEnv.setValue(exceptionChainFieldName, chain); chainAndEnv.setValue(exceptionAfterFieldName, afterExceptionAction); exceptionalChainsMap.put((Class<? extends Throwable>) clazz, chainAndEnv); } return (T) new ImmutableReceiverChain(String.valueOf(chainId), description, receivers, arguments, exceptionalChainsMap); } catch (ChainNotFoundException | ClassNotFoundException | ResolutionException | ReadValueException | RouteNotFoundException | ChangeValueException | InvalidArgumentException e) { throw new ResolveDependencyStrategyException(e); } }
public static <T> List<T > list() { return Collections.emptyList(); }
@NonNull public static String trim(String source) { return StringUtils.isBlank(source) ? StringUtils.EMPTY : source.trim().replaceAll(" +", " "); }
@Override public String execute(List<String> parameterList, TestContext context) { if (CollectionUtils.isEmpty(parameterList) || parameterList.size() < 1) { throw new InvalidFunctionUsageException("Invalid function parameter usage! Missing parameters!"); } String charset = "UTF-8"; if (parameterList.size() > 1) { charset = parameterList.get(1); } try { return Base64.encodeBase64String(parameterList.get(0).getBytes(charset)); } catch (UnsupportedEncodingException e) { throw new CitrusRuntimeException("Unsupported character encoding", e); } }
@Override public List<Monitor<?>> getMonitors() { List<Monitor<?>> monitors = new ArrayList<>(); for (Meter meter : this) { ServoMeter sm = getServoMeter(meter); if (!meter.hasExpired() && sm != null) { sm.addMonitors(monitors); } } removeExpiredMeters(); return monitors; }
@Override protected void encode(IoSessionEx session, HttpMessage httpMessage, ProtocolEncoderOutput out) throws Exception { switch (httpMessage.getKind()) { case CONTENT: HttpContentMessage httpContent = (HttpContentMessage)httpMessage; encodeContent(session, httpContent, out); break; case RESPONSE: HttpResponseMessage httpResponse = (HttpResponseMessage)httpMessage; encodeResponse(session, httpResponse, out); break; default: throw new ProtocolEncoderException("Unexpected HTTP message kind: " + httpMessage.getKind()); } }
@Override public void getApiary(long apiaryId, @NonNull final GetApiaryCallback callback) { checkNotNull(callback); if (cachedApiaries != null && !cacheIsDirty) { callback.onApiaryLoaded(cachedApiaries.get(apiaryId)); return; } goBeesDataSource.getApiary(apiaryId, callback); }
@SuppressWarnings("unchecked") public static <T> Function<T, Tuple0OfNullables> toTupleOfNullables() { return (Function<T, Tuple0OfNullables>) Tuple0OfNullablesMapperImpl.EMPTY_MAPPER; }
public String getArtifactVersion( StorageAsset artifactDir, ItemSelector selector) { if (selector.hasArtifactVersion()) { return selector.getArtifactVersion(); } else if (selector.hasVersion()) { if ( VersionUtil.isGenericSnapshot( selector.getVersion() ) ) { return getLatestArtifactSnapshotVersion( artifactDir, selector.getVersion( ) ); } else { return selector.getVersion( ); } } else { throw new IllegalArgumentException( "No version set on the selector " ); } }
public Flags reset() { this.flags = 0; return this; }
@NonNull Student parseStudent(@NonNull String loginJson, @NonNull String attendanceJson) throws InvalidCredentialsException, InvalidResponseException { Student student = processLogin(loginJson); try { student.subjects.putAll(processAttendance(attendanceJson)); } catch (InvalidResponseException ignored) { } return student; }
@Override public boolean updatePortPair(PortPair portPair) { checkNotNull(portPair, PORT_PAIR_NULL); if (!portPairStore.containsKey(portPair.portPairId())) { log.debug("The portPair is not exist whose identifier was {} ", portPair.portPairId().toString()); return false; } portPairStore.put(portPair.portPairId(), portPair); if (!portPair.equals(portPairStore.get(portPair.portPairId()))) { log.debug("The portPair is updated failed whose identifier was {} ", portPair.portPairId().toString()); return false; } return true; }
@Override public ExecutionDag generate(final DAG<ConfigVertex, MISTEdge> configDag, final List<String> jarFilePaths) throws IOException, ClassNotFoundException { final ExecutionDag executionDag = new ExecutionDag(new AdjacentListConcurrentMapDAG<>()); final URL[] urls = SerializeUtils.getJarFileURLs(jarFilePaths); final ClassLoader classLoader = classLoaderProvider.newInstance(urls); final Map<ConfigVertex, ExecutionVertex> created = new HashMap<>(configDag.numberOfVertices()); for (final ConfigVertex source : configDag.getRootVertices()) { final ExecutionVertex currExecutionVertex = executionVertexGenerator.generate(source, urls, classLoader); executionDag.getDag().addVertex(currExecutionVertex); created.put(source, currExecutionVertex); for (final Map.Entry<ConfigVertex, MISTEdge> edges : configDag.getEdges(source).entrySet()) { final ConfigVertex childVertex = edges.getKey(); final MISTEdge edge = edges.getValue(); dfsCreation(currExecutionVertex, edge, childVertex, created, configDag, executionDag, urls, classLoader); } } return executionDag; }
public static Introspect newIntrospectRequest() { return new Introspect().requestType(INTROSPECT); }
public final E_OneOf in(Object expr, ExprList list) { return new E_OneOf(asExpr(expr), list); }
@Override public ItemStatus execute(WorkerParameters params, HandlerIO handler) { final ItemStatus itemStatus = new ItemStatus(CHECK_UNIT_SCHEMA_TASK_ID); try { checkAUJsonAgainstSchema(handler, params, itemStatus); itemStatus.increment(StatusCode.OK); return new ItemStatus(CHECK_UNIT_SCHEMA_TASK_ID).setItemsStatus(CHECK_UNIT_SCHEMA_TASK_ID, itemStatus); } catch (MetadataValidationException e) { LOGGER.warn("Unit schema validation failed " + params.getObjectName(), e); switch (e.getErrorCode()) { case SCHEMA_VALIDATION_FAILURE: { itemStatus.setGlobalOutcomeDetailSubcode(INVALID_UNIT); final ObjectNode object = JsonHandler.createObjectNode(); object.put(SedaConstants.EV_DET_TECH_DATA, e.getMessage()); itemStatus.increment(StatusCode.KO); itemStatus.setEvDetailData(JsonHandler.unprettyPrint(object)); return new ItemStatus(itemStatus.getItemId()).setItemsStatus(itemStatus.getItemId(), itemStatus); } case ONTOLOGY_VALIDATION_FAILURE: { itemStatus.setItemId(ONTOLOGY_VALIDATION); itemStatus.increment(StatusCode.KO); final ObjectNode object = JsonHandler.createObjectNode(); object.put(SedaConstants.EV_DET_TECH_DATA, e.getMessage()); itemStatus.setEvDetailData(JsonHandler.unprettyPrint(object)); return new ItemStatus(CHECK_UNIT_SCHEMA_TASK_ID).setItemsStatus(CHECK_UNIT_SCHEMA_TASK_ID, itemStatus); } case INVALID_UNIT_DATE_FORMAT: { itemStatus.setGlobalOutcomeDetailSubcode(DATE_FORMAT); itemStatus.increment(StatusCode.KO); itemStatus.setEvDetailData(e.getMessage()); return new ItemStatus(itemStatus.getItemId()).setItemsStatus(itemStatus.getItemId(), itemStatus); } case INVALID_START_END_DATE: { itemStatus.setGlobalOutcomeDetailSubcode(CONSISTENCY); itemStatus.increment(StatusCode.KO); final ObjectNode object = JsonHandler.createObjectNode(); object.put(SedaConstants.EV_DET_TECH_DATA, e.getMessage()); itemStatus.setEvDetailData(JsonHandler.unprettyPrint(object)); return new ItemStatus(itemStatus.getItemId()).setItemsStatus(itemStatus.getItemId(), itemStatus); } case ARCHIVE_UNIT_PROFILE_SCHEMA_VALIDATION_FAILURE: case ARCHIVE_UNIT_PROFILE_SCHEMA_INACTIVE: case UNKNOWN_ARCHIVE_UNIT_PROFILE: case EMPTY_ARCHIVE_UNIT_PROFILE_SCHEMA: default: throw new IllegalStateException("Unexpected value: " + e.getErrorCode()); } } catch (final ArchiveUnitContainSpecialCharactersException e) { itemStatus.setItemId(UNIT_SANITIZE); itemStatus.increment(StatusCode.KO); final ObjectNode object = JsonHandler.createObjectNode(); object.put(SedaConstants.EV_DET_TECH_DATA, e.getMessage()); itemStatus.setEvDetailData(JsonHandler.unprettyPrint(object)); return new ItemStatus(CHECK_UNIT_SCHEMA_TASK_ID).setItemsStatus(CHECK_UNIT_SCHEMA_TASK_ID, itemStatus); } catch (final Exception e) { LOGGER.error(e); itemStatus.increment(StatusCode.FATAL); return new ItemStatus(CHECK_UNIT_SCHEMA_TASK_ID).setItemsStatus(itemStatus.getItemId(), itemStatus); } }
static Given given(String text) { reset(); final Given given = new Given(text); sRoot = given; return given; }
public static RegenProductEntitlementCertsConfig createJobConfig() { return new RegenProductEntitlementCertsConfig(); }
public static Map<String, Object> asMap(final Object... keyValues) { return asPairs(keyValues).stream().collect(Collectors.toMap(p -> p.getValue0(), p -> p.getValue1())); }
public HOTPBuilder digits(int digits) { Preconditions.checkArgument(Range.closed(MIN_ALLOWED_DIGITS, MAX_ALLOWED_DIGITS).contains(digits)); this.digits = digits; return this; }
static AdjustableDate parseAdjustableDate( CsvRow row, String dateField, String conventionField, String calendarField) { LocalDate date = row.getValue(dateField, LoaderUtils::parseDate); return parseBusinessDayAdjustment(row, conventionField, calendarField) .map(adj -> AdjustableDate.of(date, adj)) .orElse(AdjustableDate.of(date)); }
public boolean isEmpty() { return 0 == size; }
@Override public List<LookupResult> resolve(final String fqdn_ignored) { return resolvedCluster; }
@Override public void renderContext(Request request) { container.renderContext(request); }
@JSMethod(uiThread = true) public void setNavBarLeftItem(String param, JSCallback callback) { if (!TextUtils.isEmpty(param)) { if (WXSDKEngine.getActivityNavBarSetter() != null) { if (WXSDKEngine.getActivityNavBarSetter().setNavBarLeftItem(param)) { if (callback != null) { callback.invoke(MSG_SUCCESS); } return; } } } if (callback != null) { callback.invoke(MSG_FAILED); } }
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path("/filter/genTweetIds") public Response generateTweetsIDSCSVFromAllJSONFiltered(String queryString, @QueryParam("collectionCode") String collectionCode, @DefaultValue("true") @QueryParam("downloadLimited") Boolean downloadLimited, @QueryParam("userName") String userName) throws UnknownHostException { DeserializeFilters des = new DeserializeFilters(); JsonQueryList queryList = des.deserializeConstraints(queryString); JsonDeserializer jsonD = new JsonDeserializer(); logger.info("received request for collection: " + collectionCode); if (queryList != null) { logger.info(collectionCode + ": received constraints = " + queryList.toString()); } else { logger.info(collectionCode + ": received constraints = " + queryList); } Map<String, Object> result = jsonD.generateClassifiedJson2TweetIdsAndClassifiersCSVFiltered(collectionCode, queryList, downloadLimited, userName); logger.info("Done processing request for collection: " + collectionCode + ", returning created file: " + result.get("fileName")); JSONObject obj = new JSONObject(); if ((Integer) result.get("count") < Integer.parseInt(PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.DEFAULT_TWEETID_VOLUME_LIMIT))) { obj.putAll(ResultStatus.getUIWrapper(collectionCode, PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.PERSISTER_CHANGE_NOTIFY_MSG), result.get("fileName").toString(), true)); logger.info("Returning JSON object: " + ResultStatus.getUIWrapper(collectionCode, PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.PERSISTER_CHANGE_NOTIFY_MSG), result.get("fileName").toString(), true)); return Response.ok(obj.toJSONString()) .allow("POST", "OPTIONS", "HEAD") .header("Access-Control-Allow-Origin", "*") .header("Access-Control-Allow-Credentials", "true") .header("Access-Control-Allow-Methods", "POST, OPTIONS, HEAD") .header("Access-Control-Allow-Headers", "Content-Type, Accept, X-Requested-With") .build(); } else { obj.putAll(ResultStatus.getUIWrapper(collectionCode, PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.TWEET_DOWNLOAD_LIMIT_MSG_PREFIX) + PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.DEFAULT_TWEETID_VOLUME_LIMIT)+ PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.TWEET_DOWNLOAD_LIMIT_MSG_SUFFIX) + PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.PERSISTER_CHANGE_NOTIFY_MSG), result.get("fileName").toString(), true)); logger.info("Returning JSON object: " + ResultStatus.getUIWrapper(collectionCode, PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.TWEET_DOWNLOAD_LIMIT_MSG_PREFIX) + PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.DEFAULT_TWEETID_VOLUME_LIMIT)+ PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.TWEET_DOWNLOAD_LIMIT_MSG_SUFFIX) + PersisterConfigurator.getInstance().getProperty(PersisterConfigurationProperty.PERSISTER_CHANGE_NOTIFY_MSG), result.get("fileName").toString(), true)); return Response.ok(obj.toJSONString()) .allow("POST", "OPTIONS", "HEAD") .header("Access-Control-Allow-Origin", "*") .header("Access-Control-Allow-Credentials", "true") .header("Access-Control-Allow-Methods", "POST, OPTIONS, HEAD") .header("Access-Control-Allow-Headers", "Content-Type, Accept, X-Requested-With") .build(); } }
@Override public int inverseCumulativeProbability(final double p) { if (p < 0 || p > 1) { throw new DistributionException(DistributionException.INVALID_PROBABILITY, p); } int lower = getSupportLowerBound(); if (p == 0) { return lower; } if (lower == Integer.MIN_VALUE) { if (checkedCumulativeProbability(lower) >= p) { return lower; } } else { lower -= 1; } int upper = getSupportUpperBound(); if (p == 1) { return upper; } final double mu = getMean(); final double sigma = Math.sqrt(getVariance()); final boolean chebyshevApplies = Double.isFinite(mu) && Double.isFinite(sigma) && sigma != 0.0; if (chebyshevApplies) { double k = Math.sqrt((1.0 - p) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; } k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { upper = ((int) Math.ceil(tmp)) - 1; } } return solveInverseCumulativeProbability(p, lower, upper); }
public void render(final BufferedImage targetImage) throws IllegalArgumentException { final Graphics2D targetGraphics = targetImage.createGraphics(); targetGraphics.setColor(foregroundColor); targetGraphics.setStroke(stroke); if (backgroundColor != null) { targetGraphics.setBackground(backgroundColor); targetGraphics.clearRect(0, 0, targetImage.getWidth(), targetImage.getHeight()); } final List<TileSpec> tileSpecs = renderParameters.getTileSpecs(); final int maxCharactersPerLine = 12; int lineWidth = 0; int lineHeight = 0; int minBoxWidthForTileIdRendering = 0; if (tileSpecs.size() > 0) { targetGraphics.setFont(TILE_ID_FONT); final FontMetrics metrics = targetGraphics.getFontMetrics(); lineWidth = metrics.stringWidth("A") * maxCharactersPerLine; lineHeight = metrics.getHeight(); minBoxWidthForTileIdRendering = (int) (lineWidth * 1.3) + 1; } Rectangle box; String tileId; int x; int y; int start; for (final TileSpec tileSpec : tileSpecs) { box = getScaledBox(tileSpec); targetGraphics.draw(box); if (box.width > minBoxWidthForTileIdRendering) { tileId = tileSpec.getTileId(); if (tileId != null) { x = box.x + ((box.width - lineWidth) / 2); y = box.y + (box.height / 4); start = 0; for (int stop = maxCharactersPerLine; stop < tileId.length(); stop += maxCharactersPerLine) { targetGraphics.drawString(tileId.substring(start, stop), x, y); y = y + lineHeight; start = stop; } if (start < tileId.length()) { targetGraphics.drawString(tileId.substring(start), x, y); } } } } if (renderParameters.isAddWarpFieldDebugOverlay()) { WarpFieldDebugRenderer.render(renderParameters, targetGraphics, targetImage.getWidth(), targetImage.getHeight()); } targetGraphics.dispose(); LOG.debug("render: exit, boxes for {} tiles rendered", tileSpecs.size()); }
public static Dataset<? extends Instance> lsun() { if (lsun == null) { lsun = new ArrayDataset(400, 2); lsun.setName("lsun"); ARFFHandler arff = new ARFFHandler(); try { arff.load(fixture.lsun(), lsun, 2); } catch (IOException | ParserError ex) { Exceptions.printStackTrace(ex); } } return lsun; }
public boolean isConsentExpired(CmsConsent cmsConsent, Long consentId) { AisConsentRequestType consentRequestType = cmsAisConsentMapper.mapToAisConsent(cmsConsent).getConsentRequestType(); if (consentRequestType == AisConsentRequestType.BANK_OFFERED) { return false; } if (consentRequestType == AisConsentRequestType.ALL_AVAILABLE_ACCOUNTS) { return true; } AccountAccess aspspAccountAccesses = cmsConsent.getAspspAccountAccesses(); List<AccountReference> references = Stream.of(aspspAccountAccesses.getAccounts(), aspspAccountAccesses.getBalances(), aspspAccountAccesses.getTransactions()) .flatMap(Collection::stream).collect(Collectors.toList()); List<String> consentResourceIds = references.stream() .map(AccountReference::getResourceId) .distinct() .collect(Collectors.toList()); boolean isExpired = true; for (String resourceId : consentResourceIds) { List<AisConsentTransaction> consentTransactions = aisConsentTransactionRepository.findByConsentIdAndResourceId(consentId, resourceId, PageRequest.of(0, 1)); int numberOfTransactions = CollectionUtils.isNotEmpty(consentTransactions) ? consentTransactions.get(0).getNumberOfTransactions() : 0; boolean isConsentGlobal = consentRequestType == AisConsentRequestType.GLOBAL; int maximumNumberOfGetRequestsForConsent = getMaximumNumberOfGetRequestsForConsentsAccount(aspspAccountAccesses, resourceId, numberOfTransactions, isConsentGlobal, cmsConsent.getInstanceId()); int numberOfUsedGetRequestsForConsent = getNumberOfUsedGetRequestsForConsent(consentId, resourceId); if (numberOfUsedGetRequestsForConsent < maximumNumberOfGetRequestsForConsent) { isExpired = false; break; } } return isExpired; }
protected CharSequence getValue(String key) { CharSequence val = tagValues.get(key); if (val == null) return getDefault(key); else return val; }
@Override public void deleteCatalogEntry(final CatalogEntry ce) { log.debug("deleteCatalogEntry start... ce=" + ce); if (ce.getType() == CatalogEntry.TYPE_LEAF) { final SecurityGroup owner = ce.getOwnerGroup(); catalogDao.deleteCatalogEntry(ce); if (owner != null) { log.debug("deleteCatalogEntry case_1: delete owner-group=" + owner); securityManager.deleteSecurityGroup(owner); } } else { final List secGroupsToBeDeleted = new ArrayList(); deleteCatalogSubtree(ce, secGroupsToBeDeleted); for (final Iterator iter = secGroupsToBeDeleted.iterator(); iter.hasNext();) { final SecurityGroup grp = (SecurityGroup) iter.next(); log.debug("deleteCatalogEntry case_2: delete groups of deleteCatalogSubtree grp=" + grp); securityManager.deleteSecurityGroup(grp); } } log.debug("deleteCatalogEntry END"); }
@Override public BigDecimal getTotal() { return this.fundingAmount; }
public int get() { return counter; }
public static Monitor start(String label) { return factory.start(label); }
public static byte[] serialize(Object v, int type) { if (v == null) { return null; } switch (type) { case ColumnTypes.BYTEARRAY: case ColumnTypes.NOTNULL_BYTEARRAY: return (byte[]) v; case ColumnTypes.INTEGER: case ColumnTypes.NOTNULL_INTEGER: if (v instanceof Integer) { return Bytes.intToByteArray((Integer) v); } else if (v instanceof Number) { return Bytes.intToByteArray(((Number) v).intValue()); } else { return Bytes.intToByteArray(Integer.parseInt(v.toString())); } case ColumnTypes.LONG: case ColumnTypes.NOTNULL_LONG: if (v instanceof Long) { return Bytes.longToByteArray((Long) v); } else if (v instanceof Number) { return Bytes.longToByteArray(((Number) v).longValue()); } else { return Bytes.longToByteArray(Long.parseLong(v.toString())); } case ColumnTypes.STRING: case ColumnTypes.NOTNULL_STRING: if (v instanceof RawString) { RawString rs = (RawString) v; return rs.toByteArray(); } else { return Bytes.string_to_array(v.toString()); } case ColumnTypes.BOOLEAN: case ColumnTypes.NOTNULL_BOOLEAN: if (v instanceof Boolean) { return Bytes.booleanToByteArray((Boolean) v); } else { return Bytes.booleanToByteArray(Boolean.parseBoolean(v.toString())); } case ColumnTypes.DOUBLE: case ColumnTypes.NOTNULL_DOUBLE: if (v instanceof Double) { return Bytes.doubleToByteArray((Double) v); } else if (v instanceof Long) { return Bytes.doubleToByteArray((Long) v); } else if (v instanceof Number) { return Bytes.doubleToByteArray(((Number) v).longValue()); } else { return Bytes.doubleToByteArray(Double.parseDouble(v.toString())); } case ColumnTypes.TIMESTAMP: case ColumnTypes.NOTNULL_TIMESTAMP: if (v instanceof Long) { return Bytes.timestampToByteArray(new java.sql.Timestamp(((Long) v))); } if (!(v instanceof java.sql.Timestamp)) { throw new IllegalArgumentException("bad value type for column " + type + ": required java.sql.Timestamp, but was " + v.getClass() + ", toString of value is " + v); } return Bytes.timestampToByteArray((java.sql.Timestamp) v); default: throw new IllegalArgumentException("bad column type " + type); } }
@Override public boolean equalChars(char x, char y) { return (Math.abs((int) x - (int) y) == N); }
public Criteria setJSONB(boolean isJSONB) { this.isJSONB = isJSONB; return this; }
@CheckReturnValue @NonNull public static <T> MaybeSubject<T> create() { return new MaybeSubject<T>(); }
@Override public WorkObject validateType() throws FedoraException { if (!isType(Cdr.Work.toString())) { throw new ObjectTypeMismatchException("Object " + pid + " is not a Work object."); } return this; }
public Object get(PropType pt, String key) { if (!store.containsRow(key)) { return store.get(pt, key); } throw new IllegalArgumentException("Map key not found: " + key); }
@Override public void close() { super.close(); cache.invalidateAll(); }
@Override public Observable<Task> retrieveArchivedTask(String taskId) { return retrieveEntityById(taskId, Task.class, retrieveArchivedTaskStatement) .switchIfEmpty(retrieveEntityById(taskId, Task.class, retrieveActiveTaskStatement) .filter(task -> task.getStatus().getState() == TaskState.Finished) ) .switchIfEmpty(Observable.error(JobStoreException.taskDoesNotExist(taskId))); }
@Override public FileVisitResult visitFileFailed(T file, IOException exc) throws IOException { checkNotNull("file", file); checkNotNull("exc", exc); throw exc; }
@Override public Class<ReassignmentsEditorFieldType> getFieldType() { return ReassignmentsEditorFieldType.class; }
public QueryResult<K, V> query(final KafkaStreamsContainer streams, final Queried options) { Objects.requireNonNull(streams, "streams cannot be null"); Objects.requireNonNull(options, "options cannot be null"); long now = Time.SYSTEM.milliseconds(); if (streams.isNotRunning()) { throw new InvalidStreamsStateException( "streams instance for id '" + streams.applicationId() + "' is not running (" + streams.state().value() + ")" ); } QueryResult<K, V> result; if (query.isKeyedQuery()) { result = querySingleHostStateStore(streams, options); } else { result = queryMultiHostStateStore(streams, options); } return result.took(Time.SYSTEM.milliseconds() - now); }
@Override public UInt64 divide(UInt64 value) { if (value.value == 0) { throw new ArithmeticException("divide by zero"); } if (value.value == 1) { return this; } return create(toBigInteger().divide(value.toBigInteger()).longValue()); }
@Override public Node getNode(String nodeId) { logger.info("Getting node {}", nodeId); return nodeDAO.getNode(nodeId); }
public static String resolve(String version, String baseResource, Map<String, String> headers) throws Invalid, UnsupportedRangeSet { if ((version == null) || (!version.startsWith("[") && !version.startsWith("("))) { return version; } boolean inclusiveStart = version.startsWith("["), inclusiveEnd = version.endsWith("]"); String lower, upper; int index = 0; while (index < version.length()) { if (version.charAt(index) == ',') { break; } index++; } if (index == version.length()) { index -= 1; } lower = version.substring(1, index); char cur; int lowerEnd = index + 1; if (index == (version.length() - 1)) { upper = lower; } else { while ((cur = version.charAt(++index)) != ')' && (cur != ']')) { } upper = version.substring(lowerEnd, index); if (version.length() != (index + 1)) { throw new UnsupportedRangeSet(); } } lower = lower.trim(); upper = upper.trim(); if (lower.isEmpty() && upper.isEmpty()) { throw new Invalid(); } if (inclusiveEnd && !upper.isEmpty()) { return upper; } MavenMetadataParser parser = new MavenMetadataParser(); MavenMetadataParser.Metadata metadata = parser.parseMetadata(baseResource, headers); if ((metadata == null) || ((metadata.latest == null) && (metadata.versions == null))) { Output.print("^warn^ Could not resolve the 'maven-metadata.xml' file from the repository at %s", baseResource); return null; } String latest = (metadata.latest == null ? metadata.versions.get(metadata.versions.size() - 1) : metadata.latest); if (!lower.isEmpty() && !withinLowerBound(inclusiveStart, lower, latest)) { Output.print("^warn^ Version ^b^%s^r^ falls outside of lower bound restriction: ^b^%s%s^r^", latest, (inclusiveStart ? "[" :"("), lower); return null; } if (upper.isEmpty()) { return latest; } else { int compare = MAVEN_VERSION_COMPARATOR.compare(upper, latest); if (compare <= 0) { if (metadata.versions != null) { for (int i = metadata.versions.size() - 1; i > -1; i--) { latest = metadata.versions.get(i); if (MAVEN_VERSION_COMPARATOR.compare(upper, latest) > 0) { if (!lower.isEmpty() && !withinLowerBound(inclusiveStart, lower, latest)) { Output.print("^warn^ All available versions fall outside of lower bound restriction: ^b^%s%s^r^", (inclusiveStart ? "[" :"("), lower); return null; } return latest; } } } Output.print("^warn^ All available versions fall outside of upper bound restriction: ^b^%s%s^r^", upper, (inclusiveEnd ? "[" : "(")); return null; } return latest; } }
public static Reader createInstance(FormatType format) { if (FormatType.JSON == format) { return new JsonReader(); } if (FormatType.XML == format) { return new XmlReader(); } throw new IllegalStateException("Server response has a bad format type: " + format); }
@Override public FluentListAssert hasClass(String classToFind) { return validateHasClasses("No selected elements have class: ", classToFind); }
void listObjects(AmazonS3 s3, Collection<String> domains, long modTime) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("listObjects: Retrieving domains from {} with mod time > {}", s3BucketName, modTime); } ObjectListing objectListing = s3.listObjects(new ListObjectsRequest() .withBucketName(s3BucketName)); String objectName; while (objectListing != null) { final List<S3ObjectSummary> objectSummaries = objectListing.getObjectSummaries(); boolean listTruncated = objectListing.isTruncated(); if (LOGGER.isDebugEnabled()) { LOGGER.debug("listObjects: retrieved {} objects, more objects available - {}", objectSummaries.size(), listTruncated); } for (S3ObjectSummary objectSummary : objectSummaries) { if (modTime > 0 && objectSummary.getLastModified().getTime() <= modTime) { continue; } objectName = objectSummary.getKey(); if (objectName.charAt(0) == '.') { continue; } domains.add(objectName); } if (!listTruncated) { break; } objectListing = s3.listNextBatchOfObjects(objectListing); } }
public void setGenerator(IdGenerator idg) { generator = Args.notNull(idg, "generator"); }
@SuppressFBWarnings(value = "REC_CATCH_EXCEPTION", justification = "Applies Maven exception wrapper") public EntryPoint getEntryPoint(ClassLoaderResolver classLoaderResolver, String groupId, String artifactId, String version, String packaging) throws MojoExecutionException { if (entryPoint == null || entryPoint.length() == 0) { throw new MojoExecutionException("Entry point name is not defined"); } for (EntryPoint.Default entryPoint : EntryPoint.Default.values()) { if (this.entryPoint.equals(entryPoint.name())) { return entryPoint; } } try { return (EntryPoint) Class.forName(entryPoint, false, classLoaderResolver.resolve(asCoordinate(groupId, artifactId, version, packaging))) .getDeclaredConstructor() .newInstance(); } catch (Exception exception) { throw new MojoExecutionException("Cannot create entry point: " + entryPoint, exception); } }
public PropertyDispatcher createDispatcherChain(Object pmo, BoundProperty boundProperty, PropertyBehaviorProvider behaviorProvider) { requireNonNull(pmo, "pmo must not be null"); requireNonNull(boundProperty, "boundProperty must not be null"); requireNonNull(behaviorProvider, "behaviorProvider must not be null"); String modelPropertyName = boundProperty.getModelAttribute(); String modelObjectName = boundProperty.getModelObject(); String pmoPropertyName = boundProperty.getPmoProperty(); ExceptionPropertyDispatcher exceptionDispatcher = newExceptionDispatcher(pmo, modelObjectName, pmoPropertyName); ReflectionPropertyDispatcher reflectionDispatcher = newReflectionDispatcher(pmo, pmoPropertyName, modelObjectName, modelPropertyName, exceptionDispatcher); StaticValueDispatcher bindingAnnotationDispatcher = new StaticValueDispatcher(reflectionDispatcher); PropertyDispatcher customDispatchers = createCustomDispatchers(pmo, boundProperty, bindingAnnotationDispatcher); return new BehaviorDependentDispatcher(customDispatchers, behaviorProvider); }
public static String processApidInfo(String apidnum, String apidgaps) { String stringParsed=""; if(apidnum!=null && apidgaps != null) { String[] apidnumList = apidnum.trim().split(";"); String[] apidgapsList = apidgaps.trim().split(";"); if(apidnumList.length == apidgapsList.length) { for(int i=0;i<apidnumList.length;i++) { stringParsed = stringParsed + "Apid#: "+(apidnumList[i].isEmpty()?"-":apidnumList[i])+ " Apid total gaps: "+ (apidgapsList[i].isEmpty()?"-":apidgapsList[i])+"; "; } } else { for(int i=0;i<apidnumList.length;i++) { stringParsed = stringParsed + "Apid#: "+(apidnumList[i].isEmpty()?"-":apidnumList[i])+"; "; } } } else { logger.error("Error getting Information on missing ISPs APID"); } logger.debug(" ************* missing ISPs APID: " + stringParsed); stringParsed=stringParsed.replace("Apid#: - Apid total gaps: -;", "N/A").replace("Apid#: -;", "N/A"); if(stringParsed.length()>MAX_METADATA_SIZE) { stringParsed=stringParsed.substring(0,MAX_METADATA_SIZE-4)+"..."; } return stringParsed; }
public FEELFnResult<String> invoke(@ParameterName("string") String string) { if ( string == null ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "string", "cannot be null")); } else { return FEELFnResult.ofResult( string.toLowerCase() ); } }
public static Builder newBuilder(SpanProcessor spanProcessor) { return new Builder(Preconditions.checkNotNull(spanProcessor)); }
@EventHandler public void handle(ChargingStationCreatedEvent event) { LOG.info("Handling ChargingStationCreatedEvent"); String chargingStationId = event.getChargingStationId().getId(); ChargingStation chargingStation = chargingStationRepository.findOne(chargingStationId); if (chargingStation == null) { chargingStation = new ChargingStation(chargingStationId); } chargingStationRepository.createOrUpdate(chargingStation); }
@Override public String toHumanString(T value) { if (value == null) { return "null"; } switch (type.typeId()) { case DATE: return TransformUtil.humanDay((Integer) value); case TIME: return TransformUtil.humanTime((Long) value); case TIMESTAMP: if (((Types.TimestampType) type).shouldAdjustToUTC()) { return TransformUtil.humanTimestampWithZone((Long) value); } else { return TransformUtil.humanTimestampWithoutZone((Long) value); } case FIXED: case BINARY: if (value instanceof ByteBuffer) { return TransformUtil.base64encode(((ByteBuffer) value).duplicate()); } else if (value instanceof byte[]) { return TransformUtil.base64encode(ByteBuffer.wrap((byte[]) value)); } else { throw new UnsupportedOperationException("Unsupported binary type: " + value.getClass()); } default: return value.toString(); } }
public void process( int number ) { for ( int i = 0; i < number; i++) { everyTime( i ); if ( i % blockSize == blockSize - 1 || i == number - 1 ) { everyBlock( i ); } } blocksComplete(); }
public IAtomContainerSet getStructures(IAtomContainer molecule) { int countStructure = 0; IAtomContainerSet setOfMol = molecule.getBuilder().newInstance(IAtomContainerSet.class); setOfMol.addAtomContainer(molecule); for (int i = 0; i < setOfMol.getAtomContainerCount(); i++) { IAtomContainer mol = setOfMol.getAtomContainer(i); for (IReactionProcess aReactionsList : reactionsList) { IReactionProcess reaction = aReactionsList; IAtomContainerSet setOfReactants = molecule.getBuilder().newInstance(IAtomContainerSet.class); setOfReactants.addAtomContainer(mol); try { IReactionSet setOfReactions = reaction.initiate(setOfReactants, null); if (setOfReactions.getReactionCount() != 0) for (int k = 0; k < setOfReactions.getReactionCount(); k++) for (int j = 0; j < setOfReactions.getReaction(k).getProducts().getAtomContainerCount(); j++) { IAtomContainer product = setOfReactions.getReaction(k).getProducts() .getAtomContainer(j); if (!existAC(setOfMol, product)) { setOfMol.addAtomContainer(product); countStructure++; if (countStructure > maxStructures) return setOfMol; } } } catch (CDKException e) { e.printStackTrace(); } } } return setOfMol; }
@Override public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException { throw new UnsupportedOperationException("Unsupported export redis service. url: " + invoker.getUrl()); }
Collection<BindingStrategy> collectFromAggregates(Collection<Class<? extends AggregateRoot>> aggregateClasses) { Collection<BindingStrategy> bindingStrategies = new ArrayList<>(); Map<Type[], Key<?>> allGenerics = new HashMap<>(); for (Class<? extends AggregateRoot<?>> aggregateClass : BusinessUtils.includeSuperClasses(aggregateClasses)) { Type[] generics = getTypes(aggregateClass); TypeLiteral<?> genericInterface = TypeLiteral.get(newParameterizedType(Repository.class, generics)); allGenerics.put(generics, resolveDefaultQualifier( bindings, application.getConfiguration(aggregateClass), DEFAULT_REPOSITORY_KEY, aggregateClass, genericInterface ).orElse(null) ); } for (Class<? extends Repository> defaultRepoImpl : defaultRepositoryImplementations) { bindingStrategies.add(new GenericBindingStrategy<>( Repository.class, defaultRepoImpl, allGenerics) ); } return bindingStrategies; }
public static Function<String, String> rollup(int n) { return new RollupLimiter(n); }
public static Document parse(URLConnection uc, Element instruction, PrintWriter logger) throws SSLProtocolException { Document doc = null; InputStream is = null; try { is = uc.getInputStream(); doc = parse(is, instruction, logger); } catch (SSLProtocolException sslep){ throw new SSLProtocolException("[SSL ERROR] Failed to connect with the requested URL due to \"Invalid server_name\" found!! :" + uc.getURL() +":" + sslep.getClass() +" : "+ sslep.getMessage()); } catch (Exception e) { String msg = String.format( "Failed to parse %s resource from %s %n %s", uc.getContentType(), uc.getURL(), e.getMessage()); jlogger.warning(msg); } finally { if (null != is) { try { is.close(); } catch (IOException e) { } } } return doc; }
@Override public SwitchLacpGroup getSwitchLacpGroup( SwitchNode switchNode, String lacpGroupName ) throws HmsException { CumulusTorSwitchSession session = (CumulusTorSwitchSession) getSession( switchNode ); if ( session == null ) { error( String.format( "Cannot ssh to switch %s (%s)", switchNode.getIpAddress(), switchNode.getSwitchId() ), HmsOobNetworkErrorCode.SWITCH_UNREACHABLE ); } return lacpHelper.getSwitchLacpGroup( switchNode, lacpGroupName ); }
@Override public ToShort<T> orThrow() { return original; }
public FEELFnResult<Boolean> invoke(@ParameterName( "range1" ) Range range1, @ParameterName( "range2" ) Range range2) { return OverlapsFunction.INSTANCE.invoke(range1, range2); }
public boolean isValidPropertiesMap(Map<String, Object> properties) { if (skipValidation) { LOG.info("Skipping property validation because no properties were specified."); return true; } if (properties.size() != validationRules.size()) { LOG.info("Properties size does not match the number of validation rules."); return false; } return validationRules.stream() .allMatch(rule -> properties.containsKey(rule.getName()) && rule.getType().isInstance(properties.get(rule.getName()))); }
public static void toggleTerrainLocked() { setTerrainLocked(!ourTerrainLocked); }
@Override public String doPostEntity(Map<String, String> requestProperties, URL urlToCall, String body, MediaType contentType, MediaType acceptType) throws ODataClientException { return sendRequest(populateRequestProperties(requestProperties, body.length(), contentType, acceptType), urlToCall, body, ODataRequest.Method.POST.name()); }
@Override public List<QuestionStatusResource> getNotificationsForUser(Collection<QuestionStatusResource> questionStatuses, Long userId) { return questionStatuses.stream(). filter(qs -> userId.equals(qs.getAssigneeUserId()) && (qs.getNotified() != null && qs.getNotified().equals(Boolean.FALSE))) .collect(Collectors.toList()); }
@Override public String applyTemplate(String templateName, String templateContent, WorkflowInstance workflowInstance) { if (templateContent == null && templateScannerRef.get() != null) { templateContent = templateScannerRef.get().getTemplate(templateName); } if (templateContent == null) { logger.warn("E-mail template not found: {}", templateName); return "TEMPLATE NOT FOUND: " + templateName; } HashMap<String, HashMap<String, String>> catalogs = initCatalogs(workflowInstance.getMediaPackage()); WorkflowOperationInstance failed = findFailedOperation(workflowInstance); List<Incident> incidentList = null; if (failed != null) { try { IncidentTree incidents = incidentService.getIncidentsOfJob(failed.getId(), true); incidentList = generateIncidentList(incidents); } catch (Exception e) { logger.error("Error when populating template with incidents", e); } } return DocUtil.generate(new EmailData(templateName, workflowInstance, catalogs, failed, incidentList), templateContent); }
public ImageQueryPipelineBuilder removeSingleImageGroups() { this.postProcessing.add(new RemoveSingleImageSetStage()); return this; }
public static String stripTrailingSlash(String s) { return s == null ? null : CharMatcher.is('/').trimTrailingFrom(s); }
@Override public synchronized int read() throws IOException { byte[] buf = new byte[1]; if (read(buf, 0, 1) == EOF) { return EOF; } return Byte.toUnsignedInt(buf[0]); }
public long getWaitTime() { return configuration.getMonitoringBroadcastIntervalMs(); }
public static int indexOf(Object[] array, Object objectToFind) { return indexOf(array, objectToFind, 0); }
public static Origin parse(String line) throws ParseException { Matcher m = parsePattern.matcher(line); if (!m.find()) throw new ParseException("not a valid origin record", 0); Origin result = null; try { long sessionId = Long.parseLong(m.group(2)); long version = Long.parseLong(m.group(3)); InetAddress addr = InetAddress.getByName(m.group(6)); result = new Origin(m.group(1), sessionId, version, addr); } catch (Exception ex) { throw (ParseException) new ParseException("not a valid origin record", 0).initCause(ex); } result.setNetworkType(m.group(4)); return result; }
private void mergeSegment(PlatformOutboundInstruction platformOutboundInstruction) { EventProcessorSegmentReference mergeSegment = platformOutboundInstruction.getMergeEventProcessorSegment(); String processorName = mergeSegment.getProcessorName(); int segmentId = mergeSegment.getSegmentIdentifier(); String errorMessage = format("Failed to merge segment [%s] for processor [%s]", segmentId, processorName); try { if (!eventProcessorController.mergeSegment(processorName, segmentId)) { throw new RuntimeException(errorMessage); } resultPublisher.publishSuccessFor(platformOutboundInstruction.getInstructionId()); } catch (Exception e) { logger.error(errorMessage, e); resultPublisher.publishFailureFor(platformOutboundInstruction.getInstructionId(), e); } }
public static Multimap<Long, JsonIssueDetails> getMergedDetectionErrors(BatchJob job) { Multimap<Long, DetectionProcessingError> errorsIndexedByMedia = Multimaps.index(job.getDetectionProcessingErrors(), DetectionProcessingError::getMediaId); SetMultimap<Long, JsonIssueDetails> results = MultimapBuilder.hashKeys().hashSetValues().build(); for (var entry : errorsIndexedByMedia.asMap().entrySet()) { Media media = job.getMedia(entry.getKey()); Collection<DetectionProcessingError> mediaErrors = entry.getValue(); if (media.getMediaType() == MediaType.VIDEO) { results.putAll(media.getId(), mergeErrors(job, mediaErrors)); } else { List<JsonIssueDetails> issues = mediaErrors .stream() .map(d -> convertDetectionErrorToIssue(job, d)) .collect(toList()); results.putAll(media.getId(), issues); } } return results; }
public static String setQueryParams(final String httpUrl, final Map<String, Object> queryParams) throws URISyntaxException { URIBuilder uriBuilder = new URIBuilder(httpUrl); Map<String, Object> nullSafeQueryParams = ofNullable(queryParams).orElseGet(HashMap::new); nullSafeQueryParams.keySet().forEach(key -> uriBuilder.addParameter(key, nullSafeQueryParams.get(key).toString()) ); String composedURL = uriBuilder.build().toString(); LOGGER.info("### Effective url is : {}", composedURL); return composedURL; }
protected void verifyDefaultPropertyCanBeSet(ResourceEditProperty property, ContextEntity context) throws ValidationException { if (isSameValue(property.getDefaultValue(), property.getPropertyValue())) { if (context.isGlobal()) { throw new ValidationException("The default value of property \"" + property.getPropertyDisplayName() + "\" can not be set on global context"); } if (property.getParent() == null && property.getOriginalValue() == null) { throw new ValidationException("The default value of property \"" + property.getPropertyDisplayName() + "\" can not be set unless it overwrites a value defined on a parent context"); } } }
public void filter(Set<String> services) throws SSOException, SMSException { filterByAuthServices(services); filterByKnownServices(services); filterByDisplayableAttribute(services); }
public void doMain(String[] args) { if (args.length < 1) { printUsageAndExit("Expected at least a service argument.", ExitCode.INVALID_ARGS); } String service = args[0].toLowerCase(); try { getMain(service).invoke(null, (Object) Arrays.copyOfRange(args, 1, args.length, String[].class)); } catch (IllegalAccessException e) { printUsageAndExit("Service " + service + " has invalid main method.", ExitCode.SERVICE_ERROR); } catch (InvocationTargetException e) { printUsageAndExit("Service " + service + " error: " + e.getCause().getMessage(), ExitCode.SERVICE_ERROR); } return; }
public static long computeStartOfNextDay(long now) { Calendar cal = Calendar.getInstance(); cal.setTime(new Date(now)); cal.add(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.MILLISECOND, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.HOUR_OF_DAY, 0); return cal.getTime().getTime(); }
static String checkCoinNameExist(String coinName, Map<String, String> coins) { if(coins.containsKey(coinName)) { String nameWithBrace = coinName + "("; int number = 0; for (String existingName : coins.keySet()){ if(existingName.contains(nameWithBrace)){ int parsedNumber = parseNumberOfDuplicateName(nameWithBrace.length(), existingName); if(parsedNumber > number) number = parsedNumber; } } return coinName + "(" + ++number + ")"; } return coinName; }
public static IpAddress getDefaultInstance(final String defaultValue) { return IPV4_PATTERN.matcher(defaultValue).matches() ? new IpAddress(new Ipv4Address(defaultValue)) : new IpAddress(new Ipv6Address(defaultValue)); }
public int size() { return pool.size(); }
@Override public void handleMessage(Exchange exchange) throws TransactionFailureException { if (_transactionManager == null) { return; } Property prop = exchange.getContext().getProperty(BEFORE_INVOKED_PROPERTY, Scope.EXCHANGE); if (prop != null && Boolean.class.cast(prop.getValue())) { handleAfter(exchange); } else { exchange.getContext().setProperty(BEFORE_INVOKED_PROPERTY, Boolean.TRUE, Scope.EXCHANGE).addLabels(BehaviorLabel.TRANSIENT.label()); handleBefore(exchange); } }
public Span startSpan(String operationName, SpanContext spnContext){ Span span; if (spnContext!= null){ span = modelServiceApiTracer.buildSpan(operationName).asChildOf(spnContext).start(); } else { span = modelServiceApiTracer.buildSpan(operationName).start(); } return span; }
public void setActive(boolean active) { this.active = active; }
@Override public Set<DeviceId> getDevicesOf(NodeId nodeId) { checkPermission(CLUSTER_READ); checkNotNull(nodeId, NODE_ID_NULL); return store.getDevices(nodeId); }
public boolean containsAll(Collection<?> arg0) { return delegate.containsAll(arg0); }
public MicroserviceInstance getInstance() { return instance; }
public static int getInt(byte[] bytes, int index) { return (bytes[index] & 0xFF) | (bytes[index + 1] & 0xFF) << 8 | (bytes[index + 2] & 0xFF) << 16 | (bytes[index + 3] & 0xFF) << 24; }
@NotNull protected Tree getTree(@Nullable String oakPath, long permissions, boolean checkAcContent) throws RepositoryException { Tree tree = (oakPath == null) ? root.getTree("/") : root.getTree(oakPath); if (!tree.exists()) { throw new PathNotFoundException("No tree at " + oakPath); } if (permissions != Permissions.NO_PERMISSION) { checkPermissions((oakPath == null) ? null : tree, permissions); } if (checkAcContent && config.getContext().definesTree(tree)) { throw new AccessControlException("Tree " + tree.getPath() + " defines access control content."); } return tree; }
public void draw(Graphics2D graphics, Cell1DDataset dataset) { Color dividerColor = new Color(196, 196, 196); Color lineColor = new Color(140, 140, 140); Color histogramColor = new Color(175, 175, 175); this.g = graphics; this.referenceLineColor = this.backgroundColor; calculateRanges(dataset.getXRange(), dataset.getXRange(), dataset.getStatistics().getRange(), dataset.getDisplayRange()); calculateLabels(); calculateGraphArea(); drawBackground(); drawGraphArea(); int[] binLimitsPx = new int[dataset.getXCount() + 1]; int[] binHeightsPx = new int[dataset.getXCount()]; focusValueIndex = null; for (int i = 0; i < dataset.getXCount(); i++) { binLimitsPx[i] = (int) scaledX(dataset.getXBoundaries().getDouble(i)); binHeightsPx[i] = (int) scaledY(dataset.getValue(i)); if (focusPixelX != null && binLimitsPx[i] < focusPixelX) { focusValueIndex = i; } } binLimitsPx[dataset.getXCount()] = (int) scaledX(dataset.getXBoundaries().getDouble(dataset.getXCount())); int plotStart = (int) scaledY(getYPlotRange().getMinimum()); for (int i = 0; i < binHeightsPx.length; i++) { graphics.setColor(histogramColor); if (!highlightFocusValue || focusValueIndex == null || i != focusValueIndex) { graphics.fillRect(binLimitsPx[i], binHeightsPx[i], binLimitsPx[i+1] - binLimitsPx[i], plotStart - binHeightsPx[i]); } graphics.setColor(dividerColor); if ((plotStart - binHeightsPx[i]) > 0) { graphics.drawLine(binLimitsPx[i], binHeightsPx[i], binLimitsPx[i], plotStart); } } graphics.setColor(backgroundColor); drawHorizontalReferenceLines(); int previousHeight = plotStart; for (int i = 0; i < binHeightsPx.length; i++) { graphics.setColor(lineColor); graphics.drawLine(binLimitsPx[i], previousHeight, binLimitsPx[i], binHeightsPx[i]); graphics.drawLine(binLimitsPx[i], binHeightsPx[i], binLimitsPx[i+1], binHeightsPx[i]); previousHeight = binHeightsPx[i]; } if (previousHeight > 0) graphics.drawLine(binLimitsPx[binLimitsPx.length - 1], previousHeight, binLimitsPx[binLimitsPx.length - 1], plotStart); }
protected Double[] getArrayOfDouble(Object input, Double lowerDefault, Double upperDefault) { Double[] ret = new Double[2]; ret[0] = lowerDefault; ret[1] = upperDefault; if (input != null) { if (input instanceof Object[]) { Object[] array = (Object[]) input; if (array.length == 1) { ret[0] = (Double) getDouble(array[0]); } else if (array.length > 1) { ret[0] = (Double) getDouble(array[0]); ret[1] = (Double) getDouble(array[1]); } } else if (input instanceof Collection<?>) { Collection<?> coll = (Collection<?>) input; if (coll.size() == 1) { ret[0] = (Double) getDouble(coll.toArray()[0]); } else if (coll.size() > 1) { ret[0] = (Double) getDouble(coll.toArray()[0]); ret[1] = (Double) getDouble(coll.toArray()[1]); } } else { ret[0] = getDouble(input); } } return ret; }
public static LeaseDuration of(String initial, String max, String step) { return builder().setInitial(initial).setMax(max).setStep(step).build(); }
@Override protected Subtitle decode(byte[] bytes, int length, boolean reset) { List<List<Cue>> cues = new ArrayList<>(); List<Long> cueTimesUs = new ArrayList<>(); ParsableByteArray data = new ParsableByteArray(bytes, length); if (!haveInitializationData) { parseHeader(data); } parseEventBody(data, cues, cueTimesUs); return new SsaSubtitle(cues, cueTimesUs); }
public void deliveryPlan(FormSubmission submission) { allTimelines.add( forDeliveryPlan( submission.entityId(), submission.getFieldValue(DELIVERY_FACILITY_NAME), submission.getFieldValue(TRANSPORTATION_PLAN), submission.getFieldValue(BIRTH_COMPANION), submission.getFieldValue(ASHA_PHONE_NUMBER), submission.getFieldValue(PHONE_NUMBER), submission.getFieldValue(REVIEWED_HRP_STATUS), submission.getFieldValue(SUBMISSION_DATE))); serviceProvidedService.add( ServiceProvided.forDeliveryPlan( submission.entityId(), submission.getFieldValue(DELIVERY_FACILITY_NAME), submission.getFieldValue(TRANSPORTATION_PLAN), submission.getFieldValue(BIRTH_COMPANION), submission.getFieldValue(ASHA_PHONE_NUMBER), submission.getFieldValue(PHONE_NUMBER), submission.getFieldValue(REVIEWED_HRP_STATUS), submission.getFieldValue(SUBMISSION_DATE) )); }
@Override public void refreshDate(List<SelectInventoryViewModel> inventories) { adapter.refreshDate(inventories); for (SelectInventoryViewModel selectInventoryViewModel : inventories) { if (selectInventoryViewModel.isChecked()) { int position = inventories.indexOf(selectInventoryViewModel); vgContainer.setItemChecked(position, true); selectedInventory = adapter.getItem(position); } } }
@VisibleForTesting static void prepareHeaders( Metadata headers, DecompressorRegistry decompressorRegistry, Compressor compressor, boolean fullStreamDecompression) { headers.discardAll(MESSAGE_ENCODING_KEY); if (compressor != Codec.Identity.NONE) { headers.put(MESSAGE_ENCODING_KEY, compressor.getMessageEncoding()); } headers.discardAll(MESSAGE_ACCEPT_ENCODING_KEY); byte[] advertisedEncodings = InternalDecompressorRegistry.getRawAdvertisedMessageEncodings(decompressorRegistry); if (advertisedEncodings.length != 0) { headers.put(MESSAGE_ACCEPT_ENCODING_KEY, advertisedEncodings); } headers.discardAll(CONTENT_ENCODING_KEY); headers.discardAll(CONTENT_ACCEPT_ENCODING_KEY); if (fullStreamDecompression) { headers.put(CONTENT_ACCEPT_ENCODING_KEY, FULL_STREAM_DECOMPRESSION_ENCODINGS); } }
public static String toCombinedFormat(long instant) { TaiUtcConverter.DateTimeComponents dtc = taiUtcConverter.instantToUtc(instant); StringBuilder sb = new StringBuilder(); formatOn4Digits(dtc.year, sb); sb.append("-"); formatOn2Digits(dtc.month, sb); sb.append("-"); formatOn2Digits(dtc.day, sb); sb.append("/"); formatOn3Digits(dtc.doy, sb); sb.append("T"); formatOn2Digits(dtc.hour, sb); sb.append(":"); formatOn2Digits(dtc.minute, sb); sb.append(":"); formatOn2Digits(dtc.second, sb); sb.append("."); formatOn3Digits(dtc.millisec, sb); return sb.toString(); }
public static byte[] hexStringToByteArray(String hexString) { if (hexString == null) { return null; } int length = hexString.length(); byte[] bytes = new byte[length / 2]; for (int i = 0; i < length; i += 2) { bytes[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16)); } return bytes; }
static int fillExternalChanges(@NotNull StringSort externalChanges, @NotNull StringSort invalidate, @NotNull Revision from, @NotNull Revision to, @NotNull DocumentStore store) throws IOException { return fillExternalChanges(externalChanges, invalidate, Path.ROOT, from, to, store, entry -> {}, null, null); }
final <R> R poll(final PollHandler<?,R> handler, long timeout, final TimeUnit unit) { notNull(handler, "handler"); final long start = System.currentTimeMillis(); while (true) { if (pollOnce(handler)) { return handler.getResult(); } if (unit != null && start + unit.toMillis(timeout) < System.currentTimeMillis()) { throw new GoodDataException("timeout"); } try { Thread.sleep(settings.getPollSleep()); } catch (InterruptedException e) { throw new GoodDataException("interrupted"); } } }
@Override public void onEnterScope(String scopeName, View view) { currentScreen.enterScope(scopeName, view); fireOnScreenChanged(); }
@Scheduled(fixedRate = 5000, initialDelay = 3000) public void emitJvmVitals() { OperatingSystemMXBean osBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean(); ThreadMXBean threadBean = (ThreadMXBean) ManagementFactory.getThreadMXBean(); MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean(); String prefix = "vitals.jvm."; statsDClient.gauge(prefix + "cpu.load", (long) (((Number) osBean.getProcessCpuLoad()).doubleValue() * 100)); statsDClient.gauge(prefix + "thread.count", threadBean.getThreadCount()); Map<String, MemoryUsage> memory = new HashMap<>(); memory.put("heap", memoryBean.getHeapMemoryUsage()); memory.put("non-heap", memoryBean.getNonHeapMemoryUsage()); memory.forEach((key, value) -> { statsDClient.gauge(prefix + key + ".init", value.getInit()); statsDClient.gauge(prefix + key + ".committed", value.getCommitted()); statsDClient.gauge(prefix + key + ".used", value.getUsed()); statsDClient.gauge(prefix + key + ".max", value.getMax()); }); }
public long extractIdFromFilename(String filename) throws UnrecognisedFilenameException { Matcher matches = pattern.matcher(filename); if (!matches.matches() || matches.groupCount() != 1) throw new UnrecognisedFilenameException("Could not extract a change script number from filename: " + filename); return Long.parseLong(matches.group(1)); }
@SuppressWarnings("checkstyle:innerassignment") public static boolean isBlank(final CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if (!Character.isWhitespace(cs.charAt(i))) { return false; } } return true; }
protected void restoreDraftInventory() throws LMISException { List<DraftInventory> draftList = inventoryRepository.queryAllDraft(); for (DraftInventory draftInventory : draftList) { for (InventoryViewModel viewModel : inventoryViewModelList) { if (viewModel.getStockCardId() == draftInventory.getStockCard().getId()) { ((PhysicalInventoryViewModel) viewModel).setDraftInventory(draftInventory); } } } }
public int getViews(String mediapackageId) { EntityManager em = null; try { em = emf.createEntityManager(); Query q = em.createNamedQuery("countSessionsOfMediapackage"); q.setParameter("mediapackageId", mediapackageId); return ((Long) q.getSingleResult()).intValue(); } finally { if (em != null && em.isOpen()) { em.close(); } } }
@Override public final void clear() { lazySet(FUSED_CONSUMED); value = null; }
public X509Certificate createX509Certificate(Consumer consumer, Owner owner, Pool pool, Entitlement ent, Product product, Set<Product> products, List<org.candlepin.model.dto.Product> productModels, BigInteger serialNumber, KeyPair keyPair, boolean useContentPrefix) throws GeneralSecurityException, IOException { Set<X509ExtensionWrapper> extensions; Set<X509ByteExtensionWrapper> byteExtensions = new LinkedHashSet<>(); products.add(product); Map<String, EnvironmentContent> promotedContent = getPromotedContent(consumer); String contentPrefix = getContentPrefix(consumer, owner, useContentPrefix); if (shouldGenerateV3(consumer)) { extensions = prepareV3Extensions(); byteExtensions = prepareV3ByteExtensions(product, productModels, contentPrefix, promotedContent); } else { extensions = prepareV1Extensions(products, pool, consumer, ent.getQuantity(), contentPrefix, promotedContent); } Date endDate = setupEntitlementEndDate(pool, consumer); ent.setEndDateOverride(endDate); Calendar calNow = Calendar.getInstance(); Calendar calMinusHour = Calendar.getInstance(); calMinusHour.add(Calendar.HOUR, -1); Date startDate = pool.getStartDate(); if (pool.getStartDate().getTime() > calMinusHour.getTime().getTime() && pool.getStartDate().getTime() < calNow.getTime().getTime()) { startDate = calMinusHour.getTime(); } X509Certificate x509Cert = this.pki.createX509Certificate( createDN(ent, owner), extensions, byteExtensions, startDate, endDate, keyPair, serialNumber, null); return x509Cert; }
@Override public Completable write(Publisher<Write> write) { return write(write, flushStrategyHolder::currentStrategy, WriteDemandEstimators::newDefaultEstimator); }
@Override @Transactional(propagation = Propagation.NEVER) public List<ResourcePersistentId> getResources(final String theUuid, int theFrom, int theTo, @Nullable RequestDetails theRequestDetails) { TransactionTemplate txTemplate = new TransactionTemplate(myManagedTxManager); txTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); SearchTask searchTask = myIdToSearchTask.get(theUuid); if (searchTask != null) { searchTask.awaitInitialSync(); } ourLog.trace("About to start looking for resources {}-{}", theFrom, theTo); Search search; StopWatch sw = new StopWatch(); while (true) { if (myNeverUseLocalSearchForUnitTests == false) { if (searchTask != null) { ourLog.trace("Local search found"); List<ResourcePersistentId> resourcePids = searchTask.getResourcePids(theFrom, theTo); ourLog.trace("Local search returned {} pids, wanted {}-{} - Search: {}", resourcePids.size(), theFrom, theTo, searchTask.getSearch()); if ((searchTask.getSearch().getNumFound() - searchTask.getSearch().getNumBlocked()) >= theTo || resourcePids.size() == (theTo - theFrom)) { return resourcePids; } } } search = mySearchCacheSvc .fetchByUuid(theUuid) .orElseThrow(() -> newResourceGoneException(theUuid)); verifySearchHasntFailedOrThrowInternalErrorException(search); if (search.getStatus() == SearchStatusEnum.FINISHED) { ourLog.trace("Search entity marked as finished with {} results", search.getNumFound()); break; } if (search.getNumFound() >= theTo) { ourLog.trace("Search entity has {} results so far", search.getNumFound()); break; } if (sw.getMillis() > myMaxMillisToWaitForRemoteResults) { ourLog.error("Search {} of type {} for {}{} timed out after {}ms", search.getId(), search.getSearchType(), search.getResourceType(), search.getSearchQueryString(), sw.getMillis()); throw new InternalErrorException("Request timed out after " + sw.getMillis() + "ms"); } if (search.getStatus() == SearchStatusEnum.PASSCMPLET) { ourLog.trace("Going to try to start next search"); Optional<Search> newSearch = mySearchCacheSvc.tryToMarkSearchAsInProgress(search); if (newSearch.isPresent()) { ourLog.trace("Launching new search"); search = newSearch.get(); String resourceType = search.getResourceType(); SearchParameterMap params = search.getSearchParameterMap().orElseThrow(() -> new IllegalStateException("No map in PASSCOMPLET search")); IFhirResourceDao<?> resourceDao = myDaoRegistry.getResourceDao(resourceType); RequestPartitionId requestPartitionId = myRequestPartitionHelperService.determineReadPartitionForRequest(theRequestDetails, resourceType); SearchContinuationTask task = new SearchContinuationTask(search, resourceDao, params, resourceType, theRequestDetails, requestPartitionId); myIdToSearchTask.put(search.getUuid(), task); myExecutor.submit(task); } } AsyncUtil.sleep(500); } ourLog.trace("Finished looping"); List<ResourcePersistentId> pids = mySearchResultCacheSvc.fetchResultPids(search, theFrom, theTo); if (pids == null) { throw newResourceGoneException(theUuid); } ourLog.trace("Fetched {} results", pids.size()); return pids; }
public <T> T heapInstance(Class<T> tClass) { try { return (T) acquireHeapClass(tClass).newInstance(); } catch (Exception e) { throw new AssertionError(e); } }
public static void putPresenter(@NonNull Activity activity, @NonNull String viewId, @NonNull MvpPresenter<? extends MvpView> presenter) { if (activity == null) { throw new NullPointerException("Activity is null"); } ActivityScopedCache scopedCache = getOrCreateActivityScopedCache(activity); scopedCache.putPresenter(viewId, presenter); }
@Override @CatAnnotation public DataPoint save(String accountName, Account account) { Instant instant = LocalDate.now().atStartOfDay() .atZone(ZoneId.systemDefault()).toInstant(); DataPointId pointId = new DataPointId(accountName, Date.from(instant)); Set<ItemMetric> incomes = account.getIncomes().stream() .map(this::createItemMetric) .collect(Collectors.toSet()); Set<ItemMetric> expenses = account.getExpenses().stream() .map(this::createItemMetric) .collect(Collectors.toSet()); Map<StatisticMetric, BigDecimal> statistics = createStatisticMetrics(incomes, expenses, account.getSaving()); DataPoint dataPoint = new DataPoint(); dataPoint.setId(pointId); dataPoint.setIncomes(incomes); dataPoint.setExpenses(expenses); dataPoint.setStatistics(statistics); dataPoint.setRates(ratesService.getCurrentRates()); log.debug("new datapoint has been created: {}", pointId); return repository.save(dataPoint); }
protected void calculateOccurrenceRatios(FunctionalDependencyResult result) { Set<ColumnIdentifier> dependant = result.getExtendedDependant().getColumnIdentifiers(); result.setDependantOccurrenceRatio( calculateOccurrenceRatio(dependant, result.getDependantTableName())); Set<ColumnIdentifier> determinant = result.getDeterminant().getColumnIdentifiers(); result.setDeterminantOccurrenceRatio( calculateOccurrenceRatio(determinant, result.getDeterminantTableName())); }
public List<Project> getProjectByGroupId(Long groupId) throws SQLException { String sql = "SELECT id, name, namespace, dal_group_id, dal_config_name, app_scene, update_user_no, update_time FROM project WHERE dal_group_id = ? order by name"; return this.queryBySql(sql, Project.class, Parameter.integerOf(StringUtils.EMPTY, groupId)); }
public static <T> T getMethod(Object object, String name, Object... params) { Check.notNull(object); Check.notNull(name); Check.notNull(params); try { final Class<?> clazz = getClass(object); final Method method = clazz.getDeclaredMethod(name, getParamTypes(params)); setAccessible(method, true); @SuppressWarnings("unchecked") final T value = (T) method.invoke(object, params); return value; } catch (final NoSuchMethodException | InvocationTargetException | IllegalAccessException exception) { if (exception.getCause() instanceof LionEngineException) { throw (LionEngineException) exception.getCause(); } throw new LionEngineException(exception, ERROR_METHOD + name); } }
void addLine(String revision, String author, boolean enabled) { final Line line = new Line(revision, author, enabled); lines.add(line); widestRevision = Math.max(widestRevision, line.revision.length()); widestAuthor = Math.max(widestAuthor, line.author.length()); }
public static <T> T coerce(Object value, Class<T> cls) { initializeCurrentClassLoaderIfNecessary(); if (value == null || cls == null || cls.isInstance(value)) { return (T) value; } try { return (T) ConvertUtils.convert(value, cls); } catch (ConversionException | InvalidAttributeException | IllegalArgumentException e) { throw new InvalidValueException(value, e.getMessage()); } }
@CanIgnoreReturnValue public int writeBytesTo(byte[] dest, int offset, int maxLength) { maxLength = Ints.min(maxLength, bits() / 8); Preconditions.checkPositionIndexes(offset, offset + maxLength, dest.length); writeBytesToImpl(dest, offset, maxLength); return maxLength; }
void onInstructionListVisibilityChanged(boolean shown) { if (instructionListListener != null) { instructionListListener.onInstructionListVisibilityChanged(shown); } }
static long[] parseUSmilesNumbers(String aux, IAtomContainer container) { int index; long[] numbers = new long[container.getAtomCount()]; int[] first = null; int label = 1; if ((index = aux.indexOf("/R:")) >= 0) { int endIndex = aux.indexOf('/', index + 8); if (endIndex<0) endIndex = aux.length(); String[] baseNumbers = aux.substring(index + 8, endIndex).split(";"); first = new int[baseNumbers.length]; Arrays.fill(first, -1); for (int i = 0; i < baseNumbers.length; i++) { String[] numbering = baseNumbers[i].split(","); first[i] = Integer.parseInt(numbering[0]) - 1; for (String number : numbering) { numbers[Integer.parseInt(number) - 1] = label++; } } } else if ((index = aux.indexOf("/N:")) >= 0) { String[] baseNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split(";"); first = new int[baseNumbers.length]; Arrays.fill(first, -1); if ((index = aux.indexOf("/F:")) >= 0) { String[] fixedHNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split(";"); for (int i = 0; i < fixedHNumbers.length; i++) { String component = fixedHNumbers[i]; if (component.charAt(component.length() - 1) == 'm') { int n = component.length() > 1 ? Integer .parseInt(component.substring(0, component.length() - 1)) : 1; for (int j = 0; j < n; j++) { String[] numbering = baseNumbers[i + j].split(","); first[i + j] = Integer.parseInt(numbering[0]) - 1; for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++; } } else { String[] numbering = component.split(","); for (String number : numbering) numbers[Integer.parseInt(number)-1] = label++; } } } else { for (int i = 0; i < baseNumbers.length; i++) { String[] numbering = baseNumbers[i].split(","); first[i] = Integer.parseInt(numbering[0]) - 1; for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++; } } } else { throw new IllegalArgumentException("AuxInfo did not contain extractable base numbers (/N: or /R:)."); } for (int v : first) { if (v >= 0) { IAtom atom = container.getAtom(v); if (atom.getFormalCharge() == null) continue; if (atom.getAtomicNumber() == 8 && atom.getFormalCharge() == -1) { List<IAtom> neighbors = container.getConnectedAtomsList(atom); if (neighbors.size() == 1) { IAtom correctedStart = findPiBondedOxygen(container, neighbors.get(0)); if (correctedStart != null) exch(numbers, v, container.indexOf(correctedStart)); } } } } for (int i = 0; i < numbers.length; i++) if (numbers[i] == 0) numbers[i] = label++; return numbers; }
@Override public Path getDirectory() { return directory; }
public void addPage(Integer page, String title) { if (page == null) { throw new IllegalArgumentException("Unable to add a null page to the destinations."); } destinations.put(page, title); }
public static String dropSuffix(String str, String suffix) { if (str.endsWith(suffix)) return str.substring(0, str.length() - suffix.length()); else return str; }
public String getDescription() { return this.description; }
@VisibleForTesting static List<Attribute> toAttributes(Map<String, ByteBuffer> rowAttributes) { return rowAttributes.entrySet() .stream() .map(entry -> new Attribute(AttributeName.of(entry.getKey()), fromByteBuffer(entry.getValue()))) .collect(ImmutableList.toImmutableList()); }
public static List<String> join(Map<String, String> map, String separator) { if (map == null) { return null; } List<String> list = new ArrayList<String>(); if (map == null || map.size() == 0) { return list; } for (Map.Entry<String, String> entry : map.entrySet()) { String key = entry.getKey(); String value = entry.getValue(); if (value == null || value.length() == 0) { list.add(key); } else { list.add(key + separator + value); } } return list; }
protected static QueryBuilder getQuery(Map<String, ValueSet> constraintSummary) { List<String> predicates = new ArrayList<>(); constraintSummary.forEach((fieldName, constraint) -> { String predicate = getPredicate(fieldName, constraint); if (!predicate.isEmpty()) { predicates.add(predicate); } }); if (predicates.isEmpty()) { logger.info("Predicates are NOT formed."); return QueryBuilders.matchAllQuery(); } String formedPredicates = Strings.collectionToDelimitedString(predicates, AND_OPER); logger.info("Formed Predicates: {}", formedPredicates); return QueryBuilders.queryStringQuery(formedPredicates).queryName(formedPredicates); }
public NamedOperationDetail getNamedOperation(final String name, final User user) throws CacheOperationFailedException { return get(name, user, null); }
@Override public LaunchResult run( @NotNull Executor executor, @NotNull IDevice device, @NotNull LaunchStatus launchStatus, @NotNull ConsolePrinter printer) { if (!device.supportsFeature(IDevice.HardwareFeature.EMBEDDED)) { return LaunchResult.success(); } Set<String> installedIotLauncherApps = myChecker.getInstalledIotLauncherApps(device); installedIotLauncherApps.remove(myPackageName); if (!installedIotLauncherApps.isEmpty()) { String otherApplicationIds = StringUtil.join(installedIotLauncherApps, "\n"); String reason = AndroidBundle.message("deployment.failed.uninstall.prompt.androidthings.text", otherApplicationIds); if (myPrompter.showQuestionPrompt(reason)) { Map<String, Throwable> failedUninstallApps = new TreeMap<>(); for (String app : installedIotLauncherApps) { try { device.uninstallPackage(app); } catch (InstallException e) { failedUninstallApps.put(app, e); } } if (!failedUninstallApps.isEmpty()) { StringBuffer sb = new StringBuffer(); for (Map.Entry a : failedUninstallApps.entrySet()) { sb.append(a.getKey()); sb.append(": "); sb.append(a.getValue()); sb.append("\n"); } String errorMessage = AndroidBundle.message("deployment.failed.uninstall.prompt.androidthings.errortext", sb.toString()); myPrompter.showErrorMessage(errorMessage); return LaunchResult.error("", getDescription()); } } else { printer.stdout("Installation aborted"); return LaunchResult.error("", getDescription()); } } return LaunchResult.success(); }
@Override public StormTopology createTopology() { logger.info("Creating OpenTsdbTopology - {}", topologyName); TopologyBuilder tb = new TopologyBuilder(); attachInput(tb); OpenTsdbConfig openTsdbConfig = topologyConfig.getOpenTsdbConfig(); tb.setBolt(OTSDB_PARSE_BOLT_ID, new DatapointParseBolt(), openTsdbConfig.getDatapointParseBoltExecutors()) .setNumTasks(openTsdbConfig.getDatapointParseBoltWorkers()) .shuffleGrouping(OTSDB_SPOUT_ID); tb.setBolt(OTSDB_FILTER_BOLT_ID, new OpenTSDBFilterBolt(), openTsdbConfig.getFilterBoltExecutors()) .fieldsGrouping(OTSDB_PARSE_BOLT_ID, new Fields("hash")); OpenTsdbClient.Builder tsdbBuilder = OpenTsdbClient .newBuilder(openTsdbConfig.getHosts()) .returnDetails(); if (openTsdbConfig.getClientChunkedRequestsEnabled()) { tsdbBuilder.enableChunkedEncoding(); } OpenTsdbBolt openTsdbBolt = new OpenTsdbBolt(tsdbBuilder, Collections.singletonList(TupleOpenTsdbDatapointMapper.DEFAULT_MAPPER)); openTsdbBolt.withBatchSize(openTsdbConfig.getBatchSize()).withFlushInterval(openTsdbConfig.getFlushInterval()); tb.setBolt(OTSDB_BOLT_ID, openTsdbBolt, openTsdbConfig.getBoltExecutors()) .setNumTasks(openTsdbConfig.getBoltWorkers()) .shuffleGrouping(OTSDB_FILTER_BOLT_ID); return tb.createTopology(); }
public static boolean expressionIsValidSQl( String filter ) { if ( filter == null ) { return true; } if ( TextUtils.containsAnyIgnoreCase( filter, ILLEGAL_SQL_KEYWORDS ) ) { return false; } for ( int i = 0; i < filter.length(); i++ ) { char ch = filter.charAt( i ); if ( !(Character.isWhitespace( ch ) || Character.isLetterOrDigit( ch ) || SQL_VALID_CHARS.contains( ch )) ) { return false; } } return true; }
@Override public synchronized boolean onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { return backupProvider.onActivityResult(requestCode, resultCode, data); }
@Override public Range findDomainBounds(XYDataset dataset) { if (dataset == null) { return null; } if (this.centerBarAtStartValue) { return findDomainBoundsWithOffset((IntervalXYDataset) dataset); } else { return super.findDomainBounds(dataset); } }
@Override public Collection<String> apply(Collection<String> input) { checkPointer(input != null); List<String> result = new LinkedList<>(); for (String text : input) { checkPointer(text != null); result.add(text.toLowerCase(locale)); } return result; }
@Override public String updateJob(@Nonnull final IJob job) throws ConnectionException, RequestException, AccessException { Validate.notNull(job); List<Map<String, Object>> resultMaps = execMapCmdList(JOB, new String[] { "-i" }, job.getRawFields()); return ResultMapParser.parseCommandResultMapIfIsInfoMessageAsString(resultMaps); }
@Override public PatientList savePatientList(PatientList patientList) { return dao.savePatientList(patientList); }
public List<HGlossaryEntry> getEntriesByLocale(LocaleId srcLocale, int offset, int maxResults, String filter, List<GlossarySortField> sortFields, String qualifiedName) { StringBuilder queryString = new StringBuilder(); queryString .append("select term.glossaryEntry from HGlossaryTerm as term ") .append("where term.glossaryEntry.srcLocale.localeId =:srcLocale ") .append("and term.locale.localeId = term.glossaryEntry.srcLocale.localeId ") .append("and term.glossaryEntry.glossary.qualifiedName =:qualifiedName"); if (!StringUtils.isBlank(filter)) { queryString.append(" and lower(term.content) like lower(:filter) escape '!'"); } if (sortFields != null && !sortFields.isEmpty()) { queryString.append(" ORDER BY "); List<String> sortQuery = Lists.newArrayList(); for (GlossarySortField sortField : sortFields) { String order = sortField.isAscending() ? " ASC" : " DESC"; sortQuery.add(sortField.getEntityField() + order); } queryString.append(Joiner.on(", ").join(sortQuery)); } Query query = getSession().createQuery(queryString.toString()) .setParameter("srcLocale", srcLocale) .setParameter("qualifiedName", qualifiedName) .setCacheable(true) .setComment("GlossaryDAO.getEntriesByLocale"); if (StringUtils.isNotBlank(filter)) { String escapeFilter = escapeQuery(filter); query.setParameter("filter", "%" + escapeFilter + "%"); } query.setFirstResult(offset).setMaxResults(maxResults); @SuppressWarnings("unchecked") List<HGlossaryEntry> result = query.list(); return result; }
public void filterUpgradeOptions(UpgradeV4Response upgradeOptions, UpgradeV4Request upgradeRequest) { List<ImageInfoV4Response> upgradeCandidates = upgradeOptions.getUpgradeCandidates(); List<ImageInfoV4Response> filteredUpgradeCandidates; if (Objects.isNull(upgradeRequest) || upgradeRequest.isEmpty()) { filteredUpgradeCandidates = List.of(upgradeCandidates.stream().max(getComparator()).orElseThrow()); LOGGER.info("No request param, defaulting to latest image {}", filteredUpgradeCandidates); } else { String requestImageId = upgradeRequest.getImageId(); String runtime = upgradeRequest.getRuntime(); boolean lockComponents = Boolean.TRUE.equals(upgradeRequest.getLockComponents()); if (StringUtils.isNotEmpty(requestImageId)) { filteredUpgradeCandidates = validateImageId(upgradeCandidates, requestImageId); LOGGER.info("Image successfully validated by imageId {}", requestImageId); } else if (StringUtils.isNotEmpty(runtime)) { filteredUpgradeCandidates = validateRuntime(upgradeCandidates, runtime); LOGGER.info("Image successfully filtered by runtime ({}): {}", runtime, filteredUpgradeCandidates); } else if (lockComponents) { filteredUpgradeCandidates = List.of(upgradeCandidates.stream().max(getComparator()).orElseThrow()); } else { filteredUpgradeCandidates = upgradeCandidates; } } upgradeOptions.setUpgradeCandidates(filteredUpgradeCandidates); }
protected Calendar getLocalTimeAsCalendar(BigDecimal localTimeParam, Calendar date) { if (localTimeParam == null) { return null; } Calendar resultTime = (Calendar) date.clone(); BigDecimal localTime = localTimeParam; if (localTime.compareTo(BigDecimal.ZERO) == -1) { localTime = localTime.add(BigDecimal.valueOf(24.0D)); resultTime.add(Calendar.HOUR_OF_DAY, -24); } String[] timeComponents = localTime.toPlainString().split("\\."); int hour = Integer.parseInt(timeComponents[0]); BigDecimal minutes = new BigDecimal("0." + timeComponents[1]); minutes = minutes.multiply(BigDecimal.valueOf(60)).setScale(0, RoundingMode.HALF_EVEN); if (minutes.intValue() == 60) { minutes = BigDecimal.ZERO; hour += 1; } if (hour == 24) { hour = 0; } resultTime.set(Calendar.HOUR_OF_DAY, hour); resultTime.set(Calendar.MINUTE, minutes.intValue()); resultTime.set(Calendar.SECOND, 0); resultTime.set(Calendar.MILLISECOND, 0); resultTime.setTimeZone(date.getTimeZone()); return resultTime; }
public static File getArtifactFileFromProjectDependencies(AbstractWisdomMojo mojo, String artifactId, String type) { Preconditions.checkNotNull(mojo); Preconditions.checkNotNull(artifactId); Preconditions.checkNotNull(type); for (Artifact artifact : mojo.project.getArtifacts()) { if (artifact.getArtifactId().equals(artifactId) && artifact.getType().equals(type)) { return artifact.getFile(); } } return null; }
boolean isConstraintValuePredicate() { return plugin().constraintValue() == BaseSingleFieldConstraint.TYPE_PREDICATE; }
@Override public ModelT get() { return myValue; }
public void step(Program aprogram) { steps(aprogram,1); }
public int getPosition(VpnProfile profile) { Connection.TransportType transportType = getUsePluggableTransports(context) ? OBFS4 : OPENVPN; GatewaySelector gatewaySelector = new GatewaySelector(new ArrayList<>(gateways.values())); Gateway gateway; int nClosest = 0; while ((gateway = gatewaySelector.select(nClosest)) != null) { if (profile.equals(gateway.getProfile(transportType))) { return nClosest; } nClosest++; } return -1; }
@GET @Path("/{projectName}/{exploratoryName}/{computationalName}") @Produces(MediaType.APPLICATION_JSON) public Response fetchSchedulerJobForComputationalResource(@Auth UserInfo userInfo, @PathParam("exploratoryName") String exploratoryName, @PathParam("projectName") String projectName, @PathParam("computationalName") String computationalName) { log.debug("Loading scheduler job for user {}, exploratory {} and computational resource {}...", userInfo.getName(), exploratoryName, computationalName); final SchedulerJobDTO schedulerJob = schedulerJobService .fetchSchedulerJobForComputationalResource(userInfo.getName(), projectName, exploratoryName, computationalName); return Response.ok(schedulerJob).build(); }
@Override public CompletableFuture<Void> putAsync(String key, V record) { Preconditions.checkArgument(StringUtils.isNotBlank(key), "key must not be null, empty or blank"); Preconditions.checkArgument(!key.contains(" "), String.format("key should not contain spaces: %s", key)); Preconditions.checkNotNull(record); Document<?> document = record instanceof JsonObject ? JsonDocument.create(key, (int) ttl.getSeconds(), (JsonObject) record) : BinaryDocument.create(key, (int) ttl.getSeconds(), Unpooled.copiedBuffer(valueSerde.toBytes(record))); return asyncWriteHelper( bucket.async().upsert(document, timeout.toMillis(), TimeUnit.MILLISECONDS), String.format("Failed to insert key %s into bucket %s", key, bucketName)); }
@SuppressWarnings("WeakerAccess") public AuthenticationRequest login(@NonNull String usernameOrEmail, @NonNull String password, @NonNull String realmOrConnection) { ParameterBuilder builder = ParameterBuilder.newBuilder() .set(USERNAME_KEY, usernameOrEmail) .set(PASSWORD_KEY, password); if (auth0.isOIDCConformant()) { final Map<String, Object> parameters = builder .setGrantType(GRANT_TYPE_PASSWORD_REALM) .setRealm(realmOrConnection) .asDictionary(); return loginWithToken(parameters); } else { final Map<String, Object> parameters = builder .setGrantType(GRANT_TYPE_PASSWORD) .setScope(SCOPE_OPENID) .setConnection(realmOrConnection) .asDictionary(); return loginWithResourceOwner(parameters); } }
@Override public UserDetails getUser(String username) throws ApsSystemException { return this.extractUser(username, null); }
public Aggregator getAggregator(String aggregatorId) throws DoesNotExistException { WebTarget target = client.target(restUrl + "/" + AggregatorOptionListContainer.AGGREGATORS + "/" + aggregatorId); Response response = target.request(MediaType.APPLICATION_JSON).get(); if (response.getStatus() == 404) { Result errorMessage = response.readEntity(Result.class); LOGGER.warn("getAggregator(..) failure! : " + errorMessage.getResult()); throw new DoesNotExistException(errorMessage.getResult()); } Aggregator aggregator = response.readEntity(Aggregator.class); LOGGER.info("getAggregator(..) success!"); return aggregator; }
public MapStream<K, V> distinctValues() { final Set<V> temp = newSetFromMap(new ConcurrentHashMap<>()); inner = inner.flatMap(e -> temp.add(e.getValue()) ? Stream.of(e) : Stream.empty() ); return this; }
@Override public void handleCanvasElementUpdated(final CanvasElementUpdatedEvent event) { final Element<?> element = event.getElement(); if ((element instanceof Node)) { if (element.getContent() instanceof Definition) { final Definition definition = (Definition) element.getContent(); final Optional<Definitions> definitions = Optional.ofNullable(dmnGraphUtils.getDefinitions()); definitions.ifPresent(d -> { if (Objects.equals(d, definition.getDefinition())) { view.setReturnToLinkText(returnToLinkTextSupplier.get()); } }); hasExpression.ifPresent(e -> { if (Objects.equals(e.asDMNModelInstrumentedBase(), definition.getDefinition())) { view.setExpressionNameText(Optional.ofNullable((HasName) definition.getDefinition())); view.refresh(); } }); } } }
public static SearchCond convert(final SearchCondVisitor visitor, final String fiql, final String... realms) { SyncopeFiqlParser<SearchBean> parser = new SyncopeFiqlParser<>( SearchBean.class, AbstractFiqlSearchConditionBuilder.CONTEXTUAL_PROPERTIES); try { if (realms != null && realms.length > 0) { visitor.setRealm(realms[0]); } SearchCondition<SearchBean> sc = parser.parse(URLDecoder.decode(fiql, StandardCharsets.UTF_8)); sc.accept(visitor); return visitor.getQuery(); } catch (Exception e) { SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidSearchExpression); sce.getElements().add(fiql); sce.getElements().add(ExceptionUtils.getRootCauseMessage(e)); throw sce; } }
@Override public Factory<?> getValueFactory(Parameter parameter) { if (parameter.getDeclaredAnnotation(FHIRParameter.class) != null) { if (IBaseResource.class.isAssignableFrom(parameter.getRawType())) return new ParamResourceFactory(injector, parameter, ctx.newJsonParser()); } return null; }
public static OwnerTypeLocatable of(FieldNameExtractor fieldNameExtractor) { return new ForImplicitProperty(new FieldLocation.Relative(fieldNameExtractor)); }
public synchronized Set<K> keys() { final Set<K> keys = new LinkedHashSet<>(); for (final K key : items.keySet()) { keys.add(key); } return keys; }
public static ProductInfo getProductInfoInstance(){ if (productInfo != null) { return productInfo; } return generateProductInfo(); }
public X509Certificate createX509Certificate(Consumer consumer, Owner owner, Pool pool, Entitlement ent, Product product, Set<Product> products, List<org.candlepin.model.dto.Product> productModels, BigInteger serialNumber, KeyPair keyPair, boolean useContentPrefix) throws GeneralSecurityException, IOException { Set<X509ExtensionWrapper> extensions; Set<X509ByteExtensionWrapper> byteExtensions = new LinkedHashSet<>(); products.add(product); Map<String, EnvironmentContent> promotedContent = getPromotedContent(consumer); String contentPrefix = getContentPrefix(consumer, owner, useContentPrefix); if (shouldGenerateV3(consumer)) { extensions = prepareV3Extensions(); byteExtensions = prepareV3ByteExtensions(product, productModels, contentPrefix, promotedContent); } else { extensions = prepareV1Extensions(products, pool, consumer, ent.getQuantity(), contentPrefix, promotedContent); } Date endDate = setupEntitlementEndDate(pool, consumer); ent.setEndDateOverride(endDate); Calendar calNow = Calendar.getInstance(); Calendar calMinusHour = Calendar.getInstance(); calMinusHour.add(Calendar.HOUR, -1); Date startDate = pool.getStartDate(); if (pool.getStartDate().getTime() > calMinusHour.getTime().getTime() && pool.getStartDate().getTime() < calNow.getTime().getTime()) { startDate = calMinusHour.getTime(); } X509Certificate x509Cert = this.pki.createX509Certificate( createDN(ent, owner), extensions, byteExtensions, startDate, endDate, keyPair, serialNumber, null); return x509Cert; }
@Pure public static byte[] parseLEInt(int value) { return new byte[] { (byte) (value & 0xFF), (byte) ((value >> 8) & 0xFF), (byte) ((value >> 16) & 0xFF), (byte) ((value >> 24) & 0xFF), }; }
@Override public Orchestratable process(Orchestratable message) { if (message instanceof OutboundOrchestratable) { return process((OutboundOrchestratable) message); } return null; }
@Override public String loadEditableDescription(Authorization authorization) { return accountDao.strongVerifyAccount(authorization) .map(Account::getEscapedDescription) .orElse(""); }
@Override public String getDescription() { return description; }
@Override public ResultSet getTableTypes() { return null; }
public Single<List<User>> getUsers(Integer lastIdQueried, final boolean refresh) { return getUsersReply(lastIdQueried, refresh) .map(Reply::getData); }
public JsonNode createSelectDSLQuery(Map<String, String> searchCriteriaMap) throws InvalidParseOperationException, InvalidCreateOperationException { final SelectMultiQuery select = new SelectMultiQuery(); final BooleanQuery booleanQueries = and(); for (final Entry<String, String> entry : searchCriteriaMap.entrySet()) { final String searchKeys = entry.getKey(); final String searchValue = entry.getValue(); if (searchKeys.isEmpty() || searchValue.isEmpty()) { throw new InvalidParseOperationException("Parameters should not be empty or null"); } if (searchKeys.startsWith(PROJECTION_PREFIX)) { select.addUsedProjection(searchValue); continue; } if (searchKeys.equals(ORDER_BY)) { select.addOrderByAscFilter(searchValue); continue; } if (searchKeys.equals(UiConstants.SELECT_BY_ID.toString())) { select.addRoots(searchValue); continue; } booleanQueries.add(eq(searchKeys, searchValue)); } if (booleanQueries.isReady()) { boolean noRoots = select.getRoots() == null || select.getRoots().isEmpty(); if (!(noRoots && select.getNbQueries() == 0)) { booleanQueries.setDepthLimit(DEPTH_LIMIT); } select.addQueries(booleanQueries); } return select.getFinalSelect(); }
public static List<HttpCookie> decodeCookies(List<String> cookieStrs) { List<HttpCookie> cookies = new ArrayList<HttpCookie>(); if (cookieStrs == null) { return cookies; } for (String cookieStr : cookieStrs) { if (cookieStr == null) { continue; } StringTokenizer tokenizer = new StringTokenizer(cookieStr, ";"); String nameValuePair; HttpCookie cookieToBeAdd = null; while (tokenizer.hasMoreTokens()) { nameValuePair = tokenizer.nextToken(); int index = nameValuePair.indexOf('='); if (index != -1) { String name = nameValuePair.substring(0, index).trim(); String value = stripOffSurrounding(nameValuePair.substring(index + 1).trim()); if (name.charAt(0) != '$') { if (cookieToBeAdd != null) { cookies.add(cookieToBeAdd); } cookieToBeAdd = new HttpCookie(name, value); } else if (cookieToBeAdd != null) { if (name.equals("$Path")) { cookieToBeAdd.setPath(value); } else if (name.equals("$Domain")) { cookieToBeAdd.setDomain(value); } else if (name.equals("$Port")) { cookieToBeAdd.setPortlist(value); } } } else { throw new IllegalArgumentException("Invalid cookie name-value pair"); } } if (cookieToBeAdd != null) { cookies.add(cookieToBeAdd); } } return cookies; }
public static Builder get(Observable root) { return new Builder(root); }
@Override public PDDocumentHandler open(PdfURLSource source) throws TaskIOException { return openGeneric(source); }
@Override public ApiExceptionHandlerListenerResult shouldHandleException(Throwable ex) { if (ex instanceof MethodArgumentNotValidException) { return ApiExceptionHandlerListenerResult.handleResponse( convertSpringErrorsToApiErrors( ((MethodArgumentNotValidException) ex).getBindingResult().getAllErrors() ) ); } if (ex instanceof BindException) { return ApiExceptionHandlerListenerResult.handleResponse( convertSpringErrorsToApiErrors(((BindException) ex).getAllErrors()) ); } String exClassname = (ex == null) ? null : ex.getClass().getName(); if (Objects.equals(exClassname, WEB_EXCHANGE_BIND_EXCEPTION_CLASSNAME)) { List<ObjectError> objectErrors = extractAllErrorsFromWebExchangeBindException(ex); if (objectErrors != null && !objectErrors.isEmpty()) { return ApiExceptionHandlerListenerResult.handleResponse( convertSpringErrorsToApiErrors(objectErrors) ); } } return ApiExceptionHandlerListenerResult.ignoreResponse(); }
@DescribeResult(name = "result", description = "Classified feature collection") public SimpleFeatureCollection execute( @DescribeParameter(name = "features", description = "Input feature collection") SimpleFeatureCollection features, @DescribeParameter( name = "classifyOnAttribute", description = "Attribute to be classified using intervals of values." ) String classifyOnAttribute, @DescribeParameter( name = "thresholds", min = 0, description = "List of thresholds (use this one to specify custom intervals). Ignored if classifier is specified (use classes in that case)." ) String[] thresholds, @DescribeParameter( name = "outputValues", min = 0, description = "List of class values for each given threshold (+1 for out of range)." ) String[] outputValues, @DescribeParameter( name = "classifier", min = 0, description = "Classifier type (EqualInterval, Quantile, Jenks, etc.). Use with classes to calculate intervals automatically" ) String classifier, @DescribeParameter( name = "classes", min = 0, description = "Classifier # of classes, used when classifier is specified (defaults to 5)." ) Integer classes, @DescribeParameter( name = "include", min = 0, defaultValue = "FALSE", description = "Include or exclude current threshold in the interval." ) Boolean include, @DescribeParameter( name = "outputAttribute", min = 0, description = "Name of the output attribute with class values (defaults to class)." ) String outputAttribute, @DescribeParameter( name = "outputType", min = 0, description = "Optional binding type for output values (defaults to String)." ) String outputType) throws ProcessException { if (features == null) { throw new ProcessException("features input cannot be null!"); } SimpleFeatureType schema = features.getSchema(); List<Definition> transform = new ArrayList<Definition>(); for (AttributeDescriptor descriptor : schema.getAttributeDescriptors()) { Definition definition = new Definition(); definition.name = descriptor.getLocalName(); definition.expression = FF.property(descriptor.getLocalName()); definition.binding = descriptor.getType().getBinding(); transform.add(definition); } Definition classify = new Definition(); if (outputAttribute == null || outputAttribute.trim().isEmpty()) { outputAttribute = "class"; } classify.name = outputAttribute; try { classify.binding = outputType != null ? Class.forName(outputType) : String.class; } catch (ClassNotFoundException e) { throw new ProcessException( outputType + " is not a valid value for outputType: should be a class name"); } AttributeDescriptor classifyDescriptor = features.getSchema().getDescriptor(classifyOnAttribute); if (classifyDescriptor == null) { throw new ProcessException( "classifyOnAttribute is not a valid schema attribute: " + classifyOnAttribute); } Class<?> rangeType = classifyDescriptor.getType().getBinding(); if (rangeType == null) { rangeType = Number.class; } List<Expression> params = new ArrayList<Expression>(); params.add(FF.property(classifyOnAttribute)); if ((thresholds == null || thresholds.length == 0) && (classifier == null || classifier.trim().isEmpty())) { throw new ProcessException("at least one of thresholds and classifier is mandatory"); } List<Object> ranges = new ArrayList<Object>(); if (classifier != null && !classifier.trim().isEmpty()) { if (classes == null) { classes = 5; } Function classifyFun = FF.function(classifier, FF.property(classifyOnAttribute), FF.literal(classes)); RangedClassifier rc = (RangedClassifier) classifyFun.evaluate(features); for (int i = 0; i < rc.getSize(); i++) { ranges.add(rc.getMin(i)); } ranges.add(rc.getMax(rc.getSize() - 1)); } else { for (String threshold : thresholds) { ranges.add(threshold); } } if (outputValues == null || outputValues.length == 0) { outputValues = new String[ranges.size() + 1]; for (int count = 1; count <= ranges.size(); count++) { outputValues[count - 1] = count + ""; } outputValues[ranges.size()] = (ranges.size() + 1 + ""); } if (outputValues.length != (ranges.size() + 1)) { throw new ProcessException("values are not consistent with thresholds (should be +1)"); } for (int count = 0; count < ranges.size(); count++) { Object outputValue = Converters.convert(outputValues[count], classify.binding); if (outputValue == null) { throw new ProcessException( "Incompatible output value found " + outputValues[count] + " for type " + classify.binding.getName()); } params.add(FF.literal(outputValue)); Object rangeValue = Converters.convert(ranges.get(count), rangeType); if (rangeValue == null) { throw new ProcessException( "Incompatible range value found " + rangeValue + " for type " + rangeType.getName()); } params.add(FF.literal(rangeValue)); } params.add( FF.literal( Converters.convert( outputValues[outputValues.length - 1], classify.binding))); params.add( FF.literal(include ? CategorizeFunction.PRECEDING : CategorizeFunction.SUCCEEDING)); classify.expression = new CategorizeFunction(params, null); transform.add(classify); return new TransformProcess().executeList(features, transform); }
@Override protected void service(WorkbenchRequest req, HttpServletResponse resp, String xslPath) throws Exception { String id = info.getId(); if (null != id && !manager.hasRepositoryConfig(id)) { throw new RepositoryConfigException(id + " does not exist."); } TupleResultBuilder builder = getTupleResultBuilder(req, resp, resp.getOutputStream()); builder.start("id", "description", "location", "server", "readable", "writeable", "default-limit", "default-queryLn", "default-infer", "default-Accept", "default-Content-Type", "upload-format", "query-format", "graph-download-format", "tuple-download-format", "boolean-download-format"); String desc = info.getDescription(); URL loc = info.getLocation(); URL server = getServer(); builder.result(id, desc, loc, server, info.isReadable(), info.isWritable()); builder.namedResult("default-limit", req.getParameter("limit")); builder.namedResult("default-queryLn", req.getParameter("queryLn")); builder.namedResult("default-infer", req.getParameter("infer")); builder.namedResult("default-Accept", req.getParameter("Accept")); builder.namedResult("default-Content-Type", req.getParameter("Content-Type")); for (RDFParserFactory parser : RDFParserRegistry.getInstance().getAll()) { String mimeType = parser.getRDFFormat().getDefaultMIMEType(); String name = parser.getRDFFormat().getName(); builder.namedResult("upload-format", mimeType + " " + name); } for (QueryParserFactory factory : getInstance().getAll()) { String name = factory.getQueryLanguage().getName(); builder.namedResult("query-format", name + " " + name); } for (RDFWriterFactory writer : RDFWriterRegistry.getInstance().getAll()) { String mimeType = writer.getRDFFormat().getDefaultMIMEType(); String name = writer.getRDFFormat().getName(); builder.namedResult("graph-download-format", mimeType + " " + name); } for (TupleQueryResultWriterFactory writer : TupleQueryResultWriterRegistry.getInstance().getAll()) { String mimeType = writer.getTupleQueryResultFormat().getDefaultMIMEType(); String name = writer.getTupleQueryResultFormat().getName(); builder.namedResult("tuple-download-format", mimeType + " " + name); } for (BooleanQueryResultWriterFactory writer : BooleanQueryResultWriterRegistry.getInstance().getAll()) { String mimeType = writer.getBooleanQueryResultFormat().getDefaultMIMEType(); String name = writer.getBooleanQueryResultFormat().getName(); builder.namedResult("boolean-download-format", mimeType + " " + name); } builder.end(); }
public void addLinkInformation(OspfRouter ospfRouter, OspfLinkTed ospfLinkTed) { controller.addLinkDetails(ospfRouter, ospfLinkTed); }
public boolean overlaps(final BoundingBox pBoundingBox, double pZoom) { if (pZoom < 3) return true; boolean latMatch=false; boolean lonMatch=false; if (pBoundingBox.mLatSouth <= mLatNorth && pBoundingBox.mLatSouth >= mLatSouth ) latMatch=true; if (mLonWest >= pBoundingBox.mLonWest && mLonWest <= pBoundingBox.mLonEast) lonMatch=true; if (mLonEast >= pBoundingBox.mLonWest && mLonWest <= pBoundingBox.mLonEast) lonMatch=true; if (mLonWest<=pBoundingBox.mLonWest && mLonEast>=pBoundingBox.mLonEast && mLatNorth>=pBoundingBox.mLatNorth && mLatSouth<=pBoundingBox.mLatSouth) return true; if (mLatNorth >= pBoundingBox.mLatSouth && mLatNorth <= mLatSouth) latMatch=true; if (mLatSouth>= pBoundingBox.mLatSouth && mLatSouth <= mLatSouth) latMatch=true; if (mLonWest > mLonEast) { if (mLonEast<=pBoundingBox.mLonEast && pBoundingBox.mLonWest >= mLonWest) lonMatch=true; if (mLonWest>= pBoundingBox.mLonEast && mLonEast<= pBoundingBox.mLonEast) { lonMatch = true; if (pBoundingBox.mLonEast < mLonWest && pBoundingBox.mLonWest < mLonWest) lonMatch = false; if (pBoundingBox.mLonEast > mLonEast && pBoundingBox.mLonWest > mLonEast ) lonMatch = false; } if (mLonWest>= pBoundingBox.mLonEast && mLonEast>= pBoundingBox.mLonEast) { lonMatch = true; } } return latMatch && lonMatch; }
List<Experiment> getAuthorizedExperimentsByName(final String authorizationHeader, final Application.Name applicationName) { return getExperimentsByName(true, authorizationHeader, applicationName); }
public boolean hasMessage() { return this.message != null; }
@Nonnull public static String center( @Nonnull String str, int size ) { return center( str, size, " " ); }
public static <T extends PipelineOptions> T validate(Class<T> klass, PipelineOptions options) { return validate(klass, options, false); }
@Override @SuppressWarnings( "unchecked" ) public List<String> resolve( String name ) { if( name.startsWith( REQUEST_PARAM_PREFIX ) ) { return Collections.singletonList(getRequestParam(name.substring(REQUEST_PARAM_PREFIX.length()))); } else if ( name.startsWith( GATEWAY_PARAM_PREFIX ) ) { return Collections.singletonList(getGatewayParam(name.substring(GATEWAY_PARAM_PREFIX.length()))); } else if ( name.startsWith( CLUSTER_PARAM_PREFIX ) ) { return Collections.singletonList(getClusterParam(name.substring(GATEWAY_PARAM_PREFIX.length()))); } else if ( name.startsWith( INBOUND_QUERY_PARAM_PREFIX ) ) { return getInboundQueryParam(name.substring(INBOUND_QUERY_PARAM_PREFIX.length())); } else { return Collections.singletonList(config.getInitParameter(name)); } }
@Override protected void loadDataObject(DataObject dataObject) { clear(); setReadonly(true); if (dataObject != null) { this.dataObject = dataObject; view.setName(dataObject.getName()); Annotation annotation = dataObject.getAnnotation(MainDomainAnnotations.LABEL_ANNOTATION); if (annotation != null) { view.setLabel(AnnotationValueHandler.getStringValue(annotation, MainDomainAnnotations.VALUE_PARAM)); } annotation = dataObject.getAnnotation(MainDomainAnnotations.DESCRIPTION_ANNOTATION); if (annotation != null) { view.setDescription(AnnotationValueHandler.getStringValue(annotation, MainDomainAnnotations.VALUE_PARAM)); } view.setPackageName(dataObject.getPackageName()); initSuperClassList(false); setReadonly(getContext() == null || getContext().isReadonly()); } }
@Override public void execute(StormTaskTuple stormTaskTuple) { try { String fileContent = new String(stormTaskTuple.getFileData()); LOGGER.info("starting enrichment on {} .....", stormTaskTuple.getFileUrl()); String output = enrichmentWorker.process(fileContent); LOGGER.info("Finishing enrichment on {} .....", stormTaskTuple.getFileUrl()); emitEnrichedContent(stormTaskTuple, output); } catch (Exception e) { LOGGER.error("Exception while Enriching/dereference", e); emitErrorNotification(stormTaskTuple.getTaskId(), stormTaskTuple.getFileUrl(), e.getMessage(), "Remote Enrichment/dereference service caused the problem!. The full error: " + ExceptionUtils.getStackTrace(e)); } }
@Override public byte[] serialize(final String topic, final GenericRow data) { if (data == null) { return null; } try { return objectMapper.writeValueAsBytes(dataToMap(data)); } catch (Exception e) { throw new SerializationException("Error serializing JSON message", e); } }
@Override public Class<?> getColumnClass(int columnIndex) { if (columnIndex == 0) { return Study.class; } return EntityUtil.getConcreteTypeOrEntity(getCharacteristic(columnIndex).getValueType()); }
public static Builder builder() { return new ThreadPoolExecutorBuilder(); }
public boolean isBoolean(String str) { return str.toLowerCase().equals("true") || str.toLowerCase().equals("false"); }
@Override public String lookup(String key) { StringTokenizer tokenizer = new StringTokenizer(key, "."); if(tokenizer.countTokens() != 4) { log.error("Invalid IPv4 address passed: " + key); throw new IllegalArgumentException("Invalid IPv4 address passed: " + key); } long ipAddr = 0; long[] parts = new long[4]; try { for(int i=0; i<4; i++) { parts[i] = Integer.parseInt(tokenizer.nextToken()); if(parts[i] < 0 || parts[i] > 255) throw new IllegalArgumentException("Invalid IPv4 address passed: " + key); } } catch(NumberFormatException e) { log.error("Invalid IPv4 address passed: " + key); throw new IllegalArgumentException("Invalid IPv4 address passed: " + key, e); } for(int i=0; i<4; i++) ipAddr |= parts[i] << ((3-i)*8); return Long.toString(ipAddr); }
@Override public final int doStartTag() throws JspException { if (!isRequestInMode()) { return SKIP_BODY; } return EVAL_BODY_INCLUDE; }
@Override public void onAutoConfigurationStarting(FeatureAutoConfigurable f) { isCalibrating = true; setUnCalibratedState(); }
@Override public Detector findByUuid(String uuid) { Detector detector = repository.findByUuid(uuid); if (detector == null) { throw new RecordNotFoundException("Invalid UUID: " + uuid); } return detector; }
@Override public ConnectResponse<String> delete(final String connector) { try { LOG.debug("Issuing request to Kafka Connect at URI {} to delete {}", connectUri, connector); final ConnectResponse<String> connectResponse = withRetries(() -> Request .Delete(connectUri.resolve(String.format("%s/%s", CONNECTORS, connector))) .setHeaders(headers()) .socketTimeout(DEFAULT_TIMEOUT_MS) .connectTimeout(DEFAULT_TIMEOUT_MS) .execute() .handleResponse( createHandler(HttpStatus.SC_NO_CONTENT, new TypeReference<Object>() {}, foo -> connector))); connectResponse.error() .ifPresent(error -> LOG.warn("Could not delete connector: {}.", error)); return connectResponse; } catch (final Exception e) { throw new KsqlServerException(e); } }
public List<Segment> tokenize() throws ParseException { SegmentTokenizer segmentTokenizer = new SegmentTokenizer(this.una); int unbIndex = getStartOfSegment("UNB"); if (unbIndex == -1) { throw new ParseException("Required UNB segment not found"); } String tmp = this.message.substring(unbIndex); String processedMessage = TextUtils.convertToSingleLine(tmp).toUpperCase(); List<String> stringSegments = TextUtils.splitWithEscapeChar(processedMessage, this.una.getSegmentTerminator(), this.una.getReleaseCharacter()); Pattern startOfSegmentPattern = getStartOfSegmentPattern(); List<Segment> segments = new LinkedList<>(); for (String s : stringSegments) { Segment segment = segmentTokenizer.buildSegment(s); segment.setText(s + this.una.getSegmentTerminator()); if (validSegmentStart(segment.getText(), startOfSegmentPattern)) { segments.add(segment); } } return segments; }
public boolean refreshDDL(Set<DDLWatcher.DDLListener> callbacks) throws IOException{ Collection<String> ongoingDDLChangeIds=watchChecker.getCurrentChangeIds(); if(ongoingDDLChangeIds==null) return false; Set<Pair<DDLChange,String>> newChanges=new HashSet<>(); boolean currentWasEmpty=currentDDLChanges.isEmpty(); try{ clearFinishedChanges(ongoingDDLChangeIds,callbacks); }catch(StandardException se){ throw exceptionFactory.asIOException(se); } for(String changeId : ongoingDDLChangeIds){ if(!seenDDLChanges.contains(changeId)){ DDLChange change=watchChecker.getChange(changeId); if(change==null)continue; String cId=change.getChangeId(); changeTimeouts.add(cId); SpliceLogUtils.info(LOG,"New change with id=%s, and change=%s",changeId,change); try { processPreCommitChange(change, callbacks); seenDDLChanges.add(changeId); newChanges.add(new Pair<DDLChange, String>(change,null)); } catch (Exception e) { LOG.error("Encountered an exception processing DDL change",e); newChanges.add(new Pair<>(change,e.getLocalizedMessage())); } } } watchChecker.notifyProcessed(newChanges); int killed = killTimeouts(callbacks); if(currentWasEmpty!=currentDDLChanges.isEmpty()){ boolean case1=!currentDDLChanges.isEmpty(); for(DDLWatcher.DDLListener listener : callbacks){ if(case1){ listener.startGlobalChange(); }else listener.finishGlobalChange(); } }else if(killed>0){ for(DDLWatcher.DDLListener listener : callbacks){ listener.finishGlobalChange(); } } return true; }
@Override public boolean checkCondition(final WilmaHttpRequest request, final ParameterList parameterList) { boolean result = false; List<Parameter> params = parameterList.getAllParameters(); if (params.size() == 1) { String contentType = request.getHeader(CONTENT_TYPE_HEADER); if (contentType != null && (contentType.contains(XML_CONTENT) || FASTINFOSET_CONTENT.equals(contentType))) { try { Parameter paramater = params.iterator().next(); String element = paramater.getName(); String value = paramater.getValue(); result = evaluateCondition(request.getBody(), element, value); } catch (SaxonApiException e) { throw new ConditionEvaluationFailedException("XQuery evaluation failed at request: " + request.getWilmaMessageLoggerId(), e); } } } else { throw new ConditionEvaluationFailedException("Please provide exactly one parameter in Stub Configuration!"); } return result; }
@Override public Object encode(final Object value, final MappedField optionalExtraInfo) { if (value == null) { return null; } if (value instanceof ZonedDateTime) { return Date.from(((ZonedDateTime) value).toInstant()); } throw new IllegalArgumentException("Can't convert to ZonedDateTime from " + value); }
@Override public void update(Job job) throws ConcurrentModificationException { Connection c = getConnection(); DBRecord r = new DBRecord(); if (job.getId() == null) { r.create(tableJob); } else { r.read(tableJob, job.getId(), c); } r.setBeanValues(job); try { r.setModified(tableJob.label, true); r.update(c); } catch (RecordUpdateInvalidException ex) { throw new ConcurrentModificationException(ex); } r.getBeanProperties(job); }
public void add2(DataWord word) { BigInteger result = value().add(word.value()); this.data = ByteUtil.copyToArray(result.and(MAX_VALUE)); }
public boolean hasPermission(CommandSender sender, PermissionNode permissionNode) { if (permissionNode == null) { return true; } if (!(sender instanceof Player) || !isEnabled()) { return permissionNode.getDefaultPermission().evaluate(sender); } Player player = (Player) sender; return player.hasPermission(permissionNode.getNode()); }
@Override public Status read(String table, String endpoint, Set<String> fields, Map<String, ByteIterator> result) { int responseCode; try { responseCode = httpGet(urlPrefix + endpoint, result); } catch (Exception e) { responseCode = handleExceptions(e, urlPrefix + endpoint, HttpMethod.GET); } if (logEnabled) { System.err.println(new StringBuilder("GET Request: ").append(urlPrefix).append(endpoint) .append(" | Response Code: ").append(responseCode).toString()); } return getStatus(responseCode); }
public String getInstance(Class<?> clazz) { return new String(); }
public ConfigPayloadBuilder build(Element configE) { parseConfigName(configE); ConfigPayloadBuilder payloadBuilder = new ConfigPayloadBuilder(configDefinition); for (Element child : XML.getChildren(configE)) { parseElement(child, payloadBuilder, null); } return payloadBuilder; }
@Override public boolean equals(Object object) { if (this == object) { return true; } if (object == null || object.getClass() != getClass()) { return false; } final CollisionFunctionLinear other = (CollisionFunctionLinear) object; return Double.doubleToLongBits(a) == Double.doubleToLongBits(other.a) && Double.doubleToLongBits(b) == Double.doubleToLongBits(other.b); }
public static void agentmain(String agentArgs, Instrumentation instrumentation) { JvmAgentConfig config = new JvmAgentConfig(agentArgs); if (!config.isModeStop()) { startAgent(config,false, instrumentation); } else { stopAgent(); } }
@Override public void postXHtmlToConfluence(final SwaggerConfluenceConfig swaggerConfluenceConfig, final String xhtml) { LOG.info("Posting XHTML to Confluence..."); SWAGGER_CONFLUENCE_CONFIG.set(swaggerConfluenceConfig); SWAGGER_DOCUMENT.set(parseXhtml(xhtml)); final Map<String, ConfluenceLink> titleLinkMap = buildTableOfContentsLinkMap(); final List<ConfluencePage> confluencePages = handlePagination(); Integer categoryAncestorId = null; Integer individualAncestorId = null; for (final ConfluencePage confluencePage : confluencePages) { final PageType pageType = confluencePage.getPageType(); LOG.debug("PROCESSING PAGE: {} --> {}", confluencePage.getPageType(), confluencePage.getXhtml()); switch (pageType) { case ROOT: confluencePage.setAncestorId(swaggerConfluenceConfig.getAncestorId()); break; case CATEGORY: confluencePage.setAncestorId(categoryAncestorId); break; case INDIVIDUAL: confluencePage.setAncestorId(individualAncestorId); break; default: throw new SwaggerConfluenceConfigurationException("Unknown Page Type Encountered!"); } LOG.debug("ANCESTOR ID SET: <{}> -> {}", confluencePage.getConfluenceTitle(), confluencePage.getAncestorId()); addExistingPageData(confluencePage); if (confluencePage.exists()) { updatePage(confluencePage, titleLinkMap); if(pageType == PageType.CATEGORY){ cleanPages(confluencePage); } } else { createPage(confluencePage, titleLinkMap); } if (pageType == PageType.ROOT) { categoryAncestorId = confluencePage.getAncestorId(); } else if (pageType == PageType.CATEGORY) { individualAncestorId = confluencePage.getAncestorId(); } } }
public boolean match(String txt) { Objects.requireNonNull(txt); int acceptanceState = regex.length(); Set<Integer> vertices = nfsm.findConnected(0); for (int i = 0; i < txt.length(); i++) { char current = txt.charAt(i); if (current == '*' || current == '|' || current == '(' || current == ')') { throw new IllegalArgumentException("text contains the metacharacter '" + txt.charAt(i) + "'"); } Set<Integer> match = new HashSet<>(); for (int v : vertices) { if (v == acceptanceState) { continue; } if ((regex.charAt(v) == txt.charAt(i)) || regex.charAt(v) == '.') { match.add(v + 1); } } if(match.isEmpty()){ return false; } vertices = nfsm.findConnected(match); } return vertices.contains(acceptanceState); }
public Content createContent(ContentDTO dto, Owner owner) { if (dto == null) { throw new IllegalArgumentException("dto is null"); } if (dto.getId() == null || dto.getType() == null || dto.getLabel() == null || dto.getName() == null || dto.getVendor() == null) { throw new IllegalArgumentException("dto is incomplete"); } if (this.ownerContentCurator.contentExists(owner, dto.getId())) { throw new IllegalStateException("content has already been created: " + dto.getId()); } Content entity = new Content(dto.getId()); this.applyContentChanges(entity, dto); log.debug("Creating new content for org: {}, {}", entity, owner); List<Content> alternateVersions = this.ownerContentCurator.getContentByVersions( owner, Collections.<String, Integer>singletonMap(entity.getId(), entity.getEntityVersion())) .list(); log.debug("Checking {} alternate content versions", alternateVersions.size()); for (Content alt : alternateVersions) { if (alt.equals(entity)) { this.ownerContentCurator.mapContentToOwner(alt, owner); return alt; } } entity = this.contentCurator.create(entity); this.ownerContentCurator.mapContentToOwner(entity, owner); return entity; }
@Override public Notification buildNotification(Context context, FollowsChecker followsChecker) { Resources r = context.getResources(); String contentText = r.getString(R.string.notification_district_points_updated, districtName); Intent instance = getIntent(context); stored = new StoredNotification(); stored.setType(getNotificationType()); String districtCode = EventHelper.getEventCode(districtKey); String title = r.getString(R.string.notification_district_points_title, districtCode); stored.setTitle(title); stored.setBody(contentText); stored.setMessageData(messageData); stored.setIntent(MyTBAHelper.serializeIntent(instance)); stored.setTime(Calendar.getInstance().getTime()); stored.setSystemId(getNotificationId()); NotificationCompat.Builder builder = getBaseBuilder(context, instance) .setContentTitle(title) .setContentText(contentText); NotificationCompat.BigTextStyle style = new NotificationCompat.BigTextStyle().bigText(contentText); builder.setStyle(style); return builder.build(); }
public E peek() { return this.elements.get(this.elements.size() - 1); }
@Deactivate private void deactivate() { if (reg != null) { reg.unregister(); } }
public String combineErrorMessages() { return StringUtils.join(errors, ", "); }
@Override public void removeEquipmentsFromJedi(int jediId) { Jedi jedi = jediDao.findById(jediId); if (jedi != null) { List<Equipment> equipments = jedi.getEquipments(); equipments.forEach(equipmentDao::delete); } else { throw new ApplicationException(JEDI_NOT_FOUND); } }
public JavaArchive artifact(String gav) throws IOException, ModuleLoadException { return artifact(gav, null); }
@Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } Offline offline = (Offline) o; return Objects.equals(node, offline.node); }
@GetMapping(path = "/", produces = APPLICATION_JSON_VALUE) public Map<String, JsonNode> get() throws JsonProcessingException { return store; }
@Override protected void shutdownOutput() throws IOException { lock.run(() -> { if (output != null) { output.shutdown(); } }); }
@Override public void computeChecksum(IPv4Header ipv4Header, ByteBuffer payload) { byte[] rawArray = raw.array(); int rawOffset = raw.arrayOffset(); byte[] payloadArray = payload.array(); int payloadOffset = payload.arrayOffset(); int source = ipv4Header.getSource(); int destination = ipv4Header.getDestination(); int length = ipv4Header.getTotalLength() - ipv4Header.getHeaderLength(); assert (length & ~0xffff) == 0 : "Length cannot take more than 16 bits"; int sum = source >>> 16; sum += source & 0xffff; sum += destination >>> 16; sum += destination & 0xffff; sum += IPv4Header.Protocol.TCP.getNumber(); sum += length; setChecksum((short) 0); for (int i = 0; i < headerLength / 2; ++i) { sum += ((rawArray[rawOffset + 2 * i] & 0xff) << 8) | (rawArray[rawOffset + 2 * i + 1] & 0xff); } int payloadLength = length - headerLength; assert payloadLength == payload.limit() : "Payload length does not match"; for (int i = 0; i < payloadLength / 2; ++i) { sum += ((payloadArray[payloadOffset + 2 * i] & 0xff) << 8) | (payloadArray[payloadOffset + 2 * i + 1] & 0xff); } if (payloadLength % 2 != 0) { sum += (payloadArray[payloadOffset + payloadLength - 1] & 0xff) << 8; } while ((sum & ~0xffff) != 0) { sum = (sum & 0xffff) + (sum >> 16); } setChecksum((short) ~sum); }
String getType(String value) { if (value == null || value.isEmpty()) { return "string"; } if (isNumeric(value)) { return "long"; } if ("true".equals(value) || "false".equals(value)) { return "boolean"; } if (isDouble(value)) { return "double"; } return "string"; }
@Override public double cumulativeProbability(double x) { final double dev = x - mean; if (Math.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; } return 0.5 * Erfc.value(-dev / (standardDeviation * SQRT2)); }
public void setValue(ConfigurationSetting config) { mapper.updateValue(config); }
public int size() { return length; }
public static JobId parse(String str) throws HyracksDataException { Matcher m = jobIdPattern.matcher(str); if (m.matches()) { int ccId = Integer.parseInt(m.group(1)); if (ccId <= 0xffff && ccId >= 0) { long jobId = Long.parseLong(m.group(2)) | (long) ccId << CcIdPartitionedLongFactory.ID_BITS; return new JobId(jobId); } } throw HyracksDataException.create(ErrorCode.NOT_A_JOBID, str); }
@Override public boolean test(final Map input) { return input.containsKey(key); }
@Override public void validate(final PreparedUpdate update, final UpdateContext updateContext) { final RpslObject updatedRouteObject = update.getUpdatedObject(); final AttributeType attributeType = findAttributeType(updatedRouteObject); final CIString prefix = updatedRouteObject.findAttribute(attributeType).getCleanValue(); for (final RpslAttribute holeAttribute : updatedRouteObject.findAttributes(AttributeType.HOLES)) { for (final CIString hole : holeAttribute.getCleanValues()) { validatePrefixForHolesAttribute(update, updateContext, AddressPrefixRange.parse(hole), prefix, holeAttribute); } } for (final RpslAttribute pingableAttribute : updatedRouteObject.findAttributes(AttributeType.PINGABLE)) { for (final CIString pingable : pingableAttribute.getCleanValues()) { validatePrefixForPingableAttribute(update, updateContext, pingable, prefix, pingableAttribute); } } final IpInterval ipInterval = IpInterval.parse(prefix); if ((ipInterval.getPrefixLength() < 8 && attributeType == AttributeType.ROUTE) || (ipInterval.getPrefixLength() < 12 && attributeType == AttributeType.ROUTE6)) { updateContext.addMessage(update, UpdateMessages.invalidRoutePrefix(attributeType.getName())); } }
@Override public String appendContent() { final String addonVersion = configurationService.getConfiguration().getString(WORLDPAY_ADDON_VERSION_KEY); if (StringUtils.isBlank(addonVersion)) { return StringUtils.EMPTY; } return format("{0}Worldpay Plugin Version: {1}{0}", System.lineSeparator(), addonVersion); }
public CompletionStage<Ui> convert(final String family, final String lang, final ConfigTypeNode node, final T context) { final Collection<String> rootProperties = node.getProperties().stream().map(SimplePropertyDefinition::getPath).collect(toSet()); rootProperties .removeIf(path -> node.getProperties().stream().anyMatch(p -> path.startsWith(p.getPath() + '.'))); if (rootProperties.isEmpty()) { log.warn("No root properties for configuration node {} (family={})", node.getId(), family); } final Collection<SimplePropertyDefinition> props; final Predicate<SimplePropertyDefinition> isRootProperty; if (rootProperties.size() == 1 && rootProperties.iterator().next().startsWith("configuration.")) { final String root = rootProperties.iterator().next(); final SimplePropertyDefinition def = node.getProperties().stream().filter(prop -> prop.getPath().equals(root)).findFirst().get(); props = node .getProperties() .stream() .map(prop -> new SimplePropertyDefinition(def.getName() + prop.getPath().substring(root.length()), prop.getName(), prop.getDisplayName(), prop.getType(), prop.getDefaultValue(), prop.getValidation(), prop.getMetadata(), prop.getPlaceholder(), prop.getProposalDisplayNames())) .collect(toList()); isRootProperty = p -> p.getPath().equals(def.getName()); } else { props = node.getProperties(); isRootProperty = p -> rootProperties.contains(p.getPath()); } return convert(node::getDisplayName, () -> family, () -> props, node::getActions, isRootProperty, context, lang); }
@Override public boolean isSuccessful(final PaymentTransactionEntryModel entry) { if (isEntryPending(entry)) { return false; } final String transactionStatus = extractTransactionStatusFromEntry(entry); return transactionStatus.equalsIgnoreCase(TransactionStatus.ACCEPTED.name()); }
public static String getUrlToken(final String bookmarkableUrl, final String screen) { int st = isPerspectiveInUrl(bookmarkableUrl) ? (bookmarkableUrl.indexOf(PERSPECTIVE_SEP) + 1) : 0; String screensList = bookmarkableUrl.replace(OTHER_SCREEN_SEP, SEPARATOR) .substring(st, bookmarkableUrl.length()); String tokens[] = screensList.split(SEPARATOR); Optional<String> token = Arrays.asList(tokens).stream() .filter(s -> s.contains(screen)) .findFirst(); return token.orElse(screen); }
public RabbitTemplate decorateRabbitTemplate(RabbitTemplate rabbitTemplate) { if (beforePublishPostProcessorsField == null) return rabbitTemplate; Collection<MessagePostProcessor> processors; try { processors = (Collection) beforePublishPostProcessorsField.get(rabbitTemplate); } catch (IllegalAccessException e) { return rabbitTemplate; } TracingMessagePostProcessor tracingMessagePostProcessor = new TracingMessagePostProcessor(this); if (processors == null) { rabbitTemplate.setBeforePublishPostProcessors(tracingMessagePostProcessor); return rabbitTemplate; } for (MessagePostProcessor processor : processors) { if (processor instanceof TracingMessagePostProcessor) { return rabbitTemplate; } } List<MessagePostProcessor> newProcessors = new ArrayList<>(processors.size() + 1); newProcessors.addAll(processors); newProcessors.add(tracingMessagePostProcessor); rabbitTemplate.setBeforePublishPostProcessors( newProcessors.toArray(new MessagePostProcessor[0]) ); return rabbitTemplate; }
@Override protected void dispatch(final MoveDividerEndHandler handler) { handler.onMoveDividerEnd(this); }
public final int getPort() { return port; }
public static <A, B, R> LiveData<R> combineLatest(@NonNull LiveData<A> a, @NonNull LiveData<B> b, @NonNull Combine<A, B, R> combine) { return new CombineLiveData<>(a, b, combine); }
@Override public int getElementCount() { throw new IllegalStateException("Not implemented"); }
@Override public long getIfAbsent( long key, long ifAbsent ) { if ( isSentinelKey( key ) ) { return getForSentinelKey( key, ifAbsent ); } final int idx = indexOf( key ); final long keyAtIdx = getKeyAt( idx ); if ( keyAtIdx == key ) { return getValueAt( idx ); } return ifAbsent; }
@Override public long transferTo(long position, long count, WritableByteChannel target) throws IOException { checkNotNull(target); Util.checkNotNegative(position, "position"); Util.checkNotNegative(count, "count"); checkOpen(); checkReadable(); long transferred = 0; boolean completed = false; try { if (!beginBlocking()) { return 0; } file.readLock().lockInterruptibly(); try { transferred = file.transferTo(position, count, target); file.updateAccessTime(); completed = true; } finally { file.readLock().unlock(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { endBlocking(completed); } return transferred; }
public static List<String> allResourceLines(ClassLoader classLoader, String resourceName) throws IOException { final List<String> result = new ArrayList<String>(); final Enumeration<URL> resources = classLoader.getResources(resourceName); final Set<String> seenURLs = new HashSet<String>(); while (resources.hasMoreElements()) { final URL url = resources.nextElement(); final String urlString = url.toString(); if (seenURLs.contains(urlString)) { continue; } seenURLs.add(urlString); final InputStream in = url.openStream(); try { final BufferedReader reader = new BufferedReader(new InputStreamReader(in, "utf-8")); while (true) { String line = reader.readLine(); if (line == null) { break; } final int comment = line.indexOf('#'); if (comment >= 0) { line = line.substring(0, comment); } line = line.trim(); if (line.length() > 0) { result.add(line); } } reader.close(); } finally { in.close(); } } return result; }
@Override public PipelineElement apply(final PipelineElement value, final String paramsIncludingParentheses, final ExpressionResolver expressionResolver) { final String splitValue = parseAndResolve(paramsIncludingParentheses, expressionResolver); return value.onResolved(previousStage -> { if (previousStage.contains(splitValue)) { return PipelineElement.resolved(previousStage.substring(previousStage.indexOf(splitValue) + 1)); } else { return PipelineElement.unresolved(); } }); }
public boolean contains(T item) { checkNotNull(item, "item cannot be null"); if (low == null) { return item.compareTo(high) <= 0; } if (high == null) { return item.compareTo(low) >= 0; } return item.compareTo(high) <= 0 && item.compareTo(low) >= 0; }
public static boolean compare(Object source, Object target) { if (source == target) { return true; } if (source == null || target == null) { return false; } if (source.equals(target)) { return true; } if (source instanceof Number) { return compare(((Number) source), target); } if (target instanceof Number) { return compare(((Number) target), source); } if (source instanceof Date) { return compare(((Date) source), target); } if (target instanceof Date) { return compare(((Date) target), source); } if (source instanceof String) { return compare(((String) source), target); } if (target instanceof String) { return compare(((String) target), source); } if (source instanceof Collection) { return compare(((Collection) source), target); } if (target instanceof Collection) { return compare(((Collection) target), source); } if (source instanceof Map) { return compare(((Map) source), target); } if (target instanceof Map) { return compare(((Map) target), source); } if (source.getClass().isEnum()) { return compare(((Enum) source), target); } if (target.getClass().isEnum()) { return compare(((Enum) target), source); } if (source.getClass().isArray()) { return compare(((Object[]) source), target); } if (target.getClass().isArray()) { return compare(((Object[]) target), source); } return compare(FastBeanCopier.copy(source, HashMap.class), FastBeanCopier.copy(target, HashMap.class)); }
@Deprecated public static RetrieveSubjects of(final String policyId, final Label label, final DittoHeaders dittoHeaders) { return of(PolicyId.of(policyId), label, dittoHeaders); }
public boolean contains(Rectangle rect) { float llx = this.getX(); float lly = this.getY(); float urx = llx + this.getWidth(); float ury = lly + this.getHeight(); float rllx = rect.getX(); float rlly = rect.getY(); float rurx = rllx + rect.getWidth(); float rury = rlly + rect.getHeight(); return llx - EPS <= rllx && lly - EPS <= rlly && rurx <= urx + EPS && rury <= ury + EPS; }
public static double similarity(String s1, String s2) { if (s1.equals(s2)) return 1.0; if (s1.length() > s2.length()) { String tmp = s2; s2 = s1; s1 = tmp; } boolean[] isCommonCharInS2 = new boolean[s2.length()]; int maxdist = s2.length() / 2; int c = 0; int t = 0; int prevpos = -1; for (int ix = 0; ix < s1.length(); ix++) { char ch = s1.charAt(ix); for (int ix2 = Math.max(0, ix - maxdist); ix2 < Math.min(s2.length(), ix + maxdist); ix2++) { if (ch == s2.charAt(ix2) && !isCommonCharInS2[ix2]) { c++; isCommonCharInS2[ix2] = true; if (prevpos != -1 && ix2 < prevpos) t++; prevpos = ix2; break; } } } if (c == 0) return 0.0; double score = ((c / (double) s1.length()) + (c / (double) s2.length()) + ((c - t) / (double) c)) / 3.0; int p = 0; int last = Math.min(4, s1.length()); for (; p < last && s1.charAt(p) == s2.charAt(p); p++) ; score = score + ((p * (1 - score)) / 10); return score; }
public Budget toDomain(final BudgetContract contract) { final Budget budget = new Budget(); budget.setId(contract.getId()); budget.setName(contract.getName()); budget.setFinancialYear(contract.getFinancialYear()); budget.setEstimationType( contract.getEstimationType() != null ? EstimationType.valueOf(contract.getEstimationType().name()) : null); budget.setParent( Budget.builder().id(contract.getParent() != null ? contract.getParent().getId() : null).build()); budget.setDescription(contract.getDescription()); budget.setActive(contract.getActive()); budget.setPrimaryBudget(contract.getPrimaryBudget()); budget.setMaterializedPath(contract.getMaterializedPath()); budget.setReferenceBudget(Budget.builder() .id(contract.getReferenceBudget() != null ? contract.getReferenceBudget().getId() : null).build()); budget.setDocumentNumber(contract.getDocumentNumber()); budget.setStatus(FinancialStatusContract.builder() .id(contract.getStatus() != null ? contract.getStatus().getId() : null).build()); budget.setCreatedBy(contract.getCreatedBy()); budget.setCreatedDate(contract.getCreatedDate()); budget.setLastModifiedBy(contract.getLastModifiedBy()); budget.setLastModifiedDate(contract.getLastModifiedDate()); budget.setTenantId(contract.getTenantId()); return budget; }
public long get(Map<String, Object> msg) { Object value = msg.get(fieldName); if (value instanceof Number) { return ((Number) value).longValue(); } return formatter.parser().parseMillis(value.toString()); }
protected void importUserSettings( UserExport user ) { IUserSettingService settingService = PentahoSystem.get( IUserSettingService.class ); IAnyUserSettingService userSettingService = null; if ( settingService != null && settingService instanceof IAnyUserSettingService ) { userSettingService = (IAnyUserSettingService) settingService; } if ( userSettingService != null ) { List<ExportManifestUserSetting> exportedSettings = user.getUserSettings(); try { for ( ExportManifestUserSetting exportedSetting : exportedSettings ) { if ( isOverwriteFile() ) { userSettingService.setUserSetting( user.getUsername(), exportedSetting.getName(), exportedSetting.getValue() ); } else { IUserSetting userSetting = userSettingService.getUserSetting( user.getUsername(), exportedSetting.getName(), null ); if ( userSetting == null ) { userSettingService.setUserSetting( user.getUsername(), exportedSetting.getName(), exportedSetting.getValue() ); } } } } catch ( SecurityException e ) { log.error( Messages.getInstance().getString( "ERROR.ImportingUserSetting", user.getUsername() ) ); log.debug( Messages.getInstance().getString( "ERROR.ImportingUserSetting", user.getUsername() ), e ); } } }
public Map<String,Object> queryAllGroup() { Map<String, Object> result = new HashMap<>(); List<WorkerGroup> workerGroups = getWorkerGroups(false); Set<String> availableWorkerGroupSet = workerGroups.stream() .map(workerGroup -> workerGroup.getName()) .collect(Collectors.toSet()); result.put(Constants.DATA_LIST, availableWorkerGroupSet); putMsg(result, Status.SUCCESS); return result; }
@Override public void checkAttributeSemantics(PerunSessionImpl perunSession, Resource resource, Attribute attribute) throws WrongReferenceAttributeValueException, WrongAttributeAssignmentException { if (attribute.getValue() == null) { throw new WrongReferenceAttributeValueException(attribute, null, resource, null, "Attribute cannot be null!"); } Facility facility = perunSession.getPerunBl().getResourcesManagerBl().getFacility(perunSession, resource); Attribute facilityAttr; try { facilityAttr = perunSession.getPerunBl().getAttributesManagerBl().getAttribute(perunSession, facility, A_F_homeMountPoints); } catch (AttributeNotExistsException ex) { throw new InternalErrorException(ex); } if(facilityAttr.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, facilityAttr, resource, null, facility, null, "Reference attribute has null value."); if (!(facilityAttr.valueAsList()).containsAll(attribute.valueAsList())) { throw new WrongReferenceAttributeValueException(attribute, facilityAttr, resource, null, facility, null, "Facility does not contain all of the attribute homeMountPoints!"); } }
@Override protected CompletableFuture<JobVertexBackPressureInfo> handleRequest( @Nonnull HandlerRequest<EmptyRequestBody, JobVertexMessageParameters> request, @Nonnull RestfulGateway gateway) throws RestHandlerException { final JobID jobId = request.getPathParameter(JobIDPathParameter.class); final JobVertexID jobVertexId = request.getPathParameter(JobVertexIdPathParameter.class); return gateway .requestOperatorBackPressureStats(jobId, jobVertexId) .thenApply( operatorBackPressureStats -> operatorBackPressureStats.getOperatorBackPressureStats().map( JobVertexBackPressureHandler::createJobVertexBackPressureInfo).orElse( JobVertexBackPressureInfo.deprecated())); }
@AtlasConversionInfo(sourceType = FieldType.FLOAT, targetType = FieldType.FLOAT) public Float toFloat(Float value) { if (value == null) { return null; } return value.floatValue(); }
void disableWarningHighlight() { final NodeList<Element> warningElements = getElement().parentNode.querySelectorAll("." + WARNING_CSS_CLASS); for (int i = 0; i < warningElements.length; i++) { warningElements.getAt(i).classList.remove(WARNING_CSS_CLASS); } }
public Project getProjectByUri(final String uri) { notEmpty(uri, "uri"); try { return restTemplate.getForObject(uri, Project.class); } catch (GoodDataRestException e) { if (HttpStatus.NOT_FOUND.value() == e.getStatusCode()) { throw new ProjectNotFoundException(uri, e); } else { throw e; } } catch (RestClientException e) { throw new GoodDataException("Unable to get project " + uri, e); } }
@Override public boolean hasKey(String key) { return myExtraColumns.containsKey(key) || myOriginal.hasKey(key); }
@Override public void toggleRowExpansion() { toggleRowExpansion(!isShown()); }
@Override public Maybe<Location> getLastLocation(RxLostApiClient client) { throw new RuntimeException("Sorry, not yet implemented"); }
public static Timestamp create(long seconds, int nanos) { if (seconds < -MAX_SECONDS) { throw new IllegalArgumentException( "'seconds' is less than minimum (" + -MAX_SECONDS + "): " + seconds); } if (seconds > MAX_SECONDS) { throw new IllegalArgumentException( "'seconds' is greater than maximum (" + MAX_SECONDS + "): " + seconds); } if (nanos < 0) { throw new IllegalArgumentException("'nanos' is less than zero: " + nanos); } if (nanos > MAX_NANOS) { throw new IllegalArgumentException( "'nanos' is greater than maximum (" + MAX_NANOS + "): " + nanos); } return new AutoValue_Timestamp(seconds, nanos); }
public static double[] values(double[] v) { ArgChecker.notNull(v, "v"); int n = v.length - 1; double[] tmp = new double[n]; for (int i = 0; i < n; i++) { tmp[i] = v[i + 1] - v[i]; } return tmp; }
public static boolean isNullOrEmpty(final Object value) { if (value == null) { return true; } final String s = value.toString(); return s == null || s.isEmpty(); }
@Override public Map<String, Object> getParameters(final TimePeriodType entity, final Map<String, Object> parameters) { addParameter(entity.getAbbrName(), "abbrName", parameters); addParameter(entity.getName(), "name", parameters); return parameters; }
@Nullable public <V> V queryValue(@Nullable RegionAssociable subject, Flag<V> flag) { Collection<V> values = queryAllValues(subject, flag, true); return flag.chooseValue(values); }
public final Boolean getAsBoolean(String parameterName) { return getAsBoolean(parameterName, null); }
CodeClass parse(File file, Model model) throws IOException { try (InputStream in = new FileInputStream(file)) { return parse(in, model); } }
public static Map<String, String> getExecutionVariables(Map<String, String> variables, CommandExecution commandExecution) { Objects.requireNonNull(variables); Objects.requireNonNull(commandExecution); if (commandExecution.getOverloadedVariables() != null) { return ImmutableMap.<String, String>builder() .putAll(variables) .putAll(commandExecution.getOverloadedVariables()) .build(); } return variables; }
public static PropertyTree build(PropertyPath...paths) { return build(Arrays.asList(paths)); }
public Mono<List<BackingApplication>> transformParameters(List<BackingApplication> backingApplications, Map<String, Object> parameters) { return Flux.fromIterable(backingApplications) .flatMap(backingApplication -> { List<ParametersTransformerSpec> specs = getTransformerSpecsForApplication(backingApplication); return Flux.fromIterable(specs) .flatMap(spec -> { ParametersTransformer<BackingApplication> transformer = locator .getByName(spec.getName(), spec.getArgs()); return transformer.transform(backingApplication, parameters); }) .then(Mono.just(backingApplication)); }) .collectList(); }
public boolean isDateValid(String dateOfBirth) { if (dateOfBirth != null) { return Pattern.matches("\\d\\d/\\d\\d/\\d\\d\\d\\d", dateOfBirth); } else { return false; } }
@Override public JsonArrayBuilder add(final int index, final JsonValue value) { addValue(index, value); return this; }
public static void main(String[] args) throws IOException { runSqlLine(args, null, System.out, System.err); }
List<IntermediateJoinColumn> getJoinColumns() throws ODataJPAModelException { lazyBuildEdmItem(); return joinColumns; }
public CompletableFuture<TransferProcessorResult> runStateTransfer (Stream<TransferBatchRequest> batchStream, int parFactor) { Iterator<TransferBatchRequest> iterator = batchStream.iterator(); if (!iterator.hasNext()) { return CompletableFuture.completedFuture(TransferProcessorResult.builder() .transferState(TRANSFER_SUCCEEDED).build()); } CompletableFuture<Void> allFutures = CompletableFuture.completedFuture(null); if (parFactor <= 0) { allFutures = handleNonTransferException(allFutures, new IllegalArgumentException("Number of nodes should be > 0")); } else { Semaphore semaphore = new Semaphore(parFactor * NUM_REQUESTS_PER_NODE, true); while (iterator.hasNext() && !allFutures.isCompletedExceptionally()) { try { TransferBatchRequest request = iterator.next(); allFutures = handleBatchRequest(request, allFutures, semaphore); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); allFutures = handleNonTransferException(allFutures, ie); } } } return allFutures.handle((res, ex) -> { if (ex == null) { return TransferProcessorResult.builder().transferState(TRANSFER_SUCCEEDED).build(); } return TransferProcessorResult .builder() .transferState(TRANSFER_FAILED) .causeOfFailure(Optional.of(new TransferSegmentException(ex))) .build(); }); }
@Override public List<StatusDetail> statusDetails() { String databaseStatusName = "MongoDB Status"; Document document = new Document().append("ping", 1); Document answer; try { answer = mongoDatabase.runCommand(document); } catch (MongoTimeoutException e) { return singletonList( statusDetail(databaseStatusName, ERROR, "Mongo database check ran into timeout (" + e.getMessage() + ").") ); } catch (Exception other) { return singletonList( statusDetail(databaseStatusName, ERROR, "Exception during database check (" + other.getMessage() + ").") ); } if (answer != null && answer.get("ok") != null && (Double)answer.get("ok") == 1.0d) { return singletonList( statusDetail(databaseStatusName, OK, "Mongo database is reachable.") ); } return singletonList( statusDetail(databaseStatusName, ERROR, "Mongo database unreachable or ping command failed.") ); }
public static String decode(final String s, final Type t) { if (s == null) { throw new IllegalArgumentException(); } final int n = s.length(); if (n == 0) { return s; } if (s.indexOf('%') < 0) { if (t == Type.QUERY_PARAM) { if (s.indexOf('+') < 0) { return s; } } else { return s; } } else { if (n < 2) { throw new IllegalArgumentException(LocalizationMessages.URI_COMPONENT_ENCODED_OCTET_MALFORMED(1)); } if (s.charAt(n - 2) == '%') { throw new IllegalArgumentException(LocalizationMessages.URI_COMPONENT_ENCODED_OCTET_MALFORMED(n - 2)); } } if (t == null) { return decode(s, n); } switch (t) { case HOST: return decodeHost(s, n); case QUERY_PARAM: return decodeQueryParam(s, n); default: return decode(s, n); } }
@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; B2Bucket b2Bucket = (B2Bucket) o; return getRevision() == b2Bucket.getRevision() && Objects.equals(getAccountId(), b2Bucket.getAccountId()) && Objects.equals(getBucketId(), b2Bucket.getBucketId()) && Objects.equals(getBucketName(), b2Bucket.getBucketName()) && Objects.equals(getBucketType(), b2Bucket.getBucketType()) && Objects.equals(getBucketInfo(), b2Bucket.getBucketInfo()) && Objects.equals(getCorsRules(), b2Bucket.getCorsRules()) && Objects.equals(getLifecycleRules(), b2Bucket.getLifecycleRules()) && Objects.equals(getOptions(), b2Bucket.getOptions()); }
@Override public Path subpath(int i, int i2) { if ((0 == i && parts.length <= 1 && parts[0].isEmpty()) || i < 0 || i2 < 0 || i >= parts.length || i2 > parts.length || i > i2) { throw new IllegalArgumentException("invalid indices"); } return new GlusterPath(fileSystem, Arrays.copyOfRange(parts, i, i2), absolute); }
@Override public int getChannelMax() { return _channelMax; }
@Override public String getDriverClass() { return DRIVER_CLASS_NAME; }
public boolean cancelRequest(String sessionId, long executionId) throws TeiidComponentException { RequestID requestID = new RequestID(sessionId, executionId); return cancelRequest(requestID, "by an admin operation"); }
@Nonnull public static ExtendedCommunity parse(String communityStr) { String[] parts = communityStr.trim().split(":"); checkArgument(parts.length == 3, "Invalid extended community string: %s", communityStr); long gaLong; long laLong; String subType = parts[0].toLowerCase(); String globalAdministrator = parts[1].toLowerCase(); String localAdministrator = parts[2].toLowerCase(); Byte typeByte = null; byte subTypeByte; if (subType.equals("target")) { subTypeByte = 0x02; } else if (subType.equals("origin")) { subTypeByte = 0x03; } else { Integer intVal = Ints.tryParse(subType); if (intVal != null && intVal <= 0xFFFF && intVal >= 0) { subTypeByte = (byte) (intVal & 0xFF); typeByte = (byte) ((intVal & 0xFF00) >> 8); } else { throw new IllegalArgumentException( String.format("Invalid extended community type: %s", communityStr)); } } laLong = Long.parseUnsignedLong(localAdministrator); String[] gaParts = globalAdministrator.split("\\."); if (gaParts.length == 4) { typeByte = firstNonNull(typeByte, (byte) 0x01); gaLong = Ip.parse(globalAdministrator).asLong(); checkArgument(laLong <= 0xFFFFL, "Invalid local administrator value %s", localAdministrator); } else if (gaParts.length == 2) { typeByte = firstNonNull(typeByte, (byte) 0x02); int hi = Integer.parseUnsignedInt(gaParts[0]); int lo = Integer.parseUnsignedInt(gaParts[1]); checkArgument( hi <= 0xFFFF && lo <= 0xFFFF, "Invalid global administrator value %s", globalAdministrator); gaLong = ((long) hi) << 16 | lo; checkArgument(laLong <= 0xFFFFL, "Invalid local administrator value %s", localAdministrator); } else { if (globalAdministrator.endsWith("l")) { typeByte = firstNonNull(typeByte, (byte) 0x02); gaLong = Long.parseUnsignedLong( globalAdministrator.substring(0, globalAdministrator.length() - 1)); checkArgument( gaLong <= 0xFFFFFFFFL, "Invalid global administrator value %s", globalAdministrator); checkArgument( laLong <= 0xFFFFL, "Invalid local administrator value %s", localAdministrator); } else { gaLong = Long.parseUnsignedLong(globalAdministrator); if (gaLong <= 0xFFFFL) { checkArgument( laLong <= 0xFFFFFFFFL, "Invalid local administrator value %s", localAdministrator); typeByte = firstNonNull(typeByte, (byte) 0x00); } else { checkArgument( gaLong <= 0xFFFFFFFFL, "Invalid global administrator value %s", globalAdministrator); checkArgument( laLong <= 0xFFFFL, "Invalid local administrator value %s", localAdministrator); typeByte = firstNonNull(typeByte, (byte) 0x02); } } } return of((int) typeByte << 8 | (int) subTypeByte, gaLong, laLong); }
private String trimPrefix(final String url) { return trimPrefix(url, "jdbc:"); }
@Override public String describe() { return String.format("LeaseLock: %s - %s (%s)", leaseNamespace, leaseName, identity); }
public Expiration guess(String maybeIso) { for (Map.Entry<Expiration, List<String>> value : patterns.entrySet()) { for (String pattern : value.getValue()) { if (checkIfPatternMatch.apply(pattern, maybeIso).isPresent()) { return value.getKey(); } } } return Expiration.EXPRESSION; }
public SortedMap<Long, List<Sibling>> getSiblings() { if (siblings != null) { return siblings; } DataWord address = new DataWord(SIBLINGS_KEY.getBytes(StandardCharsets.UTF_8)); byte[] bytes = this.repository.getStorageBytes(this.contractAddress, address); siblings = getSiblingsFromBytes(bytes); return siblings; }
@VisibleForTesting void attemptDelivery(Mail mail) throws MailQueue.MailQueueException { ExecutionResult executionResult = mailDelivrer.deliver(mail); switch (executionResult.getExecutionState()) { case SUCCESS: outgoingMailsMetric.increment(); break; case TEMPORARY_FAILURE: handleTemporaryFailure(mail, executionResult); break; case PERMANENT_FAILURE: bouncer.bounce(mail, executionResult.getException().orElse(null)); break; } }
@Override public void process(final ApplicationDeployable input) throws Exception { List<ProgramDescriptor> programDescriptors = new ArrayList<>(); final ApplicationSpecification appSpec = input.getSpecification(); Iterable<ProgramSpecification> specifications = Iterables.concat( appSpec.getMapReduce().values(), appSpec.getWorkflows().values(), appSpec.getServices().values(), appSpec.getSpark().values(), appSpec.getWorkers().values() ); for (ProgramSpecification spec: specifications) { ProgramType type = ProgramTypes.fromSpecification(spec); ProgramId programId = input.getApplicationId().program(type, spec.getName()); programDescriptors.add(new ProgramDescriptor(programId, appSpec)); } emit(new ApplicationWithPrograms(input, programDescriptors)); }
public static ExtraDataConverter newInstance() { return new ExtraDataConverter( DataEntryConverter.newInstance() ); }
public static void propagateVoid(final CheckedRunnable runnable) { propagateVoid(runnable, RuntimeException::new); }
public List<Map<String, Object>> getClosedIssueInfo(String assetGroup, int size) throws DataException { String responseJson = null; List<Map<String, Object>> issueDetails = null; List<Map<String, Object>> closedLissues = new ArrayList<>(); Gson serializer = new GsonBuilder().create(); StringBuilder requestBody = new StringBuilder( "{\"size\":\"" + size + "\",\"_source\":[\"_resourceid\",\"reason-to-close\"],\"sort\":[{\"closeddate\":{\"order\":\"desc\"}}],\"query\":{\"bool\":{\"must\":[{\"match\":{\"issueStatus.keyword\":\"closed\"}},{\"match\":{\"ruleId.keyword\":\"" + EC2_KERNEL_COMPLIANCE_RULE + "\"}},{\"exists\":{\"field\":\"reason-to-close\"}}],\"must_not\":[{\"match\":{\"reason-to-close.keyword\":\"Rule evaluation sucessfull\"}},{\"match\":{\"reason-to-close.keyword\":\"resource not found\"}}]}}}"); StringBuilder urlToQueryBuffer = new StringBuilder(esUrl).append("/") .append(assetGroup).append("/").append(SEARCH); try{ responseJson = PacHttpUtils.doHttpPost(urlToQueryBuffer.toString(), requestBody.toString()); } catch(Exception e){ throw new DataException(e); } Map<String, Object> responseMap = (Map<String, Object>) serializer .fromJson(responseJson, Object.class); if (responseMap.containsKey("hits")) { Map<String, Object> hits = (Map<String, Object>) responseMap .get("hits"); if (hits.containsKey("hits")) { issueDetails = (List<Map<String, Object>>) hits.get("hits"); for (Map<String, Object> issueDetail : issueDetails) { Map<String, Object> sourceMap = (Map<String, Object>) issueDetail .get("_source"); closedLissues.add(sourceMap); } } } return closedLissues; }
@Override public int compare(IAtom o1, IAtom o2) { if (o1.getSymbol().equalsIgnoreCase(o2.getSymbol())) { if (o1.getHybridization() != null && o2.getHybridization() != null) { return o1.getHybridization().compareTo(o2.getHybridization()); } return 0; } return 10 * o1.getSymbol().compareToIgnoreCase(o2.getSymbol()); }
public static BlackFxOptionSmileVolatilities of( FxOptionVolatilitiesName name, CurrencyPair currencyPair, ZonedDateTime valuationTime, SmileDeltaTermStructure smile) { return new BlackFxOptionSmileVolatilities(name, currencyPair, valuationTime, smile); }
public CompletableFuture<Void> createTerminatingServiceAction(BigInteger dpnId) { short offset = NwConstants.SFC_TRANSPORT_INGRESS_TABLE; CreateTerminatingServiceActionsInput input = new CreateTerminatingServiceActionsInputBuilder() .setDpnId(dpnId) .setInstruction(Collections.singletonList(MDSALUtil.buildAndGetGotoTableInstruction(offset, 0))) .setServiceId(SfcGeniusConstants.SFC_VNID) .build(); return CompletableFuture.supplyAsync(() -> { try { RpcResult<Void> result = itmRpcService.createTerminatingServiceActions(input).get(); if (!result.isSuccessful()) { throw new SfcGeniusRuntimeException( new RuntimeException( "Could not add terminating service action on dara plane node " + dpnId, result.getErrors().stream().findFirst().map(RpcError::getCause).orElse(null))); } } catch (InterruptedException | ExecutionException e) { throw new SfcGeniusRuntimeException( new RuntimeException( "Could not add terminating service action on dara plane node " + dpnId, e)); } return null; }, executor); }
@Override public String getPartition() { return ""; }
@Override protected Promise<AuthorizationResult, ResourceException> authorize(Context context) { if (!enabled) { if (debug.messageEnabled()) { debug.message("CoreTokenResourceAuthzModule :: Restricted access to CoreTokenResource"); } return Promises.newResultPromise(AuthorizationResult.accessDenied("CoreTokenResource not enabled.")); } if (debug.messageEnabled()) { debug.message("CoreTokenResourceAuthzModule :: Request forwarded to AdminOnlyAuthzModule."); } return super.authorize(context); }
@Override public Object decode(Response response, Type type) throws IOException { Object delegateResult = delegate.decode(response, type); if (response.status() == 204 || (response.status() == 200 && delegateResult == null)) { @Nullable Object object = blankInstanceCache.get(type); return Preconditions.checkNotNull( object, "Received HTTP 204 but unable to construct an empty instance for return type", SafeArg.of("type", type)); } else { return delegateResult; } }
public void startAgent() { printLog("***************************************************"); printLog(" Start nGrinder Agent ..."); printLog("***************************************************"); if (StringUtils.isEmpty(System.getenv("JAVA_HOME"))) { printLog("Hey!! JAVA_HOME env var was not provided. " + "Please provide JAVA_HOME env var before running agent." + "Otherwise you can not execute the agent in the security mode."); } boolean serverMode = agentConfig.isServerMode(); if (!serverMode) { printLog("JVM server mode is disabled."); } if (agentConfig.isConnectionMode()) { LOG.info("waiting for connection on {}:{}", agentConfig.getBroadcastIP(), agentConfig.getConnectionAgentPort()); } else { String controllerIP = getIP(agentConfig.getControllerIP()); agentConfig.setControllerHost(controllerIP); LOG.info("connecting to controller {}:{}", controllerIP, agentConfig.getControllerPort()); } try { agentController = new AgentControllerDaemon(agentConfig); agentController.run(); } catch (Exception e) { LOG.error("Error while starting Agent", e); printHelpAndExit("Error while starting Agent", e); } }
public String getId() { return id; }
public ServiceMethodHandler getServiceMethodHandler(String methodName, String version) { return serviceHandlerMap.get(ServiceMethodHandler.methodWithVersion(methodName, version)); }
@Override public long installEgressFlow(DatapathId dpid, String flowId, Long cookie, int inputPort, int outputPort, int transitTunnelId, int outputVlanId, OutputVlanType outputVlanType, FlowEncapsulationType encapsulationType, boolean multiTable) throws SwitchOperationException { List<OFAction> actionList = new ArrayList<>(); IOFSwitch sw = lookupSwitch(dpid); OFFactory ofFactory = sw.getOFFactory(); actionList.addAll(egressFlowActions(ofFactory, outputVlanId, outputVlanType, encapsulationType)); actionList.add(actionSetOutputPort(ofFactory, OFPort.of(outputPort))); OFInstructionApplyActions actions = buildInstructionApplyActions(ofFactory, actionList); OFFlowMod flowMod = prepareFlowModBuilder(ofFactory, cookie & FLOW_COOKIE_MASK, FLOW_PRIORITY, multiTable ? EGRESS_TABLE_ID : INPUT_TABLE_ID) .setMatch(matchFlow(ofFactory, inputPort, transitTunnelId, encapsulationType)) .setInstructions(ImmutableList.of(actions)) .build(); return pushFlow(sw, "--InstallEgressFlow--", flowMod); }
public static ExecutionBuilder run(String... command) { return new ExecutionBuilder(new ProcessBuilder().command(command)); }
public boolean getPropertyBoolean(String propertyFileName, String propertyName) throws PropertyAccessException { PropertiesConfiguration properties = propertyFilesHashmap.get(propertyFileName); if (properties != null && properties.containsKey(propertyName)) { try { return properties.getBoolean(propertyName); } catch (ConversionException ex) { LOG.warn("Could not read property {}: {}", propertyName, ex.getLocalizedMessage(), ex); String sProp = properties.getString(propertyName); if (NullChecker.isNotNullish(sProp)) { return sProp.equalsIgnoreCase("t"); } } } throw new PropertyAccessException(getErrorMessage(propertyFileName, propertyName)); }
@Override public void execute() { byte sourceValue = z80.get8BitRegisterValue(sourceRegister); byte registerAValue = z80.get8BitRegisterValue(Register.A); byte result = (byte) (registerAValue - sourceValue); z80.set8BitRegisterValue(Register.A, result); z80.setLastInstructionExecutionTime(1); z80.resetFlagF(); z80.enableFlagN(); if (result == 0) { z80.enableFlagZ(); } if (((result & 0xF) < (sourceValue & 0xF))) { z80.enableFlagH(); } if ((result & 0xff) < (sourceValue & 0xff)) { z80.enableFlagCY(); } }
public boolean seekToNewSource(long targetPos) throws IOException { return false; }
public static DesiredRateReadWriteExpression<?, Object> formula(String formula) { DesiredRateExpression<?> exp = parseFormula(formula); if (exp instanceof LastOfChannelExpression) { return new DesiredRateReadWriteExpressionImpl<>(exp, org.diirt.datasource.vtype.ExpressionLanguage.vType(exp.getName())); } else if (exp instanceof ErrorDesiredRateExpression) { return new DesiredRateReadWriteExpressionImpl<>(exp, readOnlyWriteExpression("Parsing error")); } else { return new DesiredRateReadWriteExpressionImpl<>(exp, readOnlyWriteExpression("Read-only formula")); } }
public void finish() throws IOException { if (finished) { return; } flush(); VarInt.encode(terminatorValue, os); if (!BUFFER_POOL.offer(buffer)) { } finished = true; }
public void run( @NonNull Collection<TransformInput> inputs, @NonNull Collection<TransformInput> referencedClasses, @NonNull TransformOutputProvider output, @NonNull ImmutableMap<CounterSet, KeepRules> keepRules, boolean saveState) throws IOException { output.deleteAll(); buildGraph(inputs, referencedClasses); Stopwatch stopwatch = Stopwatch.createStarted(); setCounters(keepRules); logTime("Set counters", stopwatch); writeOutput(inputs, output); logTime("Write output", stopwatch); if (saveState) { mGraph.saveState(); logTime("Saving state", stopwatch); } }
static String starEncrypt(String str) { if (str == null) { return null; } return str.replaceAll(".", "*"); }
@Override protected void channelRead0( ChannelHandlerContext ctx, final TxPullRequest msg ) throws Exception { monitor.increment(); if ( msg.previousTxId() <= 0 ) { log.error( "Illegal tx pull request" ); endInteraction( ctx, E_INVALID_REQUEST, -1 ); return; } StoreId localStoreId = storeIdSupplier.get(); StoreId expectedStoreId = msg.expectedStoreId(); long firstTxId = msg.previousTxId() + 1; long txIdPromise = transactionIdStore.getLastCommittedTransactionId(); IOCursor<CommittedTransactionRepresentation> txCursor = getCursor( txIdPromise, ctx, firstTxId, localStoreId, expectedStoreId ); if ( txCursor != null ) { ChunkedTransactionStream txStream = new ChunkedTransactionStream( log, localStoreId, firstTxId, txIdPromise, txCursor, protocol ); ctx.writeAndFlush( txStream ).addListener( f -> { if ( log.isDebugEnabled() || !f.isSuccess() ) { String message = format( "Streamed transactions [%d--%d] to %s", firstTxId, txStream.lastTxId(), ctx.channel().remoteAddress() ); if ( f.isSuccess() ) { log.debug( message ); } else { log.warn( message, f.cause() ); } } } ); } }
@Override public List<WizardPage> getPages() { return new ArrayList<WizardPage>() {{ add(ruleModellerPage); add(defaultValuesPage); add(additionalInfoPage()); }}; }
@Deprecated public ConfigGroup compat(final ConfigGroup configGroup) { if (configGroup != null) { final ConfigItem<List<String>> roles = configGroup.getConfigItem("security:roles"); if (roles != null) { configGroup.addConfigItem(configurationFactory.newConfigItem("security:groups", new ArrayList<String>(roles.getValue()))); configGroup.removeConfigItem("security:roles"); } final ConfigItem<List<String>> groups = configGroup.getConfigItem("security:groups"); if (groups == null) { configGroup.addConfigItem(configurationFactory.newConfigItem("security:groups", new ArrayList<String>())); } } return configGroup; }
void initialise( boolean createIfNotExists ) { try { checkAndLoadStorage( createIfNotExists ); } catch ( Exception e ) { closeAndThrow( e ); } }
public int getClientType() { return client_type; }
public static boolean in( char[] chars, String str ) { return Chr.in ( chars, FastStringUtils.toCharArray(str) ); }
static long defineMatchupPattern(String primarySensorName, String secondarySensorName, long referenceSensorPattern, PersistenceManager pm, Stack<EntityTransaction> rollbackStack) { long matchupPattern; final Storage storage = pm.getStorage(); rollbackStack.push(pm.transaction()); final String primaryOrbitName = SensorNames.getOrbitName(primarySensorName); final Sensor primarySensor = storage.getSensor(primaryOrbitName); if (secondarySensorName != null) { final String secondaryOrbitName = SensorNames.getOrbitName(secondarySensorName); final Sensor secondarySensor = storage.getSensor(secondaryOrbitName); matchupPattern = referenceSensorPattern | primarySensor.getPattern() | secondarySensor.getPattern(); } else { matchupPattern = referenceSensorPattern | primarySensor.getPattern(); } pm.commit(); return matchupPattern; }
public static SdxL2ConnectionPoint sdxl2ConnectionPoint( String name, String connectPoint, String vlans, String mac) { checkNotNull(connectPoint); enforceNameFormat(name); ConnectPoint connectionPoint = ConnectPoint.deviceConnectPoint(connectPoint); List<VlanId> vlansList = enforceVlans(vlans); MacAddress macAddress = MacAddress.ZERO; if (mac != null) { macAddress = MacAddress.valueOf(mac); } return new SdxL2ConnectionPoint(name, connectionPoint, vlansList, macAddress); }
@Override protected void create(boolean stream) throws IOException { copyToDelegate(); long start = System.currentTimeMillis(); try { method("create", boolean.class).invoke(delegate, stream); } catch (Exception e) { ExceptionUtil.processException(e); } finally { logSocket(System.currentTimeMillis() - start); copyFromDelegate(); } }
public RegistryErrorList validateDocumentMetaData(ProvideAndRegisterDocumentSetRequestType body) { RegistryErrorList result = new RegistryErrorList(); LOG.debug("begin validateDocumentMetaData()"); if (body == null) { RegistryError error = createRegistryError(XDR_EC_XDSMissingDocument, NhincConstants.XDS_REGISTRY_ERROR_SEVERITY_ERROR, "ProvideAndRegisterDocumentSetRequestType was null"); result.getRegistryError().add(error); return processErrorList(result); } if (validateDocumentData(body, result)) { return processErrorList(result); } validateSubmittedObjectsRequest(body.getSubmitObjectsRequest(), result, body.getDocument()); return processErrorList(result); }
@Override public MajorFlushEvent beginCacheFlush() { log.info( "Start whole page cache flush." ); return new PageCacheMajorFlushEvent( flushedPages.get(), flushBytesWritten.get(), clock.nanos() ); }
public static TypeDescriptor javaTypeForFieldType(FieldType fieldType) { switch (fieldType.getTypeName()) { case LOGICAL_TYPE: return javaTypeForFieldType(fieldType.getLogicalType().getBaseType()); case ARRAY: return TypeDescriptors.lists(javaTypeForFieldType(fieldType.getCollectionElementType())); case ITERABLE: return TypeDescriptors.iterables( javaTypeForFieldType(fieldType.getCollectionElementType())); case MAP: return TypeDescriptors.maps( javaTypeForFieldType(fieldType.getMapKeyType()), javaTypeForFieldType(fieldType.getMapValueType())); case ROW: return TypeDescriptors.rows(); default: return PRIMITIVE_MAPPING.get(fieldType.getTypeName()); } }
protected static Set<String> parseShortInvokedMethods(String line) { Set<String> methods = Sets.newHashSet(); Set<String> blacklist = Sets.newHashSet("time", "date"); String regex = "\\b(?!" + StringUtils.join(blacklist, "|") + ")[\\w\\.]+\\("; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(line); while (matcher.find()) { if(!matcher.group().startsWith("concourse.")) { methods.add(matcher.group().replace("(", "")); } } return methods; }
@Override public Tuple<Collection<ExecutionLineageNode>, Collection<ChannelInstance>> evaluate( ChannelInstance[] inputs, ChannelInstance[] outputs, SparkExecutor sparkExecutor, OptimizationContext.OperatorContext operatorContext) { assert inputs.length == this.getNumInputs(); assert outputs.length == this.getNumOutputs(); final RddChannel.Instance input = (RddChannel.Instance) inputs[0]; final RddChannel.Instance output = (RddChannel.Instance) outputs[0]; final JavaRDD<Type> inputRdd = input.provideRdd(); long datasetSize = this.isDataSetSizeKnown() ? this.getDatasetSize() : inputRdd.count(); int sampleSize = this.getSampleSize(operatorContext); long seed = this.getSeed(operatorContext); double sampleFraction = ((double) sampleSize) / datasetSize; final JavaRDD<Type> outputRdd = inputRdd.sample(false, sampleFraction, seed); this.name(outputRdd); output.accept(outputRdd, sparkExecutor); return ExecutionOperator.modelLazyExecution(inputs, outputs, operatorContext); }
public List<Coordinate> computeSideHull(boolean left, Coordinate p1, Coordinate p2) { if(p1.equals(p2)) { return new ArrayList<>(); } Set<LineSegment> freeFieldSegments = new HashSet<>(); GeometryFactory geometryFactory = new GeometryFactory(); List<Coordinate> input = new ArrayList<>(); Coordinate[] coordinates = new Coordinate[0]; int indexp1 = 0; int indexp2 = 0; boolean convexHullIntersects = true; input.add(p1); input.add(p2); Set<Integer> buildingInHull = new HashSet<>(); Plane cutPlane = ComputeZeroRadPlane(p1, p2); IntersectionRayVisitor intersectionRayVisitor = new IntersectionRayVisitor( data.freeFieldFinder.getPolygonWithHeight(), p1, p2, data.freeFieldFinder, input, buildingInHull, cutPlane); data.freeFieldFinder.getBuildingsOnPath(p1, p2, intersectionRayVisitor); int k; while (convexHullIntersects) { ConvexHull convexHull = new ConvexHull(input.toArray(new Coordinate[0]), geometryFactory); Geometry convexhull = convexHull.getConvexHull(); if (convexhull.getLength() / p1.distance(p2) > MAX_RATIO_HULL_DIRECT_PATH) { return new ArrayList<>(); } convexHullIntersects = false; coordinates = convexhull.getCoordinates(); input.clear(); input.addAll(Arrays.asList(coordinates)); indexp1 = -1; for (int i = 0; i < coordinates.length - 1; i++) { if (coordinates[i].equals(p1)) { indexp1 = i; break; } } if (indexp1 == -1) { return new ArrayList<>(); } Coordinate[] coordinatesShifted = new Coordinate[coordinates.length]; int len = (coordinates.length - 1) - indexp1; System.arraycopy(coordinates, indexp1, coordinatesShifted, 0, len); System.arraycopy(coordinates, 0, coordinatesShifted, len, coordinates.length - len - 1); coordinatesShifted[coordinatesShifted.length - 1] = coordinatesShifted[0]; coordinates = coordinatesShifted; indexp1 = 0; indexp2 = -1; for (int i = 1; i < coordinates.length - 1; i++) { if (coordinates[i].equals(p2)) { indexp2 = i; break; } } if (indexp2 == -1) { return new ArrayList<>(); } for (k = 0; k < coordinates.length - 1; k++) { LineSegment freeFieldTestSegment = new LineSegment(coordinates[k], coordinates[k + 1]); if (left && k < indexp2 || !left && k >= indexp2) { if (!freeFieldSegments.contains(freeFieldTestSegment)) { if(!data.freeFieldFinder.getMeshEnvelope().contains(coordinates[k]) || !data.freeFieldFinder.getMeshEnvelope().contains(coordinates[k+1])) { return new ArrayList<>(); } intersectionRayVisitor = new IntersectionRayVisitor(data.freeFieldFinder.getPolygonWithHeight(), coordinates[k], coordinates[k + 1], data.freeFieldFinder, input, buildingInHull, cutPlane); data.freeFieldFinder.getBuildingsOnPath(coordinates[k], coordinates[k + 1], intersectionRayVisitor); if(!intersectionRayVisitor.doContinue()) { convexHullIntersects = true; } if (!convexHullIntersects) { freeFieldSegments.add(freeFieldTestSegment); } else { break; } } } } } for(Coordinate p : coordinates) { if(p.z < 0) { return new ArrayList<>(); } } if(left) { return Arrays.asList(Arrays.copyOfRange(coordinates,indexp1, indexp2 + 1)); } else { ArrayList<Coordinate> inversePath = new ArrayList<>(); inversePath.addAll(Arrays.asList(Arrays.copyOfRange(coordinates,indexp2, coordinates.length))); Collections.reverse(inversePath); return inversePath; } }
public boolean isMultifactorEnrollRequired() { return "a0.mfa_registration_required".equals(code) || "unsupported_challenge_type".equals(code); }
@Override public FluentWebElementAssert hasNotTextContaining(String textToFind) { if (actual.text().contains(textToFind)) { failWithMessage("The element contains the text: " + textToFind); } return this; }
public void add(TimeSeriesDataItem item) { add(item, true); }
@Override public boolean getBoolean(final String name) { final JsonValue obj = valueOrExcpetion(name, JsonValue.class); if (JsonValue.TRUE == obj) { return true; } if (JsonValue.FALSE == obj) { return false; } throw new ClassCastException("Wrong value for a boolean: " + obj); }
public static byte[] deserializeRow(NameMetadataDescription description, JsonNode node) { return deserializeRowish(description, node, true); }
public static Token token(Class<?> aClass, String groupId, String artifactId) { return new Token(artifactId, MavenVersion.version(aClass, groupId, artifactId), Optional.empty()); }
public Map<String, Object> updateProcessInstance(User loginUser, String projectName, Integer processInstanceId, String processInstanceJson, String scheduleTime, Boolean syncDefine, Flag flag, String locations, String connects) throws ParseException { Map<String, Object> result = new HashMap<>(); Project project = projectMapper.queryByName(projectName); Map<String, Object> checkResult = projectService.checkProjectAndAuth(loginUser, project, projectName); Status resultEnum = (Status) checkResult.get(Constants.STATUS); if (resultEnum != Status.SUCCESS) { return checkResult; } ProcessInstance processInstance = processService.findProcessInstanceDetailById(processInstanceId); if (processInstance == null) { putMsg(result, Status.PROCESS_INSTANCE_NOT_EXIST, processInstanceId); return result; } if (!processInstance.getState().typeIsFinished()) { putMsg(result, Status.PROCESS_INSTANCE_STATE_OPERATION_ERROR, processInstance.getName(), processInstance.getState().toString(), "update"); return result; } Date schedule = null; if (scheduleTime != null) { schedule = DateUtils.getScheduleDate(scheduleTime); } else { schedule = processInstance.getScheduleTime(); } processInstance.setScheduleTime(schedule); processInstance.setLocations(locations); processInstance.setConnects(connects); String globalParams = null; String originDefParams = null; int timeout = processInstance.getTimeout(); ProcessDefinition processDefinition = processService.findProcessDefineById(processInstance.getProcessDefinitionId()); if (StringUtils.isNotEmpty(processInstanceJson)) { ProcessData processData = JSONUtils.parseObject(processInstanceJson, ProcessData.class); Map<String, Object> checkFlowJson = processDefinitionService.checkProcessNodeList(processData, processInstanceJson); if (checkFlowJson.get(Constants.STATUS) != Status.SUCCESS) { return result; } originDefParams = JSONUtils.toJsonString(processData.getGlobalParams()); List<Property> globalParamList = processData.getGlobalParams(); Map<String, String> globalParamMap = globalParamList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue)); globalParams = ParameterUtils.curingGlobalParams(globalParamMap, globalParamList, processInstance.getCmdTypeIfComplement(), schedule); timeout = processData.getTimeout(); processInstance.setTimeout(timeout); Tenant tenant = processService.getTenantForProcess(processData.getTenantId(), processDefinition.getUserId()); if(tenant != null){ processInstance.setTenantCode(tenant.getTenantCode()); } processInstance.setProcessInstanceJson(processInstanceJson); processInstance.setGlobalParams(globalParams); } int update = processService.updateProcessInstance(processInstance); int updateDefine = 1; if (Boolean.TRUE.equals(syncDefine) && StringUtils.isNotEmpty(processInstanceJson)) { processDefinition.setProcessDefinitionJson(processInstanceJson); processDefinition.setGlobalParams(originDefParams); processDefinition.setLocations(locations); processDefinition.setConnects(connects); processDefinition.setTimeout(timeout); updateDefine = processDefineMapper.updateById(processDefinition); } if (update > 0 && updateDefine > 0) { putMsg(result, Status.SUCCESS); } else { putMsg(result, Status.UPDATE_PROCESS_INSTANCE_ERROR); } return result; }
public ColorTheme getColorThemeFromSkinFile(String filename) { try { return lessColorThemeConverter.getColorThemeFromSkinFile(filename, false); } catch (LESSCompilerException e) { return new ColorTheme(); } }
@Override public boolean importPublicationFile(File file) { logger.info("Processing {}", file.getName()); boolean handled; CorrelationIdHolder.set(agentService.getCorrelationIdFromPublicationFile(file)); PublicationType publicationType = agentService.getPublicationTypeFromPublicationFile(file); try (ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file)))) { long startedAt = System.currentTimeMillis(); Object object = ois.readObject(); logger.debug( "Deserialized a {} in {} ms", object.getClass().getSimpleName(), System.currentTimeMillis() - startedAt); handled = !isValidObject(object) || handlePublication(object); } catch (InvalidClassException e) { logger.error("Could not import {}: {}. Will not try again.", file, e.toString()); handled = true; } catch (LicenseViolationException e) { logger.warn("Ignoring {}: {}", file, e.toString()); handled = true; } catch (DataAccessException e) { logger.warn("Could not import {}: {}. Will try again.", file, e.toString()); handled = false; } catch (Exception e) { logger.error("Cannot import " + file + ". Will try again.", e); handled = false; } finally { CorrelationIdHolder.clear(); } if (!handled) { metricsService.countRejectedPublication(publicationType); } return handled; }
@Override public void meet(Join join) { super.meet(join); TupleExpr leftArg = join.getLeftArg(); TupleExpr rightArg = join.getRightArg(); if (leftArg instanceof EmptySet || rightArg instanceof EmptySet) { join.replaceWith(new EmptySet()); } else if (leftArg instanceof SingletonSet) { join.replaceWith(rightArg); } else if (rightArg instanceof SingletonSet) { join.replaceWith(leftArg); } else if (leftArg instanceof Union) { Union union = (Union) leftArg; Join leftJoin = new Join(union.getLeftArg(), rightArg.clone()); Join rightJoin = new Join(union.getRightArg(), rightArg.clone()); Union newUnion = new Union(leftJoin, rightJoin); join.replaceWith(newUnion); newUnion.visit(this); } else if (rightArg instanceof Union) { Union union = (Union) rightArg; Join leftJoin = new Join(leftArg.clone(), union.getLeftArg()); Join rightJoin = new Join(leftArg.clone(), union.getRightArg()); Union newUnion = new Union(leftJoin, rightJoin); join.replaceWith(newUnion); newUnion.visit(this); } else if (leftArg instanceof LeftJoin && isWellDesigned(((LeftJoin) leftArg))) { LeftJoin leftJoin = (LeftJoin) leftArg; join.replaceWith(leftJoin); join.setLeftArg(leftJoin.getLeftArg()); leftJoin.setLeftArg(join); leftJoin.visit(this); } else if (rightArg instanceof LeftJoin && isWellDesigned(((LeftJoin) rightArg))) { LeftJoin leftJoin = (LeftJoin) rightArg; join.replaceWith(leftJoin); join.setRightArg(leftJoin.getLeftArg()); leftJoin.setLeftArg(join); leftJoin.visit(this); } }
@Override public void onSyncToFilesystemSuccess(@NonNull BreakpointInfo info, int blockIndex, long increaseLength) throws IOException { if (remitHelper.isNotFreeToDatabase(info.getId())) { sqliteCache.onSyncToFilesystemSuccess(info, blockIndex, increaseLength); return; } onSQLiteWrapper.onSyncToFilesystemSuccess(info, blockIndex, increaseLength); }
public Properties getPropertiesFromTimestamp(final String group, final long timestamp) throws SerialisationException { final SchemaElementDefinition elementDefinition = schema.getElement(group); if (null == elementDefinition) { throw new SerialisationException("No SchemaElementDefinition found for group " + group + ", is this group in your schema or do your table iterators need updating?"); } final Properties properties = new Properties(); if (null != timestampProperty && elementDefinition.containsProperty(timestampProperty)) { properties.put(timestampProperty, timestamp); } return properties; }
public static List<String> extractLabelValuesByPosition(String key, LabeledMetricConf labeledMetricConf) { List<String> keyParts = keyParts(key); Map<Integer, String> keyPartsByPosition = keyPartsByPosition(keyParts); return labeledMetricConf.getLabelConfs().stream() .map(LabelConf::getPattern) .map(pattern -> replacePatternTokens(pattern, keyPartsByPosition)) .collect(Collectors.toList()); }
@Override public boolean match(File file) throws FilterRuleNotAppliableException { long lastModified = file.getLastModified(); if (-1 == lastModified) { throw new FilterRuleNotAppliableException("The file or directory doesn't have any modification date"); } long now = SystemDate.getInstance().currentTimeMillis(); long delta = (long) (Math.floor(now / 1000.0) - Math.floor(lastModified / 1000.0)); switch (op) { case OP_IS: return delta == age.getSeconds(); case OP_ISNT: return delta != age.getSeconds(); case OP_IS_GREATER_THAN: return delta > age.getSeconds(); case OP_IS_LESS_THAN: return delta < age.getSeconds(); default: return false; } }
protected RegionFactory<K, V> createRegionFactory(Cache cache) { if (this.shortcut != null) { RegionFactory<K, V> regionFactory = mergeRegionAttributes(cache.createRegionFactory(this.shortcut), this.attributes); setDataPolicy(getDataPolicy(regionFactory, this.shortcut)); return regionFactory; } else if (this.attributes != null) { return cache.createRegionFactory(this.attributes); } else { return cache.createRegionFactory(); } }
@Override public boolean checkCacheOrSet(final Metric metric) { if (writeCache.getIfPresent(metric.generateHash()) != null) { log.trace("Metric in cache: {}", metric); return true; } writeCache.put(metric.generateHash(), true); return false; }
public Map<String, PropertyDefinition> getDefinitions() { return definitions; }
public List<RegistrationUnit> search(RegistrationUnitSearchCriteria regnUnitSearchCriteria) { return registrationUnitRepository.search(regnUnitSearchCriteria); }
@Override public List<StreamsExecutionEnvironment> environments() { initializeDefaultEnvironment(); return List.copyOf(environments.values()); }
public static long encodeZigZag64(final long n) { return (n << 1) ^ (n >> 63); }
public Map<TopicPartition, Long> apply(Map<TopicPartition, Replica> partitionsAndLogDir) { Map<TopicPartition, Long> result = new HashMap<>(); for (Map.Entry<TopicPartition, Replica> entry : partitionsAndLogDir.entrySet()) { TopicPartition topicPartition = entry.getKey(); Replica replica = entry.getValue(); Path path = new File(replica.getLogDir(), topicPartition.toString()).toPath(); try { long size = Files.walk(path).filter(Files::isRegularFile).mapToLong(p -> p.toFile().length()).sum(); result.put(topicPartition, size); } catch (IOException e) { throw new UncheckedIOException("Unable to determine size of " + path, e); } } return result; }
public static String[] getUncontainedArray(String[] subArray, String[] containerArray, boolean ignoreCase) { String[] uncontainedArray = new String[subArray.length]; int index = 0; boolean found = false; for (String subStr : subArray) { for (String contStr : containerArray) { found = elementsAreEqual(subStr, contStr, ignoreCase); if (found) { break; } } if (!found) { uncontainedArray[index] = subStr; index++; } } String[] newUncontainedArray = new String[index]; System.arraycopy(uncontainedArray, 0, newUncontainedArray, 0, index); return newUncontainedArray; }
public static BearerAuthCredentialProvider getBearerAuthCredentialProvider( String bearerAuthCredentialSource, Map<String, ?> configs) { ServiceLoader<BearerAuthCredentialProvider> serviceLoader = ServiceLoader.load( BearerAuthCredentialProvider.class, BearerAuthCredentialProviderFactory.class.getClassLoader() ); for (BearerAuthCredentialProvider bearerAuthCredentialProvider : serviceLoader) { if (bearerAuthCredentialProvider.alias().equals(bearerAuthCredentialSource)) { bearerAuthCredentialProvider.configure(configs); return bearerAuthCredentialProvider; } } return null; }
public static <T> Builder<T> builder(Class<T> dataType) { return new Builder<>(dataType); }
@Override public List<RoleAssignment> getStaffRoleAssignments(PID pid) { return getRoleAssignments(pid, true); }
public static String ltrim(String s) { return LTRIM.matcher(s).replaceAll(""); }
public DbRequestResult execute(Select request) throws InvalidParseOperationException, DatabaseException, BadRequestException, InvalidCreateOperationException, VitamDBException, SchemaValidationException { DynamicParserTokens parserTokens = new DynamicParserTokens(vitamCollection.getVitamDescriptionResolver(), ontologyLoader.loadOntologies()); return findDocuments(request.getFinalSelect(), parserTokens); }
@PUT @Path("{realmId}") @Consumes("application/json") @RightsAllowed({ Right.CRUD_REALM }) public Response updateRealm(@PathParam("realmId") String realmId, EntityBody updatedRealm, @Context final UriInfo uriInfo) { if (updatedRealm == null) { throw new IllegalArgumentException("Updated Realm was null"); } EntityBody oldRealm = service.get(realmId); if (!canEditCurrentRealm(updatedRealm) || oldRealm.get(ED_ORG) != null && !oldRealm.get(ED_ORG).equals(SecurityUtil.getEdOrg())) { EntityBody body = new EntityBody(); body.put(RESPONSE, "You are not authorized to update this realm."); return Response.status(Status.FORBIDDEN).entity(body).build(); } Response validateUniqueness = validateUniqueId(realmId, (String) updatedRealm.get(UNIQUE_IDENTIFIER), (String) updatedRealm.get(NAME), getIdpId(updatedRealm)); if (validateUniqueness != null) { return validateUniqueness; } Map<String, Object> idp = (Map<String, Object>) updatedRealm.get(IDP); Response validateArtifactResolution = validateArtifactResolution((String) idp.get(ARTIFACT_RESOLUTION_ENDPOINT), (String) idp.get(SOURCE_ID)); if (validateArtifactResolution != null) { LOG.debug("Invalid artifact resolution information"); return validateArtifactResolution; } updatedRealm.put("tenantId", SecurityUtil.getTenantId()); updatedRealm.put(ED_ORG, SecurityUtil.getEdOrg()); if (service.update(realmId, updatedRealm, false)) { logSecurityEvent(uriInfo, oldRealm, updatedRealm); return Response.status(Status.NO_CONTENT).build(); } return Response.status(Status.BAD_REQUEST).build(); }
public ExtractingTypePatternMatcher createExtractingMatcher(Type typePattern, Type typeToExtract) { if ( typePattern instanceof TypeVariable ) { throw new UnsupportedOperationException( "Matching a type variable is not supported" ); } else if ( typePattern instanceof WildcardType ) { throw new UnsupportedOperationException( "Matching a wildcard type is not supported" ); } else if ( typePattern instanceof ParameterizedType ) { ParameterizedType parameterizedTypePattern = (ParameterizedType) typePattern; return createExtractingParameterizedTypeMatcher( parameterizedTypePattern, typeToExtract ); } else if ( typePattern instanceof Class ) { Class<?> classTypePattern = (Class<?>) typePattern; return createExtractingClassTypeMatcher( classTypePattern, typeToExtract ); } else if ( typePattern instanceof GenericArrayType ) { GenericArrayType arrayTypePattern = (GenericArrayType) typePattern; return createExtractingGenericArrayTypeMatcher( arrayTypePattern, typeToExtract ); } else { throw new AssertionFailure( "Unexpected java.lang.reflect.Type type: " + typePattern.getClass() ); } }
public ReactionGroupCorpus getReactionGroupCorpus() { Map<String, ReactionGroup> sequenceToReactionGroupMap = getSequenceToReactionGroupMap(seqIterator); LOGGER.info("Done getting seq group map, found %d distinct SeqGroups.", sequenceToReactionGroupMap.size()); return new ReactionGroupCorpus(sequenceToReactionGroupMap.values()); }
public static String setQueryParams(final String httpUrl, final Map<String, Object> queryParams) throws URISyntaxException { URIBuilder uriBuilder = new URIBuilder(httpUrl); Map<String, Object> nullSafeQueryParams = ofNullable(queryParams).orElseGet(HashMap::new); nullSafeQueryParams.keySet().forEach(key -> uriBuilder.addParameter(key, nullSafeQueryParams.get(key).toString()) ); String composedURL = uriBuilder.build().toString(); LOGGER.info("### Effective url is : {}", composedURL); return composedURL; }
public static Link[] getObjectDescription(LwM2mObjectEnabler objectEnabler, String root) { List<Link> links = new ArrayList<>(); String rootPath = root == null ? "" : root; Map<String, String> objectAttributes = getObjectAttributes(objectEnabler.getObjectModel()); String objectURL = getPath("/", rootPath, Integer.toString(objectEnabler.getId())); links.add(new Link(objectURL, objectAttributes)); for (Integer instanceId : objectEnabler.getAvailableInstanceIds()) { links.addAll(Arrays.asList(getInstanceDescription(objectEnabler, instanceId, rootPath))); } return links.toArray(new Link[] {}); }
@Override public List<SeriesData<Long>> getDataForRange(Range rangeUs) { long minNs = TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMin()); long maxNs = TimeUnit.MICROSECONDS.toNanos((long)rangeUs.getMax()); GetEventGroupsRequest request = GetEventGroupsRequest.newBuilder() .setStreamId(myStreamId) .setPid(myPid) .setKind(Common.Event.Kind.CPU_THREAD) .setFromTimestamp(minNs) .setToTimestamp(maxNs) .build(); GetEventGroupsResponse response = myClient.getEventGroups(request); TreeMap<Long, Long> timestampToCountMap = new TreeMap<>(); for (Transport.EventGroup group : response.getGroupsList()) { if (group.getEventsCount() > 0) { Common.Event first = group.getEvents(0); Common.Event last = group.getEvents(group.getEventsCount() - 1); timestampToCountMap.compute(first.getTimestamp(), (timestamp, count) -> count == null ? 1 : count + 1); if (last.getIsEnded()) { timestampToCountMap.compute(last.getTimestamp(), (timestamp, count) -> count == null ? -1 : count - 1); } } } List<SeriesData<Long>> data = new ArrayList<>(); long total = 0; for (Map.Entry<Long, Long> entry : timestampToCountMap.entrySet()) { total += entry.getValue(); data.add(new SeriesData<>(TimeUnit.NANOSECONDS.toMicros(entry.getKey()), total)); } if (timestampToCountMap.isEmpty()) { data.add(new SeriesData<>((long)rangeUs.getMin(), total)); data.add(new SeriesData<>((long)rangeUs.getMax(), total)); } else if (data.get(data.size() - 1).x < rangeUs.getMax()) { data.add(new SeriesData<>((long)rangeUs.getMax(), total)); } return data; }
public static Coordinate parse(String s) throws ParseException { try { double[] parsed = parseDoubleValues(s, ","); if (parsed.length < 2) { throw new ParseException(String.format( "No coordinates were recognized in the string \"%s\"", s), -1); } else { return new Coordinate(parsed[0], parsed[1]); } } catch (Exception e) { throw new ParseException(e.getMessage(), -1); } }
@Override public void setDefaultDataTableEntryTransformer( TableEntryByTypeTransformer defaultDataTableEntryByTypeTransformer ) { dataTableTypeRegistry.setDefaultDataTableEntryTransformer(defaultDataTableEntryByTypeTransformer); }
@Deprecated public static String testServiceEndpointUrl(final String serviceEndpoint) { return normalizeEndpoint(serviceEndpoint); }
protected void setHeaderColumns(AbstractScesimModel abstractScesimModel, ScenarioSimulationModel.Type type) { final List<FactMapping> factMappings = abstractScesimModel.getScesimModelDescriptor().getUnmodifiableFactMappings(); boolean editableHeaders = !(ScenarioSimulationModel.Type.DMN.equals(type) || (abstractScesimModel instanceof Background)); IntStream.range(0, factMappings.size()) .forEach(columnIndex -> setHeaderColumn(columnIndex, factMappings.get(columnIndex), editableHeaders)); }
public void registerChildrenForOA(FormSubmission submission) { Child child = allChildren.findByCaseId(submission.getField(ID)); child.withAnm(submission.anmId()).withThayiCard(submission.getField(THAYI_CARD_NUMBER)); List<String> immunizationsGiven = getNamesOfImmunizationsGiven(submission.getField(IMMUNIZATIONS_GIVEN_FIELD_NAME)); List<String> vitaminHistory = getVitaminDoses(submission.getField(CHILD_VITAMIN_A_HISTORY)); child.withImmunizations(getChildImmunizationDetails(submission, child, immunizationsGiven)); child.withVitaminADoses(getVitaminDoseDetails(submission, child, vitaminHistory)); allChildren.update(child); childSchedulesService.enrollChild(child); }
public static @Nonnull Builder builder() { return new Builder(); }
public static void main(String[] args) throws Exception { File file = new File(args[0]); try (BufferedReader buffer = new BufferedReader(new FileReader(file))) { List<List<Short>> triangle = new ArrayList<>(); String line; while ((line = buffer.readLine()) != null) { line = line.trim(); String[] stringRow = line.split(" "); List<Short> row = new ArrayList<>(); for (String element : stringRow) { row.add(Short.valueOf(element)); } triangle.add(row); } sumSoFar = new int[triangle.size() + 1][triangle.size() + 1]; int sum = findSum(triangle, triangle.size(), 0, 0); System.out.println(sum); } }
boolean isIsogram(String phrase) { throw new UnsupportedOperationException("Delete this statement and write your own implementation."); }
public void calculateOrderQuantity() { if (allNotNull(maxStockQuantity, stockInHand)) { calculatedOrderQuantity = ((maxStockQuantity - stockInHand) < 0) ? 0 : maxStockQuantity - stockInHand; } }
@Override @Nullable public Icon getIconForId(@Nonnull final IconID id) { return MAP.get(id); }
public static Builder<RuleSetBuilder, DecisionTreeRuleSet> creator(final List<String> driverNames) { return creator("", driverNames); }
public static List<Locale> parseAcceptLanguage(final String header) { if (header == null || header.isEmpty()) { return Collections.emptyList(); } final List<Locale> result = new ArrayList<>(); for (final String str : header.split(",")) { final String[] arr = str.trim().replace("-", "_").split(";"); final Locale locale; final String[] l = arr[0].split("_"); switch (l.length) { case 2: locale = new Locale(l[0], l[1]); break; case 3: locale = new Locale(l[0], l[1], l[2]); break; default: locale = new Locale(l[0]); break; } result.add(locale); } return result; }
public static void copyTo(IntNdArray dst, int[] array) { vectorOf(array).copyTo(dst); }
@VisibleForTesting static Datum createDatum(Value value) { return value.match( datumDoubleFunction, datumLongFunction, datumDistributionFunction, datumSummaryFunction, Functions.<Datum>throwIllegalArgumentException()); }
@GetMapping("/{inviteHash}/register") public String yourDetails(Model model, @PathVariable("inviteHash") String inviteHash, @ModelAttribute(name = FORM_ATTR_NAME, binding = false) AssessorRegistrationForm form) { return doViewYourDetails(model, inviteHash); }
protected static <T extends Annotation> T getAnnotationFor(Class<?> clazz, Class<T> annotationType) { if (annotationType.getAnnotation(Inherited.class) != null) { T annotation = clazz.getAnnotation(annotationType); if (annotation != null) { return annotation; } } else { Class<?> currentType = clazz; while (currentType != Object.class) { T annotation = currentType.getAnnotation(annotationType); if (annotation != null) { return annotation; } else { currentType = currentType.getSuperclass(); } } } for (Class<?> iface : clazz.getInterfaces()) { T annotation = iface.getAnnotation(annotationType); if (annotation != null) { return annotation; } } return null; }
@SuppressWarnings("unchecked") public static <Poly extends AMultivariatePolynomial<?, Poly>> PolynomialFactorDecomposition<Poly> Factor(final Poly poly) { if (poly.isOverFiniteField()) return (PolynomialFactorDecomposition<Poly>) FactorInGF((AMultivariatePolynomial) poly); else if (poly.isOverZ()) return FactorInZ((MultivariatePolynomial) poly); else if (Util.isOverRationals(poly)) return (PolynomialFactorDecomposition<Poly>) FactorInQ((MultivariatePolynomial) poly); else if (Util.isOverSimpleNumberField(poly)) return (PolynomialFactorDecomposition<Poly>) FactorInNumberField((MultivariatePolynomial) poly); else if (Util.isOverMultipleFieldExtension(poly)) return (PolynomialFactorDecomposition<Poly>) FactorInMultipleFieldExtension((MultivariatePolynomial) poly); else { PolynomialFactorDecomposition<Poly> factors = tryNested(poly, MultivariateFactorization::Factor); if (factors != null) return factors; throw new RuntimeException("Unsupported ring: " + poly.coefficientRingToString()); } }
@Override public ImmutableListPathCore getRoot() { if (isAbsolute()) { return new ImmutableListPathCore(root, ImmutableList.<String>of()); } else { return null; } }
@Override public void run() { List<String> describeType = describeActionConfig.describeType; if (describeType == null || describeType.isEmpty()) { throw new IllegalArgumentException("Must specify a single type to describe."); } if (describeActionConfig.name == null || !validName(describeActionConfig.name)) { throw new IllegalArgumentException(format("Invalid name, must match %s", VALID_NAME_PATTERN)); } String firstType = describeType.get(0).toLowerCase().trim(); String name = describeActionConfig.name; switch (firstType) { case "group": try { Group group = keywhizClient.getGroupByName(name); printing.printGroupWithDetails(group); } catch (NotFoundException e) { throw new AssertionError("Group not found."); } catch (IOException e) { throw Throwables.propagate(e); } break; case "client": try { Client client = keywhizClient.getClientByName(name); printing.printClientWithDetails(client); } catch (NotFoundException e) { throw new AssertionError("Client not found."); } catch (IOException e) { throw Throwables.propagate(e); } break; case "secret": SanitizedSecret sanitizedSecret; try { sanitizedSecret = keywhizClient.getSanitizedSecretByName(name); printing.printSanitizedSecretWithDetails(sanitizedSecret); } catch (NotFoundException e) { throw new AssertionError("Secret not found."); } catch (IOException e) { throw Throwables.propagate(e); } break; default: throw new IllegalArgumentException("Invalid describe type specified: " + firstType); } }
@Override public void shutdown() { try { this.memcachedClient.shutdown(); } catch (IOException e) { throw new MemcachedOperationException("Failed to shutdown client", e); } }
public static String h(Object input) { return HtmlEscapeUtils.htmlEscape(input); }
static TimelineFilterList parseEventFilters(String expr) throws TimelineParseException { return parseFilters(new TimelineParserForExistFilters(expr, TimelineParseConstants.COMMA_CHAR)); }
public ContactCursor apply() { return contactDb.queryAll(); }
@Override public Tag find(Iterable<Tag> tags) { for (Tag tag : tags) { if (tag.key().equals(tagKey)) { return tag; } } return null; }
@Override public boolean remove(Object o) { if (o instanceof JexlNode) { String nodeKey = buildKey((JexlNode) o); return nodeMap.remove(nodeKey, nodeMap.get(nodeKey)); } else if (o instanceof String) { JexlNode node = nodeMap.get(o); return nodeMap.remove(o, node); } return false; }
public DBObject build() { DBObject container; if (useAggregationPipeline()) { container = new BasicDBObject(); container.put("$match", filterQuery); } else { container = filterQuery; } return container; }
@Override public synchronized void clear() { registeredPoints = Collections.<List<LabelValue>, PointWithFunction<?>>emptyMap(); }
public static EtdOptionType parseEtdOptionType(String str) { switch (str.toUpperCase(Locale.ENGLISH)) { case "AMERICAN": case "A": return EtdOptionType.AMERICAN; case "EUROPEAN": case "E": return EtdOptionType.EUROPEAN; default: throw new IllegalArgumentException( "Unknown EtdOptionType value, must be 'American' or 'European' but was '" + str + "'; " + "parser is case insensitive and also accepts 'A' and 'E'"); } }
public void setGeckcoDriverPath(String path) { setProperty("GeckoDriverPath", path); }
@Override public void onDataReceived(@NonNull final BluetoothDevice device, @NonNull final Data data) { super.onDataReceived(device, data); if (data.size() < 2) { onInvalidDataReceived(device, data); return; } final int opCode = data.getIntValue(Data.FORMAT_UINT8, 0); int expectedOperandSize; switch (opCode) { case OP_CODE_COMMUNICATION_INTERVAL_RESPONSE: expectedOperandSize = 1; break; case OP_CODE_CALIBRATION_VALUE_RESPONSE: expectedOperandSize = 10; break; case OP_CODE_PATIENT_HIGH_ALERT_LEVEL_RESPONSE: case OP_CODE_PATIENT_LOW_ALERT_LEVEL_RESPONSE: case OP_CODE_HYPO_ALERT_LEVEL_RESPONSE: case OP_CODE_HYPER_ALERT_LEVEL_RESPONSE: case OP_CODE_RATE_OF_DECREASE_ALERT_LEVEL_RESPONSE: case OP_CODE_RATE_OF_INCREASE_ALERT_LEVEL_RESPONSE: expectedOperandSize = 2; break; case OP_CODE_RESPONSE_CODE: expectedOperandSize = 2; break; default: onInvalidDataReceived(device, data); return; } if (data.size() != 1 + expectedOperandSize && data.size() != 1 + expectedOperandSize + 2) { onInvalidDataReceived(device, data); return; } final boolean crcPresent = data.size() == 1 + expectedOperandSize + 2; if (crcPresent) { final int expectedCrc = data.getIntValue(Data.FORMAT_UINT16, 1 + expectedOperandSize); final int actualCrc = CRC16.MCRF4XX(data.getValue(), 0, 1 + expectedOperandSize); if (expectedCrc != actualCrc) { onCGMSpecificOpsResponseReceivedWithCrcError(device, data); return; } } switch (opCode) { case OP_CODE_COMMUNICATION_INTERVAL_RESPONSE: final int interval = data.getIntValue(Data.FORMAT_UINT8, 1); onContinuousGlucoseCommunicationIntervalReceived(device, interval, crcPresent); return; case OP_CODE_CALIBRATION_VALUE_RESPONSE: final float glucoseConcentrationOfCalibration = data.getFloatValue(Data.FORMAT_SFLOAT, 1); final int calibrationTime = data.getIntValue(Data.FORMAT_UINT16, 3); final int calibrationTypeAndSampleLocation = data.getIntValue(Data.FORMAT_UINT8, 5); @SuppressLint("WrongConstant") final int calibrationType = calibrationTypeAndSampleLocation & 0x0F; final int calibrationSampleLocation = calibrationTypeAndSampleLocation >> 4; final int nextCalibrationTime = data.getIntValue(Data.FORMAT_UINT16, 6); final int calibrationDataRecordNumber = data.getIntValue(Data.FORMAT_UINT16, 8); final int calibrationStatus = data.getIntValue(Data.FORMAT_UINT8, 10); onContinuousGlucoseCalibrationValueReceived(device, glucoseConcentrationOfCalibration, calibrationTime, nextCalibrationTime, calibrationType, calibrationSampleLocation, calibrationDataRecordNumber, new CGMCalibrationStatus(calibrationStatus), crcPresent); return; case OP_CODE_RESPONSE_CODE: final int requestCode = data.getIntValue(Data.FORMAT_UINT8, 1); final int responseCode = data.getIntValue(Data.FORMAT_UINT8, 2); if (responseCode == CGM_RESPONSE_SUCCESS) { onCGMSpecificOpsOperationCompleted(device, requestCode, crcPresent); } else { onCGMSpecificOpsOperationError(device, requestCode, responseCode, crcPresent); } return; } final float value = data.getFloatValue(Data.FORMAT_SFLOAT, 1); switch (opCode) { case OP_CODE_PATIENT_HIGH_ALERT_LEVEL_RESPONSE: onContinuousGlucosePatientHighAlertReceived(device, value, crcPresent); return; case OP_CODE_PATIENT_LOW_ALERT_LEVEL_RESPONSE: onContinuousGlucosePatientLowAlertReceived(device, value, crcPresent); return; case OP_CODE_HYPO_ALERT_LEVEL_RESPONSE: onContinuousGlucoseHypoAlertReceived(device, value, crcPresent); return; case OP_CODE_HYPER_ALERT_LEVEL_RESPONSE: onContinuousGlucoseHyperAlertReceived(device, value, crcPresent); return; case OP_CODE_RATE_OF_DECREASE_ALERT_LEVEL_RESPONSE: onContinuousGlucoseRateOfDecreaseAlertReceived(device, value, crcPresent); return; case OP_CODE_RATE_OF_INCREASE_ALERT_LEVEL_RESPONSE: onContinuousGlucoseRateOfIncreaseAlertReceived(device, value, crcPresent); return; } }
@Override public String getHeader(CharSequence name) { return rawRequest.getHeaders().headers().get(name); }
String cleanLinkId(String url, String linkId, boolean image) { String ret = linkId.replace('\n', ' '); ret = LINK_MULTIPLE_SPACES.matcher(ret).replaceAll(" "); ret = LINK_SAFE_CHARS.matcher(ret).replaceAll(LINK_REPLACEMENT); ret = LINK_MULTIPLE_REPLACE.matcher(ret).replaceAll(LINK_REPLACEMENT); ret = LINK_EDGE_REPLACE.matcher(ret).replaceAll(""); ret = ret.trim(); if(ret.length() == 0 || ret.equals(LINK_REPLACEMENT)) { if(image) { if(url != null) { Matcher m = LINK_FILENAME.matcher(url); if(m.find()) { ret = cleanLinkId(null, m.group(1), true); } else { genericImageUrlCounter++; ret = "Image " + genericImageUrlCounter; } } else { genericImageUrlCounter++; ret = "Image " + genericImageUrlCounter; } } else { genericLinkUrlCounter++; ret = "Link " + genericLinkUrlCounter; } } return ret; }
@Override public String toString() { ToStringHelper helper = MoreObjects.toStringHelper("byte[]"); if (bytes != null) { helper.add("length", bytes.length) .add("hash", Arrays.hashCode(bytes)); } else { helper.addValue(bytes); } return helper.toString(); }
public static PersistBlockTask create( final ProtocolSchedule protocolSchedule, final ProtocolContext protocolContext, final EthContext ethContext, final Block block, final HeaderValidationMode headerValidationMode, final MetricsSystem metricsSystem) { return new PersistBlockTask( protocolSchedule, protocolContext, ethContext, block, headerValidationMode, metricsSystem); }
public static void appendConfigItemsIntoExistingOnes(List<ConfigDocItem> existingConfigItems, List<ConfigDocItem> configDocItems) { for (ConfigDocItem configDocItem : configDocItems) { if (configDocItem.isConfigKey()) { existingConfigItems.add(configDocItem); } else { ConfigDocSection configDocSection = configDocItem.getConfigDocSection(); boolean configSectionMerged = mergeSectionIntoPreviousExistingConfigItems(configDocSection, existingConfigItems); if (!configSectionMerged) { existingConfigItems.add(configDocItem); } } } }
@Override public List<PathsDiffValidator> create() { List<PathsDiffValidator> validators = new ArrayList<>(); validators.add(new PathsPathItemsDiffValidator(pathItemDiffValidatorFactory.create())); return Collections.unmodifiableList(validators); }
@Override public void removeSave(String id) { saver.delete(id); }
public void exportAccessionRegisters(String processId) throws ProcessingStatusException { try (BatchReportClient batchReportClient = batchReportClientFactory.getClient()) { batchReportClient.generatePurgeAccessionRegisterReport( processId, new ReportExportRequest(ACCESSION_REGISTER_REPORT_JSONL)); } catch (VitamClientInternalException e) { throw new ProcessingStatusException(StatusCode.FATAL, "Could not generate purge accession register reports (" + processId + ")", e); } }
public void setLink(String link) { this.link = link; }
@Override public Stream<LogEvent> stream() { return Collections.<LogEvent>emptyList().stream(); }
public static Suite merge(Suite current, Suite lastVersion) { return merge(current, lastVersion, lastVersion); }
public static <T> T instantiate(Class<T> clazz) { try { return clazz .getConstructor() .newInstance(); } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) { throw new IllegalArgumentException( String.format("Cannot instantiate %s", clazz.getName()), e); } }
public Result verify() throws IOException, ApkFormatException, NoSuchAlgorithmException, IllegalStateException { Closeable in = null; try { DataSource apk; if (mApkDataSource != null) { apk = mApkDataSource; } else if (mApkFile != null) { RandomAccessFile f = new RandomAccessFile(mApkFile, "r"); in = f; apk = DataSources.asDataSource(f, 0, f.length()); } else { throw new IllegalStateException("APK not provided"); } return verify(apk); } finally { if (in != null) { in.close(); } } }
public boolean addJobExecutionEvent(final JobExecutionEvent jobExecutionEvent) { if (null == jobExecutionEvent.getCompleteTime()) { return insertJobExecutionEvent(jobExecutionEvent); } else { if (jobExecutionEvent.isSuccess()) { return updateJobExecutionEventWhenSuccess(jobExecutionEvent); } else { return updateJobExecutionEventFailure(jobExecutionEvent); } } }
@Pure @Override public int getAttributeAsInt(String name) throws AttributeException { final AttributeValue value = getAttribute(name); if (value == null) { throw new NoAttributeFoundException(name); } return (int) value.getInteger(); }
public List<Token> tokenize(File file) throws IOException { return getAllTokens(lexerInstance(CharStreams.fromPath(file.toPath()))); }
public boolean isString() { return value instanceof String; }
public String convert(String line) { return StringEscapeUtils.escapeXml(line); }
@Override public void onLosing(Network network, int maxMsToLive) { notifyMerlinService(network); }
public static short bytesToShort(byte[] bytes, int offset, int length, ByteOrder bo) { return bytesToShorts(bytes, offset, length, bo)[0]; }
@Override public IndexSample sampleIndex() { return indexSamplers.parallelStream() .map( this::sampleIndex ) .reduce( this::combine ) .get(); }
public static boolean methodAnnotatedWithRxLogSingle(ProceedingJoinPoint joinPoint) { return ((MethodSignature) joinPoint.getSignature()).getReturnType() == Single.class; }
@Override public boolean handle(final OrderEvent orderEvent) throws OrderException { synchronized (OrderEventHandler.syncMonitor) { for (CustomerOrderDelivery customerOrderDelivery : orderEvent.getCustomerOrder().getDelivery()) { reserveQuantity(customerOrderDelivery); } handleInternal(orderEvent); final CustomerOrder order = orderEvent.getCustomerOrder(); final Shop pgShop = order.getShop().getMaster() != null ? order.getShop().getMaster() : order.getShop(); final PaymentProcessor paymentProcessor = paymentProcessorFactory.create(order.getPgLabel(), pgShop.getCode()); if (!paymentProcessor.isPaymentGatewayEnabled()) { throw new PGDisabledException("PG " + order.getPgLabel() + " is disabled in " + order.getShop().getCode(), order.getPgLabel()); } if (paymentProcessor.getPaymentGateway().getPaymentGatewayFeatures().isOnlineGateway()) { final String result = paymentProcessor.authorize(orderEvent.getCustomerOrder(), false, isForceProcessing(orderEvent), orderEvent.getParams()); if (Payment.PAYMENT_STATUS_OK.equals(result)) { getOrderStateManager().fireTransition(new OrderEventImpl(orderEvent, OrderStateManager.EVT_PAYMENT_OK, orderEvent.getCustomerOrder())); } else if (Payment.PAYMENT_STATUS_PROCESSING.equals(result)) { getOrderStateManager().fireTransition(new OrderEventImpl(orderEvent, OrderStateManager.EVT_PAYMENT_PROCESSING, orderEvent.getCustomerOrder())); } else { getOrderStateManager().fireTransition(new OrderEventImpl(orderEvent, OrderStateManager.EVT_CANCEL, orderEvent.getCustomerOrder())); } } else if (paymentProcessor.getPaymentGateway().getPaymentGatewayFeatures().isAutoCapture()) { getOrderStateManager().fireTransition(new OrderEventImpl(orderEvent, OrderStateManager.EVT_PAYMENT_CONFIRMED, orderEvent.getCustomerOrder())); } else { getOrderStateManager().fireTransition(new OrderEventImpl(orderEvent, OrderStateManager.EVT_PAYMENT_OFFLINE, orderEvent.getCustomerOrder())); } return true; } }
@Nonnull public static Ebms3ReaderBuilder <Ebms3Messaging> ebms3Messaging () { return new Ebms3ReaderBuilder <> (EEbms3DocumentType.MESSAGING, Ebms3Messaging.class); }
@Override public PageProvider getProvider() { return m_provider; }
@Override public <R, Q> CompletableFuture<R> query(String queryName, Q query, ResponseType<R> responseType) { CompletableFuture<QueryResponseMessage<R>> queryResponse = queryBus .query(processInterceptors(new GenericQueryMessage<>(asMessage(query), queryName, responseType))); CompletableFuture<R> result = new CompletableFuture<>(); queryResponse.exceptionally(cause -> asResponseMessage(responseType.responseMessagePayloadType(), cause)) .thenAccept(queryResponseMessage -> { try { if (queryResponseMessage.isExceptional()) { result.completeExceptionally(queryResponseMessage.exceptionResult()); } else { result.complete(queryResponseMessage.getPayload()); } } catch (Exception e) { result.completeExceptionally(e); } }); return result; }
public static <E> SearchTerm<E>[] parse(String text) { return parse(text, Collections.<SearchEngineTextMatcherEditor.Field<E>>emptySet()); }
public static NetworkInBytes parseArpa(String name) { LOGGER.debug("parseArpa:{}", name); if (StringUtils.isEmpty(name)) { return null; } else if (StringUtils.endsWith(name, DomainUtil.IPV4_ARPA_SUFFIX)) { return parseIpV4Arpa(name); } else if (StringUtils.endsWith(name, DomainUtil.IPV6_ARPA_SUFFIX)) { return parseIpV6Arpa(name); } return null; }
public static boolean hasAttemptId(String bucketFilename) { Matcher matcher = BUCKET_WITH_OPTIONAL_ATTEMPT_ID_PATTERN.matcher(bucketFilename); return matcher.matches() && matcher.group(2) != null; }
public static void main(String[] args) { try (Scanner in = new Scanner(System.in)) { Integer persons = in.nextInt(); Integer topics = in.nextInt(); in.nextLine(); Boolean[][] personCapabilities = new Boolean[persons][topics]; for (Integer i = 0; i < persons; ++i) { String person = in.nextLine(); for (Integer j = 0; j < person.length(); ++j) { personCapabilities[i][j] = person.substring(j, j + 1).equals("1"); } } Integer groupsThatCoverMax = 0; Integer maxTopicCount = 0; for (Integer i = 0; i < persons - 1; ++i) { for (Integer j = i + 1; j < persons; ++j) { Integer currentTopicCount = 0; for (Integer k = 0; k < topics; ++k) { if (personCapabilities[i][k] || personCapabilities[j][k]) { ++currentTopicCount; } } if (currentTopicCount > maxTopicCount) { groupsThatCoverMax = 1; maxTopicCount = currentTopicCount; } else if (currentTopicCount.equals(maxTopicCount)) { groupsThatCoverMax++; } } } System.out.println(maxTopicCount); System.out.println(groupsThatCoverMax); } }
@Override public void getStreamingExportRecords( final ExportRecordsOptions opts, @Nonnull final IStreamingCallback callback, final int key) throws P4JavaException { Validate.notNull(callback); Map<String, Object> inMap = new HashMap<>(); if (nonNull(opts)) { inMap = opts.processFieldRules(); } server.execStreamingMapCommand( EXPORT.toString(), processParameters(opts, server), inMap, callback, key); }
static MethodDeclaration getDiscretizeExpressionMethodDeclaration(final String methodName, final Discretize discretize, final ClassOrInterfaceType returnedType, final LinkedHashMap<String, ClassOrInterfaceType> parameterNameTypeMap) { throw new KiePMMLException("Discretize not managed, yet"); }
@VisibleForTesting boolean shouldShowCftDisclaimer(final SummaryModel props) { return PaymentTypes.isCreditCardPaymentType(props.getPaymentTypeId()) && !TextUtil.isEmpty(props.getCftPercent()); }
public static Runnable catalogs(final UserSession session, final DrillbitContext dContext, final GetCatalogsReq req, final ResponseSender responseSender) { return new CatalogsProvider(session, dContext, req, responseSender); }
@Override public void fill(byte val) { myList.fill(val); }
public static CFG buildCFG(List<? extends Tree> trees, boolean ignoreBreak) { return new CFG(trees, null, ignoreBreak); }
public ComplianceStatus getStatus(Consumer c) { return getStatus(c, null, false); }
public static TaskContext from(final String id) { String[] result = id.split(DELIMITER); Preconditions.checkState(5 == result.length); return new TaskContext(id, MetaInfo.from(result[0] + DELIMITER + result[1]), ExecutionType.valueOf(result[2]), result[3]); }
public RunInstancesOptions withBlockDeviceMappings(Set<? extends BlockDeviceMapping> mappings) { int i = 1; for (BlockDeviceMapping mapping : checkNotNull(mappings, "mappings")) { checkNotNull(mapping.getDeviceName(), "deviceName"); formParameters.put(String.format("BlockDeviceMapping.%d.DeviceName", i), mapping.getDeviceName()); if (mapping.getVirtualName() != null) formParameters.put(String.format("BlockDeviceMapping.%d.VirtualName", i), mapping.getVirtualName()); if (mapping.getEbsSnapshotId() != null) formParameters.put(String.format("BlockDeviceMapping.%d.Ebs.SnapshotId", i), mapping.getEbsSnapshotId()); if (mapping.getEbsVolumeSize() != null) formParameters.put(String.format("BlockDeviceMapping.%d.Ebs.VolumeSize", i), String.valueOf(mapping.getEbsVolumeSize())); if (mapping.getEbsNoDevice() != null) formParameters.put(String.format("BlockDeviceMapping.%d.Ebs.NoDevice", i), String.valueOf(mapping.getEbsNoDevice())); if (mapping.getEbsDeleteOnTermination() != null) formParameters.put(String.format("BlockDeviceMapping.%d.Ebs.DeleteOnTermination", i), String.valueOf(mapping.getEbsDeleteOnTermination())); if (mapping.getEbsVolumeType() != null) formParameters.put(String.format("BlockDeviceMapping.%d.Ebs.VolumeType", i), mapping.getEbsVolumeType()); if (mapping.getEbsIops() != null) formParameters.put(String.format("BlockDeviceMapping.%d.Ebs.Iops", i), String.valueOf(mapping.getEbsIops())); if (mapping.getEbsEncrypted() != null && mapping.getEbsEncrypted()) formParameters.put(String.format("BlockDeviceMapping.%d.Ebs.Encrypted", i), String.valueOf(mapping.getEbsEncrypted())); i++; } return this; }
public B proxy(String proxy) { this.proxy = proxy; return getThis(); }
@SuppressWarnings("unchecked") public B addHeader(String key, String value) { assertFinishState(); httpContent.addHeader(key, value); return (B) this; }
@Override public Logger getUnderlyingLogger() { return underlyingLogger; }
static int computeRawVarint32Size(final int value) { if ((value & (0xffffffff << 7)) == 0) { return 1; } if ((value & (0xffffffff << 14)) == 0) { return 2; } if ((value & (0xffffffff << 21)) == 0) { return 3; } if ((value & (0xffffffff << 28)) == 0) { return 4; } return 5; }
public boolean hasVariable(String name) { String regex = "\\?" + name + "\\b"; return Pattern.compile(regex).matcher(queryString).find(); }
@Override public WorkflowOperationResult start(WorkflowInstance workflowInstance, JobContext context) throws WorkflowOperationException { final WorkflowOperationInstance operation = workflowInstance.getCurrentOperation(); final String configuredMediaPackageID = trimToEmpty(operation.getConfiguration(MEDIA_PACKAGE_ID)); final String configuredWorkflowDefinition = trimToEmpty(operation.getConfiguration(WORKFLOW_DEFINITION)); Opt<MediaPackage> mpOpt = assetManager.getMediaPackage(configuredMediaPackageID); if (mpOpt.isNone()) { throw new WorkflowOperationException(format("Media package %s not found", configuredMediaPackageID)); } final MediaPackage mp = mpOpt.get(); final Map<String, String> properties = new HashMap<>(); for (String key : operation.getConfigurationKeys()) { if (MEDIA_PACKAGE_ID.equals(key) || WORKFLOW_DEFINITION.equals(key)) { continue; } properties.put(key, operation.getConfiguration(key)); } try { final WorkflowDefinition workflowDefinition = workflowService.getWorkflowDefinitionById( configuredWorkflowDefinition); logger.info("Starting '{}' workflow for media package '{}'", configuredWorkflowDefinition, configuredMediaPackageID); workflowService.start(workflowDefinition, mp, properties); } catch (NotFoundException e) { throw new WorkflowOperationException(format("Workflow Definition '%s' not found", configuredWorkflowDefinition)); } catch (Exception e) { throw new WorkflowOperationException(e); } return createResult(WorkflowOperationResult.Action.CONTINUE); }
public static MpcScore of(float score) { return new MpcScore(score, score * 0.2f); }
@Override public List<String> getSeqNames() { return new ArrayList<String>(sequences.keySet()); }
protected Field[] getFields() { return fields; }
@Override protected void runOneIteration() { if (this.evaluator == null) { stopAsync(); return; } switch (this.jobProgress.getState()) { case PENDING: return; case RUNNING: try { List<Object> objects = Stream.concat(Stream.<Object>of(this.jobProgress), this.jobProgress.getTaskProgress().stream()).collect( Collectors.toList()); if (this.evaluator.evaluate(objects)) { log.info("Interrupting job due to satisfied job interruption predicate. Predicate: " + this.sql); this.jobInterruptionHook.run(); stopAsync(); } } catch (Throwable exc) { log.warn("Failed to evaluate job interruption predicate. Will not preemptively interrupt job.", exc); throw Throwables.propagate(exc); } break; default: log.info(String.format("Detected job finished with state %s. Stopping job interruption predicate.", this.jobProgress.getState())); stopAsync(); } }
@Override public void check(String content) throws IntegrityCheckException { if (content.contains(REPLACEMENT_CHARACTER)) { throw new EncodingIntegrityCheckerException("Input does not have a valid encoding (it should be UTF-8)"); } }
public void parse(byte[] data) throws ParseException { Text text = new Text(); text.strain(data, 0, data.length); init(text); }
public void migrate() { CassandraMigration cm = new CassandraMigration(); cm.getConfigs().setScriptsLocations(scriptsLocations); cm.setKeyspace(keyspace); cm.migrate(); }
public static String collapseText(Throwable t) { return collapseText(t, false); }
public void onRefreshFormPropertiesEvent(final @Observes RefreshFormPropertiesEvent event) { searchBarComponent.disableSearch(); }
public byte[][] readTextRecord() throws IOException { if (isLastLine) { return null; } currentLine = readLine(); isLastLine = startPos + readBytes > blockInfo.getStartPos() + blockInfo.getLength(); return splitLine(currentLine); }
public static String[] split(String escapedString, String delimiter) throws IllegalArgumentException { return split(escapedString, delimiter, 0); }
public static void requireNonNulls(Object o0) { if (o0 == null) { throw new NullPointerException(FIRST_ARG_IS_NULL); } }
@Override public void update(Object args, Observable observable) { EventType type = (EventType) args; if(!(observable instanceof ClusterDeleteEvent) || type != EventType.DELETE) { logger.info("[update] observable object not ShardDeleteEvent, skip. observable: {}, args: {}", observable.getClass().getName(), args.getClass().getName()); return; } ClusterDeleteEvent clusterDeleteEvent = (ClusterDeleteEvent) observable; for(ShardEvent shardEvent : clusterDeleteEvent.getShardEvents()) { shardEvent.onEvent(); } }
public void init(ByteBuffer instructions_and_sizes) { instructionsAndSizes = instructions_and_sizes; lastInstructionStart = -1; pendingSecondInstruction = NO_OPCODE; lastPendingSecondInstruction = NO_OPCODE; }
private boolean parseBoolean(String key, String value) throws ConfigException { if (value.equalsIgnoreCase("true")) { return true; } else if (value.equalsIgnoreCase("false")) { return false; } else { throw new ConfigException("Invalid option " + value + " for " + key + ". Choose 'true' or 'false.'"); } }
@Override public AuthorisationProcessorResponse doScaPsuIdentified(AuthorisationProcessorRequest authorisationProcessorRequest) { UpdateAuthorisationRequest request = authorisationProcessorRequest.getUpdateAuthorisationRequest(); return request.isUpdatePsuIdentification() ? applyIdentification(authorisationProcessorRequest) : applyAuthorisation(authorisationProcessorRequest); }
public ResponseObject<Xs2aCardAccountDetailsHolder> getCardAccountDetails(String consentId, String accountId, String requestUri) { xs2aEventService.recordAisTppRequest(consentId, EventType.READ_CARD_ACCOUNT_DETAILS_REQUEST_RECEIVED); Optional<AisConsent> aisConsentOptional = aisConsentService.getAccountConsentById(consentId); if (aisConsentOptional.isEmpty()) { log.info("Account-ID [{}], Consent-ID [{}]. Get card account details failed. Account consent not found by ID", accountId, consentId); return ResponseObject.<Xs2aCardAccountDetailsHolder>builder() .fail(AIS_400, TppMessageInformation.of(CONSENT_UNKNOWN_400)) .build(); } AisConsent aisConsent = aisConsentOptional.get(); ValidationResult validationResult = getCardAccountDetailsValidator.validate(new GetCardAccountDetailsRequestObject(aisConsent, accountId, requestUri)); if (validationResult.isNotValid()) { log.info("Account-ID [{}], Consent-ID [{}], RequestUri [{}]. Get card account details - validation failed: {}", accountId, consentId, requestUri, validationResult.getMessageError()); return ResponseObject.<Xs2aCardAccountDetailsHolder>builder() .fail(validationResult.getMessageError()) .build(); } SpiResponse<SpiCardAccountDetails> spiResponse = getAccountDetailsSpiResponse(aisConsent, consentId, accountId); if (spiResponse.hasError()) { ErrorHolder errorHolder = spiErrorMapper.mapToErrorHolder(spiResponse, ServiceType.AIS); log.info("Account-ID [{}], Consent-ID: [{}]. Get card account details failed: couldn't get account details. Error msg: [{}]", accountId, consentId, errorHolder); return ResponseObject.<Xs2aCardAccountDetailsHolder>builder() .fail(errorHolder) .build(); } loggingContextService.storeConsentStatus(aisConsent.getConsentStatus()); return getXs2aAccountDetailsHolderResponseObject(consentId, requestUri, aisConsent, spiResponse.getPayload()); }
protected String internalResolveCodeWithoutArguments( String code, Locale locale) { String msg = getMessages(locale).getProperty(code); if (msg != null) { return msg; } List<Locale> locales = getAlternativeLocales(locale); for (int i = 0; i < locales.size(); i++) { msg = getMessages(locales.get(i)).getProperty(code); if (msg != null) { return msg; } } return null; }
@SuppressWarnings({"FutureReturnValueIgnored", "MissingOverride"}) public SafeFuture<T> exceptionallyCompose( final Function<Throwable, ? extends CompletionStage<T>> errorHandler) { final SafeFuture<T> result = new SafeFuture<>(); whenComplete( (value, error) -> { try { final CompletionStage<T> nextStep = error != null ? errorHandler.apply(error) : completedFuture(value); propagateResult(nextStep, result); } catch (final Throwable t) { result.completeExceptionally(t); } }); return result; }
@Override public boolean matches(Path path) { Path fileName = path.getFileName(); if (fileName != null) { return extensions.contains(Files.getFileExtension(fileName.toString())); } return false; }
public int size() { return registryMap.size(); }
@Override public <OutType> OutType accumulate(OutType initValue, Accumulator<OutType, T> accumulator) { final OutType retVal; Yielder<OutType> yielder = toYielder(initValue, YieldingAccumulators.fromAccumulator(accumulator)); try { while (!yielder.isDone()) { yielder = yielder.next(yielder.get()); } retVal = yielder.get(); } catch (Throwable t1) { try { yielder.close(); } catch (Throwable t2) { t1.addSuppressed(t2); } throw t1; } try { yielder.close(); } catch (IOException e) { throw new RuntimeException(e); } return retVal; }
public void delete(final EnhancedDependency enhancedDependency) { enhancedDependencies.remove(enhancedDependency); originalSetOfDependencies.remove(enhancedDependency.getDependency()); update(); }
@Override public long decr(final String key, final int by) throws TimeoutException, CacheException { try { return memcachedClient.decr(key, by); } catch (OperationTimeoutException e) { LOGGER.warn("Operation timeout while decr {}", key, e); throw new TimeoutException(e.getMessage()); } catch (RuntimeException e) { if (translateException(e)) { throw new CacheException(e); } throw e; } }
public List<Integer> match(String toMatch) { toMatch = toMatch.toLowerCase(); ArrayList<Integer> result= new ArrayList<>(); if (toMatch.length() == 0) return result; int found = 0; while ((found = content.indexOf(toMatch, found)) != -1 ) { int actualPos = convertIndexToPos(found); result.add(actualPos); found++; } return result; }
public ResultSet invoke(Connection conn, Statement statement) throws SQLException { switch (type) { case SQL: boolean ret = Objects.requireNonNull(statement).execute(sql); ResultSet results = statement.getResultSet(); assert ret || null == results; return results; case METADATA: DatabaseMetaData metadata = Objects.requireNonNull(conn).getMetaData(); switch (metaDataOperation) { case GET_ATTRIBUTES: verifyOpArgs(4); return metadata.getAttributes((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String) operationArgs[3]); case GET_BEST_ROW_IDENTIFIER: verifyOpArgs(5); return metadata.getBestRowIdentifier((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (int) operationArgs[3], (boolean) operationArgs[4]); case GET_CATALOGS: verifyOpArgs(0); return metadata.getCatalogs(); case GET_COLUMNS: verifyOpArgs(4); return metadata.getColumns((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String) operationArgs[3]); case GET_COLUMN_PRIVILEGES: verifyOpArgs(4); return metadata.getColumnPrivileges((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String) operationArgs[3]); case GET_CROSS_REFERENCE: verifyOpArgs(6); return metadata.getCrossReference((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String) operationArgs[3], (String) operationArgs[4], (String) operationArgs[5]); case GET_EXPORTED_KEYS: verifyOpArgs(3); return metadata.getExportedKeys((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_FUNCTIONS: verifyOpArgs(3); return metadata.getFunctions((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_FUNCTION_COLUMNS: verifyOpArgs(4); return metadata.getFunctionColumns((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String) operationArgs[3]); case GET_IMPORTED_KEYS: verifyOpArgs(3); return metadata.getImportedKeys((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_INDEX_INFO: verifyOpArgs(5); return metadata.getIndexInfo((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (boolean) operationArgs[3], (boolean) operationArgs[4]); case GET_PRIMARY_KEYS: verifyOpArgs(3); return metadata.getPrimaryKeys((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_PROCEDURES: verifyOpArgs(3); return metadata.getProcedures((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_PROCEDURE_COLUMNS: verifyOpArgs(4); return metadata.getProcedureColumns((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String) operationArgs[3]); case GET_PSEUDO_COLUMNS: verifyOpArgs(4); return metadata.getPseudoColumns((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String) operationArgs[3]); case GET_SCHEMAS: verifyOpArgs(0); return metadata.getSchemas(); case GET_SCHEMAS_WITH_ARGS: verifyOpArgs(2); return metadata.getSchemas((String) operationArgs[0], (String) operationArgs[1]); case GET_SUPER_TABLES: verifyOpArgs(3); return metadata.getSuperTables((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_SUPER_TYPES: verifyOpArgs(3); return metadata.getSuperTypes((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_TABLES: verifyOpArgs(4); return metadata.getTables((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (String[]) operationArgs[3]); case GET_TABLE_PRIVILEGES: verifyOpArgs(3); return metadata.getTablePrivileges((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); case GET_TABLE_TYPES: verifyOpArgs(0); return metadata.getTableTypes(); case GET_TYPE_INFO: verifyOpArgs(0); return metadata.getTypeInfo(); case GET_UDTS: verifyOpArgs(4); return metadata.getUDTs((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2], (int[]) operationArgs[3]); case GET_VERSION_COLUMNS: verifyOpArgs(3); return metadata.getVersionColumns((String) operationArgs[0], (String) operationArgs[1], (String) operationArgs[2]); default: throw new IllegalArgumentException("Unhandled Metadata operation: " + metaDataOperation); } default: throw new IllegalArgumentException("Unable to process QueryState of type " + type); } }
@Override public TrackingToken createTokenAt(Instant dateTime) { TrackingToken tokenFromActiveStorage = activeStorage.createTokenAt(dateTime); if (tokenFromActiveStorage == null) { return historicStorage.createTokenAt(dateTime); } return tokenFromActiveStorage; }
public static boolean areEqual(Date current, Date date) { if ((date == null) && (current == null)) { return true; } if (date != null) { return date.equals(current); } return false; }
public K getKey(int index) { return this.orderKeys.get(index); }
@Override public Stream<AxisPointDTO> getPoints(long projectId) { return Arrays.stream(CoverageLevel.values()) .map(coverageLevel -> new AxisPointDTO(coverageLevel.name(), coverageLevel.getLabel(), coverageLevel.getTooltip())); }
public static Object toObject(String json) throws JsonException { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.serializeNulls(); gsonBuilder.registerTypeAdapter(Object.class, new NaturalGsonDeserializer()); Gson gson = gsonBuilder.create(); return gson.fromJson(json, Object.class); }
@Override public final boolean accepts(final SlingHttpServletRequest request) { if (request == null) { return false; } final String suffix = request.getRequestPathInfo().getSuffix(); if (StringUtils.isBlank(suffix)) { return false; } final String transformName = PathInfoUtil.getFirstSuffixSegment(request); if (!this.namedImageTransformers.keySet().contains(transformName)) { return false; } final String lastSuffix = PathInfoUtil.getLastSuffixSegment(request); final Matcher matcher = lastSuffixPattern.matcher(lastSuffix); if (!matcher.matches()) { return false; } return true; }
@Override public boolean shouldIntercept(MessageContext messageContext, Object endpoint) { return true; }
@Override public void registerLedgerMetadataListener(long ledgerId, LedgerMetadataListener listener) { if (null != listener) { if (LOG.isDebugEnabled()) { LOG.debug("Registered ledger metadata listener {} on ledger {}.", listener, ledgerId); } Set<LedgerMetadataListener> listenerSet = listeners.get(ledgerId); if (listenerSet == null) { Set<LedgerMetadataListener> newListenerSet = new HashSet<LedgerMetadataListener>(); Set<LedgerMetadataListener> oldListenerSet = listeners.putIfAbsent(ledgerId, newListenerSet); if (null != oldListenerSet) { listenerSet = oldListenerSet; } else { listenerSet = newListenerSet; } } synchronized (listenerSet) { listenerSet.add(listener); } new ReadLedgerMetadataTask(ledgerId).run(); } }
public <T extends BaseRequest, R extends BaseResponse> R execute(BaseRequest<T, R> request) { return api.send(request); }
@Override public void serialize(XYChart xychart, JsonGenerator jgen, SerializerProvider sp) throws IOException, JsonProcessingException { jgen.writeStartObject(); serialize(xychart, jgen); jgen.writeObjectField(GRAPHICS_LIST, xychart.getGraphics()); jgen.writeObjectField(CONSTANT_LINES, xychart.getConstantLines()); jgen.writeObjectField(CONSTANT_BANDS, xychart.getConstantBands()); jgen.writeObjectField(RASTERS, xychart.getRasters()); jgen.writeObjectField(TEXTS, xychart.getTexts()); jgen.writeObjectField(X_AUTO_RANGE, xychart.getXAutoRange()); jgen.writeObjectField(X_LOWER_BOUND, xychart.getXLowerBound()); jgen.writeObjectField(X_UPPER_BOUND, xychart.getXUpperBound()); jgen.writeObjectField(LOG_X, xychart.getLogX()); jgen.writeObjectField(X_LOG_BASE, xychart.getXLogBase()); if (xychart.getLodThreshold() != null) { jgen.writeObjectField(LOD_THRESHOLD, xychart.getLodThreshold()); } jgen.writeObjectField(X_TICK_LABELS_VISIBLE, xychart.isxTickLabelsVisible()); jgen.writeObjectField(Y_TICK_LABELS_VISIBLE, xychart.isyTickLabelsVisible()); jgen.writeEndObject(); }
@Override public void configure(Configuration conf) { field = conf.getString("field"); value = conf.getString("value"); Validate.notBlank(field); Validate.notBlank(value); }
public List<Contrast> getContrasts() { return getContrastAndAnnotationPairs().stream().map(Pair::getLeft).collect(Collectors.toList()); }
protected void validateAccess() throws PentahoAccessControlException { if ( !getPolicy().isAllowed( PublishAction.NAME ) ) { throw new PentahoAccessControlException( "Access Denied" ); } }
public static String getProperty(String key, String def) { return System.getProperty(SYSTEM_PROP_PREFIX + key, def); }
@Override public void init() { super.init(); view.setValue(new CaseInstanceSearchRequest()); refreshData(); }
@Override public GitHubBranchCause check(@Nonnull GitHubBranchDecisionContext context) throws IOException { TaskListener listener = context.getListener(); GitHubBranch localBranch = context.getLocalBranch(); GHBranch remoteBranch = context.getRemoteBranch(); GitHubBranchCause cause = null; if (nonNull(localBranch) && isNull(remoteBranch)) { final PrintStream logger = listener.getLogger(); logger.println(DISPLAY_NAME + ": state has changed (branch was deleted)"); LOG.debug("{}: state has changed (branch was deleted)", DISPLAY_NAME); localBranch.setCommitSha(null); cause = context.newCause(DISPLAY_NAME, false); } return cause; }
public <R> PandaStream<R> map(Function<T, R> function) { return new PandaStream<>(stream.map(function)); }
@Override public void onResponse(Call<SearchResult> call, Response<SearchResult> response) { final SearchResult searchResult = response.body(); currentSearchResult = searchResult; logger.logContentView((searchResult.name != null) ? searchResult.name + "" : "empty", "company_received", String.valueOf(searchResult.product_id), (searchResult.code != null) ? searchResult.code : "empty", sessionId.get(), searchResult.askForPics()); productList.addProduct(searchResult); viewBinder.resumeScanning(); viewBinder.setTeachPolaButtonVisibility(searchResult.askForPics(), searchResult); if(searchResult.askForPics()) { viewBinder.displayHelpMessageDialog(searchResult); } }
public static int getMinInt (final int nValue, @Nonnull final int... aValues) { int ret = nValue; for (final int n : aValues) ret = Math.min (ret, n); return ret; }
public static void validateExpression(Expression expression) { Assert.notNull(expression, "subscription expression can't null"); Assert.isTrue(Operator.AND.equals(expression.getOperator()), "Only AND operator is supported now"); Assert.notEmpty(expression.getOperands(), "Operands can't be empty"); expression.getOperands().forEach(operand -> validateOperand(operand)); }
@Override public int hashCode() { HashCodeBuilder b = new HashCodeBuilder(17, 37); b.append(myModifier); b.append(mySystem); b.append(myValue); return b.toHashCode(); }
public static String parseCharset(String target){ Matcher matcher = charsetPattern.matcher(target); if (matcher.find()){ return matcher.group(1); } return ""; }
public static boolean canAddPermission(String path,String token) { String safeType = ControllerUtil.getSafeType(path); String safeName = ControllerUtil.getSafeName(path); List<String> existingSafeNames = getAllExistingSafeNames(safeType, token); List<String> duplicateSafeNames = new ArrayList<String>(); int count=0; for (String existingSafeName: existingSafeNames) { if (existingSafeName.equalsIgnoreCase(safeName)) { count++; duplicateSafeNames.add(existingSafeName); } } if (count == 1) { return true; } else { return false; } }
@Deprecated public static double getDouble(Object value) { if (value == null) { return 0; } double result = 0; String temp = value.toString().trim(); if (temp.endsWith("wx")) { if (WXEnvironment.isApkDebugable()) { WXLogUtils.w("the value of " + value + " use wx unit, which will be not supported soon after."); } try { return transferWx(temp, 750); } catch (NumberFormatException e) { WXLogUtils.e("Argument format error! value is " + value, e); } catch (Exception e) { WXLogUtils.e("Argument error! value is " + value, e); } }else if (temp.endsWith("px")) { try { temp = temp.substring(0, temp.indexOf("px")); return Double.parseDouble(temp); } catch (NumberFormatException nfe) { WXLogUtils.e("Argument format error! value is " + value, nfe); } catch (Exception e) { WXLogUtils.e("Argument error! value is " + value, e); } }else { try { return Double.parseDouble(temp); } catch (NumberFormatException nfe) { WXLogUtils.e("Argument format error! value is " + value, nfe); } catch (Exception e) { WXLogUtils.e("Argument error! value is " + value, e); } } return result; }
@DescribeResult(name = "result", description = "Output feature collection") public FeatureCollection execute( @DescribeParameter(name = "features", description = "Input feature collection") FeatureCollection featureCollection, @DescribeParameter( name = "from_measure_attb", description = "Attribute providing start measure of feature" ) String fromMeasureAttb, @DescribeParameter( name = "to_measure_attb", description = "Attribute providing end measure of feature" ) String toMeasureAttb, @DescribeParameter(name = "point", description = "Point whose location to measure") Point point, @DescribeParameter( name = "crs", min = 0, description = "Coordinate reference system to use for input (default is the input collection CRS)" ) CoordinateReferenceSystem crs) throws ProcessException { DefaultFeatureCollection results = new DefaultFeatureCollection(); try { if (featureCollection == null || featureCollection.size() == 0) { LOGGER.info("No features provided in request"); return results; } if (crs == null) { GeometryDescriptor gd = featureCollection.getSchema().getGeometryDescriptor(); if (gd != null) { crs = gd.getCoordinateReferenceSystem(); } } if (crs == null) { throw new ProcessException( "The CRS parameter was not provided and the feature collection does not have a default one either"); } if (fromMeasureAttb == null || featureCollection.getSchema().getDescriptor(fromMeasureAttb) == null) { throw new ProcessException( "The from_measure_attb parameter was not provided or not defined in schema"); } if (toMeasureAttb == null || featureCollection.getSchema().getDescriptor(toMeasureAttb) == null) { throw new ProcessException("The to_measure_attb parameter was not provided"); } if (point == null) { throw new ProcessException("The point parameter was not provided"); } CoordinateReferenceSystem epsg4326; try { epsg4326 = CRS.decode("EPSG:4326"); } catch (Exception e) { throw new ProcessException("Unknown CRS code: EPSG:4326", e); } MathTransform crsTransform = CRS.findMathTransform(crs, epsg4326); FeatureType targetFeatureType = createTargetFeatureType(featureCollection.getSchema()); Feature nearestFeature = null; double nearestDistance = 9e9; Coordinate[] nearestCoords = null; FeatureIterator<Feature> featureIterator = null; try { featureIterator = featureCollection.features(); while (featureIterator.hasNext()) { SimpleFeature f = (SimpleFeature) featureIterator.next(); if (f.getDefaultGeometryProperty().getValue() == null) continue; DistanceOp op = new DistanceOp( point, (Geometry) f.getDefaultGeometryProperty().getValue()); Coordinate[] co = op.nearestPoints(); double[] co0 = new double[] { co[0].x, co[0].y, }; double[] co1 = new double[] { co[1].x, co[1].y, }; double[] geo0 = new double[2]; double[] geo1 = new double[2]; crsTransform.transform(co0, 0, geo0, 0, 1); crsTransform.transform(co1, 0, geo1, 0, 1); Measure m = DefaultGeographicCRS.WGS84.distance(geo0, geo1); if (m.doubleValue() > nearestDistance) continue; nearestFeature = f; nearestDistance = m.doubleValue(); nearestCoords = co; } } finally { if (featureIterator != null) featureIterator.close(); } if (nearestFeature != null) { LengthIndexedLine lengthIndexedLine = new LengthIndexedLine( (Geometry) nearestFeature.getDefaultGeometryProperty().getValue()); double lineIndex = lengthIndexedLine.indexOf(nearestCoords[1]); double lineLength = ((Geometry) nearestFeature.getDefaultGeometryProperty().getValue()) .getLength(); Double featureFromMeasure = (Double) nearestFeature.getProperty(fromMeasureAttb).getValue(); Double featureToMeasure = (Double) nearestFeature.getProperty(toMeasureAttb).getValue(); double lrsMeasure = featureFromMeasure + (featureToMeasure - featureFromMeasure) * lineIndex / lineLength; nearestFeature .getDefaultGeometryProperty() .setValue( geometryFactory.createPoint( new Coordinate(nearestCoords[1].x, nearestCoords[1].y))); results.add( createTargetFeature( nearestFeature, (SimpleFeatureType) targetFeatureType, lrsMeasure)); return results; } return results; } catch (ProcessException e) { throw e; } catch (Throwable e) { LOGGER.warning("Error executing method: " + e); throw new ProcessException("Error executing method: " + e, e); } }
static List<TextFragment> parseTemplateString(String template) { ArrayList<TextFragment> fragments = new ArrayList<>(); Matcher fragmentMatcher = DYNAMIC_FRAGMENT_PATTERN.matcher(template); int position = 0; while (position < template.length()) { if (!fragmentMatcher.find(position)) { String prefix = template.substring(position); fragments.add(staticFragment(prefix)); break; } final int prefixStart = position; final int prefixEnd = fragmentMatcher.start(1) - "{{".length(); final int dynamicStart = fragmentMatcher.start(1); final int dynamicEnd = fragmentMatcher.end(1); if (prefixEnd - prefixStart > 0) { String prefixText = template.substring(prefixStart, prefixEnd); fragments.add(staticFragment(prefixText)); } String dynamicFragmentText = template.substring(dynamicStart, dynamicEnd); fragments.add(dynamicFragment(dynamicFragmentText)); position = dynamicEnd + "}}".length(); } return fragments; }
@Nullable static Ip4 parse(String hostname) { String[] segments = hostname.split("\\."); if (segments.length != 4) { return null; } byte[] addr = new byte[4]; for (int i = 0; i < segments.length; i++) { int val; String segment = segments[i]; if (segment.length() > 1 && segment.startsWith("0")) { return null; } try { val = Integer.parseInt(segment); } catch (NumberFormatException e) { return null; } if (val < 0 || val > 255) { return null; } addr[i] = (byte) val; } return fromAddress(addr); }
@Override public Job animate(URI animation, Map<String, String> metadata, List<String> arguments) throws AnimateServiceException { Gson gson = new Gson(); List<String> jobArguments = Arrays.asList(animation.toString(), gson.toJson(metadata), gson.toJson(arguments)); try { logger.debug("Create animate service job"); return serviceRegistry.createJob(JOB_TYPE, OPERATION, jobArguments, jobLoad); } catch (ServiceRegistryException e) { throw new AnimateServiceException(e); } }
public void save(Vendor vendor) { if (vendor.getId() == null) { repository.insert(vendor); } else { repository.update(vendor); } }
boolean isModified(Namespace namespace) { Release release = releaseService.findLatestActiveRelease(namespace); List<Item> items = itemService.findItemsWithoutOrdered(namespace.getId()); if (release == null) { return hasNormalItems(items); } Map<String, String> releasedConfiguration = gson.fromJson(release.getConfigurations(), GsonType.CONFIG); Map<String, String> configurationFromItems = generateConfigurationFromItems(namespace, items); MapDifference<String, String> difference = Maps.difference(releasedConfiguration, configurationFromItems); return !difference.areEqual(); }
public static Builder builder() { return new Builder(); }
public ConsumerType getByLabel(String label) { return this.getByLabel(label, false); }
public void setLdapName(String ldapName) { this.ldapName = ldapName; }
public void editSoftlinkRelation(ForeignableOwner editingUser, SoftlinkRelationEntity editedSoftlinkRelation) throws ForeignableOwnerViolationException { SoftlinkRelationEntity softlinkRelation = entityManager.find(SoftlinkRelationEntity.class, Objects.requireNonNull(editedSoftlinkRelation, "editedSoftlinkRelation must not be null!").getId()); permissionService.checkPermissionAndFireException(Permission.RESOURCE, null, Action.UPDATE, softlinkRelation.getCpiResource().getResourceGroup(), null, null); if (softlinkRelation != null) { int beforeChangeForeignableFieldHashCode = softlinkRelation.foreignableFieldHashCode(); SoftlinkRelationEntity mergedSoftlinkRelation = entityManager.merge(editedSoftlinkRelation); foreignableService.verifyEditableByOwner(editingUser, beforeChangeForeignableFieldHashCode, mergedSoftlinkRelation); } else { throw new RuntimeException("No softlink relation found for "+ editedSoftlinkRelation); } }
public Object getData() { return data; }
@Override public void create(User user) { User existing = userRepository.findByUsername(user.getUsername()); Assert.isNull(existing, "user already exist: " + user.getUsername()); String hash = encoder.encode(user.getPassword()); user.setPassword(hash); user.setEnabled(true); user = userRepository.save(user); UserRole userRole = new UserRole(user.getId(), UserUtility.ROLE_USER); userRoleRepository.save(userRole); logger.info("new user has been created {}", user.getUsername()); }
public static @Nullable Object value(@Nullable Object obj, List<String> path) throws Exception { return value(obj, path, 0); }
public Language getLanguage() { return currentLanguage; }
static List<String> diff(ToNode actual, ToNode expected) { return new NodeDiff().findDifferences(actual.toNode(), expected.toNode(), "") .collect(Collectors.toList()); }
public <Sub> Match<In, Out> missing(Class<Sub> type) { return when_(type, reportMissing(type)); }
public void changeDueDateBy(IncreaseOrDecrease increaseOrDecrease, TimeUnit timeUnit, int quantity) { DayOverflow overflow = DayOverflow.LastDay; int dys = 0, hrs = 0, mts = 0; switch (timeUnit) { case DAYS: dys += quantity; break; case MINUTES: mts += quantity; break; case HOURS: hrs += quantity; } if (_dueDateTime == null) { _dueDateTime = _coreDateUtils.now(); } if (increaseOrDecrease == MINUS) { _dueDateTime = _dueDateTime.minus(0, 0, dys, hrs, mts, 0, 0, overflow); } else { _dueDateTime = _dueDateTime.plus(0, 0, dys, hrs, mts, 0, 0, overflow); } _talkToTaskCreate.updateDueDateDisplay( _taskCreatePresenter.getDueDateText(_dueDateTime), _taskCreatePresenter.getDueDateDiffText(_dueDateTime)); }
@Deprecated @Nullable public static String get(String name) { BaggageField field = BaggageField.getByName(validateFieldName(name)); if (field == null) return null; return field.getValue(); }
public static Object getProperty(Object object, String nestedPropertyName) throws CayenneRuntimeException { return accessor(nestedPropertyName).getValue(object); }
@SuppressWarnings("unchecked") public static <S> Object convertToRepresentation(S o, Representation rep) throws ConversionException { return convertToRepresentation(o, rep, (Converter) null); }
public static String convertFromActiveMQDestination(Object value) { return convertFromActiveMQDestination(value, false); }
@Override public void execute(SensorContext context) { String baseDir = context.fileSystem().baseDir().getPath(); Configuration config = context.config(); warnDeprecatedPropertyUsage(config); HashSet<InputFile> filesCovered = new HashSet<>(); List<File> reports = getCoverageReports(baseDir, config); if (!reports.isEmpty()) { LOG.info("Python test coverage"); for (File report : uniqueAbsolutePaths(reports)) { Map<InputFile, NewCoverage> coverageMeasures = parseReport(report, context); saveMeasures(coverageMeasures, filesCovered); } } }
public ModelList resolveModelList(String modelPath) { return resolve(modelPath, ModelList.class); }
@Override @GetContent public Promise getContent() { return diagramServices.transform(getEditor().getEditorProxy().getContentSupplier().get()); }
@Override public void startQuery(final String ryaInstance, final StreamsQuery query) throws QueryExecutorException { requireNonNull(ryaInstance); requireNonNull(query); checkState(state() == State.RUNNING, "The service must be RUNNING to execute this method."); lock.lock(); try { final Set<String> topics = Sets.newHashSet( KafkaTopics.statementsTopic(ryaInstance), KafkaTopics.queryResultsTopic(ryaInstance, query.getQueryId())); createKafkaTopic.createTopics(topics, 1, 1, Optional.empty()); final KafkaStreams streams = streamsFactory.make(ryaInstance, query); streams.start(); ryaInstanceById.put(query.getQueryId(), ryaInstance); idByRyaInstance.put(ryaInstance, query.getQueryId()); byQueryId.put(query.getQueryId(), streams); } catch (final KafkaStreamsFactoryException e) { throw new QueryExecutorException("Could not start query " + query.getQueryId(), e); } finally { lock.unlock(); } }
@Override public void deleteConfiguration(ConfigurationModel configModel) throws AlertDatabaseConstraintException { if (configModel == null) { throw new AlertDatabaseConstraintException("Cannot delete a null object from the database"); } deleteConfiguration(configModel.getConfigurationId()); }
public static MessageBatch create(boolean history, ConfigManager configManager, JSONObject cookies, BatchId batchId) throws JSONException { MessageBatch uploadMessage = new MessageBatch(); if (BuildConfig.MP_DEBUG) { uploadMessage.put(Constants.MessageKey.ECHO, true); } uploadMessage.put(Constants.MessageKey.TYPE, Constants.MessageType.REQUEST_HEADER); uploadMessage.put(Constants.MessageKey.ID, UUID.randomUUID().toString()); uploadMessage.put(Constants.MessageKey.TIMESTAMP, System.currentTimeMillis()); uploadMessage.put(Constants.MessageKey.MPARTICLE_VERSION, Constants.MPARTICLE_VERSION); uploadMessage.put(Constants.MessageKey.OPT_OUT_HEADER, configManager.getOptedOut()); uploadMessage.put(Constants.MessageKey.CONFIG_UPLOAD_INTERVAL, configManager.getUploadInterval()/1000); uploadMessage.put(Constants.MessageKey.CONFIG_SESSION_TIMEOUT, configManager.getSessionTimeout()/1000); uploadMessage.put(Constants.MessageKey.MPID, String.valueOf(batchId.getMpid())); uploadMessage.put(Constants.MessageKey.SANDBOX, configManager.getEnvironment().equals(MParticle.Environment.Development)); uploadMessage.put(Constants.MessageKey.DEVICE_APPLICATION_STAMP, configManager.getDeviceApplicationStamp()); if (history) { String deletedAttr = configManager.getUserStorage(batchId.getMpid()).getDeletedUserAttributes(); if (deletedAttr != null) { uploadMessage.put(Constants.MessageKey.DELETED_USER_ATTRIBUTES, new JSONArray(deletedAttr)); configManager.getUserStorage().deleteDeletedUserAttributes(); } } uploadMessage.put(Constants.MessageKey.COOKIES, cookies); uploadMessage.put(Constants.MessageKey.PROVIDER_PERSISTENCE, configManager.getProviderPersistence()); uploadMessage.put(Constants.MessageKey.INTEGRATION_ATTRIBUTES, configManager.getIntegrationAttributes()); uploadMessage.addConsentState(configManager.getConsentState(batchId.getMpid())); uploadMessage.addDataplanContext(batchId.getDataplanId(), batchId.getDataplanVersion()); return uploadMessage; }
@Override public Optional<String> get(RestUri restUri, Optional<String> fieldSet, Optional<String> cluster) throws RestApiException { SyncSession syncSession = syncSessions.alloc(); Optional<String> route = cluster.isPresent() ? Optional.of(clusterDefToRoute(resolveClusterDef(cluster, clusterEnumerator.enumerateClusters()))) : Optional.empty(); setRoute(syncSession, route); try { DocumentId id = new DocumentId(restUri.generateFullId()); final Document document = syncSession.get(id, fieldSet.orElse(restUri.getDocumentType() + ":[document]"), DocumentProtocol.Priority.NORMAL_1); if (document == null) { return Optional.empty(); } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); JsonWriter jsonWriter = new JsonWriter(outputStream); jsonWriter.write(document); return Optional.of(outputStream.toString(StandardCharsets.UTF_8.name())); } catch (Exception e) { throw new RestApiException(Response.createErrorResponse(500, ExceptionUtils.getStackTraceAsString(e), restUri, RestUri.apiErrorCodes.UNSPECIFIED)); } finally { syncSessions.free(syncSession); } }
public Set<Transaction> reduce( final Set<TransactionInfo> pendingTransactions, final List<Filter> filters, final int limit) throws InvalidJsonRpcParameters { return pendingTransactions.stream() .filter(transactionInfo -> applyFilters(transactionInfo, filters)) .limit(limit) .map(TransactionInfo::getTransaction) .collect(Collectors.toSet()); }
public static Schema typeFor(DataType dataType) { return typeFor(dataType, true); }
@Override public String toString() { String result = "{"; if (m != null) { result += "adv_type:" + m + ","; } if (si != null) { result += "slot_id:" + si + ","; } if (t != null) { result += "net_type:" + t + ","; } if (g != null) { result += "gender:" + g + ","; } if (a != null) { result += "age:" + a + ","; } if (dpc != null) { result += "device price category:" + dpc + ","; } if (pm != null) { result += "price_type:" + pm + ","; } if (r != null) { result += "residence_city" + r + ","; } if (ipl != null) { result += "ip_city_code" + ipl + ","; } if (!CommonUtil.isEmpty(ais)) { result += "app interests" + ais + ","; } if (!CommonUtil.isEmpty(aus)) { result += "app usages" + aus + ","; } if (!CommonUtil.isEmpty(pdas)) { result += "pdas" + pdas + ","; } if (!CommonUtil.isEmpty(exclude_pdas)) { result += "exclude_pdas" + exclude_pdas + ","; } if (!CommonUtil.isEmpty(dms)) { result += "device models" + dms; } result += "}"; return result; }
@Override public int read() throws IOException { throw new UnimplementedError("RpcInputStream.read()"); }
public Set<String> getSiteNodes(Session session) { String siteOrServerID = session.getID().getSessionServerID(); String siteID; if (query.isSite(siteOrServerID)) { siteID = siteOrServerID; } else { siteID = query.getSiteID(siteOrServerID); if (siteID == null) { return new HashSet<String>(Arrays.asList(siteOrServerID)); } } try { return query.getSiteNodes(siteID); } catch (Exception e) { String err = "Failed to find nodes for Site ID: " + siteOrServerID; debug.error(err, e); throw new IllegalStateException(err); } }
public QueryHolder bindToUri(String name, String uri) { String regex = "\\?" + name + "\\b"; String replacement = "<" + uri + ">"; String bound = replaceWithinBraces(regex, replacement); return new QueryHolder(bound); }
public static String formatStatus(ComputeMetadataIncludingStatus<?> resource) { if (resource.getBackendStatus() == null) return resource.getStatus().toString(); return String.format("%s[%s]", resource.getStatus(), resource.getBackendStatus()); }
public final static byte[] intToByte(int i) { byte[] bt = new byte[4]; bt[0] = (byte) (0xff & i); bt[1] = (byte) ((0xff00 & i) >> 8); bt[2] = (byte) ((0xff0000 & i) >> 16); bt[3] = (byte) ((0xff000000 & i) >> 24); return bt; }
@Override public void updateBrandingInformation(Branding branding) throws Exception { updateCompanyName(branding.getCompanyName()); updateTopBarTheme(branding.getTopBarTheme()); updateLogo(branding.getLogo()); }
@Override public TryResult evaluate(SimpleEvaluationObject seo, String code, ExecutionOptions executionOptions) { return evaluate(seo, new JavaWorkerThread(this, new JobDescriptor(code, seo, executionOptions))); }
@Override public void setPoolSize(int poolSize) { delegate.setPoolSize(poolSize); }
public Map<V, Set<V>> getDominatorSets() { if(dominatorSets == null) { getImmediateDominators(); dominatorSets = new HashMap<>(); for(V key : immediateDominators.keySet()) { Set<V> tempDominators = new HashSet<>(); for(V current = key; current != null; current = immediateDominators.get(current)) { tempDominators.add(current); } dominatorSets.put(key, Collections.unmodifiableSet(tempDominators)); } dominatorSets = Collections.unmodifiableMap(dominatorSets); } return dominatorSets; }
public OptionGameSettings update(JSONObject json) { String name = "roundSettings"; if (json.has(name)) { SettingsUtils.save(json.getJSONObject(name), roundSettings); } SettingsUtils.save(json, this); return this; }
public void execute(ContainerTask task) throws Exception { LoggingService.logInfo(MODULE_NAME, "Start executes assigned task"); docker = DockerUtil.getInstance(); if (task != null) { Optional<Microservice> microserviceOptional = microserviceManager.findLatestMicroserviceByUuid(task.getMicroserviceUuid()); switch (task.getAction()) { case ADD: if (microserviceOptional.isPresent()) { addContainer(microserviceOptional.get()); } break; case UPDATE: if (microserviceOptional.isPresent()) { Microservice microservice = microserviceOptional.get(); updateContainer(microserviceOptional.get(), microservice.isRebuild() && microservice.getRegistryId() != Constants.CACHE_REGISTRY_ID); } break; case REMOVE: removeContainerByMicroserviceUuid(task.getMicroserviceUuid(), false); break; case REMOVE_WITH_CLEAN_UP: removeContainerByMicroserviceUuid(task.getMicroserviceUuid(), true); break; case STOP: stopContainerByMicroserviceUuid(task.getMicroserviceUuid()); break; } } else { LoggingService.logError(MODULE_NAME, "Container Task cannot be null", new AgentSystemException("Container Task container be null")); } LoggingService.logInfo(MODULE_NAME, "Finished executes assigned task"); }
@Override public List<String> extractLegalBases(SourceCtJudgment sourceJudgment, ImportCorrectionList correctionList) { return Lists.newArrayList(); }
public boolean send(final Mail composedMessage) { return send(composedMessage, null, null, true); }
public HttpRequestContext handleStart(C carrier, Q request) { checkNotNull(carrier, "carrier"); checkNotNull(request, "request"); SpanBuilder spanBuilder = null; String spanName = getSpanName(request, extractor); SpanContext spanContext = null; try { spanContext = textFormat.extract(carrier, getter); } catch (SpanContextParseException e) { } if (spanContext == null || publicEndpoint) { spanBuilder = tracer.spanBuilder(spanName); } else { spanBuilder = tracer.spanBuilderWithRemoteParent(spanName, spanContext); } Span span = spanBuilder.setSpanKind(Kind.SERVER).startSpan(); if (publicEndpoint && spanContext != null) { span.addLink(Link.fromSpanContext(spanContext, Type.PARENT_LINKED_SPAN)); } if (span.getOptions().contains(Options.RECORD_EVENTS)) { addSpanRequestAttributes(span, request, extractor); } return getNewContext(span, tagger.getCurrentTagContext()); }
@Nonnull @Override public PushNotificationSubscriptionRequest getPushNotificationSubscriptionRequestByUuId(@Nonnull final String uuId) { assertPushNotificationSubscriptionRequestUuId(uuId); LOGGER.debug("Getting push notification subscription request for uuid - {}", uuId); final PushNotificationSubscriptionRequest request = pushNotificationSubscriptionRequestRepository.findByUuId(uuId); assertPushNotificationSubscriptionRequestNotNullForUuId(request, uuId); LOGGER.debug("Successfully retrieved push notification subscription request with uuId - {}, request - {}", request.getUuId(), request); return request; }
public AlignmentDataset templateLengthFilter(String value) { query.put("tlen", value); return this; }
public void registerAppAttempt(ApplicationAttemptId attemptId) { AllocateResponse response = recordFactory.newRecordInstance(AllocateResponse.class); response.setResponseId(-1); LOG.info("Registering app attempt : " + attemptId); responseMap.put(attemptId, new AllocateResponseLock(response)); rmContext.getNMTokenSecretManager().registerApplicationAttempt(attemptId); }
@Override public ListenerResponse onEpochTrainingResult(IEpochTrainer trainer, IDataManager.StatEntry statEntry) { IHistoryProcessor hp = trainer.getHistoryProcessor(); if(hp != null) { hp.stopMonitor(); } try { dataManager.appendStat(statEntry); } catch (Exception e) { log.error("Training failed.", e); return ListenerResponse.STOP; } return ListenerResponse.CONTINUE; }
@Override public void onDecisionTableSelectionsChangedEvent(final @Observes DecisionTableSelectionsChangedEvent event) { super.onDecisionTableSelectionsChangedEvent(event); }
public String getPrefix() { return prefix; }
@PostMapping("/monitoring-officer/create/{inviteHash}") public RestResult<Void> createMonitoringOfficer(@PathVariable("inviteHash") String inviteHash, @RequestBody MonitoringOfficerRegistrationResource monitoringOfficerRegistrationResource) { return monitoringOfficerInviteService .activateUserByHash(inviteHash, monitoringOfficerRegistrationResource) .andOnSuccess(user -> crmService.syncCrmContact(user.getId())) .toPostResponse(); }
ActivityDetails create(Receipt receipt, PrivateKey privateKey) throws ProfileException { byte[] decryptedKey = DecryptionHelper.decryptAsymmetric(receipt.getWrappedReceiptKey(), privateKey); Key secretKey = new SecretKeySpec(decryptedKey, SYMMETRIC_CIPHER); Profile userProfile = profileReader.read(receipt.getOtherPartyProfile(), secretKey); Profile applicationProfile = profileReader.read(receipt.getProfile(), secretKey); ExtraData extraData = parseExtraData(receipt.getExtraData(), secretKey); String rememberMeId = parseRememberMeId(receipt.getRememberMeId()); String parentRememberMeId = parseRememberMeId(receipt.getParentRememberMeId()); Date timestamp = parseTimestamp(receipt.getTimestamp()); return new SimpleActivityDetails(rememberMeId, parentRememberMeId, userProfile, applicationProfile, extraData, timestamp, receipt.getReceiptId()); }
public RoleBinding generateRoleBinding(String namespace, String watchedNamespace) { Subject ks = new SubjectBuilder() .withKind("ServiceAccount") .withName(EntityOperator.entityOperatorServiceAccountName(cluster)) .withNamespace(namespace) .build(); RoleRef roleRef = new RoleRefBuilder() .withName(EntityOperator.EO_CLUSTER_ROLE_NAME) .withApiGroup("rbac.authorization.k8s.io") .withKind("ClusterRole") .build(); RoleBinding rb = new RoleBindingBuilder() .withNewMetadata() .withName(roleBindingName(cluster)) .withNamespace(watchedNamespace) .withOwnerReferences(createOwnerReference()) .withLabels(labels.toMap()) .endMetadata() .withRoleRef(roleRef) .withSubjects(singletonList(ks)) .build(); return rb; }
@Override public <U extends BasePreference<U>, T extends BasePreferencePortable<U>> T load(final T emptyPortablePreference) { return load(emptyPortablePreference, defaultScopeResolutionStrategy.getInfo()); }
@Override public RecoveryStartInformation get() { LogTailScanner.LogTailInformation logTailInformation = logTailScanner.getTailInformation(); CheckPoint lastCheckPoint = logTailInformation.lastCheckPoint; long txIdAfterLastCheckPoint = logTailInformation.firstTxIdAfterLastCheckPoint; if ( !logTailInformation.commitsAfterLastCheckpoint() ) { monitor.noCommitsAfterLastCheckPoint( lastCheckPoint != null ? lastCheckPoint.getLogPosition() : null ); return createRecoveryInformation( LogPosition.UNSPECIFIED, txIdAfterLastCheckPoint ); } if ( lastCheckPoint != null ) { monitor.commitsAfterLastCheckPoint( lastCheckPoint.getLogPosition(), txIdAfterLastCheckPoint ); return createRecoveryInformation( lastCheckPoint.getLogPosition(), txIdAfterLastCheckPoint ); } else { if ( logTailInformation.oldestLogVersionFound != INITIAL_LOG_VERSION ) { long fromLogVersion = Math.max( INITIAL_LOG_VERSION, logTailInformation.oldestLogVersionFound ); throw new UnderlyingStorageException( "No check point found in any log file from version " + fromLogVersion + " to " + logTailInformation.currentLogVersion ); } monitor.noCheckPointFound(); return createRecoveryInformation( LogPosition.start( 0 ), txIdAfterLastCheckPoint ); } }
public void convertCommentsToRaw(Map<String,Object> source) { @SuppressWarnings("unchecked") List<Map<String, Object>> comments = (List<Map<String, Object>>) source.get(COMMENTS_FIELD); if (comments == null || comments.isEmpty()) { return; } List<String> asJson = new ArrayList<>(); for (Map<String, Object> comment : comments) { asJson.add((new AlertComment(comment)).asJson()); } source.put(COMMENTS_FIELD, asJson); }
@Override public E set(int index, E element) { return owner.set(index, element); }
public static void setProperty(JmsMessage message, String name, Object value) throws JMSException { PropertyIntercepter jmsPropertyExpression = PROPERTY_INTERCEPTERS.get(name); if (jmsPropertyExpression == null || !jmsPropertyExpression.isAlwaysWritable()) { message.checkReadOnlyProperties(); } checkPropertyNameIsValid(name, message.isValidatePropertyNames()); checkValidObject(value); if (jmsPropertyExpression != null) { jmsPropertyExpression.setProperty(message, value); } else { message.getFacade().setProperty(name, value); } }
@NotNull public static String getSqlKey(@NotNull final SQLInputs sqlInputs) { if (sqlInputs.isIgnoreCase()) { return SQLUtils.computeSessionId(sqlInputs.getDbServer().toLowerCase() + sqlInputs.getDbType().toLowerCase() + sqlInputs.getUsername() + sqlInputs.getPassword() + sqlInputs.getInstance() + sqlInputs.getDbPort() + sqlInputs.getDbName() + sqlInputs.getAuthenticationType().toLowerCase() + sqlInputs.getSqlCommand().toLowerCase() + sqlInputs.getKey()); } return SQLUtils.computeSessionId(sqlInputs.getDbServer() + sqlInputs.getDbType() + sqlInputs.getUsername() + sqlInputs.getPassword() + sqlInputs.getInstance() + sqlInputs.getDbPort() + sqlInputs.getDbName() + sqlInputs.getAuthenticationType() + sqlInputs.getSqlCommand() + sqlInputs.getKey()); }
public void syncSend(Integer id) { Demo10Message message = new Demo10Message(); message.setId(id); rabbitTemplate.convertAndSend(Demo10Message.EXCHANGE, this.getRoutingKey(id), message); }
@Override public Quality createQuality(QualityKey key) { FindFactory findFactory = new FindFactory(); key.withTypeDo(findFactory); return findFactory.create(key); }
@Override public boolean contains(Long point) { return start <= point & end > point; }
public void read(Connection connection, InputStream inputStream, ProgressVisitor progress, String tableReference, int srid) throws SQLException, IOException { BufferedInputStream bof = new BufferedInputStream(inputStream, BUFFER_SIZE); String lastWord = ""; try { Scanner scanner = new Scanner(bof); lastWord = scanner.next(); if (!lastWord.equalsIgnoreCase("NCOLS")) { throw new IOException("Unexpected word " + lastWord); } lastWord = scanner.next(); int ncols = Integer.parseInt(lastWord); if (ncols <= 0) { throw new IOException("NCOLS <= 0"); } lastWord = scanner.next(); if (!lastWord.equalsIgnoreCase("NROWS")) { throw new IOException("Unexpected word " + lastWord); } lastWord = scanner.next(); int nrows = Integer.parseInt(lastWord); if (nrows <= 0) { throw new IOException("NROWS <= 0"); } lastWord = scanner.next(); if (!(lastWord.equalsIgnoreCase("XLLCENTER") || lastWord.equalsIgnoreCase("XLLCORNER"))) { throw new IOException("Unexpected word " + lastWord); } boolean isXCenter = lastWord.equalsIgnoreCase("XLLCENTER"); lastWord = scanner.next(); double xValue = Double.parseDouble(lastWord); lastWord = scanner.next(); if (!(lastWord.equalsIgnoreCase("YLLCENTER") || lastWord.equalsIgnoreCase("YLLCORNER"))) { throw new IOException("Unexpected word " + lastWord); } boolean isYCenter = lastWord.equalsIgnoreCase("YLLCENTER"); lastWord = scanner.next(); double yValue = Double.parseDouble(lastWord); lastWord = scanner.next(); if (!lastWord.equalsIgnoreCase("CELLSIZE")) { throw new IOException("Unexpected word " + lastWord); } lastWord = scanner.next(); double cellSize = Double.parseDouble(lastWord); if (isXCenter) { xValue = xValue - cellSize / 2; } if (isYCenter) { yValue = yValue + cellSize * nrows - cellSize / 2; } else { yValue = yValue + cellSize * nrows; } lastWord = scanner.next(); boolean readFirst = false; int noData = -9999; if (lastWord.equalsIgnoreCase("NODATA_VALUE")) { readFirst = true; lastWord = scanner.next(); noData = Integer.parseInt(lastWord); } Statement st = connection.createStatement(); PreparedStatement preparedStatement; if(as3DPoint) { st.execute("CREATE TABLE " + tableReference + "(PK SERIAL NOT NULL, THE_GEOM GEOMETRY, " + " CONSTRAINT ASC_PK PRIMARY KEY (PK))"); preparedStatement = connection.prepareStatement("INSERT INTO " + tableReference + "(the_geom) VALUES (?)"); } else { st.execute("CREATE TABLE " + tableReference + "(PK SERIAL NOT NULL, THE_GEOM GEOMETRY,Z int, " + " CONSTRAINT ASC_PK PRIMARY KEY (PK))"); preparedStatement = connection.prepareStatement("INSERT INTO " + tableReference + "(the_geom, Z) VALUES (?, ?)"); } GeometryFactory factory = new GeometryFactory(); int batchSize = 0; int firstRow = 0; int firstCol = 0; int lastRow = nrows; int lastCol = ncols; if(extractEnvelope != null) { firstCol = (int)Math.floor((extractEnvelope.getMinX() - xValue) / cellSize); lastCol = (int)Math.ceil((extractEnvelope.getMaxX() - xValue) / cellSize); firstRow = nrows - (int)Math.ceil((extractEnvelope.getMaxY() - (yValue - cellSize * nrows)) / cellSize); lastRow = nrows - (int)Math.ceil((extractEnvelope.getMinY() - (yValue - cellSize * nrows)) / cellSize); } ProgressVisitor cellProgress = new EmptyProgressVisitor(); if (progress != null) { cellProgress = progress.subProcess(lastRow); } for (int i = 0; i < nrows; i++) { for (int j = 0; j < ncols; j++) { if (readFirst) { lastWord = scanner.next(); } else { readFirst = true; } if((downScale == 1 || (i % downScale == 0 && j % downScale == 0)) && (extractEnvelope == null || (i >= firstRow && i <= lastRow && j >= firstCol && j <= lastCol))) { int data = Integer.parseInt(lastWord); double x = xValue + j * cellSize; double y = yValue - i * cellSize; if (as3DPoint) { if (data != noData) { Point cell = factory.createPoint(new Coordinate(new Coordinate(x + cellSize / 2, y - cellSize / 2, data))); cell.setSRID(srid); preparedStatement.setObject(1, cell); preparedStatement.addBatch(); batchSize++; } } else { Polygon cell = factory.createPolygon(new Coordinate[]{new Coordinate(x, y), new Coordinate(x, y - cellSize * downScale), new Coordinate(x + cellSize * downScale, y - cellSize * downScale), new Coordinate(x + cellSize * downScale, y), new Coordinate(x, y)}); cell.setSRID(srid); preparedStatement.setObject(1, cell); if (data != noData) { preparedStatement.setObject(2, data); } else { preparedStatement.setNull(2, Types.INTEGER); } preparedStatement.addBatch(); batchSize++; } if (batchSize >= BATCH_MAX_SIZE) { preparedStatement.executeBatch(); preparedStatement.clearBatch(); batchSize = 0; } } } cellProgress.endStep(); if(i > lastRow) { break; } } if (batchSize > 0) { preparedStatement.executeBatch(); } } catch (NoSuchElementException | NumberFormatException ex) { throw new SQLException("Unexpected word " + lastWord, ex); } }
@Override public void stopAtOnce(String namespace, String jobName) throws SaturnJobConsoleException { JobStatus jobStatus = getJobStatus(namespace, jobName); if (!JobStatus.STOPPING.equals(jobStatus)) { throw new SaturnJobConsoleException(ERROR_CODE_BAD_REQUEST, String.format("该作业(%s)不处于STOPPING状态，不能立即终止", jobName)); } List<String> jobServerList = getJobServerList(namespace, jobName); if (jobServerList != null && !jobServerList.isEmpty()) { CuratorFrameworkOp curatorFrameworkOp = registryCenterService.getCuratorFrameworkOp(namespace); for (String executorName : jobServerList) { String path = JobNodePath.getStopOneTimePath(jobName, executorName); if (curatorFrameworkOp.checkExists(path)) { curatorFrameworkOp.delete(path); } curatorFrameworkOp.create(path); log.info("stopAtOnce namespace:{}, jobName:{}, executorName:{}", namespace, jobName, executorName); } } else { throw new SaturnJobConsoleException(ERROR_CODE_BAD_REQUEST, String.format("没有executor接管该作业(%s)，不能立即终止", jobName)); } }
@Override public Observable<UserEntity> loginUser(UserEntity user) { return this.restApi.doLogin(new UserWrapper(user)) .map(userEntityResponse -> { handleResponseError(userEntityResponse); return userEntityResponse.body(); }); }
public static boolean doubleEquals(final double a, final double b, final double epsilon) { final double diff = Math.abs(a - b); return diff < epsilon || (Double.isNaN(diff) && a == b); }
static int fixSelectionLength( String fullText, int selectionOffset, int selectionLength ) { if( selectionLength < 0 ) selectionLength = 0; else if( selectionOffset + selectionLength > fullText.length()) selectionLength = fullText.length() - selectionOffset; for( ; selectionOffset + selectionLength < fullText.length(); selectionLength ++ ) { char c = fullText.charAt( selectionOffset + selectionLength ); if( isLineBreak( c )) break; } return selectionLength; }
public boolean useFieldBoostingInQuerqyBoostQueries() { final String boostFieldBoost = solrParams.get(QBOOST_FIELD_BOOST, DEFAULT_QBOOST_FIELD_BOOST); switch (boostFieldBoost) { case QBOOST_FIELD_BOOST_ON: return true; case QBOOST_FIELD_BOOST_OFF: return false; default: throw new IllegalArgumentException("Invalid value for " + QBOOST_FIELD_BOOST + ": " + boostFieldBoost); } }
private static int alternation(String glob, int i, int length, StringBuilder result) { result.append("(?:"); while (i < length) { char current = glob.charAt(i++); switch (current) { case '}': result.append(')'); return i; case ',': result.append('|'); i = glob(glob, i, length, ",}", result); break; default: i--; i = glob(glob, i, length, ",}", result); break; } } throw new IllegalStateException(String.format("Missing } at the end of input in glob %s", glob)); }
public static String last_N_Char(String sInput, int nb) { if (sInput == null || "".equals(sInput)) { return ""; } int s_len = sInput.codePointCount(0, sInput.length()); if (s_len < nb) { nb = s_len; } return sInput.substring(sInput.offsetByCodePoints(0, s_len - nb)); }
@NotNull @Override public IndexSegment addDocument( final int documentId, @NotNull final Collection<UnsignedByteArray> values) { if (documentId < 0) throw new IllegalArgumentException("Negative document ID"); if (values.size() != 1) throw new IllegalArgumentException("A single value expected"); checkNotFrozen(); final UnsignedByteArray value = values.iterator().next(); List<Integer> indexes = this.valueDocId.computeIfAbsent(value, v -> new LinkedList<>()); if (!indexes.isEmpty()) { uniqueValues = false; } indexes.add(documentId); return this; }
void executePutMembership(ResourceContext ctx, String domainName, String roleName, RoleMember roleMember, String auditRef, String caller) { for (int retryCount = defaultRetryCount; ; retryCount--) { try (ObjectStoreConnection con = store.getConnection(true, true)) { String principal = getPrincipalName(ctx); checkDomainAuditEnabled(con, domainName, auditRef, caller, principal, AUDIT_TYPE_ROLE); Role originalRole = con.getRole(domainName, roleName); if (originalRole == null) { con.rollbackChanges(); throw ZMSUtils.notFoundError(caller + ": Unknown role: " + roleName, caller); } checkRoleAuditEnabled(con, originalRole, auditRef, caller, principal); if (isTrustRole(originalRole)) { con.rollbackChanges(); throw ZMSUtils.requestError(caller + ": " + roleName + "is a delegated role", caller); } quotaCheck.checkRoleMembershipQuota(con, domainName, roleName, caller); if (!con.insertRoleMember(domainName, roleName, roleMember, principal, auditRef)) { con.rollbackChanges(); throw ZMSUtils.requestError(caller + ": unable to insert role member: " + roleMember.getMemberName() + " to role: " + roleName, caller); } con.updateRoleModTimestamp(domainName, roleName); con.updateDomainModTimestamp(domainName); cacheStore.invalidate(domainName); StringBuilder auditDetails = new StringBuilder(ZMSConsts.STRING_BLDR_SIZE_DEFAULT); auditLogRoleMember(auditDetails, roleMember, true); auditLogRequest(ctx, domainName, auditRef, caller, ZMSConsts.HTTP_PUT, roleName, auditDetails.toString()); return; } catch (ResourceException ex) { if (!shouldRetryOperation(ex, retryCount)) { throw ex; } } } }
public static String getPath(String filename) { return doGetPath(filename, 1); }
public void onTimeout() { maxWindow = 150; LOGGER.trace("Timeout occurred. max_window=[{}]", maxWindow); }
public static byte[] serializeToByteArray(Serializable value) { try { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); try (ObjectOutputStream oos = new ObjectOutputStream(new SnappyOutputStream(buffer))) { oos.writeObject(value); } return buffer.toByteArray(); } catch (IOException exn) { throw new IllegalArgumentException("unable to serialize " + value, exn); } }
protected Mono<Void> updateInfo(InstanceId instanceId) { return this.infoUpdater.updateInfo(instanceId).onErrorResume((e) -> { log.warn("Unexpected error while updating info for {}", instanceId, e); return Mono.empty(); }).doFinally((s) -> this.intervalCheck.markAsChecked(instanceId)); }
public static Connection fromHostList(String... brokers) { return new Connection(Arrays.asList(brokers), _transportFactory.buildTransport()); }
public Hashtable<String, String> loadConfiguration(InputStream stream) { this.configurationInputSourceName = "stream"; return this.loadConfigurationSettings(stream); }
public List<Map<String, String>> pipelinePossibleStates(RangeTag action, List<Map<String, String>> possibleStateList) { String variable = action.getName(); BigDecimal from = new BigDecimal(action.getFrom()); BigDecimal to = new BigDecimal(action.getTo()); BigDecimal step; if (action.getStep() != null) { step = new BigDecimal(action.getStep()); } else { step = BigDecimal.ONE; } List<BigDecimal> rangeValues = new ArrayList<>(); if (step.signum() == 1) { for (BigDecimal current = from; current.compareTo(to) <= 0; current = current.add(step)) { rangeValues.add(current); } } else if (step.signum() == -1) { for (BigDecimal current = from; current.compareTo(to) >= 0; current = current.add(step)) { rangeValues.add(current); } } else { rangeValues.add(from); } List<Map<String, String>> productTemp = new LinkedList<>(); for (Map<String, String> p : possibleStateList) { for (BigDecimal value : rangeValues) { HashMap<String, String> n = new HashMap<>(p); n.put(variable, value.toString()); productTemp.add(n); } } return productTemp; }
public static <K, V> Reshuffle<K, V> of() { return new Reshuffle<>(); }
@Override public boolean allow(final Node parent, final Node child) { return evaluate(parent, child, command -> getCommandManager().allow(getCanvasHandler(), command)); }
public int getOnDemandPsData() throws IOException, IllegalStateException { setPsConf3Ms(PS_TRIGGER_MASK, PS_TRIGGER_ONE_TIME_CYCLE); return getPsData(); }
public static NestedAttributesMap createFullPackageMetadata(final NestedAttributesMap packageJson, final String repositoryName, final String sha1sum, @Nullable final Repository repository, final BiFunction<String, String, String> function) { String name = packageJson.get(NpmAttributes.P_NAME, String.class); String version = packageJson.get(NpmAttributes.P_VERSION, String.class); String now = NPM_TIMESTAMP_FORMAT.print(DateTime.now()); NestedAttributesMap packageRoot = new NestedAttributesMap("metadata", new HashMap<String, Object>()); packageRoot.set(META_ID, name); String packageRootLatestVersion = isNull(repository) ? "" : getPackageRootLatestVersion(packageJson, repository); packageRoot.child(DIST_TAGS).set(LATEST, function.apply(packageRootLatestVersion, version)); packageRoot.child(NpmAttributes.P_USERS); NestedAttributesMap time = packageRoot.child(TIME); time.set(version, now); time.set(MODIFIED, now); time.set(CREATED, now); setBugsUrl(packageJson, packageRoot); for (String field : FULL_HOISTED_FIELDS) { copy(packageRoot, packageJson, field); } NestedAttributesMap versionMap = packageRoot.child(VERSIONS).child(version); versionMap.set(META_ID, name + "@" + version); versionMap.child(DIST).set(NpmAttributes.P_SHASUM, sha1sum); versionMap.child(DIST).set(TARBALL, String.format("%s/repository/%s", repositoryName, NpmMetadataUtils.createRepositoryPath(name, version))); for (String field : FULL_VERSION_MAP_FIELDS) { copy(versionMap, packageJson, field); } NpmMetadataUtils.rewriteTarballUrl(repositoryName, packageRoot); return packageRoot; }
public ListFriendActivitiesRequest listFriendActivities() { return new ListFriendActivitiesRequest(getAPI(ActivityRest.class), this); }
public void shutdown() { try { if (hookThread != null) Runtime.getRuntime().removeShutdownHook(hookThread); ledger.close(); log("shutting down"); network.shutdown(); clientHTTPServer.shutdown(); } catch (Exception e) { } synchronized (parser) { parser.notifyAll(); } try { logger.close(); } catch (Exception e) { e.printStackTrace(); } }
public static void scrub(Map<String, String> attributes, ObjectNode json) throws MessageShouldBeDroppedException, AffectedByBugException { final String namespace = attributes.get(Attribute.DOCUMENT_NAMESPACE); final String docType = attributes.get(Attribute.DOCUMENT_TYPE); final String appName = attributes.get(Attribute.APP_NAME); final String appVersion = attributes.get(Attribute.APP_VERSION); final String appUpdateChannel = attributes.get(Attribute.APP_UPDATE_CHANNEL); final String appBuildId = attributes.get(Attribute.APP_BUILD_ID); if (ParseUri.TELEMETRY.equals(namespace) && "crash".equals(docType) && "nightly".equals(appUpdateChannel) && "20190719094503".equals(appBuildId) && Optional.of(json) .map(j -> j.path("payload").path("metadata").path("MozCrashReason").textValue()) .filter(s -> s.contains("do not use eval with system privileges")) .isPresent()) { throw new MessageShouldBeDroppedException("1567596"); } if (ParseUri.TELEMETRY.equals(namespace) && "crash".equals(docType) && (("nightly".equals(appUpdateChannel) && (appVersion.startsWith("68") || appVersion.startsWith("69"))) || ("beta".equals(appUpdateChannel) && appVersion.startsWith("68"))) && Optional.of(json) .map(j -> j.path("payload").path("metadata").path("RemoteType").textValue()) .filter(s -> s.startsWith("webIsolated=")) .isPresent()) { throw new MessageShouldBeDroppedException("1562011"); } if (ParseUri.TELEMETRY.equals(namespace) && "bhr".equals(docType) && (appVersion.startsWith("68") || appVersion.startsWith("69")) && Optional.of(json) .map(j -> j.path("payload").path("hangs").elements()) .map(Streams::stream).orElseGet(Stream::empty).map(j -> j.path("remoteType")) .filter(JsonNode::isTextual) .anyMatch(j -> j.textValue().startsWith("webIsolated="))) { throw new MessageShouldBeDroppedException("1562011"); } if (IGNORED_NAMESPACES.containsKey(namespace)) { throw new UnwantedDataException(IGNORED_NAMESPACES.get(namespace)); } if (ParseUri.TELEMETRY.equals(namespace) && IGNORED_TELEMETRY_DOCTYPES.containsKey(docType)) { throw new UnwantedDataException(IGNORED_TELEMETRY_DOCTYPES.get(docType)); } if ("FirefoxOS".equals(appName)) { throw new UnwantedDataException("1618684"); } if (ParseUri.TELEMETRY.equals(namespace) && FIREFOX_ONLY_DOCTYPES.contains(docType) && !"Firefox".equals(appName)) { throw new UnwantedDataException("1592010"); } if (bug1489560Affected(attributes, json)) { throw new AffectedByBugException("1489560"); } if ("default-browser-agent".equals(namespace) && "1".equals(docType)) { throw new AffectedByBugException("1626020"); } if (bug1602844Affected(attributes)) { json.path("events").elements().forEachRemaining(event -> { JsonNode eventMapValues = event.path(5); if (eventMapValues.has("fxauid")) { ((ObjectNode) eventMapValues).replace("fxauid", NullNode.getInstance()); } markBugCounter("1602844"); }); } if (bug1162183Affected(attributes)) { JsonNode payload = json.path("payload"); if (payload.has("slowSQL")) { ((ObjectNode) payload).remove("slowSQL"); markBugCounter("1162183"); } } if (bug1642386Affected(attributes)) { json.path("payload").path("syncs").elements().forEachRemaining(syncItem -> { syncItem.path("engines").elements().forEachRemaining(engine -> { ((ObjectNode) engine).remove("outgoing"); markBugCounter("1642386"); }); }); } }
public static <K> KStreamHolder<K> build( final KStreamHolder<K> left, final KStreamHolder<K> right, final StreamStreamJoin<K> join, final KsqlQueryBuilder queryBuilder, final StreamJoinedFactory streamJoinedFactory) { final Formats leftFormats = join.getLeftInternalFormats(); final QueryContext queryContext = join.getProperties().getQueryContext(); final QueryContext.Stacker stacker = QueryContext.Stacker.of(queryContext); final LogicalSchema leftSchema = left.getSchema(); final PhysicalSchema leftPhysicalSchema = PhysicalSchema.from( leftSchema, leftFormats.getOptions() ); final Serde<GenericRow> leftSerde = queryBuilder.buildValueSerde( leftFormats.getValueFormat(), leftPhysicalSchema, stacker.push(LEFT_SERDE_CTX).getQueryContext() ); final Formats rightFormats = join.getRightInternalFormats(); final LogicalSchema rightSchema = right.getSchema(); final PhysicalSchema rightPhysicalSchema = PhysicalSchema.from( rightSchema, rightFormats.getOptions() ); final Serde<GenericRow> rightSerde = queryBuilder.buildValueSerde( rightFormats.getValueFormat(), rightPhysicalSchema, stacker.push(RIGHT_SERDE_CTX).getQueryContext() ); final Serde<K> keySerde = left.getKeySerdeFactory().buildKeySerde( leftFormats.getKeyFormat(), leftPhysicalSchema, queryContext ); final StreamJoined<K, GenericRow, GenericRow> joined = streamJoinedFactory.create( keySerde, leftSerde, rightSerde, StreamsUtil.buildOpName(queryContext), StreamsUtil.buildOpName(queryContext) ); final JoinParams joinParams = JoinParamsFactory .create(join.getKeyColName(), leftSchema, rightSchema); final JoinWindows joinWindows = JoinWindows.of(join.getBeforeMillis()).after(join.getAfterMillis()); final KStream<K, GenericRow> result; switch (join.getJoinType()) { case LEFT: result = left.getStream().leftJoin( right.getStream(), joinParams.getJoiner(), joinWindows, joined); break; case OUTER: result = left.getStream().outerJoin( right.getStream(), joinParams.getJoiner(), joinWindows, joined); break; case INNER: result = left.getStream().join( right.getStream(), joinParams.getJoiner(), joinWindows, joined); break; default: throw new IllegalStateException("invalid join type"); } return left.withStream(result, joinParams.getSchema()); }
public Set<String> getPaths(long sessionId) { Set<String> s = id2paths.get(sessionId); return s != null ? Collections.unmodifiableSet(s) : null; }
@Override public O handle(T item, AbstractMessageReport report, ReportStats reportStats) { return handle(item, report, reportStats, new FileProcessStatus()); }
public boolean isValidForAddOperation() { if (!this.isSignatureValid()) return false; if (protectedStoragePayload instanceof MailboxStoragePayload) { MailboxStoragePayload mailboxStoragePayload = (MailboxStoragePayload) this.getProtectedStoragePayload(); return mailboxStoragePayload.getSenderPubKeyForAddOperation().equals(this.getOwnerPubKey()); } else { boolean result = this.ownerPubKey.equals(protectedStoragePayload.getOwnerPubKey()); if (!result) { String res1 = this.toString(); String res2 = "null"; if (protectedStoragePayload.getOwnerPubKey() != null) res2 = Utilities.encodeToHex(protectedStoragePayload.getOwnerPubKey().getEncoded(), true); log.warn("ProtectedStorageEntry::isValidForAddOperation() failed. Entry owner does not match Payload owner:\n" + "ProtectedStorageEntry={}\nPayloadOwner={}", res1, res2); } return result; } }
public static JBBPCompiledBlock compile(final String script) throws IOException { return compile(script, null); }
public static ClusterMembership from(String stringValue, Version vespaVersion) { return new ClusterMembership(stringValue, vespaVersion, Optional.empty()); }
@Override public SdkHttpRequest modifyHttpRequest(Context.ModifyHttpRequest context, ExecutionAttributes executionAttributes) { SdkHttpRequest request = context.httpRequest(); if (!request.headers().containsKey(X_AMZ_ACCOUNT_ID)) { throw SdkClientException.create("Account ID must be specified for all requests"); } String accountId = request.headers().get(X_AMZ_ACCOUNT_ID).get(0); S3ControlConfiguration config = (S3ControlConfiguration) executionAttributes.getAttribute( AwsSignerExecutionAttribute.SERVICE_CONFIG); String host = resolveHost(request, accountId, config); return request.toBuilder() .host(host) .build(); }
public PluginControllerImpl createController(String standard, Tokenizer tokenizer) { return new PluginControllerImpl(standard, tokenizer); }
@Async public void projectIterationUpdate(@Observes ProjectIterationUpdate payload) { projectIterationUpdate(payload.getIteration(), Optional.<String> absent(), Optional.of(payload.getOldSlug())); }
@Override public List<GoogleCloudStorageItemInfo> listObjectInfo( String bucketName, String objectNamePrefix, String delimiter) throws IOException { logger.atFine().log( "%s.listObjectInfo(%s, %s, %s)", delegateClassName, bucketName, objectNamePrefix, delimiter); return delegate.listObjectInfo(bucketName, objectNamePrefix, delimiter); }
@Deprecated public static void write(String str, final OutputStream outputStream) throws IOException { write(str, outputStream, Charset.defaultCharset()); }
public static void transformConfigFile(InputStream sourceStream, String destPath, Properties bootstrapProperties) throws Exception { ConvertableSchema<ConfigSchema> convertableSchema = throwIfInvalid(SchemaLoader.loadConvertableSchemaFromYaml(sourceStream)); ConfigSchema configSchema = throwIfInvalid(convertableSchema.convert()); SecurityPropertiesSchema securityProperties = BootstrapTransformer.buildSecurityPropertiesFromBootstrap(bootstrapProperties).orElse(null); ProvenanceReportingSchema provenanceReportingProperties = BootstrapTransformer.buildProvenanceReportingPropertiesFromBootstrap(bootstrapProperties).orElse(null); if (securityProperties != null) { configSchema.setSecurityProperties(securityProperties); logger.info("Bootstrap flow override: Replaced security properties"); } if (provenanceReportingProperties != null) { configSchema.setProvenanceReportingProperties(provenanceReportingProperties); logger.info("Bootstrap flow override: Replaced provenance reporting properties"); } if (BootstrapTransformer.processorSSLOverride(bootstrapProperties)) { for (ProcessorSchema processorConfig : configSchema.getProcessGroupSchema().getProcessors()) { processorConfig.getProperties().replace("SSL Context Service", processorConfig.getProperties().get("SSL Context Service"), "SSL-Context-Service"); logger.info("Bootstrap flow override: Replaced {} SSL Context Service with parent MiNiFi SSL", processorConfig.getName()); } } ByteArrayOutputStream nifiPropertiesOutputStream = new ByteArrayOutputStream(); writeNiFiProperties(configSchema, nifiPropertiesOutputStream); writeFlowXmlFile(configSchema, destPath); writeNiFiPropertiesFile(nifiPropertiesOutputStream, destPath); }
@Nullable public static JavaModuleDependency copy(IdeaProject project, IdeaModuleDependency original) { IdeaModule targetModule = null; for (IdeaModule module : project.getModules()) { if (module.getName().equals(original.getTargetModuleName())) { targetModule= module; } } if (targetModule != null && isNotEmpty(targetModule.getName())) { String scope = null; IdeaDependencyScope originalScope = original.getScope(); if (originalScope != null) { scope = originalScope.getScope(); } GradleProject gradleProject = targetModule.getGradleProject(); File projectFolder; try { projectFolder = gradleProject.getProjectIdentifier().getBuildIdentifier().getRootDir(); } catch (UnsupportedMethodException ex) { GradleProject rootGradleProject = gradleProject; while (rootGradleProject.getParent() != null) { rootGradleProject = rootGradleProject.getParent(); } projectFolder = rootGradleProject.getProjectDirectory(); } String moduleId = createUniqueModuleId(projectFolder, gradleProject.getPath()); return new JavaModuleDependency(targetModule.getName(), moduleId, scope, original.getExported()); } return null; }
public void add(T object) { synchronized (mutex) { ParseRelationOperation<T> operation = new ParseRelationOperation<>(Collections.singleton(object), null); targetClass = operation.getTargetClass(); getParent().performOperation(key, operation); knownObjects.add(object); } }
@Override protected boolean matches(Object value) { return Boolean.TRUE.equals(value); }
public String resolve() { Timestamp timestamp = RuntimeProvider.createTimestamp(); StringBuilder builder = new StringBuilder(); for (Segment segment : segments) { builder.append(segment.createToken(builder.toString(), timestamp)); } return builder.toString(); }
public static DimensionResource fromString(@NonNull String resource) throws IllegalArgumentException { return new DimensionResource(getTypeFromString(resource), getValueFromString(resource)); }
@Override public String getValueFromMessage(AdaptrisMessage msg) throws CoreException { NamespaceContext ctx = SimpleNamespaceContext.create(getNamespaceContext(), msg); DocumentBuilderFactoryBuilder builder = documentFactoryBuilder(ctx); String result = null; try { XPath xp = XPath.newXPathInstance(builder, ctx); Document d = XmlHelper.createDocument(msg, builder); result = xp.selectSingleTextItem(d, msg.resolve(getXpath())); } catch (Exception e) { throw ExceptionHelper.wrapCoreException(e); } return result; }
public String getJson() throws SanskritException { try { return objectMapper.writeValueAsString(objectNode); } catch (JsonProcessingException e) { throw new SanskritException(e); } }
@Override public Iterable<K> apply(final Map<K, V> map) { return null == map ? null : map.keySet(); }
public static ASTJexlScript parseJexlQuery(String query) throws ParseException { Parser parser = new Parser(new StringReader(";")); String caseFixQuery = AND_PATTERN.matcher(query).replaceAll(" and "); caseFixQuery = OR_PATTERN.matcher(caseFixQuery).replaceAll(" or "); caseFixQuery = NOT_PATTERN.matcher(caseFixQuery).replaceAll(" not "); if (caseFixQuery.contains(DOUBLE_BACKSLASH)) { try { return parseQueryWithBackslashes(query, parser); } catch (Exception e) { throw new ParseException("Unable to perform backslash substitution while parsing the query: " + e.getMessage()); } } else { try { return parser.parse(new StringReader(caseFixQuery), null); } catch (TokenMgrError e) { throw new ParseException(e.getMessage()); } } }
@Override public String resolvePlaceholdersInText(String text, Map<String, String> overrides) { List<PlaceholderResolver.Placeholder> placeholders = extractPlaceholders(text); String resolvedText = text; for (PlaceholderResolver.Placeholder placeholder : placeholders) { resolvedText = resolvePlaceholderInText(resolvedText, placeholder, overrides); } return resolvedText; }
public static String secure(String value, String delim) { if (null == value) { return null; } return Stream.of(value.split("/", -1)) .map(it -> it.isEmpty() ? it : secure(it)) .collect(Collectors.joining(delim)); }
public static ChronoUnit of(TimeUnit unit) { return Optional.ofNullable(TIME_UNIT_TO_CHRONO_UNIT.get(unit)) .orElseThrow(() -> new IllegalArgumentException("Unsupported TimeUnit.")); }
public boolean hasVirus(final StorageFileItem item) { return item.getName().contains("infected"); }
public static Properties combineProperties(Properties props, final Configuration conf) { return combineProperties(props, conf, Collections.<String>emptySet()); }
public DiscreteInterval getTimeRemaining() { if (!wasSet) throw new IllegalStateException("cannot compute time remaining without having duration set"); if (startTime == null) return targetElapsedTime; DiscreteInterval diff = targetEndTime.minus(clock.getNanoTime()); return (diff.getMin() <= 0L) ? new DiscreteInterval(0L,0L) : diff; }
@Override protected ClientReportUnitType resourceSpecificFieldsToClient(ClientReportUnitType client, ServerReportUnitType serverObject, ToClientConversionOptions options) { client.setAlwaysPromptControls(serverObject.isAlwaysPromptControls()); final ClientReportUnit.ControlsLayoutType controlsLayout; switch (serverObject.getControlsLayout()) { case ReportUnit.LAYOUT_POPUP_SCREEN: controlsLayout = ClientReportUnit.ControlsLayoutType.popupScreen; break; case ReportUnit.LAYOUT_SEPARATE_PAGE: controlsLayout = ClientReportUnit.ControlsLayoutType.separatePage; break; case ReportUnit.LAYOUT_IN_PAGE: controlsLayout = ClientReportUnit.ControlsLayoutType.inPage; break; case ReportUnit.LAYOUT_TOP_OF_PAGE: controlsLayout = ClientReportUnit.ControlsLayoutType.topOfPage; break; default: controlsLayout = ClientReportUnit.ControlsLayoutType.popupScreen; } client.setControlsLayout(controlsLayout); client.setInputControlRenderingView(serverObject.getInputControlRenderingView()); client.setReportRenderingView(serverObject.getReportRenderingView()); client.setQuery(resourceReferenceConverterProvider.getConverterForType(ClientReferenceableQuery.class) .toClient(serverObject.getQuery(), options)); client.setJrxml(resourceReferenceConverterProvider.getConverterForType(ClientReferenceableFile.class) .toClient(serverObject.getMainReport(), options)); List<ClientReferenceableInputControl> inputControls = null; final List<ResourceReference> serverInputControls = serverObject.getInputControls(); if (serverInputControls != null && !serverInputControls.isEmpty()) { inputControls = new ArrayList<ClientReferenceableInputControl>(serverInputControls.size()); final ResourceReferenceConverter<ClientReferenceableInputControl> inputControlResourceReferenceConverter = resourceReferenceConverterProvider.getConverterForType(ClientReferenceableInputControl.class); for (ResourceReference inputControlReference : serverInputControls) { inputControls.add(inputControlResourceReferenceConverter.toClient(inputControlReference, options)); } } client.setInputControls(inputControls); @SuppressWarnings("unchecked") final List<ResourceReference> resources = serverObject.getResources(); client.setFiles(convertResourcesToClient(resources, options)); return client; }
public static boolean containsJson(String buffer) { return CharMatcher.ascii() .and(CharMatcher.inRange('\u0001', '\u001f').negate()) .and(CharMatcher.inRange('\u007f', '\u009f').negate()) .and(CharMatcher.ascii()) .matchesAllOf(buffer); }
@Override public Set<K> keySet() { return this.BACKING_MULTIMAP.keySet(); }
public Citation convert(eu.dnetlib.iis.citationmatching.direct.schemas.Citation directCitation) { Preconditions.checkNotNull(directCitation); CitationEntry citationEntry = CitationEntry.newBuilder() .setPosition(directCitation.getPosition()) .setRawText(null) .setDestinationDocumentId(directCitation.getDestinationDocumentId()) .setConfidenceLevel(1f) .setExternalDestinationDocumentIds(Maps.newHashMap()) .build(); Citation citation = Citation.newBuilder() .setSourceDocumentId(directCitation.getSourceDocumentId()) .setEntry(citationEntry) .build(); return citation; }
public static UEnhancedForLoop create( UVariableDecl variable, UExpression elements, UStatement statement) { return new AutoValue_UEnhancedForLoop(variable, elements, (USimpleStatement) statement); }
public List<Transaction> categorize(List<Transaction> transactions) { checkNotNull(transactions); ImmutableList.Builder<Transaction> builder = ImmutableList.builder(); for (Transaction transaction : transactions) { builder.add(categorize(transaction)); } return builder.build(); }
public LDAPConnection buildLdapConnection() throws GeneralSecurityException, LDAPException { SSLSocketFactory sslSocketFactory = SSL_UTIL.createSSLSocketFactory(); return new LDAPConnection(sslSocketFactory, ldapProperties.getHost(), ldapProperties.getPort()); }
@Override public void setAlpha(float alpha) { if (isPatch()) { setAlphaPatch(alpha); return; } if (alpha < 0f || alpha > 1f) { throw new IllegalArgumentException("invalid alpha value " + alpha); } float oldValue = getAlpha(); this.alpha = alpha; if (getAlpha() < 1f) { if (oldValue == 1) { oldOpaque = isOpaque(); super.setOpaque(false); } installRepaintManager(); } else { uninstallRepaintManager(); if (oldOpaque) { super.setOpaque(true); } } firePropertyChange("alpha", oldValue, getAlpha()); repaint(); }
public static Class<?> getEntityClassFromNodeLabels(final List<String> labels, final List<Class<?>> classes) throws NoSuchClassException { for (final String label : labels) { final Optional<Class<?>> classHit = classes.stream().filter(c -> { if (c.getName().endsWith(label)) { return true; } else { final Table annotation = c.getAnnotation(Table.class); return annotation != null && annotation.name().equals(label); } }).findFirst(); if (classHit.isPresent()) { return classHit.get(); } } throw new NoSuchClassException("could not find class for a node with " + labels + " labels."); }
@PostConstruct public void init() { view.init(this); view.getVariableSelectorDropDown().init(variableSearchService, variableSearchSelectionHandler); view.getVariableSelectorDropDown().setOnChange(this::onVariableChange); view.getConditionSelectorDropDown().init(functionSearchService, functionSearchSelectionHandler); view.getConditionSelectorDropDown().setSearchCacheEnabled(false); view.getConditionSelectorDropDown().setOnChange(this::onConditionChange); }
public void cleanup(Stack stack, boolean hostOnly, boolean recover, Set<String> hostNames, Set<String> ips) { Optional<KerberosConfig> kerberosConfig = kerberosConfigService.get(stack.getEnvironmentCrn(), stack.getName()); boolean childEnvironment = environmentConfigProvider.isChildEnvironment(stack.getEnvironmentCrn()); if (kerberosDetailService.keytabsShouldBeUpdated(stack.cloudPlatform(), childEnvironment, kerberosConfig)) { OperationStatus operationStatus = sendCleanupRequest(stack, hostOnly, recover, hostNames, ips); pollCleanupOperation(operationStatus); } }
@Override public void setValidArtifactID(final boolean isValid) { view.setValidArtifactID(isValid); }
public void updateLikes(List<Integer> inProgress, List<Integer> likedIds) { mInProgress = inProgress; mLikedIds = likedIds; if (mRepository == null || mInProgress == null || mLikedIds == null) { return; } boolean isInProgress = inProgress.contains(mRepository.getId()); boolean isLiked = likedIds.contains(mRepository.getId()); getViewState().updateLike(isInProgress, isLiked); }
@Override public DataGenerator<List<A>> apply() { UnionDataGenerator nextGen = new UnionDataGenerator(this, position + 1); return nextGen.isClosed() ? (DataGenerator<List<A>>) EOS : nextGen; }
public void setColumnFormatterMap( Map<String, ColumnFormatter> columnFormatterMap) { this.columnFormatterMap = columnFormatterMap; }
public static boolean validateStartRoute(ShellConfiguration shellConfiguration, RouterConfiguration routerConfiguration, String route) { return validateRoute(shellConfiguration, routerConfiguration, route, true, false); }
@Override public void serialize(BarrierInput message, ByteBuf outBuffer) { ByteBufUtils.writeOFHeader(MESSAGE_TYPE, message, outBuffer, EncodeConstants.OFHEADER_SIZE); }
@Override public <K, V> void forward(final K key, final V value) { throw new StreamsException(EXPLANATION); }
public static Builder builder() { return new Builder(); }
@Override public CloudCredentialStatus verify(@Nonnull AuthenticatedContext authenticatedContext) { LOGGER.debug("Verify credential: {}", authenticatedContext.getCloudCredential()); GcpStackUtil.prepareCredential(authenticatedContext.getCloudCredential()); GcpContext gcpContext = gcpContextBuilder.contextInit(authenticatedContext.getCloudContext(), authenticatedContext, null, null, false); try { gcpCredentialVerifier.checkGcpContextValidity(gcpContext); gcpCredentialVerifier.preCheckOfGooglePermission(gcpContext); } catch (TokenResponseException te) { return createFailedCloudCredentialStatusWithExc(te, authenticatedContext, getErrDescriptionFromTokenResponse(te)); } catch (Exception e) { return createFailedCloudCredentialStatusWithExc(e, authenticatedContext, Optional.empty()); } return new CloudCredentialStatus(authenticatedContext.getCloudCredential(), CredentialStatus.VERIFIED); }
public CloseableThriftHiveMetastoreIface newInstance(AbstractMetaStore metaStore) { String uris = MetaStoreUriNormaliser.normaliseMetaStoreUris(metaStore.getRemoteMetaStoreUris()); String name = metaStore.getName().toLowerCase(Locale.ROOT); int connectionTimeout = Math.max(1, defaultConnectionTimeout + (int) metaStore.getLatency()); if (metaStore.getConnectionType() == TUNNELED) { return tunnelingMetaStoreClientFactory .newInstance(uris, metaStore.getMetastoreTunnel(), name, DEFAULT_CLIENT_FACTORY_RECONNECTION_RETRY, connectionTimeout); } Map<String, String> properties = new HashMap<>(); properties.put(ConfVars.METASTOREURIS.varname, uris); HiveConfFactory confFactory = new HiveConfFactory(Collections.emptyList(), properties); return defaultMetaStoreClientFactory .newInstance(confFactory.newInstance(), "waggledance-" + name, DEFAULT_CLIENT_FACTORY_RECONNECTION_RETRY, connectionTimeout); }
static public WithStatement parse(String statement, String templatePath) throws TokenException { boolean nullSafe = false; if (statement.startsWith("?")) { nullSafe = true; statement = statement.substring(1).trim(); } if (!statement.startsWith("(")) { throw new TokenException("With block does not start with parenthese"); } if (!statement.endsWith(")")) { throw new TokenException("With block does not end with parenthese"); } statement = statement.substring(1, statement.length() - 1); final List<VariableWithExpression> variables = new ArrayList<>(); final List<String> withStatements = parseWithStatement(statement, templatePath); for(int i = 0; i < withStatements.size(); i++) { final String withStatement = withStatements.get(i); final int equalsPos = withStatement.indexOf('='); if (equalsPos < 0) { throw new TokenException("With block invalid: no equals symbol found for assignment: " + withStatement); } if (withStatement.indexOf('=', equalsPos+1) > 0) { throw new TokenException("With block invalid: multiple equals symbols found for assignment " + withStatement); } final String varPart = withStatement.substring(0, equalsPos); final JavaVariable variable = JavaVariable.parse(varPart); final String valueExpression = withStatement.substring(equalsPos+1).trim(); if (valueExpression.equals("")) { throw new TokenException("With block contains an empty string for value part (e.g. var = value)"); } variables.add(new VariableWithExpression(variable, valueExpression)); } if(nullSafe && variables.size() > 1) { throw new TokenException("Nullsafe option not allowed for with block with multiple arguments"); } return new WithStatement(variables, nullSafe); }
@CheckReturnValue @SchedulerSupport(SchedulerSupport.COMPUTATION) public static Completable timer(long delay, TimeUnit unit) { return timer(delay, unit, Schedulers.computation()); }
public FEELFnResult<Boolean> invoke(@ParameterName( "range1" ) Range range1, @ParameterName( "range2" ) Range range2) { return OverlapsFunction.INSTANCE.invoke(range1, range2); }
@Override public <T extends Object> PrismPropertyValue<T> apply(PrismPropertyValue<T> propertyValue) { Validate.notNull(propertyValue, "Node must not be null."); String text = getStringValue(propertyValue); if (StringUtils.isEmpty(text)) { return propertyValue; } String newValue = Normalizer.normalize(text, Form.NFD).replaceAll( "\\p{InCombiningDiacriticalMarks}+", ""); propertyValue.setValue((T) newValue); return propertyValue; }
public synchronized void acquire() { updatePermits(); while(availablePermits < 1.0) { try { Thread.sleep(Math.min(1L, (long)(availablePermits / permitsPerNanoSecond * NANOSECONDS_PER_MILLISECOND))); } catch(InterruptedException e) { } updatePermits(); } availablePermits -= 1.0; }
String getUnit() { return band.getUnit(); }
@Override public User insert(User user) { Objects.requireNonNull(user); long now = Instant.now().toEpochMilli(); Document doc = new Document("_id", user.getEmail().getAddress()) .append("id", UUID.randomUUID().toString()) .append("version", UUID.randomUUID().toString()) .append("creation_time", String.valueOf(now)) .append("update_time", String.valueOf(now)) .append("document", UsersDao.toJson(mapper, user)); try { mongoCollection.insertOne(doc); } catch (MongoWriteException e) { switch (e.getError().getCategory()) { case DUPLICATE_KEY: LOG.error("The user {} already exists in the database.", user.getEmail(), e); throw new DatabaseException("The user already exists.", DatabaseError.CONFLICT); case EXECUTION_TIMEOUT: LOG.error("The insert operation for user {} timed out.", user.getEmail(), e); throw new DatabaseException("The insert operation timed out.", DatabaseError.DATABASE_DOWN); case UNCATEGORIZED: default: LOG.error("The insert for {} was rejected for an unknown reason.", user.getEmail(), e); throw new DatabaseException("The insert request was rejected for an unknown reason.", DatabaseError.REQUEST_REJECTED); } } catch (MongoTimeoutException e) { LOG.error("The database is currently unresponsive.", e); throw new DatabaseException("The database is currently unavailable.", DatabaseError.DATABASE_DOWN); } return user; }
public static RpslObject parse(final String input) { return new RpslObject(RpslObjectBuilder.getAttributes(input)); }
public Vec3 multiply(double scalar) { this.x *= scalar; this.y *= scalar; this.z *= scalar; return this; }
public BooleanExpression lt(String val) { return BooleanOperation.create(Ops.LT, this, literal(val)); }
public static ContinuousCompoundInterest of(RateAndPeriods rateAndPeriods) { return new ContinuousCompoundInterest(rateAndPeriods); }
public double[] gradient(double theta, double[] iparam, int k, double D){ double a = 1; double b = 0; double c = 0; double u = slipping; double[] deriv = new double[numberOfParameters]; if(numberOfParameters==3){ a = iparam[0]; b = iparam[1]; c = iparam[2]; }else if(numberOfParameters==2){ a = iparam[0]; b = iparam[1]; c = guessing; }else{ a = discrimination; b = iparam[0]; c = guessing; } double w = D*(theta-b); double z = Math.exp(D*a*(theta-b)); double z2 = z*z; double d = 1+z; double d2 = d*d; double xmc = u-c; if(numberOfParameters==3){ deriv[0] = xmc*z*w/d - xmc*z2*w/d2; deriv[1] = -(xmc*z*D*a/d - xmc*z2*D*a/d2); deriv[2] = 1.0 - z/d; if(k==0){ deriv[0] = -deriv[0]; deriv[1] = -deriv[1]; deriv[2] = -deriv[2]; } }else if(numberOfParameters==2){ deriv[0] = xmc*z*w/d - xmc*z2*w/d2; deriv[1] = -(xmc*z*D*a/d - xmc*z2*D*a/d2); if(k==0){ deriv[0] = -deriv[0]; deriv[1] = -deriv[1]; } }else{ deriv[0] = -(xmc*z*D*a/d - xmc*z2*D*a/d2); if(k==0){ deriv[0] = -deriv[0]; } } return deriv; }
@Override public void dispose() { disposable.dispose(); }
@Override public Object getValue(int row, String column) throws DataSetException { Object value = delegate.getValue(row, column); if (value != null && scriptEnginePattern.matcher(value.toString()).matches()) { ScriptEngine engine = getScriptEngine(value.toString().trim()); if (engine != null) { try { return getScriptResult(value.toString(), engine); } catch (Exception e) { log.log(Level.WARNING,String.format("Could not evaluate script expression for table '%s', column '%s'. The original value will be used.", getTableMetaData().getTableName(), column),e); } } } return value; }
public List<Target> getTargets() { return targets; }
@Override public void execute(CommandLine commandLine, Options options, RPCHook rpcHook) throws SubCommandException { DefaultMQAdminExt defaultMQAdminExt = new DefaultMQAdminExt(rpcHook); defaultMQAdminExt.setInstanceName(Long.toString(System.currentTimeMillis())); try { defaultMQAdminExt.start(); String brokerAddr = commandLine.hasOption('b') ? commandLine.getOptionValue('b').trim() : null; String clusterName = commandLine.hasOption('c') ? commandLine.getOptionValue('c').trim() : null; if (brokerAddr != null) { printBrokerRuntimeStats(defaultMQAdminExt, brokerAddr, false); } else if (clusterName != null) { Set<String> masterSet = CommandUtil.fetchMasterAndSlaveAddrByClusterName(defaultMQAdminExt, clusterName); for (String ba : masterSet) { try { printBrokerRuntimeStats(defaultMQAdminExt, ba, true); } catch (Exception e) { e.printStackTrace(); } } } } catch (Exception e) { throw new SubCommandException(this.getClass().getSimpleName() + " command failed", e); } finally { defaultMQAdminExt.shutdown(); } }
public Execution executeAlgorithm( de.metanome.backend.results_db.Algorithm storedAlgorithm, List<ConfigurationValue> parameters, List<Input> inputs, String executionIdentifier, ExecutionSetting executionSetting) throws Exception { AlgorithmAnalyzer analyzer = new AlgorithmAnalyzer(storedAlgorithm.getFileName()); Algorithm algorithm = analyzer.getAlgorithm(); Set<Result> results = new HashSet<>(); for (ConfigurationValue configValue : parameters) { configValue.triggerSetValue(algorithm, analyzer.getInterfaces()); } if (analyzer.hasType(AlgorithmType.FD)) { FunctionalDependencyAlgorithm fdAlgorithm = (FunctionalDependencyAlgorithm) algorithm; fdAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.FD)); } if (analyzer.hasType(AlgorithmType.CID)) { ConditionalInclusionDependencyAlgorithm cidAlgorithm = (ConditionalInclusionDependencyAlgorithm) algorithm; cidAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.CID)); } if (analyzer.hasType(AlgorithmType.MD)) { MatchingDependencyAlgorithm mdAlgorithm = (MatchingDependencyAlgorithm) algorithm; mdAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.MD)); } if (analyzer.hasType(AlgorithmType.CFD)) { ConditionalFunctionalDependencyAlgorithm cfdAlgorithm = (ConditionalFunctionalDependencyAlgorithm) algorithm; cfdAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.CFD)); } if (analyzer.hasType(AlgorithmType.IND)) { InclusionDependencyAlgorithm indAlgorithm = (InclusionDependencyAlgorithm) algorithm; indAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.IND)); } if (analyzer.hasType(AlgorithmType.UCC)) { UniqueColumnCombinationsAlgorithm uccAlgorithm = (UniqueColumnCombinationsAlgorithm) algorithm; uccAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.UCC)); } if (analyzer.hasType(AlgorithmType.CUCC)) { ConditionalUniqueColumnCombinationAlgorithm cuccAlgorithm = (ConditionalUniqueColumnCombinationAlgorithm) algorithm; cuccAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.CUCC)); } if (analyzer.hasType(AlgorithmType.OD)) { OrderDependencyAlgorithm odAlgorithm = (OrderDependencyAlgorithm) algorithm; odAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.OD)); } if (analyzer.hasType(AlgorithmType.MVD)) { MultivaluedDependencyAlgorithm mvdAlgorithm = (MultivaluedDependencyAlgorithm) algorithm; mvdAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.MVD)); } if (analyzer.hasType(AlgorithmType.BASIC_STAT)) { BasicStatisticsAlgorithm basicStatAlgorithm = (BasicStatisticsAlgorithm) algorithm; basicStatAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.BASIC_STAT)); } if (analyzer.hasType(AlgorithmType.DC)) { DenialConstraintAlgorithm dcAlgorithm = (DenialConstraintAlgorithm) algorithm; dcAlgorithm.setResultReceiver(resultReceiver); results.add(new Result(resultPathPrefix, ResultType.DC)); } if (analyzer.hasType(AlgorithmType.TEMP_FILE)) { TempFileAlgorithm tempFileAlgorithm = (TempFileAlgorithm) algorithm; tempFileAlgorithm.setTempFileGenerator(fileGenerator); } long beforeWallClockTime = new Date().getTime(); long before = System.nanoTime(); Execution execution = new Execution(storedAlgorithm, beforeWallClockTime) .setRunning(true) .setInputs(inputs) .setIdentifier(executionIdentifier); execution.setExecutionSetting(executionSetting); HibernateUtil.store(execution); try { algorithm.execute(); } catch (Throwable e) { execution = execution .setRunning(false) .setAborted(true); for (Result result : results) { result.setExecution(execution); } HibernateUtil.update(execution); throw new AlgorithmExecutionException("Algorithm execution failed.", e); } long after = System.nanoTime(); long executionTimeInNanos = after - before; long executionTimeInMs = executionTimeInNanos / 1000000; execution = execution .setRunning(false) .setEnd(beforeWallClockTime + executionTimeInMs) .setResults(results) .setCountResult(executionSetting.getCountResults()); for (Result result : results) { result.setExecution(execution); } execution.setExecutionSetting(executionSetting); HibernateUtil.update(execution); return execution; }
@Override protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException { response.setContentType("application/json"); PrintWriter out = response.getWriter(); Map<String, StubDescriptor> stubDescriptors = routingService.getStubDescriptors(); writeAllDialogDescriptors(out, stubDescriptors); out.flush(); out.close(); }
@SuppressWarnings({"ConstantConditions", "unchecked"}) public static UnivariatePolynomial<Rational<BigInteger>>[] ModularExtendedRationalGCD( UnivariatePolynomial<Rational<BigInteger>> a, UnivariatePolynomial<Rational<BigInteger>> b) { if (a == b || a.equals(b)) return new UnivariatePolynomial[]{a.clone(), a.createZero(), a.createOne()}; if (a.degree() < b.degree()) { UnivariatePolynomial<Rational<BigInteger>>[] r = ModularExtendedRationalGCD(b, a); ArraysUtil.swap(r, 1, 2); return r; } if (b.isZero()) { UnivariatePolynomial<Rational<BigInteger>>[] result = a.createArray(3); result[0] = a.clone(); result[1] = a.createOne(); result[2] = a.createZero(); return normalizeExtendedGCD(result); } Tuple2<UnivariatePolynomial<BigInteger>, BigInteger> ac = toCommonDenominator(a), bc = toCommonDenominator(b); UnivariatePolynomial<BigInteger> az = ac._1, bz = bc._1; BigInteger aContent = az.content(), bContent = bz.content(); UnivariatePolynomial<Rational<BigInteger>>[] xgcd = ModularExtendedRationalGCD0( az.clone().divideOrNull(aContent), bz.clone().divideOrNull(bContent)); xgcd[1].multiply(new Rational<>(Z, ac._2, aContent)); xgcd[2].multiply(new Rational<>(Z, bc._2, bContent)); return xgcd; }
public <T> void setProperty(@NonNull final String key, T value) { Class clazz = value.getClass(); if(Number.class.isAssignableFrom(clazz) || String.class == clazz || Boolean.class == clazz) { properties.put(key, value); } else { throw new RuntimeException("Value must be of type Number, String or Boolean"); } }
@Override public <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments) { final Query<T> theQuery = query.getQuery(); final Integer priority = theQuery.getContextValue(QueryContexts.PRIORITY_KEY); final String lane = theQuery.getContextValue(QueryContexts.LANE_KEY); if (lane == null && priority != null && priority < 0) { return Optional.of(LOW); } return Optional.ofNullable(lane); }
@Override public void tokenize( CharacterStream input, Tokens tokens ) throws ParsingException { while (input.hasNext()) { char c = input.next(); switch (c) { case ' ': case '\t': case '\n': case '\r': break; case '[': case ']': case '<': case '>': case '=': case '-': case '+': case '(': case ')': case ',': tokens.addToken(input.position(input.index()), input.index(), input.index() + 1, SYMBOL); break; case '{': int startIndex = input.index(); Position startingPosition = input.position(startIndex); boolean foundClosingBrace = false; while (input.hasNext()) { c = input.next(); if (c == '\\' && input.isNext('}')) { c = input.next(); } else if (c == '}') { foundClosingBrace = true; break; } } if (!foundClosingBrace) { String msg = CndI18n.vendorBlockWasNotClosed.text(startingPosition.getLine(), startingPosition.getColumn()); throw new ParsingException(startingPosition, msg); } int endIndex = input.index() + 1; if (useVendorExtensions) { tokens.addToken(startingPosition, startIndex, endIndex, VENDOR_EXTENSION); } break; case '\"': startIndex = input.index(); startingPosition = input.position(startIndex); boolean foundClosingQuote = false; while (input.hasNext()) { c = input.next(); if (c == '\\' && input.isNext('"')) { c = input.next(); } else if (c == '"') { foundClosingQuote = true; break; } } if (!foundClosingQuote) { String msg = CommonI18n.noMatchingDoubleQuoteFound.text(startingPosition.getLine(), startingPosition.getColumn()); throw new ParsingException(startingPosition, msg); } endIndex = input.index() + 1; tokens.addToken(startingPosition, startIndex, endIndex, DOUBLE_QUOTED_STRING); break; case '\'': startIndex = input.index(); startingPosition = input.position(startIndex); foundClosingQuote = false; while (input.hasNext()) { c = input.next(); if (c == '\\' && input.isNext('\'')) { c = input.next(); } else if (c == '\'') { foundClosingQuote = true; break; } } if (!foundClosingQuote) { String msg = CommonI18n.noMatchingSingleQuoteFound.text(startingPosition.getLine(), startingPosition.getColumn()); throw new ParsingException(startingPosition, msg); } endIndex = input.index() + 1; tokens.addToken(startingPosition, startIndex, endIndex, SINGLE_QUOTED_STRING); break; case '/': startIndex = input.index(); startingPosition = input.position(startIndex); if (input.isNext('/')) { boolean foundLineTerminator = false; while (input.hasNext()) { c = input.next(); if (c == '\n' || c == '\r') { foundLineTerminator = true; break; } } endIndex = input.index(); if (!foundLineTerminator) ++endIndex; if (c == '\r' && input.isNext('\n')) input.next(); if (useComments) { tokens.addToken(startingPosition, startIndex, endIndex, COMMENT); } } else if (input.isNext('*')) { while (input.hasNext() && !input.isNext('*', '/')) { c = input.next(); } if (input.hasNext()) input.next(); if (input.hasNext()) input.next(); if (useComments) { endIndex = input.index() + 1; tokens.addToken(startingPosition, startIndex, endIndex, COMMENT); } } else { continue; } break; default: startIndex = input.index(); startingPosition = input.position(startIndex); while (input.hasNext() && !(input.isNextWhitespace() || input.isNextAnyOf("[]<>=-+(),\"'/{*|"))) { c = input.next(); } endIndex = input.index() + 1; tokens.addToken(startingPosition, startIndex, endIndex, WORD); } } }
public final E_Now now() { return new E_Now(); }
public Task<FetchResponse> fetch() { return fetch(frcMetadata.getMinimumFetchIntervalInSeconds()); }
public Optional<Interceptor<INPUT, OUTPUT>> last() { if (next.isPresent() && next.get().actor.isPresent()) { return next.get().last(); } else { return actor; } }
@Override public Network importData(ReadOnlyDataSource dataSource, NetworkFactory networkFactory, Properties parameters) { try { String ext = findExtension(dataSource, true); try (BufferedReader reader = new BufferedReader(new InputStreamReader(dataSource.newInputStream(null, ext)))) { Stopwatch stopwatch = Stopwatch.createStarted(); UcteNetworkExt ucteNetwork = new UcteNetworkExt(new UcteReader().read(reader), LINE_MIN_Z); String fileName = dataSource.getBaseName(); EntsoeFileName ucteFileName = EntsoeFileName.parse(fileName); Network network = networkFactory.createNetwork(fileName, "UCTE"); network.setCaseDate(ucteFileName.getDate()); network.setForecastDistance(ucteFileName.getForecastDistance()); createBuses(ucteNetwork, network); createLines(ucteNetwork, network); createTransformers(ucteNetwork, network, ucteFileName); mergeXnodeDanglingLines(ucteNetwork, network); stopwatch.stop(); LOGGER.debug("UCTE import done in {} ms", stopwatch.elapsed(TimeUnit.MILLISECONDS)); return network; } } catch (IOException e) { throw new UncheckedIOException(e); } }
@Override public void rollback() throws SQLException { if (connection.getStateHandler().isInTransaction()) { try { if (TransactionType.LOCAL == transactionType || null == shardingTransactionManager) { localTransactionManager.rollback(); } else { shardingTransactionManager.rollback(); } MetricsUtils.buriedTransactionMetric("rollback"); } finally { connection.getStateHandler().setStatus(ConnectionStatus.TERMINATED); } } }
@NonNull @CheckReturnValue public static Observable<DataSnapshot> dataChanges(@NonNull final Query query) { return RxValue.changes(query); }
@SuppressWarnings("unchecked") public <T extends Expression> T rewrite(final T expression, final C context) { return (T) rewriter.process(expression, context); }
public IRelacionEntregaDBEntity getRelacionEntregaDBEntity() { if (relacionEntregaDBEntity == null) { relacionEntregaDBEntity = getFactory().getRelacionDBEntity(conn); } return relacionEntregaDBEntity; }
public static KTableHolder<Struct> build( final KGroupedStreamHolder groupedStream, final StreamAggregate aggregate, final KsqlQueryBuilder queryBuilder, final MaterializedFactory materializedFactory) { return build( groupedStream, aggregate, queryBuilder, materializedFactory, new AggregateParamsFactory() ); }
Map<HRegionInfo, ServerName[]> placeSecondaryAndTertiaryRS( Map<HRegionInfo, ServerName> primaryRSMap) { Map<HRegionInfo, ServerName[]> secondaryAndTertiaryMap = new HashMap<HRegionInfo, ServerName[]>(); for (Map.Entry<HRegionInfo, ServerName> entry : primaryRSMap.entrySet()) { HRegionInfo regionInfo = entry.getKey(); ServerName primaryRS = entry.getValue(); try { ServerName[] favoredNodes; String primaryRack = rackManager.getRack(primaryRS); if (getTotalNumberOfRacks() == 1) { favoredNodes = singleRackCase(regionInfo, primaryRS, primaryRack); } else { favoredNodes = multiRackCase(regionInfo, primaryRS, primaryRack); } if (favoredNodes != null) { secondaryAndTertiaryMap.put(regionInfo, favoredNodes); LOG.debug("Place the secondary and tertiary region server for region " + regionInfo.getRegionNameAsString()); } } catch (Exception e) { LOG.warn("Cannot place the favored nodes for region " + regionInfo.getRegionNameAsString() + " because " + e, e); continue; } } return secondaryAndTertiaryMap; }
@Override public FormType getFormType() { return FormType.SIMPLE; }
@Override public ResourceList<Vm> getVmDetailsInProject(String projectId) throws IOException { String path = String.format("%s/%s/vms", getBasePath(), projectId); ResourceList<Vm> vmResourceList = new ResourceList<>(); ResourceList<Vm> resourceList = getVmResourceList(path); vmResourceList.setItems(resourceList.getItems()); while (resourceList.getNextPageLink() != null && !resourceList.getNextPageLink().isEmpty()) { resourceList = getVmResourceList(resourceList.getNextPageLink()); vmResourceList.getItems().addAll(resourceList.getItems()); } return vmResourceList; }
@Override public List<SysRole> SelectAll() { return sysRoleMapper.selectAll(); }
public static void process(ASTOperationContainer container) throws MalformedQueryException { ASTOperation operation = container.getOperation(); if (operation != null) { ASTWhereClause whereClause = operation.getWhereClause(); if (whereClause != null) { SelectClauseCollector collector = new SelectClauseCollector(); try { whereClause.jjtAccept(collector, null); Set<ASTSelect> selectClauses = collector.getSelectClauses(); for (ASTSelect selectClause : selectClauses) { if (selectClause.isWildcard()) { ASTSelectQuery q = (ASTSelectQuery) selectClause.jjtGetParent(); addQueryVars(q.getWhereClause(), selectClause); selectClause.setWildcard(false); } } } catch (VisitorException e) { throw new MalformedQueryException(e); } } } if (operation instanceof ASTSelectQuery) { ASTSelectQuery selectQuery = (ASTSelectQuery) operation; ASTSelect selectClause = selectQuery.getSelect(); if (selectClause.isWildcard()) { addQueryVars(selectQuery.getWhereClause(), selectClause); selectClause.setWildcard(false); } } else if (operation instanceof ASTDescribeQuery) { ASTDescribeQuery describeQuery = (ASTDescribeQuery) operation; ASTDescribe describeClause = describeQuery.getDescribe(); if (describeClause.isWildcard()) { addQueryVars(describeQuery.getWhereClause(), describeClause); describeClause.setWildcard(false); } } }
@Override public boolean equals(Object object) { if (object == null) { return false; } if (object == this) { return true; } if (object.getClass() != getClass()) { return false; } EntitySelection entitySelection = (EntitySelection) object; return new EqualsBuilder().append(getEntityReference(), entitySelection.getEntityReference()) .append(isSelected(), entitySelection.isSelected()).isEquals(); }
@Override public ResponseEntity<Object> updateAuthorisationStatus(String psuId, String psuIdType, String psuCorporateId, String psuCorporateIdType, String paymentId, String authorisationId, String status, String instanceId, AuthenticationDataHolder authenticationDataHolder) { ScaStatus scaStatus = ScaStatus.fromValue(status); if (scaStatus == null) { return ResponseEntity.badRequest().build(); } PsuIdData psuIdData = new PsuIdData(psuId, psuIdType, psuCorporateId, psuCorporateIdType, null); try { return cmsPsuPisService.updateAuthorisationStatus(psuIdData, paymentId, authorisationId, scaStatus, instanceId, authenticationDataHolder) ? ResponseEntity.ok().build() : ResponseEntity.badRequest().build(); } catch (AuthorisationIsExpiredException e) { return new ResponseEntity<>(new CmsPaymentResponse(e.getNokRedirectUri()), HttpStatus.REQUEST_TIMEOUT); } }
public List<Statement> buildAst(String sql, MetaStore metaStore) { try { ParserRuleContext tree = getParseTree(sql); SqlBaseParser.StatementsContext statementsContext = (SqlBaseParser.StatementsContext) tree; List<Statement> astNodes = new ArrayList<>(); for (SqlBaseParser.SingleStatementContext statementContext : statementsContext .singleStatement()) { DataSourceExtractor dataSourceExtractor = new DataSourceExtractor(metaStore); dataSourceExtractor.extractDataSources(statementContext); Node root = new AstBuilder(dataSourceExtractor).visit(statementContext); Statement statement = (Statement) root; astNodes.add(statement); } return astNodes; } catch (Exception e) { throw new ParseFailedException(e.getMessage(), e); } }
public static String getRelativePath(Path sourceRootPath, Path childPath) { String childPathString = childPath.toUri().getPath(); String sourceRootPathString = sourceRootPath.toUri().getPath(); return sourceRootPathString.equals("/") ? childPathString : childPathString.substring(sourceRootPathString.length()); }
@Override public AuthorisationProcessorResponse doScaReceived(AuthorisationProcessorRequest authorisationProcessorRequest) { return doScaPsuIdentified(authorisationProcessorRequest); }
@Override public void setRampDownPercent(long rampDownPercent) { Validate.isTrue((rampDownPercent >= 0) && (rampDownPercent < 100), "rampDownPercent must be a value between 0 and 99"); this.rampDownPercent = rampDownPercent; }
public int doJob() { checkParams(); AbstractGraphPanelVisualizer pluginInstance = pluginType; pluginType.setIgnoreCurrentTestStartTime(); setOptions(pluginInstance); CorrectedResultCollector rc; rc = (CorrectedResultCollector) pluginInstance.createTestElement(); rc.setExcludeLabels(excludeLabels); rc.setIncludeLabels(includeLabels); rc.setStartOffset(startOffset); rc.setEndOffset(endOffset); if (includeSamplesWithRegex >= 0) { rc.setEnabledIncludeRegex(includeSamplesWithRegex != 0); } if (excludeSamplesWithRegex >= 0) { rc.setEnabledExcludeRegex(excludeSamplesWithRegex != 0); } if (successFilter >= 0) { rc.setErrorLogging(successFilter == 0); rc.setSuccessOnlyLogging(successFilter != 0); } if (pluginType.getStaticLabel().equals(JMeterPluginsUtils.prefixLabel("Merge Results"))) { mergeResults(pluginInstance, rc); } else { log.debug("Using JTL file: " + inputFile); rc.setFilename(inputFile); rc.setListener(pluginInstance); pluginInstance.configure(rc); rc.loadExistingFile(); } setOptions(pluginInstance); pluginInstance.getGraphPanelChart().setYAxisLabel(yAxisLabel); if ((exportMode & EXPORT_PNG) == EXPORT_PNG) { File pngFile = new File(outputPNG); forceDir(pngFile); try { pluginInstance.getGraphPanelChart().saveGraphToPNG(pngFile, graphWidth, graphHeight); } catch (IOException ex) { throw new RuntimeException(ex); } } if ((exportMode & EXPORT_CSV) == EXPORT_CSV) { File csvFile = new File(outputCSV); forceDir(csvFile); try { pluginInstance.getGraphPanelChart().saveGraphToCSV(csvFile); } catch (IOException ex) { throw new RuntimeException(ex); } } return 0; }
public static BinomialTreeNode merge(BinomialTreeNode a, BinomialTreeNode b) { return null; }
@Override public String toString() { String orderTypeStr = orderType.getStr(); String comparisonOperatorStr = comparisonOperator.getStr(); return lhs + OD_SEPARATOR + "[" + comparisonOperatorStr + "," + orderTypeStr + "]" + rhs; }
public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone, Optional<DeploymentInstanceSpec> instanceSpec) { var t0 = Instant.now(); Optional<EndpointCertificateMetadata> metadata = getOrProvision(instance, zone, instanceSpec); Duration duration = Duration.between(t0, Instant.now()); if (duration.toSeconds() > 30) log.log(Level.INFO, String.format("Getting endpoint certificate metadata for %s took %d seconds!", instance.id().serializedForm(), duration.toSeconds())); return metadata; }
public static String taskItemPath(String taskName, String ownSign, String taskItem) { return taskItemBasePath(taskName, ownSign) + "/" + taskItem; }
@Override public OrganisationId generate(final String keyPlaceHolder, final RpslObject object) { return generateForName(keyPlaceHolder, object.getValueForAttribute(AttributeType.ORG_NAME).toString()); }
public static int convertToInt(final String val) { return convertToInt(val, 0); }
public Event createBeginAdapterDelegation() { return new BeginAdapterDelegationEvent(); }
public String getAccumuloPassword() { if (containsKey(ACCUMULO_PASSWORD_PROP)) { return verifyNotNull(ACCUMULO_PASSWORD_PROP, getString(ACCUMULO_PASSWORD_PROP)); } else if (containsKey(CLIENT_ACCUMULO_PASSWORD_PROP)) { return verifyNotNull(CLIENT_ACCUMULO_PASSWORD_PROP, getString(CLIENT_ACCUMULO_PASSWORD_PROP)); } throw new NoSuchElementException(ACCUMULO_PASSWORD_PROP + " is not set!"); }
@VisibleForTesting protected void releaseToken() { holdToken.set(false); resourceManager.getLeakyBucket().release(); }
public static Realm valueOf(@NonNull String name) throws IllegalArgumentException { final Realm realm; synchronized (KNOWN_REALMS) { realm = KNOWN_REALMS.get(name); } if (realm == null) { throw new IllegalArgumentException("Unknown realm " + name); } return realm; }
public JsonInput<T> open( String path, InputStream input, Collection<? extends InputOption> options) throws IOException { JsonEncoding encoding = ENCODING_MAP.get(charset); if (encoding != null) { return createInput(path, factory.createParser(input), options); } else { return open(path, new InputStreamReader(input, charset), options); } }
@Override public void removeEquipmentsFromJedi(int jediId) { Jedi jedi = jediDao.findById(jediId); if (jedi != null) { List<Equipment> equipments = jedi.getEquipments(); equipments.forEach(equipmentDao::delete); } else { throw new ApplicationException(JEDI_NOT_FOUND); } }
@Override public OMRequest preExecute(OzoneManager ozoneManager) throws IOException { GetDelegationTokenRequestProto getDelegationTokenRequest = getOmRequest().getGetDelegationTokenRequest(); Token<OzoneTokenIdentifier> token = ozoneManager .getDelegationToken(new Text(getDelegationTokenRequest.getRenewer())); OMRequest.Builder omRequest; if (token != null) { omRequest = OMRequest.newBuilder().setUserInfo(getUserInfo()) .setUpdateGetDelegationTokenRequest( UpdateGetDelegationTokenRequest.newBuilder() .setGetDelegationTokenResponse( GetDelegationTokenResponseProto.newBuilder() .setResponse( SecurityProtos.GetDelegationTokenResponseProto .newBuilder().setToken(OMPBHelper .convertToTokenProto(token)).build()) .build()) .setTokenRenewInterval(ozoneManager.getDelegationTokenMgr() .getTokenRenewInterval())) .setCmdType(getOmRequest().getCmdType()) .setClientId(getOmRequest().getClientId()); } else { omRequest = OMRequest.newBuilder().setUserInfo(getUserInfo()) .setUpdateGetDelegationTokenRequest( UpdateGetDelegationTokenRequest.newBuilder() .setGetDelegationTokenResponse( GetDelegationTokenResponseProto.newBuilder())) .setCmdType(getOmRequest().getCmdType()) .setClientId(getOmRequest().getClientId()); } if (getOmRequest().hasTraceID()) { omRequest.setTraceID(getOmRequest().getTraceID()); } return omRequest.build(); }
@SuppressWarnings({"unchecked", "rawtypes"}) @Override public int compare(Object v1, Object v2) { if (v1 == null) { if (v2 == null) { return 0; } else { return -1; } } else if (v2 == null) { return 1; } else { return ((Comparable) cast(v1)).compareTo(cast(v2)); } }
public void onRefresh() { refreshRuntimeEvent.fire(new RefreshRuntimeEvent(providerKey)); }
protected static Class<? extends Object> resolveTypeVariable(Type type, List<ParameterizedType> ancestorTypeList) throws IllegalStateException { if (isNotTypeVariable(type)) { return getRawClass(type); } TypeVariable<?> targetType = (TypeVariable<?>) type; Type actualType = null; for (int i = ancestorTypeList.size() - 1; i >= 0; i--) { ParameterizedType ancestorType = ancestorTypeList.get(i); GenericDeclaration declaration = targetType.getGenericDeclaration(); if (!(declaration instanceof Class)) { throw new IllegalStateException("TypeVariable(" + targetType .getName() + " is not declared at Class " + "(ie. is declared at Method or Constructor)"); } Class<?> declaredClass = (Class<?>) declaration; if (declaredClass != ancestorType.getRawType()) { continue; } Type[] parameterTypes = declaredClass.getTypeParameters(); int index = ArrayUtils.indexOf(parameterTypes, targetType); if (index == -1) { throw new IllegalStateException("Class(" + declaredClass .getName() + ") does not declare TypeValidable(" + targetType.getName() + ")"); } actualType = ancestorType.getActualTypeArguments()[index]; if (log.isDebugEnabled()) { log.debug("resolved " + targetType.getName() + " -> " + actualType); } if (isNotTypeVariable(actualType)) { return getRawClass(actualType); } targetType = (TypeVariable<?>) actualType; } throw new IllegalStateException("Concrete type of Type(" + type + ") was not found in ancestorList(" + ancestorTypeList + ")"); }
public boolean isCompareMode() { return comparisonGenerationResult != null; }
@Override public Collection<Object> values() { return documentAsMap.values(); }
public RequestSummary importSpdxBOMAsProject(InputStream inputStream, AttachmentContent attachmentContent) throws InvalidSPDXAnalysisException, SW360Exception { return importSpdxBOM(inputStream, attachmentContent, SW360Constants.TYPE_PROJECT); }
public List<String> buildConstraints(Class propertyType, AnnotationProvider annotationProvider) { Validate annotation = annotationProvider.getAnnotation(Validate.class); if (annotation == null) return null; return Arrays.asList(validatorPattern.split(annotation.value())); }
@Override public int hashCode() { int hash = 7; hash = 37 * hash + Objects.hashCode(VariantEffectFilter.filterType); hash = 37 * hash + Objects.hashCode(this.offTargetVariantTypes); return hash; }
public static List<UidRange> mergeRanges(List<UidRange> ranges) { if (ranges.isEmpty()) { return ranges; } RangeSet<MessageUid> rangeSet = createSortedRangeSet(ranges); List<Range<MessageUid>> mergedRanges = mergeContiguousRanges(rangeSet); return toUidRanges(mergedRanges); }
public String formatInchiString(String inchi) { String tmpInchi = inchi.replaceAll("\\s+",""); String formattedInchi = tmpInchi.replaceAll("InChI[0-9]?", "InChI"); return formattedInchi; }
@GET @Path("/{uri:.+}") @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public Response getPermissionsEntryPoint(@Context UriInfo uriInfo) throws ErrorDescriptorException { PermissionComplexKey permissionComplexKey = new PermissionComplexKey(uriInfo).invoke(); MultivaluedMap<String, String> queryParams = permissionComplexKey.getQueryParams(); Response response; if (permissionComplexKey.getRecipientUri() == null){ response = getPermissions(permissionComplexKey.getResourceUri(), "true".equalsIgnoreCase(queryParams.getFirst("effectivePermissions")), queryParams.getFirst("recipientType"), queryParams.getFirst("recipientId"), "true".equalsIgnoreCase(queryParams.getFirst("resolveAll")), parseIntParam(RestConstants.QUERY_PARAM_OFFSET, queryParams.getFirst(RestConstants.QUERY_PARAM_OFFSET)), parseIntParam(RestConstants.QUERY_PARAM_LIMIT, queryParams.getFirst(RestConstants.QUERY_PARAM_LIMIT))); } else { response = getPermission(permissionComplexKey.getResourceUri(), permissionComplexKey.getRecipientUri()); } return response; }
public static void cardinalityInBuckets(RoaringBitmap bitmap, int[][] indexes, long[][] buckets) { int numContainers = bitmap.highLowContainer.size(); int bucketLength = buckets.length; int[] currentBucket = new int[bucketLength]; Arrays.fill(currentBucket, 0); int[] currentBucketStart = new int[bucketLength]; int[] currentBucketEnd = new int[bucketLength]; for (int bi = 0; bi < bucketLength; bi++) { currentBucketStart[bi] = indexes[bi][currentBucket[bi]]; currentBucketEnd[bi] = indexes[bi][currentBucket[bi] + 1]; } int numExhausted = 0; boolean[] exhausted = new boolean[bucketLength]; for (int pos = 0; pos < numContainers; pos++) { int min = containerMin(bitmap, pos); for (int bi = 0; bi < bucketLength; bi++) { while (!exhausted[bi] && min >= currentBucketEnd[bi]) { currentBucket[bi]++; if (currentBucket[bi] == buckets[bi].length) { numExhausted++; exhausted[bi] = true; break; } currentBucketStart[bi] = indexes[bi][currentBucket[bi]]; currentBucketEnd[bi] = indexes[bi][currentBucket[bi] + 1]; } } if (numExhausted == bucketLength) { break; } boolean[] candidate = new boolean[bucketLength]; boolean anyCandidates = false; for (int bi = 0; bi < bucketLength; bi++) { candidate[bi] = (min < currentBucketEnd[bi]); anyCandidates |= candidate[bi]; } if (anyCandidates) { Container container = bitmap.highLowContainer.values[pos]; int max = min + (1 << 16); boolean[] bucketContainsPos = new boolean[bucketLength]; boolean allContainPos = true; boolean anyContainPos = false; for (int bi = 0; bi < bucketLength; bi++) { bucketContainsPos[bi] = (currentBucketStart[bi] <= min && max <= currentBucketEnd[bi]); allContainPos &= bucketContainsPos[bi]; anyContainPos |= bucketContainsPos[bi]; } if (anyContainPos) { int cardinality = container.getCardinality(); for (int bi = 0; bi < bucketLength; bi++) { if (bucketContainsPos[bi]) { buckets[bi][currentBucket[bi]] += cardinality; } } } if (!allContainPos) { if (container instanceof ArrayContainer) { ArrayContainer arrayContainer = (ArrayContainer) container; for (int i = 0; i < arrayContainer.cardinality && numExhausted < bucketLength; i++) { int index = toIntUnsigned(arrayContainer.content[i]) | min; next: for (int bi = 0; bi < bucketLength; bi++) { if (!candidate[bi] || bucketContainsPos[bi] || exhausted[bi]) { continue; } while (index >= currentBucketEnd[bi]) { currentBucket[bi]++; if (currentBucket[bi] == buckets[bi].length) { numExhausted++; exhausted[bi] = true; continue next; } currentBucketStart[bi] = indexes[bi][currentBucket[bi]]; currentBucketEnd[bi] = indexes[bi][currentBucket[bi] + 1]; } if (index >= currentBucketStart[bi]) { buckets[bi][currentBucket[bi]]++; } } } } else if (container instanceof RunContainer) { RunContainer runContainer = (RunContainer) container; for (int i = 0; i < runContainer.nbrruns && numExhausted < bucketLength; i++) { int base = toIntUnsigned(runContainer.getValue(i)); int startInclusive = base | min; int endExclusive = startInclusive + 1 + toIntUnsigned(runContainer.getLength(i)); for (int index = startInclusive; index < endExclusive && numExhausted < bucketLength; index++) { next: for (int bi = 0; bi < bucketLength; bi++) { if (!candidate[bi] || bucketContainsPos[bi] || exhausted[bi]) { continue; } while (index >= currentBucketEnd[bi]) { currentBucket[bi]++; if (currentBucket[bi] == buckets[bi].length) { numExhausted++; exhausted[bi] = true; continue next; } currentBucketStart[bi] = indexes[bi][currentBucket[bi]]; currentBucketEnd[bi] = indexes[bi][currentBucket[bi] + 1]; } if (index >= currentBucketStart[bi]) { buckets[bi][currentBucket[bi]]++; } } } } } else { BitmapContainer bitmapContainer = (BitmapContainer) container; int maxIndex = bitmapContainer.bitmap.length << 6; for (int i = bitmapContainer.nextSetBit(0); i >= 0 && numExhausted < bucketLength; i = (i + 1 >= maxIndex) ? -1 : bitmapContainer.nextSetBit(i + 1)) { int index = toIntUnsigned((short) i) | min; next: for (int bi = 0; bi < bucketLength; bi++) { if (!candidate[bi] || bucketContainsPos[bi] || exhausted[bi]) { continue; } while (index >= currentBucketEnd[bi]) { currentBucket[bi]++; if (currentBucket[bi] == buckets[bi].length) { numExhausted++; exhausted[bi] = true; continue next; } currentBucketStart[bi] = indexes[bi][currentBucket[bi]]; currentBucketEnd[bi] = indexes[bi][currentBucket[bi] + 1]; } if (index >= currentBucketStart[bi]) { buckets[bi][currentBucket[bi]]++; } } } } } } } }
public static String loadFile(String path) { try { URL resource = RequestLogServiceImpl.class.getClassLoader().getResource(path); if (resource == null) { return null; } String res = toString(resource); if (res != null) { res = res.replace("\r\n", ""); res = res.replace("\n", ""); } return res; } catch (Throwable e) { logger.error(e.getMessage(), e); } return null; }
@Override public void receiveFlowControlledFrame( final Http2Stream stream, final ByteBuf data, final int padding, final boolean endOfStream) throws Http2Exception { assert ctx != null && ctx.executor().inEventLoop(); final int dataLength = data.readableBytes() + padding; final FlowState connectionState = connectionState(); connectionState.receiveFlowControlledFrame(dataLength); if (stream != null && !isClosed(stream)) { final FlowState state = state(stream); state.endOfStream(endOfStream); state.receiveFlowControlledFrame(dataLength); } else if (dataLength > 0) { connectionState.consumeBytes(dataLength); } }
public void addSofaMapping(String componentName, String componentViewName, String aggregateViewName) { if (componentNames.contains(componentName)) { sofaMappings.add(SofaMappingFactory.createSofaMapping(componentName, componentViewName, aggregateViewName)); } else { throw new IllegalArgumentException("No component with the name '" + componentName + "' has been added to this builder. Sofa mappings may only be added for " + "components that have been added to this builder. "); } }
@Override public List<String> getInitColumns() { return Arrays.asList(COL_ID_SELECT, COLUMN_NAME, COLUMN_PROCESS_ID, COLUMN_STATUS, COLUMN_CREATED_ON, COL_ID_ACTIONS); }
public String extract(int start, int end) { return origBuffer.extract(map(start), map(end)); }
static boolean isLandsat5Filename(String filename) { if (filename.matches(L5_FILENAME_REGEX + "_MTL" + getTxtExtension())) { return true; } else if (filename.matches(L5_FILENAME_REGEX + getCompressionExtension())) { return true; } else { return false; } }
@Override @Loggable(value = Loggable.DEBUG, skipResult = true, name = INVOCATION_LOG_NAME) public void drop_table_with_environment_context( String dbname, String name, boolean deleteData, EnvironmentContext environment_context) throws NoSuchObjectException, MetaException, TException { DatabaseMapping mapping = checkWritePermissions(dbname); mapping .getClient() .drop_table_with_environment_context(mapping.transformInboundDatabaseName(dbname), name, deleteData, environment_context); }
@Override public Set<String> convert(Collection<String> scopes) { Set<String> convertedScopes = new LinkedHashSet<>(); for (String scope : scopes) { String convertedScope = convertToLocalScope(scope); if (convertedScope != null) { convertedScopes.add(convertedScope); } } return convertedScopes; }
@Override public Object nth(int index) { assertIndexInBounds(index); if (index == 0) { return item1; } return item2; }
public SearchQuery atPosition(int position) throws IllegalStateException { ensureConfigurationArray(Pagelet.class); Pagelet[] pagelets = (Pagelet[]) stack.peek(); for (Pagelet pagelet : pagelets) { PageletURI uri = pagelet.getURI(); if (uri == null) { uri = new PageletURIImpl(null, null, position); } else { uri.setPosition(position); } pagelet.setURI(uri); } return this; }
@Override public void init() { workerId = getWorkerId(); maxVibrationOffset = getMaxVibrationOffset(); maxTolerateTimeDifferenceMilliseconds = getMaxTolerateTimeDifferenceMilliseconds(); }
@Override public Map<String, Object> getParameters(final EnrolmentForeignType entity, final Map<String, Object> parameters) { addParameter(entity.getName(), "name", parameters); addParameter(entity.getAbbrName(), "abbrName", parameters); return parameters; }
public static RecordedHttpBody create(String contentType, String contentEncoding, final InputStream inputStream, final String charset) throws IOException { if (HttpUtilities.isCompressedContentEncoding(contentEncoding)) { return new RecordedEncodedHttpBody(IOUtils.toByteArray(inputStream), contentEncoding, charset, contentType); } else if (HttpUtilities.isTextContentType(contentType)) { return new RecordedStringHttpBody(IOUtils.toString(inputStream, charset)); } else { return new RecordedByteHttpBody(IOUtils.toByteArray(inputStream)); } }
public void initializeAttachments() throws IOException { initializeRootMessage(); Object maxCountProperty = message.getContextualProperty(AttachmentDeserializer.ATTACHMENT_MAX_COUNT); int maxCount = 50; if (maxCountProperty != null) { if (maxCountProperty instanceof Integer) { maxCount = (Integer)maxCountProperty; } else { maxCount = Integer.parseInt((String)maxCountProperty); } } attachments = new LazyAttachmentCollection(this, maxCount); message.setAttachments(attachments); }
public Map<String, List<ProcessKeyValue>> computeDataFromCsv(String dataFromCsv) { HashMap<String, List<ProcessKeyValue>> map = new HashMap<>(); if (dataFromCsv != null) { String[] tabSplitLine = dataFromCsv.split("\n"); for (String line : tabSplitLine) { String[] lineSplitBydelimiter = line.split(";"); if (lineSplitBydelimiter.length < 3) { return map; } List<ProcessKeyValue> listElem = new ArrayList<>(); try { for (int i = 1; i < lineSplitBydelimiter.length; i = i + 2) { listElem.add(ProcessKeyValue.builder().key(lineSplitBydelimiter[i]).value(lineSplitBydelimiter[i + 1]).build()); } map.put(lineSplitBydelimiter[0], listElem); } catch (Exception e) { log.error("Exception during parse CSV {}", e); return new HashMap<>(); } } } return map; }
@Override public boolean equals( Object o ) { if ( this == o ) { return true; } if ( o instanceof AttributeValueItem ) { AttributeValueItem that = ( AttributeValueItem ) o; if ( attributes != null ) { if ( ( that.attributes == null ) || ( that.attributes.size() != attributes.size() ) ) { return false; } for ( Attribute attribute : attributes ) { if ( !that.attributes.contains( attribute ) ) { return false; } } return true; } else { return attributes == null; } } return false; }
public static Integer getIntegerFromJsonMap(Map<String, Object> map, String key) throws NumberFormatException { if (map == null) return null; Object o = map.get(key); if (o == null) return null; if (o instanceof Integer) return (Integer) o; else if (o instanceof Number) return ((Number) o).intValue(); else if (o instanceof String) return Integer.valueOf((String) o); else throw new NumberFormatException(); }
public static StackManipulation of(TypeDescription typeDescription) { if (typeDescription.isArray() || typeDescription.isPrimitive() || typeDescription.isAbstract()) { throw new IllegalArgumentException(typeDescription + " is not instantiable"); } return new TypeCreation(typeDescription); }
public void validate(Iterable<? extends ApiConfig> apiConfigs) throws ApiConfigInvalidException, ApiClassConfigInvalidException, ApiMethodConfigInvalidException, ApiParameterConfigInvalidException { if (Iterables.isEmpty(apiConfigs)) { return; } Map<String, ApiMethodConfig> restfulSignatures = Maps.newHashMap(); Iterator<? extends ApiConfig> i = apiConfigs.iterator(); ApiConfig first = i.next(); validate(first, restfulSignatures); while (i.hasNext()) { ApiConfig config = i.next(); Iterable<ApiConfigInconsistency<Object>> inconsistencies = config.getConfigurationInconsistencies(first); if (!Iterables.isEmpty(inconsistencies)) { throw new InconsistentApiConfigurationException(config, first, inconsistencies); } validate(config, restfulSignatures); } }
public final static boolean deleteBigFile(File file) { return cleanFile(file) && file.delete(); }
public static LabelParameterMetadata of(String label) { return new LabelParameterMetadata(label); }
protected boolean checkIfTopPossible(Point viewCenterPoint, CoachMarkPixelInfo coachMarkDimenInPixel) { int centerY = viewCenterPoint.y; return (coachMarkDimenInPixel.getPopUpHeightInPixelsWithOffset() + coachMarkDimenInPixel.getMarginRectInPixels().top + coachMarkDimenInPixel.getMarginRectInPixels().bottom + coachMarkDimenInPixel.getActionBarHeightPixels()) <= centerY && ((coachMarkDimenInPixel.getWidthHeightOffsetForCoachMarkPopUp() + coachMarkDimenInPixel.getMarginRectInPixels().left + coachMarkDimenInPixel.getMarginRectInPixels().right) <= coachMarkDimenInPixel.getScreenWidthInPixels()); }
@Override public String render(XWikiContext context) throws XWikiException { CreateActionRequestHandler handler = new CreateActionRequestHandler(context); handler.processRequest(); ScriptContext scontext = getCurrentScriptContext(); scontext.setAttribute(SPACE_REFERENCE, handler.getSpaceReference(), ScriptContext.ENGINE_SCOPE); scontext.setAttribute(NAME, handler.getName(), ScriptContext.ENGINE_SCOPE); scontext.setAttribute(IS_SPACE, handler.isSpace(), ScriptContext.ENGINE_SCOPE); scontext.setAttribute("availableTemplateProviders", handler.getAvailableTemplateProviders(), ScriptContext.ENGINE_SCOPE); scontext.setAttribute("recommendedTemplateProviders", handler.getRecommendedTemplateProviders(), ScriptContext.ENGINE_SCOPE); DocumentReference newDocumentReference = handler.getNewDocumentReference(); if (newDocumentReference == null) { return CREATE_TEMPLATE; } if (!handler.isTemplateProviderAllowedToCreateInCurrentSpace()) { return CREATE_TEMPLATE; } checkRights(newDocumentReference.getLastSpaceReference(), context); XWikiDocument newDocument = context.getWiki().getDocument(newDocumentReference, context); if (handler.isDocumentAlreadyExisting(newDocument) || handler.isDocumentPathTooLong(newDocumentReference) || !this.isEntityReferenceNameValid(newDocumentReference)) { return CREATE_TEMPLATE; } if (StringUtils.isBlank(handler.getType()) && !handler.hasTemplate()) { return CREATE_TEMPLATE; } doCreate(context, newDocument, handler.isSpace(), handler.getTemplateProvider()); return null; }
@VisibleForTesting protected static boolean shouldReplacePartition(Config config, String replacedPartitionDbName, String replacedPartitionTableName, Optional<String> replacementPartitionDbName, Optional<String> replacementPartitionTableName) { boolean shouldReplacePartition = ConfigUtils.getBoolean(config, SHOULD_REPLACE_PARTITION_KEY, false); if (!replacementPartitionDbName.isPresent() || !replacementPartitionTableName.isPresent()) { return false; } else { return shouldReplacePartition && !(replacedPartitionDbName.equalsIgnoreCase(replacementPartitionDbName.get()) && replacedPartitionTableName.equalsIgnoreCase(replacementPartitionTableName.get())); } }
public static Color interpolateColor(final java.awt.Color COLOR1, final java.awt.Color COLOR2, float fraction) { final float INT_TO_FLOAT_CONST = 1f / 255f; fraction = Math.min(fraction, 1f); fraction = Math.max(fraction, 0f); final float RED1 = COLOR1.getRed() * INT_TO_FLOAT_CONST; final float GREEN1 = COLOR1.getGreen() * INT_TO_FLOAT_CONST; final float BLUE1 = COLOR1.getBlue() * INT_TO_FLOAT_CONST; final float ALPHA1 = COLOR1.getAlpha() * INT_TO_FLOAT_CONST; final float RED2 = COLOR2.getRed() * INT_TO_FLOAT_CONST; final float GREEN2 = COLOR2.getGreen() * INT_TO_FLOAT_CONST; final float BLUE2 = COLOR2.getBlue() * INT_TO_FLOAT_CONST; final float ALPHA2 = COLOR2.getAlpha() * INT_TO_FLOAT_CONST; final float DELTA_RED = RED2 - RED1; final float DELTA_GREEN = GREEN2 - GREEN1; final float DELTA_BLUE = BLUE2 - BLUE1; final float DELTA_ALPHA = ALPHA2 - ALPHA1; float red = RED1 + (DELTA_RED * fraction); float green = GREEN1 + (DELTA_GREEN * fraction); float blue = BLUE1 + (DELTA_BLUE * fraction); float alpha = ALPHA1 + (DELTA_ALPHA * fraction); red = Math.min(red, 1f); red = Math.max(red, 0f); green = Math.min(green, 1f); green = Math.max(green, 0f); blue = Math.min(blue, 1f); blue = Math.max(blue, 0f); alpha = Math.min(alpha, 1f); alpha = Math.max(alpha, 0f); return new Color((new java.awt.Color(red, green, blue, alpha)).getRGB()); }
public static List<Type> resolveTypeParameters(DotName input, DotName target, IndexView index) { final ClassInfo inputClassInfo = fetchFromIndex(input, index); Type startingType = getType(inputClassInfo, index); final List<Type> result = findParametersRecursively(startingType, target, new HashSet<>(), index); if (result == null) { return Collections.emptyList(); } return result; }
@Override public boolean isEmpty() { return size <= 0; }
@Override protected void describeMismatchSafely(final T item, final Description mismatchDescription) { mismatchDescription.appendText(String.format("<%s>", item.toString())).appendText( " is not a valid yaml"); }
@Override public String getMessage() { if (this.message == null) { return this.errorCode; } return this.message; }
@Override public S3DataTransferer createDataTransfer() { String bucketName = System.getProperty(BUCKET_NAME_PROPERTY); String region = System.getProperty(REGION_PROPERTY); String accessKey = System.getProperty(ACCESS_KEY_PROPERTY); String secretKey = System.getProperty(SECRET_KEY_PROPERTY); boolean encrypt = Boolean.getBoolean(ENCRYPT_PROPERTY); AmazonS3Client s3 = (AmazonS3Client) AmazonS3ClientBuilder.standard() .withRegion(region) .withCredentials( new AWSStaticCredentialsProvider( new BasicAWSCredentials(accessKey, secretKey))) .build(); return new S3DataTransferer(s3, bucketName, encrypt); }
public String getValue() { return value; }
@Override public ProcessorSchema convert() { Map<String, Object> map = new HashMap<>(); map.put(NAME_KEY, name); map.put(CLASS_KEY, processorClass); map.put(MAX_CONCURRENT_TASKS_KEY, maxConcurrentTasks); map.put(SCHEDULING_STRATEGY_KEY, schedulingStrategy); map.put(SCHEDULING_PERIOD_KEY, schedulingPeriod); map.put(PENALIZATION_PERIOD_KEY, penalizationPeriod); map.put(YIELD_PERIOD_KEY, yieldPeriod); map.put(RUN_DURATION_NANOS_KEY, runDurationNanos); map.put(AUTO_TERMINATED_RELATIONSHIPS_LIST_KEY, autoTerminatedRelationshipsList); map.put(PROPERTIES_KEY, new HashMap<>(properties)); return new ProcessorSchema(map); }
public static AnnotatedElement getAnnotatedElement(Class<?> beanClass, String propertyName, Class<?> propertyClass) { Field field = getFieldOrNull(beanClass, propertyName); Method method = getGetterOrNull(beanClass, propertyName, propertyClass); if (field == null || field.getAnnotations().length == 0) { return (method != null && method.getAnnotations().length > 0) ? method : EMPTY; } else if (method == null || method.getAnnotations().length == 0) { return field; } else { return new Annotations(field, method); } }
public NpmParseResult parse(final String sourcePath, final Optional<String> packageJsonText, final String lockFileText, final boolean includeDevDependencies) { final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph(); logger.info("Parsing lock file text: "); logger.debug(lockFileText); Optional<PackageJson> packageJson = Optional.empty(); if (packageJsonText.isPresent()) { logger.debug(packageJsonText.get()); packageJson = Optional.of(gson.fromJson(packageJsonText.get(), PackageJson.class)); } final PackageLock packageLock = gson.fromJson(lockFileText, PackageLock.class); logger.debug(lockFileText); logger.info("Processing project."); if (packageLock.dependencies != null) { logger.info(String.format("Found %d dependencies.", packageLock.dependencies.size())); NpmDependencyConverter dependencyConverter = new NpmDependencyConverter(externalIdFactory); NpmDependency rootDependency = dependencyConverter.convertLockFile(packageLock, packageJson); traverse(rootDependency, dependencyGraph, true, includeDevDependencies); } else { logger.info("Lock file did not have a 'dependencies' section."); } logger.info("Finished processing."); final ExternalId projectId = externalIdFactory.createNameVersionExternalId(Forge.NPM, packageLock.name, packageLock.version); final DetectCodeLocation codeLocation = new DetectCodeLocation.Builder(DetectCodeLocationType.NPM, sourcePath, projectId, dependencyGraph).build(); return new NpmParseResult(packageLock.name, packageLock.version, codeLocation); }
public HystrixProperty<String> executionIsolationThreadPoolKeyOverride() { return executionIsolationThreadPoolKeyOverride; }
@Override public int hashCode() { return Arrays.hashCode(data); }
public static FunctionConfig validateUpdate(FunctionConfig existingConfig, FunctionConfig newConfig) { FunctionConfig mergedConfig = existingConfig.toBuilder().build(); if (!existingConfig.getTenant().equals(newConfig.getTenant())) { throw new IllegalArgumentException("Tenants differ"); } if (!existingConfig.getNamespace().equals(newConfig.getNamespace())) { throw new IllegalArgumentException("Namespaces differ"); } if (!existingConfig.getName().equals(newConfig.getName())) { throw new IllegalArgumentException("Function Names differ"); } if (!StringUtils.isEmpty(newConfig.getClassName())) { mergedConfig.setClassName(newConfig.getClassName()); } if (!StringUtils.isEmpty(newConfig.getJar())) { mergedConfig.setJar(newConfig.getJar()); } if (newConfig.getInputSpecs() == null) { newConfig.setInputSpecs(new HashMap<>()); } if (mergedConfig.getInputSpecs() == null) { mergedConfig.setInputSpecs(new HashMap<>()); } if (newConfig.getInputs() != null) { newConfig.getInputs().forEach((topicName -> { newConfig.getInputSpecs().put(topicName, ConsumerConfig.builder().isRegexPattern(false).build()); })); } if (newConfig.getTopicsPattern() != null && !newConfig.getTopicsPattern().isEmpty()) { newConfig.getInputSpecs().put(newConfig.getTopicsPattern(), ConsumerConfig.builder() .isRegexPattern(true) .build()); } if (newConfig.getCustomSerdeInputs() != null) { newConfig.getCustomSerdeInputs().forEach((topicName, serdeClassName) -> { newConfig.getInputSpecs().put(topicName, ConsumerConfig.builder() .serdeClassName(serdeClassName) .isRegexPattern(false) .build()); }); } if (newConfig.getCustomSchemaInputs() != null) { newConfig.getCustomSchemaInputs().forEach((topicName, schemaClassname) -> { newConfig.getInputSpecs().put(topicName, ConsumerConfig.builder() .schemaType(schemaClassname) .isRegexPattern(false) .build()); }); } if (!newConfig.getInputSpecs().isEmpty()) { newConfig.getInputSpecs().forEach((topicName, consumerConfig) -> { if (!existingConfig.getInputSpecs().containsKey(topicName)) { throw new IllegalArgumentException("Input Topics cannot be altered"); } if (consumerConfig.isRegexPattern() != existingConfig.getInputSpecs().get(topicName).isRegexPattern()) { throw new IllegalArgumentException("isRegexPattern for input topic " + topicName + " cannot be altered"); } mergedConfig.getInputSpecs().put(topicName, consumerConfig); }); } if (!StringUtils.isEmpty(newConfig.getOutputSerdeClassName()) && !newConfig.getOutputSerdeClassName().equals(existingConfig.getOutputSerdeClassName())) { throw new IllegalArgumentException("Output Serde mismatch"); } if (!StringUtils.isEmpty(newConfig.getOutputSchemaType()) && !newConfig.getOutputSchemaType().equals(existingConfig.getOutputSchemaType())) { throw new IllegalArgumentException("Output Schema mismatch"); } if (!StringUtils.isEmpty(newConfig.getLogTopic())) { mergedConfig.setLogTopic(newConfig.getLogTopic()); } if (newConfig.getProcessingGuarantees() != null && !newConfig.getProcessingGuarantees().equals(existingConfig.getProcessingGuarantees())) { throw new IllegalArgumentException("Processing Guarantees cannot be altered"); } if (newConfig.getRetainOrdering() != null && !newConfig.getRetainOrdering().equals(existingConfig.getRetainOrdering())) { throw new IllegalArgumentException("Retain Ordering cannot be altered"); } if (!StringUtils.isEmpty(newConfig.getOutput())) { mergedConfig.setOutput(newConfig.getOutput()); } if (newConfig.getUserConfig() != null) { mergedConfig.setUserConfig(newConfig.getUserConfig()); } if (newConfig.getSecrets() != null) { mergedConfig.setSecrets(newConfig.getSecrets()); } if (newConfig.getRuntime() != null && !newConfig.getRuntime().equals(existingConfig.getRuntime())) { throw new IllegalArgumentException("Runtime cannot be altered"); } if (newConfig.getAutoAck() != null && !newConfig.getAutoAck().equals(existingConfig.getAutoAck())) { throw new IllegalArgumentException("AutoAck cannot be altered"); } if (newConfig.getMaxMessageRetries() != null) { mergedConfig.setMaxMessageRetries(newConfig.getMaxMessageRetries()); } if (!StringUtils.isEmpty(newConfig.getDeadLetterTopic())) { mergedConfig.setDeadLetterTopic(newConfig.getDeadLetterTopic()); } if (!StringUtils.isEmpty(newConfig.getSubName()) && !newConfig.getSubName().equals(existingConfig.getSubName())) { throw new IllegalArgumentException("Subscription Name cannot be altered"); } if (newConfig.getParallelism() != null) { mergedConfig.setParallelism(newConfig.getParallelism()); } if (newConfig.getResources() != null) { mergedConfig.setResources(ResourceConfigUtils.merge(existingConfig.getResources(), newConfig.getResources())); } if (newConfig.getWindowConfig() != null) { mergedConfig.setWindowConfig(newConfig.getWindowConfig()); } if (newConfig.getTimeoutMs() != null) { mergedConfig.setTimeoutMs(newConfig.getTimeoutMs()); } if (newConfig.getCleanupSubscription() != null) { mergedConfig.setCleanupSubscription(newConfig.getCleanupSubscription()); } if (!StringUtils.isEmpty(newConfig.getRuntimeFlags())) { mergedConfig.setRuntimeFlags(newConfig.getRuntimeFlags()); } if (!StringUtils.isEmpty(newConfig.getCustomRuntimeOptions())) { mergedConfig.setCustomRuntimeOptions(newConfig.getCustomRuntimeOptions()); } return mergedConfig; }
public PlaceResponse pickBestResponse(Set<PlaceResponse> responses) { if (responses == null || responses.isEmpty()) { return null; } return scoreOrdering.reverse().sortedCopy(responses).get(0); }
@Override public void execute(Date expirationTime) { LOGGER.debug(CleanUpJob.LOG_MARKER, format(Messages.DELETING_PROCESS_LOGS_MODIFIED_BEFORE_0, expirationTime)); try { int deletedProcessLogs = processLogsPersistenceService.deleteModifiedBefore(expirationTime); LOGGER.info(CleanUpJob.LOG_MARKER, format(Messages.DELETED_PROCESS_LOGS_0, deletedProcessLogs)); } catch (FileStorageException e) { throw new SLException(e, Messages.COULD_NOT_DELETE_PROCESS_LOGS_MODIFIED_BEFORE_0, expirationTime); } }
public static Task<ParseUser> logInInBackground(AccessToken accessToken) { checkInitialization(); return userDelegate.logInWithInBackground(AUTH_TYPE, getController().getAuthData(accessToken)); }
@Override public DefaultDataGroupInfo createGroup(Toolbox toolbox, String providerType, String folderName, Consumer<DataGroupInfo> deleteListener) { DefaultDataGroupInfo group; if (deleteListener != null) { group = new DefaultDeletableDataGroupInfo(false, toolbox, providerType, folderName); group.setAssistant(new DeletableDataGroupInfoAssistant(MantleToolboxUtils.getMantleToolbox(toolbox), null, null, deleteListener)); } else { group = new DefaultDataGroupInfo(false, toolbox, providerType, folderName); } return group; }
@Override public String getKey() { return IF_NONE_MATCH_HEADER_KEY; }
@Override public TimeStampResponse sign(TimeStampRequest request) throws OperatorCreationException, TSPException, CertificateEncodingException { final DigestCalculator digestCalculator = digestCalculatorProvider.get(new AlgorithmIdentifier(request.getMessageImprintAlgOID())); final String tspAlgorithm = computeTspAlgorithm(key, VitamConfiguration.getDefaultTimestampDigestType()); final SignerInfoGenerator signerInfoGen = new JcaSimpleSignerInfoGeneratorBuilder().build(tspAlgorithm, key, (X509Certificate) certificateChain[0]); final ASN1ObjectIdentifier tsaPolicy = new ASN1ObjectIdentifier(tspPolicy); final TimeStampTokenGenerator tokenGen = new TimeStampTokenGenerator(signerInfoGen, digestCalculator, tsaPolicy); tokenGen.addCertificates(new JcaCertStore(Arrays.asList(certificateChain))); final TimeStampResponseGenerator timeStampResponseGenerator = new TimeStampResponseGenerator(tokenGen, TSPAlgorithms.ALLOWED); final Date currentDate = LocalDateUtil.getDate(LocalDateUtil.now()); return timeStampResponseGenerator.generate(request, BigInteger.ONE, currentDate); }
@Override public String getName() { return name; }
@Override @SuppressWarnings("unchecked") public List<Person> getPeople(String searchString, Boolean dead, Boolean voided) { if (searchString == null) { return new ArrayList<>(); } int maxResults = HibernatePersonDAO.getMaximumSearchResults(); boolean includeVoided = (voided != null) ? voided : false; if (StringUtils.isBlank(searchString)) { Criteria criteria = sessionFactory.getCurrentSession().createCriteria(Person.class); if (dead != null) { criteria.add(Restrictions.eq("dead", dead)); } if (!includeVoided) { criteria.add(Restrictions.eq("personVoided", false)); } criteria.setMaxResults(maxResults); return criteria.list(); } String query = LuceneQuery.escapeQuery(searchString); PersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory); LuceneQuery<PersonName> nameQuery = personLuceneQuery.getPersonNameQueryWithOrParser(query, includeVoided); if (dead != null) { nameQuery.include("person.dead", dead); } List<Person> people = new ArrayList<>(); ListPart<Object[]> names = nameQuery.listPartProjection(0, maxResults, "person.personId"); names.getList().forEach(name -> people.add(getPerson((Integer) name[0]))); LuceneQuery<PersonAttribute> attributeQuery = personLuceneQuery.getPersonAttributeQueryWithOrParser(query, includeVoided, nameQuery); ListPart<Object[]> attributes = attributeQuery.listPartProjection(0, maxResults, "person.personId"); attributes.getList().forEach(attribute -> people.add(getPerson((Integer) attribute[0]))); return people; }
public User create(String name, String pwd, String mail) { User user = new User(); user.setFullname(name); user.setPassword(pwd); user.setEmail(mail); return dao.create(user); }
public Rnr getRequisitionWithoutLineItems(Long facilityId, Long programId, Long periodId) { return requisitionMapper.getRequisitionWithoutLineItems(facilityId, programId, periodId); }
@Override public ServiceResult<FileEntryResource> findFile(long formInputId) { return findFormInputEntity(formInputId).andOnSuccess(formInput -> ofNullable(formInput.getFile()) .map(FileEntry::getId) .map(fileEntryService::findOne) .orElse(serviceSuccess(null))); }
@Override public boolean matching(String target) { return null != target && null != pattern && target.matches(pattern); }
static boolean containsException(TestSuite testSuite) { if (testSuite.getException() != null) { return true; } if (!CollectionUtils.isEmpty(testSuite.getTestCases())) { for (TestCase tc : testSuite.getTestCases().values()) { if (tc.getException() != null) { return true; } for (TestCaseStep step : tc.getSteps()) { if (step.getException() != null) { return true; } } } } return false; }
public static String byteToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j < bytes.length; j++) { int v = bytes[j] & 0xFF; hexChars[j * 2] = hexArray[v >>> 4]; hexChars[j * 2 + 1] = hexArray[v & 0x0F]; } return new String(hexChars).toLowerCase(); }
@Before("classAnnotatedWithRxLogSubscriber(joinPoint) && onCompletedMethodExecution()") public void beforeOnCompletedExecution(JoinPoint joinPoint) { stopWatch.stop(); messageManager.printSubscriberOnCompleted(joinPoint.getTarget().getClass().getSimpleName(), stopWatch.getTotalTimeMillis(), counter.tally()); resetCounters(); }
public void deleteReportByIdAndTenant(String processId, int tenantId) { super.deleteReportByIdAndTenant(processId, tenantId, collection); }
@Override public ProcessVariableSummary apply(final VariableInstance variableInstance) { if (variableInstance == null) { return null; } return new ProcessVariableSummary(variableInstance.getVariableName(), variableInstance.getVariableName(), variableInstance.getProcessInstanceId(), variableInstance.getOldValue(), variableInstance.getValue(), variableInstance.getDate().getTime(), type, deploymentId, serverTemplateId); }
@When("^terminate process \"([^\"]*)\"$") public InstanceFailureStepDefinitions terminateProcessOnAllHealthyInstances(String processName) throws Throwable { List<EC2InstanceTO> instances = executionStateCache.getInstances(); if (instances == null || instances.isEmpty()) { throw new RuntimeException("No Instances are available"); } executionStateCache.addProcessName(processName); terminateProcess(processName, instances.size(), instances); return this; }
@Override public void close() throws IOException { impl.close(); }
public void setName(String name) { this.name = name; }
public static CSLName[] parse(String names) { CharStream cs = CharStreams.fromString(names); InternalNameLexer lexer = new InternalNameLexer(cs); lexer.removeErrorListeners(); CommonTokenStream tokens = new CommonTokenStream(lexer); InternalNameParser parser = new InternalNameParser(tokens); parser.removeErrorListeners(); NamesContext ctx = parser.names(); if (ctx.result.isEmpty() || ctx.exception != null || parser.getNumberOfSyntaxErrors() > 0) { return new CSLName[] { new CSLNameBuilder().literal(names).build() }; } return ctx.result.toArray(new CSLName[0]); }
void onMapReady(MapView mapView, MapzenMapHttpHandler mapzenMapHttpHandler, OnMapReadyCallback callback, MapDataManager mapDataManager, MapStateManager mapStateManager, SceneUpdateManager sceneUpdateManager, Locale locale, BitmapMarkerManager bitmapMarkerManager, ImportYamlGenerator yamlGenerator) { MapController mapController = mapView.getTangramMapView().getMap(null); mapController.setSceneLoadListener(null); mapController.setHttpHandler(mapzenMapHttpHandler.httpHandler()); MapzenManager mapzenManager = MapzenManager.instance(mapView.getContext()); bitmapMarkerManager.setMapController(mapController); callback.onMapReady( new MapzenMap(mapView, mapController, new OverlayManager(mapView, mapController, mapDataManager, mapStateManager), mapStateManager, new LabelPickHandler(mapView), bitmapMarkerManager, sceneUpdateManager, locale, mapzenManager, yamlGenerator)); }
@Override public Object getInstance(ObjectModel model, ClassLoader cl, Map<String, Object> contextParams) { Class<?> clazz = getClassObject(model.getIdentifier(), cl); Object instance = null; InternalRuntimeManager manager = null; if (contextParams.containsKey("runtimeManager")) { manager = (InternalRuntimeManager) contextParams.get("runtimeManager"); instance = manager.getCacheManager().get(clazz.getName()); if (instance != null) { return instance; } } if (model.getParameters() == null || model.getParameters().isEmpty()) { logger.debug("About to create instance of {} with no arg constructor", model.getIdentifier()); try { instance = clazz.newInstance(); } catch (Exception e) { throw new IllegalArgumentException("Unable to create instance (no arg constructor) of type " + model.getIdentifier() + " due to " + e.getMessage(), e); } } else { logger.debug("About to create instance of {} with {} parameters", model.getIdentifier(), model.getParameters().size()); Class<?>[] parameterTypes = new Class<?>[model.getParameters().size()]; Object[] paramInstances = new Object[model.getParameters().size()]; int index = 0; for (Object param : model.getParameters()) { if (param instanceof ObjectModel) { logger.debug("Parameter is of type ObjectModel (id: {}), trying to create instance based on that model", ((ObjectModel) param).getIdentifier()); Class<?> paramclazz = getClassObject(((ObjectModel)param).getIdentifier(), cl); parameterTypes[index] = paramclazz; paramInstances[index] = getInstance(((ObjectModel)param), cl, contextParams); } else { if (contextParams.containsKey(param)) { logger.debug("Parametr references context parametr with name {}", param); Object contextValue = contextParams.get(param); Class<?> paramClass = contextValue.getClass(); if (knownContextParamMapping.containsKey(param)) { paramClass = knownContextParamMapping.get(param); } parameterTypes[index] = paramClass; paramInstances[index] = contextValue; } else { logger.debug("Parameter is simple type (string) - {}", param); parameterTypes[index] = param.getClass(); paramInstances[index] = param; } } index++; } try { logger.debug("Creating instance of class {} with parameter types {} and parameter instances {}", clazz, parameterTypes, paramInstances); Constructor<?> constructor = clazz.getConstructor(parameterTypes); instance = constructor.newInstance(paramInstances); } catch (Exception e) { throw new IllegalArgumentException("Unable to create instance (" + parameterTypes + " constructor) of type " + model.getIdentifier() + " due to " + e.getMessage(), e); } } logger.debug("Created instance : {}", instance); if (manager != null && instance instanceof Cacheable) { manager.getCacheManager().add(instance.getClass().getName(), instance); } return instance; }
public void setState(ImageState state) { EntityStateValidator.validateStateChange(this.getState(), state, ImageState.PRECONDITION_STATES); this.state = state; }
public Properties loadProperties(final String configFile) { Properties properties = new Properties(); try { checkPropertyFileArgument(configFile); InputStream inputStream = new FileInputStream(configFile); properties.load(inputStream); logger.debug("Properties loaded from external configuration."); } catch (IOException e) { throw new PropertiesNotAvailableException("Configuration file " + configFile + " cannot be loaded", e); } return properties; }
@Override void toHtml() throws IOException { writeBackLink(); writeln("<br/>"); if (dependencies.isEmpty()) { writeln("#Aucune_dependance#"); return; } writeTitle("beans.png", getString("Dependencies")); final HtmlTable table = new HtmlTable(); table.beginTable(getString("Dependencies")); write("<th>Artifact</th><th>#Nom#</th><th>Maven ID</th><th>#Licence#</th>"); for (final Map.Entry<String, MavenArtifact> entry : dependencies.entrySet()) { final String jarFilename = entry.getKey(); final MavenArtifact dependency = entry.getValue(); table.nextRow(); writeDependency(jarFilename, dependency); } table.endTable(); writeln("<div align='right'>" + getFormattedString("nb_dependencies", dependencies.size()) + "</div>"); }
@Override public View getView() { return view; }
public void addGroupPartitioner(final String group, final GroupPartitioner groupPartitioner) { if (groupToPartitioner.containsKey(group)) { throw new IllegalArgumentException("Cannot overwrite the groupPartitioner of a group that already exists in groupToPartitioner (group was " + group + ")"); } groupToPartitioner.put(group, groupPartitioner); }
@Override public CheckAndMutateRowResponse checkAndMutateRow(CheckAndMutateRowRequest request) { if (shouldOverrideAppProfile(request.getAppProfileId())) { request = request.toBuilder().setAppProfileId(clientDefaultAppProfileId).build(); } return createUnaryListener(request, checkAndMutateRpc, request.getTableName()) .getBlockingResult(); }
@Override public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request ) { String path = getPathForArtifact( request.getArtifact(), false ); File file = new File( getRepository().getBasedir(), path ); LocalArtifactResult result = new LocalArtifactResult( request ); if ( file.isFile() ) { result.setFile( file ); Properties props = readRepos( file ); if ( props.get( getKey( file, LOCAL_REPO_ID ) ) != null ) { result.setAvailable( true ); } else { String context = request.getContext(); for ( RemoteRepository repository : request.getRepositories() ) { if ( props.get( getKey( file, getRepositoryKey( repository, context ) ) ) != null ) { result.setAvailable( true ); result.setRepository( repository ); break; } } if ( !result.isAvailable() && !isTracked( props, file ) ) { result.setAvailable( true ); } } } return result; }
@Override public void setParameters(Map<String, String> params) throws ParametersException { modifyAction = ModifyAction.fromString(params.get(ACTION_PARAMETER)); name = params.get(NAME_PARAMETER); value = params.get(VALUE_PARAMETER); domain = params.get(DOMAIN_PARAMETER); path = params.get(PATH_PARAMETER); Validator validator = new CookieModifierValidator(name, value, modifyAction); validator.validate(validationResultBuilder); if (validationResultBuilder.hasErrors()) { throw new ParametersException(validationResultBuilder.toString()); } }
@Override public FactRecord getFact(UUID id) { return factRecordConverter.fromEntity(factManager.getFact(id)); }
@InterfaceAudience.Private @InterfaceStability.Unstable @VisibleForTesting public static void setLoginUser(UserGroupInformation ugi) { loginUserRef.set(ugi); }
public FieldValidation toAPIFieldValidation() { if (fieldValidator == null) { return fieldValidation; } FieldValidation fieldValidation = new FieldValidation(); if ( fieldValidator.getMaxLength() != null ) { fieldValidation.setMaxLength( fieldValidator.getMaxLength() ); } if ( fieldValidator.getMinLength() != null ) { fieldValidation.setMinLength( fieldValidator.getMinLength() ); } if ( !fieldValidator.getOptions().isEmpty() ) { fieldValidation.setEnum( new ArrayList<String>() ); fieldValidation.getEnum().addAll( fieldValidator.getOptions() ); } fieldValidation.setRequired( fieldValidator.isRequired() ); fieldValidation.setDisabled( fieldValidator.isDisabled() ); if ( fieldValidator.getErrorMessage() != null ) { fieldValidation.setErrorMessage( fieldValidator.getErrorMessage() ); } if ( fieldValidator.getRegex() != null ) { fieldValidation.setPattern( fieldValidator.getRegex() ); } return fieldValidation; }
public static ThingModifyCommandAdapter of(final HeaderTranslator headerTranslator) { return new ThingModifyCommandAdapter(requireNonNull(headerTranslator)); }
@Override public byte[] get(String namespacedKey) { readMessagesFromCoordinatorStream(); return messagesReadFromCoordinatorStream.get(namespacedKey); }
@Override protected byte[] getData(final BigInteger offset, final BigInteger length) { if (!isAvailable(offset, length)) { throw new IllegalStateException(format("Data to read is not available (offset=%d;length=%d;source=%s).", offset, length, this)); } return getData(values, ZERO, ZERO, offset, length, new byte[length.intValueExact()]).computeResult(); }
private static void validateResourceRequest(ResourceRequest resReq, Resource maximumResource, QueueInfo queueInfo, RMContext rmContext) throws InvalidResourceRequestException { if (resReq.getCapability().getMemory() < 0 || resReq.getCapability().getMemory() > maximumResource.getMemory()) { throw new InvalidResourceRequestException("Invalid resource request" + ", requested memory < 0" + ", or requested memory > max configured" + ", requestedMemory=" + resReq.getCapability().getMemory() + ", maxMemory=" + maximumResource.getMemory()); } if (resReq.getCapability().getVirtualCores() < 0 || resReq.getCapability().getVirtualCores() > maximumResource.getVirtualCores()) { throw new InvalidResourceRequestException("Invalid resource request" + ", requested virtual cores < 0" + ", or requested virtual cores > max configured" + ", requestedVirtualCores=" + resReq.getCapability().getVirtualCores() + ", maxVirtualCores=" + maximumResource.getVirtualCores()); } if (resReq.getCapability().getGpuCores() < 0 || resReq.getCapability().getGpuCores() > maximumResource.getGpuCores()) { throw new InvalidResourceRequestException("Invalid resource request" + ", requested gpu cores < 0" + ", or requested gpu cores > max configured" + ", requestedGpuCores=" + resReq.getCapability().getGpuCores() + ", maxGpuCores=" + maximumResource.getGpuCores()); } String labelExp = resReq.getNodeLabelExpression(); if (!ResourceRequest.ANY.equals(resReq.getResourceName()) && labelExp != null && !labelExp.trim().isEmpty()) { throw new InvalidResourceRequestException( "Invailid resource request, queue=" + queueInfo.getQueueName() + " specified node label expression in a " + "resource request has resource name = " + resReq.getResourceName()); } if (labelExp != null && labelExp.contains("&&")) { throw new InvalidResourceRequestException( "Invailid resource request, queue=" + queueInfo.getQueueName() + " specified more than one node label " + "in a node label expression, node label expression = " + labelExp); } if (labelExp != null && !labelExp.trim().isEmpty() && queueInfo != null) { if (!checkQueueLabelExpression(queueInfo.getAccessibleNodeLabels(), labelExp, rmContext)) { throw new InvalidResourceRequestException("Invalid resource request" + ", queue=" + queueInfo.getQueueName() + " doesn't have permission to access all labels " + "in resource request. labelExpression of resource request=" + labelExp + ". Queue labels=" + (queueInfo.getAccessibleNodeLabels() == null ? "" : StringUtils.join(queueInfo .getAccessibleNodeLabels().iterator(), ','))); } } }
@Override public void serialize(LocalDateTime value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeStartObject(); gen.writeFieldName(IsoDateDeSerializer.DATE_NODE); gen.writeString(value.format(DateTimeFormatter.ISO_DATE_TIME)); gen.writeEndObject(); }
public static DateTimeFormatter rfc5322() { return new DateTimeFormatterBuilder() .parseCaseInsensitive() .parseLenient() .optionalStart() .appendText(DAY_OF_WEEK, dayOfWeek()) .appendLiteral(", ") .optionalEnd() .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE) .appendLiteral(' ') .appendText(MONTH_OF_YEAR, monthOfYear()) .appendLiteral(' ') .appendValueReduced(YEAR, 2, 4, INITIAL_YEAR) .appendLiteral(' ') .appendValue(HOUR_OF_DAY, 2) .appendLiteral(':') .appendValue(MINUTE_OF_HOUR, 2) .optionalStart() .appendLiteral(':') .appendValue(SECOND_OF_MINUTE, 2) .optionalEnd() .appendLiteral(' ') .appendOffset("+HHMM", "GMT") .toFormatter(); }
@Override public Connection connect(String url, Properties info) throws SQLException { try { closeLock.readLock().lock(); checkClosed(); return super.connect(url, info); } finally { closeLock.readLock().unlock(); } }
@Override public void journalWait(final JournalWaitOptions opts) throws P4JavaException { List<Map<String, Object>> resultMaps = execMapCmdList(JOURNALWAIT, processParameters(opts, server), null); if (nonNull(resultMaps)) { for (Map<String, Object> map : resultMaps) { ResultMapParser.handleErrors(ResultMapParser.toServerMessage(map)); } } }
public DcDeleteResponse delete(final LinkDocHandler docHandler) { return this.delete(docHandler, -1); }
@Override public Mono<Mailbox> findMailboxByPath(MailboxPath path) { return mailboxPathV2DAO.retrieveId(path) .map(CassandraIdAndPath::getCassandraId) .flatMap(this::retrieveMailbox) .switchIfEmpty(fromPreviousTable(path)); }
public List<? extends TextEdit> format(TextDocument textDocument, Range range, SharedSettings sharedSettings) { try { XMLFormatterDocument formatterDocument = new XMLFormatterDocument(textDocument, range, sharedSettings); return formatterDocument.format(); } catch (BadLocationException e) { LOGGER.log(Level.SEVERE, "Formatting failed due to BadLocation", e); } return null; }
@JsonCreator public static Ip parse(String ipAsString) { return create(ipStrToLong(ipAsString)); }
@Override public Boolean exists(String key) { try (Jedis jedis = jedisPool.getResource()) { return jedis.exists(key); } }
public double getNormalizedVdWVolume(String symbol) { return this.getVdWVolume(symbol) / this.getVdWVolume("C"); }
@Override public <T> Optional<T> get(String property, Class<T> tClass) { return nodeAt(property) .map(node -> { if (tClass == Path.class) { return (T) Paths.get(node.textValue()); } return parseNodeToClass(node, tClass); }); }
public List<MBeanMetric> getMBeanMetrics(AppType appType) { List<MBeanMetric> mBeanMetrics = new ArrayList<>(); Set<ObjectName> mBeanNames; try { mBeanNames = getTesseraResourceMBeanNames(appType); for(ObjectName mBeanName : mBeanNames) { List<MBeanMetric> temp; try { temp = getMetricsForMBean(mBeanName); } catch (AttributeNotFoundException | MBeanException | InstanceNotFoundException | ReflectionException | IntrospectionException e) { throw new RuntimeException(e); } mBeanMetrics.addAll(temp); } } catch (MalformedObjectNameException e) { throw new RuntimeException(e); } return Collections.unmodifiableList(mBeanMetrics); }
@Override public boolean equals(Object obj) { if (obj == this) { return true; } else if (obj != null && obj.getClass() == ResourceSpec.class) { ResourceSpec that = (ResourceSpec) obj; return this.cpuCores == that.cpuCores && this.heapMemoryInMB == that.heapMemoryInMB && this.directMemoryInMB == that.directMemoryInMB && this.nativeMemoryInMB == that.nativeMemoryInMB && this.stateSizeInMB == that.stateSizeInMB && Objects.equals(this.extendedResources, that.extendedResources); } else { return false; } }
public String getAverageTimeFromStep(final Step step) { return stepTimes.get(step).getAverageTimeString(); }
List<K> getAllUpdatesFrom(long seqNum, long imgNum) throws Exception { LOGGER.debug(String.format("(%s) GetAllUpdatesFrom sequence number %d, image number %d", retrieverType, seqNum, imgNum)); if (imgNum >= IMAGE_NUMBER_UPDATE_UNINITIALIZED) { long curImgNum = imageRetriever.getLatestImageID(); LOGGER.debug("({}) Current image number for is {}", retrieverType, curImgNum); if (curImgNum == IMAGE_NUMBER_UPDATE_UNINITIALIZED) { return Collections.emptyList(); } if (curImgNum > imgNum) { String logMessage = String.format("(%s) Current image num %d is greater than requested " + "image num %d. Request a full update", retrieverType, curImgNum, imgNum); LOGGER.info(logMessage); System.out.println(SentryServiceUtil.getCurrentTimeStampWithMessage(logMessage)); List<K>fullImage = retrieveFullImage(); if( !fullImage.isEmpty()) { logMessage = String.format("(%s) A newer full update with image number %d " + "is less than requested image number %d. Send full update to HDFS", retrieverType, curImgNum, imgNum); LOGGER.info(logMessage); System.out.println(SentryServiceUtil.getCurrentTimeStampWithMessage(logMessage)); } return fullImage; } } long curSeqNum = deltaRetriever.getLatestDeltaID(); LOGGER.debug("({}) Current sequence number is {}", retrieverType, curSeqNum); if (seqNum == curSeqNum + 1) { LOGGER.debug("{}, No new updates", retrieverType); return Collections.emptyList(); } if (seqNum > SEQUENCE_NUMBER_FULL_UPDATE_REQUEST && deltaRetriever.isDeltaAvailable(seqNum)) { List<K> deltas = deltaRetriever.retrieveDelta(seqNum, imgNum); if (!deltas.isEmpty()) { LOGGER.info("({}) Newer delta updates are found up to sequence number {} and being sent to HDFS", retrieverType, curSeqNum); return deltas; } } String logMessage = String.format("(%s) Requested sequence number %d is less than 0 or " + "requested deltas for that sequence number are not available. Fetch a full update", retrieverType, seqNum); LOGGER.info(logMessage); System.out.println(SentryServiceUtil.getCurrentTimeStampWithMessage(logMessage)); List<K>fullImage = retrieveFullImage(); if( fullImage != null && !fullImage.isEmpty()) { logMessage = String.format("(%s) A full update is returned due to an unavailable sequence number: %d", retrieverType, seqNum); LOGGER.info(logMessage); System.out.println(SentryServiceUtil.getCurrentTimeStampWithMessage(logMessage)); } return fullImage; }
@Override public Collection<MetricAnomaly<BrokerEntity>> metricAnomalies(Map<BrokerEntity, ValuesAndExtrapolations> metricsHistoryByBroker, Map<BrokerEntity, ValuesAndExtrapolations> currentMetricsByBroker) { LOG.info("Slow broker detection started."); try { Set<BrokerEntity> detectedMetricAnomalies = detectMetricAnomalies(metricsHistoryByBroker, currentMetricsByBroker); updateBrokerSlownessScore(detectedMetricAnomalies); return createSlowBrokerAnomalies(detectedMetricAnomalies, metricsHistoryByBroker.size()); } catch (Exception e) { LOG.warn("Slow broker detector encountered exception: ", e); } finally { LOG.info("Slow broker detection finished."); } return Collections.emptySet(); }
@Override public SerializerAdapter serializerFor(Object object) { Class<?> clazz = object == null ? null : object.getClass(); SerializerAdapter serializer = null; if (clazz != null) { serializer = serializersByClass.get(clazz); } if (serializer == null) { try { serializer = delegate.serializerFor(object); } catch (HazelcastSerializationException hse) { throw serializationException(clazz, hse); } } if (serializer == null) { throw active ? serializationException(clazz) : new HazelcastInstanceNotActiveException(); } return serializer; }
@Override public String format(final String message, final Object[] arguments) { int length = message.length(); StringBuilder builder = new StringBuilder(length + ADDITIONAL_STRING_BUILDER_CAPACITY); StringBuilder buffer = new StringBuilder(length + ADDITIONAL_STRING_BUILDER_CAPACITY); StringBuilder current = builder; int argumentIndex = 0; int openingTickIndex = -1; int openingCurlyBrackets = 0; for (int index = 0; index < length; ++index) { char character = message.charAt(index); if (escape && character == '\'' && index + 1 < length && openingCurlyBrackets == 0) { if (message.charAt(index + 1) == '\'') { current.append('\''); index += 1; } else { openingTickIndex = openingTickIndex < 0 ? index : -1; } } else if (character == '{' && index + 1 < length && argumentIndex < arguments.length && openingTickIndex < 0) { if (openingCurlyBrackets++ == 0) { current = buffer; } else { current.append(character); } } else if (character == '}' && openingCurlyBrackets > 0 && openingTickIndex < 0) { if (--openingCurlyBrackets == 0) { Object argument = resolve(arguments[argumentIndex++]); if (buffer.length() == 0) { builder.append(argument); } else { builder.append(format(buffer.toString(), argument)); buffer.setLength(0); } buffer.setLength(0); current = builder; } else { current.append(character); } } else { current.append(character); } } if (buffer.length() > 0) { builder.append('{'); builder.append(buffer); } if (openingTickIndex >= 0) { builder.insert(openingTickIndex, '\''); } return builder.toString(); }
@Override public void load() throws PluginException { try { IBootstrapItem<String> item = new BootstrapItem("CollectionNamePlugin"); item .process(() -> { try { IKey collectionNameKey = Keys.getOrAdd(CollectionName.class.getCanonicalName()); IOC.register(collectionNameKey, new ResolveByNameIocStrategy( (args) -> { String name = String.valueOf(args[0]); try { return CollectionName.fromString(name); } catch (StorageException e) { throw new RuntimeException("Can't resolve collection name: ", e); } })); } catch (ResolutionException e) { throw new ActionExecuteException("CollectionName plugin can't load: can't get CollectionName key", e); } catch (InvalidArgumentException e) { throw new ActionExecuteException("CollectionName plugin can't load: can't create strategy", e); } catch (RegistrationException e) { throw new ActionExecuteException("CollectionName plugin can't load: can't register new strategy", e); } }); bootstrap.add(item); } catch (InvalidArgumentException e) { throw new PluginException("Can't load collection name plugin", e); } }
@Override public List<Assignment> doPageAssignments(Application.Name applicationName, Page.Name pageName, User.ID userID, Context context, boolean createAssignment, boolean ignoreSamplingPercent, HttpHeaders headers, SegmentationProfile segmentationProfile,boolean forceProfileCheck) { List<PageExperiment> pageExperimentList = getExperiments(applicationName, pageName); Map<Experiment.ID, Boolean> allowAssignments = new HashMap<>(pageExperimentList.size()); for (PageExperiment pageExperiment : pageExperimentList) { allowAssignments.put(pageExperiment.getId(), pageExperiment.getAllowNewAssignment()); } ExperimentBatch experimentBatch = createExperimentBatch(segmentationProfile, null); boolean updateDownstreamSystems = true; List<Assignment> assignments = doAssignments(userID, applicationName, context, createAssignment, ignoreSamplingPercent, headers, experimentBatch, pageName, allowAssignments, updateDownstreamSystems,forceProfileCheck); return assignments; }
protected static String createInteractionTypeSelector(List<String> interactionTypeSelectors) { TreeSet<InteractType> cypherTypes = new TreeSet<InteractType>(); for (String type : interactionTypeSelectors) { if (StringUtils.isNotBlank(type)) { InteractType interactType = InteractType.typeOf(type); if (interactType == null) { throw new IllegalArgumentException("unsupported interaction type [" + type + "]"); } else { cypherTypes.addAll(InteractType.typesOf(interactType)); } } } if (cypherTypes.isEmpty()) { cypherTypes.addAll(InteractType.typesOf(InteractType.RELATED_TO)); } return StringUtils.join(cypherTypes, "|"); }
@CheckForNull public MethodBehavior getMethodBehavior(String signature, SquidClassLoader classLoader) { if (methodFromArray(signature)) { return null; } methodBehavior = behaviorCache.methodBehaviorForSymbol(signature); if (!methodBehavior.isVisited()) { try { methodBehavior.visited(); execute(signature, classLoader); } catch (ExplodedGraphWalker.MaximumStepsReachedException | RelationalSymbolicValue.TransitiveRelationExceededException | BytecodeAnalysisException e) { LOG.debug("Dataflow analysis is incomplete for method {} : {}", signature, e.getMessage()); } catch (Exception e) { throw new BytecodeAnalysisException("Failed dataflow analysis for " + signature, e); } } return methodBehavior; }
@Override public LifeCycleStatusCode getObjectGroupLifeCycleStatus(String objectGroupId) throws LogbookClientNotFoundException, LogbookClientServerException { try (Response response = make(head().withPath(OBJECT_GROUP_LIFECYCLES_URL + "/" + objectGroupId).withJsonAccept())) { check(response); if (response.getHeaderString(X_EVENT_STATUS) != null) { return LifeCycleStatusCode.valueOf(response.getHeaderString(X_EVENT_STATUS)); } throw new LogbookClientServerException(ErrorMessage.INTERNAL_SERVER_ERROR.getMessage()); } catch (PreconditionFailedClientException | VitamClientInternalException | LogbookClientBadRequestException | LogbookClientAlreadyExistsException e) { throw new LogbookClientServerException(ErrorMessage.INTERNAL_SERVER_ERROR.getMessage(), e); } }
public static String unmangleXmlString(String str, boolean decodeEntityRefs) throws UnmanglingError { int slashPosition = -1; String escapedCp = ""; StringBuilder bld = new StringBuilder(); StringBuilder entityRef = null; for (int i = 0; i < str.length(); i++) { char ch = str.charAt(i); if (entityRef != null) { entityRef.append(ch); if (ch == ';') { String e = entityRef.toString(); if (e.equals("&quot;")) { bld.append("\""); } else if (e.equals("&apos;")) { bld.append("\'"); } else if (e.equals("&amp;")) { bld.append("&"); } else if (e.equals("&lt;")) { bld.append("<"); } else if (e.equals("&gt;")) { bld.append(">"); } else { throw new UnmanglingError("Unknown entity ref " + e); } entityRef = null; } } else if ((slashPosition >= 0) && (slashPosition < NUM_SLASH_POSITIONS)) { escapedCp += ch; ++slashPosition; } else if (slashPosition == NUM_SLASH_POSITIONS) { if (ch != ';') { throw new UnmanglingError("unterminated code point escape: " + "expected semicolon at end."); } try { bld.appendCodePoint(Integer.parseInt(escapedCp, 16)); } catch (NumberFormatException e) { throw new UnmanglingError("error parsing unmangling escape code", e); } escapedCp = ""; slashPosition = -1; } else if (ch == '\\') { slashPosition = 0; } else { boolean startingEntityRef = false; if (decodeEntityRefs) { startingEntityRef = (ch == '&'); } if (startingEntityRef) { entityRef = new StringBuilder(); entityRef.append("&"); } else { bld.append(ch); } } } if (entityRef != null) { throw new UnmanglingError("unterminated entity ref starting with " + entityRef.toString()); } else if (slashPosition != -1) { throw new UnmanglingError("unterminated code point escape: string " + "broke off in the middle"); } return bld.toString(); }
@Override public void basicValidate(final String configSection) throws ConfigException { if (dateField == null || dateField.getNormalisedPath().isEmpty()) { throw new ConfigException(configSection, "dateField must be provided"); } validateInteger(defaultNumberOfBuckets, "Default number of buckets"); validateInteger(minNumberOfBuckets, "Minimum number of buckets"); validateInteger(maxNumberOfBuckets, "Maximum number of buckets"); validateInteger(numberOfValues, "Number of values"); if (maxNumberOfBuckets < defaultNumberOfBuckets || minNumberOfBuckets > defaultNumberOfBuckets) { throw new ConfigException(configSection, "Default number of buckets must lie between max and min"); } }
@Override public String getDescription(Locale locale) { return Constants.DESCRIPTION; }
@Override public List<List<?>> takeNextPage() { return values; }
@Override public ReadableBuffer slice() { return new AmqpReadableBuffer(buffer.slice()); }
@GET @Path("/{applicationName}") public ApplicationSlaRepresentation getApplicationSLA(@PathParam("applicationName") String applicationName, @QueryParam("extended") boolean extended) { Either<ApplicationSlaRepresentation, WebApplicationException> result = CellWebClientConnectorUtil.doGetFromCell( cellWebClientConnector, API_PATH + '/' + applicationName + "?extended=" + extended, APPLICATION_SLA_TP, configuration.getRestRequestTimeoutMs() ); if (result.hasError()) { throw result.getError(); } return result.getValue(); }
public String convert(Object val) { if (val == null) { return null; } String converted; if (val instanceof String) { converted = val.toString(); } else if (val instanceof InetAddress) { converted = val.toString(); } else if (val instanceof UUID) { converted = val.toString(); } else if (val instanceof Date) { converted = dateFomrat.get().format(val); } else if (val instanceof LocalDateTime) { converted = timeFormatter.format((LocalDateTime) val); } else if (val instanceof BigInteger) { converted = val.toString(); } else if (val instanceof Double) { converted = Double.toString((Double) val); } else if (val instanceof BigDecimal) { converted = val.toString(); } else if (val instanceof Boolean) { converted = Boolean.toString((Boolean) val); } else if (val instanceof Integer) { converted = Integer.toString((Integer) val); } else if (val instanceof Long) { converted = Long.toString((Long) val); } else if (val instanceof Float) { converted = Float.toString((Float) val); } else { LOG.warn("Could not find mapping for type: {}", val.getClass()); converted = val.toString(); } LOG.trace("Converted: {} to {}", val, converted); return converted; }
public static String truncateToSize(String content, int size) { byte[] bytes = content.getBytes(StandardCharsets.UTF_8); if (bytes.length <= size) { return content; } bytes = Arrays.copyOf(bytes, size); int i = size - 1; while ((bytes[i] & 0x80) != 0) { i--; } if (i < (size - 1)) { bytes = Arrays.copyOf(bytes, i + 1); } return _truncateToWord(new String(bytes, StandardCharsets.UTF_8)); }
public StrategyBasedLinearGradientBuilder setGradientDirectionAsStrategy(GradientStrategy gradientStrategy) { this.gradientStrategy = gradientStrategy != null ? gradientStrategy : GradientStrategy.TO_BOTTOM; this.isCentralRotationAngleStrategy = false; return this; }
@Override public String[] getDefaultFileExtensions() { return new String[]{".hdf"}; }
@VisibleForTesting static byte[] reconstructDeletedSequence(int position, @NotNull final byte[] readSequence, @NotNull final String ref) { final byte[] refBytes = ref.getBytes(); final byte[] completeSequence = new byte[readSequence.length + ref.length() - 1]; int tailLength = readSequence.length - position - 1; System.arraycopy(readSequence, 0, completeSequence, 0, position + 1); System.arraycopy(refBytes, 1, completeSequence, position + 1, ref.length() - 1); System.arraycopy(readSequence, position + 1, completeSequence, completeSequence.length - tailLength, tailLength); return completeSequence; }
public static org.eclipse.californium.core.coap.CoAP.ResponseCode toCoapResponseCode( ResponseCode Lwm2mResponseCode) { Validate.notNull(Lwm2mResponseCode); try { return org.eclipse.californium.core.coap.CoAP.ResponseCode.valueOf(toCoapCode(Lwm2mResponseCode.getCode())); } catch (MessageFormatException e) { throw new IllegalArgumentException("Invalid CoAP code for LWM2M response: " + Lwm2mResponseCode); } }
@Override public Node getMetadata(String identifier, final MetadataType mode) throws MetadataIoException { try { alreadyRead.clear(); Object result = null; if (isCacheEnabled()) { result = getFromCache(identifier); } if (result == null) { final FullRecord f = mdReader.getRecord(identifier); if (mode == MetadataType.NATIVE) { result = f; } else { result = getObjectFromRecord(identifier, f, mode); } } else { LOGGER.log(Level.FINER, "getting from cache: {0}", identifier); } if (result != null) { return writeObjectInNode(result, mode); } return null; } catch (MD_IOException e) { throw new MetadataIoException("MD_IO Exception while reading the metadata: " + identifier, e, null, "id"); } }
@VisibleForTesting static Map<Location, BDD> getAnswerBdds( BidirectionalReachabilityResult result, ReturnFlowType returnFlowType) { Map<Location, BDD> successBdds = result.getStartLocationReturnPassSuccessBdds(); Map<Location, BDD> failureBdds = result.getStartLocationReturnPassFailureBdds(); switch (returnFlowType) { case SUCCESS: return successBdds.entrySet().stream() .map( entry -> { Location loc = entry.getKey(); BDD success = entry.getValue(); BDD fail = failureBdds.get(loc); BDD successOnly = fail == null ? success : success.diff(fail); return Maps.immutableEntry(loc, successOnly.isZero() ? success : successOnly); }) .collect(ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue)); case FAILURE: return failureBdds.entrySet().stream() .map( entry -> { Location loc = entry.getKey(); BDD fail = entry.getValue(); BDD success = successBdds.get(loc); BDD failOnly = success == null ? fail : fail.diff(success); return Maps.immutableEntry(loc, failOnly.isZero() ? fail : failOnly); }) .collect(ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue)); case MULTIPATH_INCONSISTENT: return successBdds.entrySet().stream() .flatMap( entry -> { Location loc = entry.getKey(); BDD success = entry.getValue(); BDD fail = failureBdds.get(loc); if (fail == null) { return Stream.of(); } BDD multipath = success.and(fail); return multipath.isZero() ? Stream.of() : Stream.of(Maps.immutableEntry(loc, multipath)); }) .collect(ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue)); default: throw new IllegalStateException("Unexpected ReturnFlowType: " + returnFlowType); } }
protected void evalOpInternal(final Context ctx, final Supplier<GremlinExecutor> gremlinExecutorSupplier, final BindingSupplier bindingsSupplier) throws OpProcessorException { final Timer.Context timerContext = evalOpTimer.time(); final RequestMessage msg = ctx.getRequestMessage(); final GremlinExecutor gremlinExecutor = gremlinExecutorSupplier.get(); final Settings settings = ctx.getSettings(); final Map<String, Object> args = msg.getArgs(); final String script = (String) args.get(Tokens.ARGS_GREMLIN); final String language = args.containsKey(Tokens.ARGS_LANGUAGE) ? (String) args.get(Tokens.ARGS_LANGUAGE) : null; final Bindings bindings = new SimpleBindings(); final boolean managedTransactionsForRequest = manageTransactions ? true : (Boolean) args.getOrDefault(Tokens.ARGS_MANAGE_TRANSACTION, false); final long seto = args.containsKey(Tokens.ARGS_EVAL_TIMEOUT) ? ((Number) args.get(Tokens.ARGS_EVAL_TIMEOUT)).longValue() : settings.getEvaluationTimeout(); final GremlinExecutor.LifeCycle lifeCycle = GremlinExecutor.LifeCycle.build() .evaluationTimeoutOverride(seto) .afterFailure((b,t) -> { if (managedTransactionsForRequest) attemptRollback(msg, ctx.getGraphManager(), settings.strictTransactionManagement); }) .beforeEval(b -> { try { b.putAll(bindingsSupplier.get()); } catch (OpProcessorException ope) { throw new RuntimeException(ope); } }) .withResult(o -> { final Iterator itty = IteratorUtils.asIterator(o); logger.debug("Preparing to iterate results from - {} - in thread [{}]", msg, Thread.currentThread().getName()); if (settings.authentication.enableAuditLog) { String address = ctx.getChannelHandlerContext().channel().remoteAddress().toString(); if (address.startsWith("/") && address.length() > 1) address = address.substring(1); auditLogger.info("User with address {} requested: {}", address, script); } try { handleIterator(ctx, itty); } catch (Exception ex) { if (managedTransactionsForRequest) attemptRollback(msg, ctx.getGraphManager(), settings.strictTransactionManagement); throw new RuntimeException(ex); } }).create(); final CompletableFuture<Object> evalFuture = gremlinExecutor.eval(script, language, bindings, lifeCycle); evalFuture.handle((v, t) -> { timerContext.stop(); if (t != null) { if (t instanceof OpProcessorException) { ctx.writeAndFlush(((OpProcessorException) t).getResponseMessage()); } else if (t instanceof TimedInterruptTimeoutException) { final String errorMessage = String.format("A timeout occurred within the script during evaluation of [%s] - consider increasing the limit given to TimedInterruptCustomizerProvider", msg); logger.warn(errorMessage); ctx.writeAndFlush(ResponseMessage.build(msg).code(ResponseStatusCode.SERVER_ERROR_TIMEOUT) .statusMessage("Timeout during script evaluation triggered by TimedInterruptCustomizerProvider") .statusAttributeException(t).create()); } else if (t instanceof TimeoutException) { final String errorMessage = String.format("Script evaluation exceeded the configured threshold for request [%s]", msg); logger.warn(errorMessage, t); ctx.writeAndFlush(ResponseMessage.build(msg).code(ResponseStatusCode.SERVER_ERROR_TIMEOUT) .statusMessage(t.getMessage()) .statusAttributeException(t).create()); } else { if (t instanceof MultipleCompilationErrorsException && t.getMessage().contains("Method too large") && ((MultipleCompilationErrorsException) t).getErrorCollector().getErrorCount() == 1) { final String errorMessage = String.format("The Gremlin statement that was submitted exceeds the maximum compilation size allowed by the JVM, please split it into multiple smaller statements - %s", trimMessage(msg)); logger.warn(errorMessage); ctx.writeAndFlush(ResponseMessage.build(msg).code(ResponseStatusCode.SERVER_ERROR_EVALUATION) .statusMessage(errorMessage) .statusAttributeException(t).create()); } else { final String errorMessage = (t.getMessage() == null) ? t.toString() : t.getMessage(); logger.warn(String.format("Exception processing a script on request [%s].", msg), t); ctx.writeAndFlush(ResponseMessage.build(msg).code(ResponseStatusCode.SERVER_ERROR_EVALUATION) .statusMessage(errorMessage) .statusAttributeException(t).create()); } } } return null; }); }
public MappedAppSchema getMappedSchema() { return mappedSchema; }
public boolean sendEmail(List<ContactList> listOfContactLists, String subject, String body) throws AddressException, MessagingException { return sendEmail(listOfContactLists, subject, body, null); }
@Override public long getBlobLength(String blobId) throws IOException { return blobId.length(); }
public String getMessage() { return (String) parameterMap.get(FIELD_MESSAGE); }
public List<T> getValues() { List<T> result = new ArrayList<>(); for (int i = 0; i < keys.length; i++) { int key = keys[i]; if (key >= 0) { result.add(values[i]); } } return result; }
public Users getUsers() throws StoreException { Users users = new Users(); users.setUsers(listAll()); return users; }
@Override public ApiGatewayResponse handleRequest(Map<String, Object> input, Context context) { LOG.info("received: " + input); return new ApiGatewayResponse.ApiGatewayResponseBuilder<LambdaInfo>() .headers(headers()) .statusCode(SUCCESS_STATUS_CODE) .body(lambdaInfo(context)) .build(); }
public static long random(final boolean client, final boolean bidirectional) { return encodeType(client, bidirectional, Varint.random(4)); }
<T> AxiomValueGatherer mapEntityToAxioms(URI identifier, T entity, EntityType<T> et, Descriptor descriptor) { assert identifier != null; final AxiomValueGatherer valueBuilder = createAxiomValueBuilder(identifier, descriptor); try { for (FieldSpecification<? super T, ?> att : et.getFieldSpecifications()) { addAssertions(entity, et, att, descriptor, valueBuilder); } } catch (IllegalArgumentException | IllegalAccessException e) { throw new EntityDeconstructionException(e); } return valueBuilder; }
public List<FlowDetails> processClassifier( final SclServiceFunctionForwarder theClassifier, final Acl theAcl, final boolean addClassifierScenario) { addClassifier = addClassifierScenario; Optional<ServiceFunctionForwarder> sff = Optional.of(new SffName(theClassifier.getName())) .map(SfcProviderServiceForwarderAPI::readServiceFunctionForwarder); Optional<String> itfName = classifierHandler.getInterfaceNameFromClassifier(theClassifier); if (!sff.isPresent() || !itfName.isPresent()) { LOG.error("createdServiceFunctionClassifier: " + "Cannot install ACL rules in classifier. SFF exists? {}; Interface exists? {}", sff.isPresent(), itfName.isPresent()); return Collections.emptyList(); } classifierInterface = classifierHandler.usesLogicalInterfaces(sff.get()) ? logicallyAttachedClassifier : bareClassifier.setSff(sff.get()); Optional<String> nodeName = itfName.flatMap(classifierInterface::getNodeName); if(!nodeName.isPresent()) { LOG.error("createdServiceFunctionClassifier: Could not extract the node name from the OVS interface"); return Collections.emptyList(); } if (classifierHandler.usesLogicalInterfaces(sff.get())) { if (addClassifierScenario) { ClassifierGeniusIntegration.performGeniusServiceBinding(tx, itfName.get()); LOG.info("processClassifier - Bound interface {}", itfName.get()); } else { ClassifierGeniusIntegration.performGeniusServiceUnbinding(tx, itfName.get()); LOG.info("processClassifier - Unbound interface {}", itfName.get()); } } return theAcl .getAccessListEntries() .getAce() .stream() .map(theAce -> processAce(nodeName.get(), sff.get(), theClassifier.getName(), theAcl.getAclName(), itfName.get(), theAce)) .reduce(new ArrayList<>(), (dstList, theList) -> Stream.concat(dstList.stream(), theList.stream()).collect(Collectors.toList())); }
@Override public boolean isAuthorized( HttpServletRequest request, SecuritySession securitySession, String repositoryId, String permission ) throws AuthorizationException, UnauthorizedException { AuthorizationResult authzResult = securitySystem.authorize( securitySession, permission, repositoryId ); if ( !authzResult.isAuthorized() ) { if ( authzResult.getException() != null ) { log.info( "Authorization Denied [ip={},permission={},repo={}] : {}", request.getRemoteAddr(), permission, repositoryId, authzResult.getException().getMessage() ); throw new UnauthorizedException( "Access denied for repository " + repositoryId ); } throw new UnauthorizedException( "User account is locked" ); } return true; }
@Override public String getTypeName(PropertyMetaData propertyMetaData) { Class<?> propertyType = propertyMetaData.getPropertyDescriptor().getPropertyType(); return getTypeName(propertyType); }
@Override public String getInitParameter(String name) { return initParams.get(name); }
public static JavaVersion parseJavaVersion(final String fullVersionString) { if (!StringUtils.isNullOrEmpty(fullVersionString)) { final Matcher matcher = VERSION_REGEX.matcher(fullVersionString); if (matcher.matches()) { final Integer majorVersionFamily = NumberUtils.tryParseInt(matcher.group(1)); final Integer majorVersion = NumberUtils.tryParseInt(matcher.group(2)); final Integer maintenanceNumber = NumberUtils.tryParseInt(matcher.group(3)); final Integer updateNumber = NumberUtils.tryParseInt(matcher.group(4)); return new JavaVersion(majorVersionFamily, majorVersion, maintenanceNumber, updateNumber); } } return JavaVersion.UNKNOWN; }
@Override public boolean delTemplate(String templateId) throws WxErrorException { Map<String, String> params = new HashMap<>(); params.put("template_id", templateId); String responseText = this.wxMaService.post(TEMPLATE_DEL_URL, WxGsonBuilder.create().toJson(params)); WxError wxError = WxError.fromJson(responseText); if(wxError.getErrorCode() == 0){ return true; }else { throw new WxErrorException(wxError); } }
public EntityModel saveEntity(EntityModel entity) throws IOException { JsonNode node = entity.toJson(); String fullpath = entity.getFilename(); HubEntity hubEntity = HubEntity.fromJson(fullpath, node); if (fullpath == null) { String entityFileName = entity.getName() + ENTITY_FILE_EXTENSION; File entityFile = hubConfig.getHubEntitiesDir().resolve(entityFileName).toFile(); String canonicalFileName = Paths.get(entityFile.getCanonicalPath()).getFileName().toString(); if (entityFile.exists() && !entityFileName.equals(canonicalFileName)) { throw new DataHubProjectException("An entity with this name already exists."); } em.saveEntity(hubEntity, false); } else { HubEntity renamedEntity = em.saveEntity(hubEntity, true); entity.setFilename(renamedEntity.getFilename()); } return entity; }
@Override public void adapt(Scan scan, ReadHooks readHooks, Query query) { throwIfUnsupportedScan(scan); toByteStringRange(scan, query); query.filter(buildFilter(scan, readHooks)); if (LIMIT_AVAILABLE && scan.getLimit() > 0) { query.limit(scan.getLimit()); } }
public SSLContext build() { try { PrivateKey privateKey = KeyFactory.getInstance("RSA").generatePrivate(new PKCS8EncodedKeySpec(PEM.decode(KEY))); Certificate certificate = CertificateFactory.getInstance("X.509").generateCertificate(new ByteArrayInputStream(PEM.decode(CERT))); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); keyStore.setKeyEntry("default", privateKey, new char[0], new Certificate[]{certificate}); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, new char[0]); SSLContext context = SSLContext.getInstance("TLS"); context.init(keyManagerFactory.getKeyManagers(), null, null); return context; } catch (KeyStoreException | IOException | CertificateException | UnrecoverableKeyException | NoSuchAlgorithmException | KeyManagementException | InvalidKeySpecException e) { throw new Error(e); } }
@Override public void setCheckedStatus(boolean isChecked) { ButtonResources.Css buttonCss = resources.buttonCss(); if (isChecked) { icon.removeClassNameBaseVal(buttonCss.whiteColor()); icon.addClassNameBaseVal(buttonCss.activeConsoleButton()); } else { icon.removeClassNameBaseVal(buttonCss.activeConsoleButton()); icon.addClassNameBaseVal(buttonCss.whiteColor()); } image.getElement().appendChild(icon.getSvgElement().getElement()); }
@DELETE public @Nonnull Response delete(@QueryParam(QP_KEY) String key) throws IOException { if (Main.getWorkMgr().deleteNetworkObject(_network, key)) { return Response.ok().build(); } else { return Response.status(Status.NOT_FOUND).build(); } }
@Override public void undeploy( Instance instance ) throws PluginException { this.logger.fine( this.agentId + " is undeploying instance " + instance ); try { prepareAndExecuteCommand( "undeploy", instance, null, null ); } catch( Exception e ) { throw new PluginException( e ); } }
@Override public boolean offer(S next, int nextSizeInBytes) { lock.lock(); try { if (count == maxSize) return false; if (sizeInBytes + nextSizeInBytes > maxBytes) return false; elements[writePos] = next; sizesInBytes[writePos++] = nextSizeInBytes; if (writePos == maxSize) writePos = 0; count++; sizeInBytes += nextSizeInBytes; available.signal(); return true; } finally { lock.unlock(); } }
@Override @Transactional public CmsResponse<CmsConsent> getConsentById(String consentId) { Optional<ConsentEntity> consentEntityOptional = consentJpaRepository.findByExternalId(consentId) .map(aisConsentConfirmationExpirationService::checkAndUpdateOnConfirmationExpiration) .map(this::checkAndUpdateOnExpiration); if (consentEntityOptional.isEmpty()) { log.info("Consent ID [{}]. Get consent by ID failed, couldn't find consent by its ID", consentId); return CmsResponse.<CmsConsent>builder() .error(LOGICAL_ERROR) .build(); } ConsentEntity consentEntity = consentEntityOptional.get(); consentEntity = aisConsentLazyMigrationService.migrateIfNeeded(consentEntity); List<AuthorisationEntity> authorisations = authorisationRepository.findAllByParentExternalIdAndAuthorisationType(consentEntity.getExternalId(), AuthorisationType.AIS); CmsConsent cmsConsent = cmsConsentMapper.mapToCmsConsent(consentEntity, authorisations, aisConsentUsageService.getUsageCounterMap(consentEntity)); return CmsResponse.<CmsConsent>builder() .payload(cmsConsent) .build(); }
@PublicEvolving public static <IN, OUT> TypeInformation<OUT> getMapReturnTypes(MapFunction<IN, OUT> mapInterface, TypeInformation<IN> inType) { return getMapReturnTypes(mapInterface, inType, null, false); }
public static String eventTimeToString(double eventTime) { return eventTimeToFormat(eventTime, dateTimeFormatter); }
public void setupBindings(BindingContext bindingContext) { addFieldBindings(bindingContext); addMethodBindings(bindingContext); }
public T send() throws IOException { return neow3jService.send(this, responseType); }
File directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (!taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
public static KeyStore loadKeyStore(File certificateChainFile, File privateKeyFile, String keyPassword) throws IOException, GeneralSecurityException { PrivateKey key; try { key = createPrivateKey(privateKeyFile, keyPassword); } catch (OperatorCreationException | IOException | GeneralSecurityException | PKCSException e) { throw new GeneralSecurityException("Private Key issues", e); } List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile); if (certificateChain.isEmpty()) { throw new CertificateException("Certificate file does not contain any certificates: " + certificateChainFile); } KeyStore keyStore = KeyStore.getInstance("JKS"); keyStore.load(null, null); keyStore.setKeyEntry("key", key, keyPassword.toCharArray(), certificateChain.stream().toArray(Certificate[]::new)); return keyStore; }
public static FormatterStep create(Provisioner provisioner) { return create(defaultVersion(), provisioner, null); }
@Override public void checkAuthorization( final KsqlSecurityContext securityContext, final MetaStore metaStore, final Statement statement ) { if (statement instanceof Query) { validateQuery(securityContext, metaStore, (Query)statement); } else if (statement instanceof InsertInto) { validateInsertInto(securityContext, metaStore, (InsertInto)statement); } else if (statement instanceof CreateAsSelect) { validateCreateAsSelect(securityContext, metaStore, (CreateAsSelect)statement); } else if (statement instanceof PrintTopic) { validatePrintTopic(securityContext, (PrintTopic)statement); } else if (statement instanceof CreateSource) { validateCreateSource(securityContext, (CreateSource)statement); } }
static CharSequence charSeqOrEmpty(CharSequence candidate) { return charSeqOrDefault(candidate, ""); }
public void stopAndDrainOpsOnce() throws InterruptedException { stopAndDrainOps(false); }
public static InstrumentedThreadFactory defaultThreadFactory(MetricRegistry registry, String name) { return new InstrumentedThreadFactory(Executors.defaultThreadFactory(), registry, name); }
@Override public void onNewToken(String token) { AppCenterLog.debug(LOG_TAG, "Received push token update via service callback."); Push.getInstance().onTokenRefresh(token); }
public String getDigestRollingPolicy() { return digestRollingPolicy; }
@Override public boolean matches(MatchDifference matchDifference, RequestDefinition requestDefinition) { boolean result = false; if (httpRequestPropertiesMatchers != null && !httpRequestPropertiesMatchers.isEmpty()) { for (HttpRequestPropertiesMatcher httpRequestPropertiesMatcher : httpRequestPropertiesMatchers) { if (matchDifference == null) { if (MockServerLogger.isEnabled(Level.TRACE) && requestDefinition instanceof HttpRequest) { matchDifference = new MatchDifference(requestDefinition); } result = httpRequestPropertiesMatcher.matches(matchDifference, requestDefinition); } else { MatchDifference singleMatchDifference = new MatchDifference(matchDifference.getHttpRequest()); result = httpRequestPropertiesMatcher.matches(singleMatchDifference, requestDefinition); matchDifference.addDifferences(singleMatchDifference.getAllDifferences()); } if (result) { break; } } } else { result = true; } return result; }
@Override public void write(final MySQLPacketPayload payload) { payload.writeStringLenenc(CATALOG); payload.writeStringLenenc(schema); payload.writeStringLenenc(table); payload.writeStringLenenc(orgTable); payload.writeStringLenenc(name); payload.writeStringLenenc(orgName); payload.writeIntLenenc(NEXT_LENGTH); payload.writeInt2(characterSet); payload.writeInt4(columnLength); payload.writeInt1(columnType.getValue()); payload.writeInt2(flags); payload.writeInt1(decimals); payload.writeReserved(2); }
@GetMapping("/welcome-with-object") public WelcomeBean welcomeWithObject() { return new WelcomeBean("Hello World"); }
@GetMapping("/{projectId}/monitoring-officer") public RestResult<LegacyMonitoringOfficerResource> getMonitoringOfficer(@PathVariable("projectId") final Long projectId) { return monitoringOfficerService.getMonitoringOfficer(projectId).toGetResponse(); }
public static CSVFileManager fromConfiguration() { checkState(Configuration.isInitialized(), "configuration not initialized"); String filePath = Configuration.getString(FILEPATH, null).get(); checkConfiguration(!filePath.isEmpty(), FILEPATH + " is required"); Path csvFilePath = Paths.get(filePath); checkConfiguration(Files.exists(csvFilePath), "File does not exist: " + FILEPATH + "=" + filePath); Charset fileCharset = Configuration.getValue(FILE_ENCODING, defaultCharset(), value -> { try { return Charset.forName(value); } catch (IllegalCharsetNameException | UnsupportedCharsetException e) { throw new InvalidConfigurationException( "Invalid charset: " + FILE_ENCODING + "=" + value); } } ).get(); Boolean skipHeader = Configuration.getBoolean(SKIP_HEADER, false).get(); List<String> csvColumns = Configuration.getMultiValue( CSVCOLUMNS, Collections.emptyList(), Configuration.STRING_PARSER).get(); String csvFormatName = Configuration.getString(CSV_FORMAT, "").get(); CSVFormat csvFormat = createCsvFormat(csvFormatName, csvColumns, skipHeader); Set<String> headers; try (CSVParser parser = CSVParser.parse(csvFilePath.toFile(), fileCharset, csvFormat)) { headers = parser.getHeaderMap().keySet(); } catch (IOException e) { throw new InvalidConfigurationException("Error reading " + csvFilePath, e); } List<String> uniqueKeyColumns = Configuration.getMultiValue( UNIQUE_KEY_COLUMNS, Collections.emptyList(), Configuration.STRING_PARSER).get(); verifyColumns(UNIQUE_KEY_COLUMNS, new HashSet<>(uniqueKeyColumns), "column headers", headers); UrlBuilder urlBuilder = UrlBuilder.fromConfiguration(); Set<String> missing = urlBuilder.getMissingColumns(headers); checkConfiguration(missing.isEmpty(), getMissingMessage(UrlBuilder.CONFIG_COLUMNS, missing, "column headers", headers)); List<String> multiValueColumns = Configuration.getMultiValue( MULTIVALUE_COLUMNS, Collections.emptyList(), Configuration.STRING_PARSER).get(); verifyColumns(MULTIVALUE_COLUMNS, new HashSet<>(multiValueColumns), "column headers", headers); Set<String> multiValueColumnsWithConfiguredSeparators = Configuration.getConfig() .keySet() .stream() .map(key -> key.toString()) .filter(key -> key.startsWith("csv.multiValue.")) .map(key -> key.substring("csv.multiValue.".length())) .collect(Collectors.toSet()); checkConfiguration( multiValueColumns.size() > 0 || multiValueColumnsWithConfiguredSeparators.size() == 0, "Multi-value separators are configured but no multi-value columns are configured"); verifyColumns("csv.multiValue.*", multiValueColumnsWithConfiguredSeparators, MULTIVALUE_COLUMNS, new HashSet<>(multiValueColumns)); Map<String, String> columnsToDelimiter = new HashMap<>(); for (String column : multiValueColumns) { String delimiter = Configuration .getString(String.format(MULTIVALUE_FORMAT_COLUMN, column), ",").get(); columnsToDelimiter.put(column, delimiter); } return new Builder() .setFilePath(csvFilePath) .setFileCharset(fileCharset) .setUniqueKeyColumns(uniqueKeyColumns) .setCsvFormat(csvFormat) .setContentTemplate(ContentTemplate.fromConfiguration("csv")) .setColumnsToDelimiter(columnsToDelimiter) .setUrlBuilder(urlBuilder) .verify() .build(); }
@Override public Review review(PropertyFileDescriptor descriptor, Property master, Property slave) { if(master==null||slave==null) return null; String masterValue = master.getValue(); String slaveValue = slave.getValue(); if(masterValue!=null) { if(masterValue.equals(slaveValue)) { if(terminologyProvider!=null) { Map<String, Property> terminology = terminologyProvider.getTerminology(descriptor.getVariant()); Property terminologyEntry = terminology.get(slave.getValue()); if(terminologyEntry!=null && slave.getValue().equals(terminologyEntry.getValue())){ return null; } } Review review = PropertiesFactory.eINSTANCE.createReview(); review.setCreated(System.currentTimeMillis()); review.setMessage("Template and translated string are identical"); review.setReviewType(getReviewType()); review.setSeverity(Severity.WARNING); review.setUser("Jabylon"); return review; } } return null; }
@Override public void removeSchema(Name typeName) throws IOException { this.removeSchema(typeName.getLocalPart()); }
@Override public PathAttributes find(final Path file) throws BackgroundException { if(file.isRoot()) { return PathAttributes.EMPTY; } if(file.getType().contains(Path.Type.upload)) { return PathAttributes.EMPTY; } if(containerService.isContainer(file)) { final PathAttributes attributes = new PathAttributes(); attributes.setRegion(new S3LocationFeature(session, session.getClient().getRegionEndpointCache()).getLocation(file).getIdentifier()); return attributes; } try { final String container = containerService.getContainer(file).getName(); PathAttributes attr; try { attr = this.toAttributes(session.getClient().getVersionedObjectDetails(file.attributes().getVersionId(), container, containerService.getKey(file))); } catch(ServiceException e) { if(null != e.getResponseHeaders()) { if(e.getResponseHeaders().containsKey(AMZ_DELETE_MARKER)) { attr = new PathAttributes().withVersionId(e.getResponseHeaders().get(AMZ_VERSION_ID)); attr.setCustom(Collections.singletonMap(KEY_DELETE_MARKER, Boolean.TRUE.toString())); attr.setDuplicate(true); return attr; } else { throw new S3ExceptionMappingService().map("Failure to read attributes of {0}", e, file); } } else { throw new S3ExceptionMappingService().map("Failure to read attributes of {0}", e, file); } } if(references) { if(StringUtils.isNotBlank(attr.getVersionId())) { final AttributedList<Path> list = new S3VersionedObjectListService(session, true).list(file, new DisabledListProgressListener()); final Path versioned = list.find(new DefaultPathPredicate(file)); if(null != versioned) { attr.setDuplicate(versioned.attributes().isDuplicate()); attr.setVersions(versioned.attributes().getVersions()); return attr; } } } else { if(StringUtils.isNotBlank(attr.getVersionId())) { try { final String latest = this.toAttributes(session.getClient().getObjectDetails(container, containerService.getKey(file))).getVersionId(); attr.setDuplicate(!latest.equals(attr.getVersionId())); } catch(ServiceException e) { final BackgroundException failure = new S3ExceptionMappingService().map("Failure to read attributes of {0}", e, file); if(failure instanceof NotfoundException) { attr.setCustom(Collections.singletonMap(KEY_DELETE_MARKER, Boolean.TRUE.toString())); attr.setDuplicate(true); } else { throw failure; } } } } return attr; } catch(NotfoundException e) { if(file.isPlaceholder()) { try { new S3ObjectListService(session).list(file, new DisabledListProgressListener(), containerService.getKey(file), 1); } catch(NotfoundException n) { throw e; } return PathAttributes.EMPTY; } throw e; } }
@VisibleForTesting void updateGameValidity(Game game) { Assert.state(game.getValidity() == Validity.VALID, "Validity of game '" + game + "' has already been set to: " + game.getValidity()); Assert.state(game.getState() == GameState.PLAYING || game.getState() == GameState.ENDED, "Validity of game '" + game + "' can't be set while in state: " + game.getState()); validityVoters.stream() .map(voter -> voter.apply(game)) .filter(validity -> validity != Validity.VALID) .findFirst() .ifPresent(game::setValidity); }
public static void removeAllSubNodesExceptAttributes(Node n) { NodeList childNodes = n.getChildNodes(); List<Node> childNodesToRemove = new ArrayList<Node>(); for (int i = 0; i < childNodes.getLength(); i++) { Node c = childNodes.item(i); if (c.getNodeType() != Node.ATTRIBUTE_NODE) { childNodesToRemove.add(c); } } for (Node c : childNodesToRemove) { n.removeChild(c); } }
@Override public StoredProcedureQuery createStoredProcedureQuery(final String procedureName) { throw new UnsupportedOperationException(); }
public static <T extends MessageLite> Metadata.BinaryMarshaller<T> metadataMarshaller( T defaultInstance) { return new MetadataMarshaller<T>(defaultInstance); }
public DetectedParameters detectParameters(CSVParseParameters truthParameters, LineSampler lineSampler, LineSamplerFactory samplerFactory, String changed) throws FileNotFoundException { DetectedParameters result = new DetectedParameters(); ValuesWithConfidence<? extends ColumnFormatParameters> columnFormat = getColumnFormatResult(truthParameters, lineSampler, changed); result.setColumnFormatParameter(columnFormat); Character tokenDelimiter = getTokenDelimiter(truthParameters.getColumnFormat(), columnFormat.getBestValue()); Character textDelimiter = getTextDelimiter(truthParameters.getColumnFormat(), columnFormat.getBestValue()); StringTokenizer tokenizer = new TokenizerFactoryImpl().getTokenizer(truthParameters.getColumnFormat(), columnFormat.getBestValue()); int columnCount = getColumnCount(truthParameters.getColumnFormat(), columnFormat.getBestValue()); result.setCommentParameter(getCommentResult(truthParameters, lineSampler, changed, tokenDelimiter, textDelimiter)); result.setHeaderLineParameter(getHeaderLineResult(truthParameters, lineSampler, changed, tokenizer, columnCount)); char[] quote = null; if (textDelimiter != null) { quote = new char[] { textDelimiter.charValue() }; } detectWithTextDelimiter(samplerFactory, quote, truthParameters, result, tokenizer, changed); return result; }
public EnvironmentDto changeCredentialByEnvironmentCrn(String accountId, String crn, EnvironmentChangeCredentialDto dto) { Environment environment = environmentService .findByResourceCrnAndAccountIdAndArchivedIsFalse(crn, accountId) .orElseThrow(() -> new NotFoundException(String.format("No environment found with CRN '%s'", crn))); return changeCredential(accountId, crn, dto, environment); }
void processTransactionsMessage( final EthPeer peer, final TransactionsMessage transactionsMessage, final Instant startedAt, final Duration keepAlive) { if (startedAt.plus(keepAlive).isAfter(now())) { this.processTransactionsMessage(peer, transactionsMessage); } else { totalSkippedTransactionsMessageCounter.inc(); } }
public void changeAwayStatus(final int code, final boolean away, final String awaymsg) throws CommandException { if (code == me.getCode() && !isLoggedOn()) { throw new CommandException(coreMessages.getMessage("core.away.error.notConnected")); } else if (Tools.getBytes(awaymsg) > Constants.MESSAGE_MAX_BYTES) { throw new CommandException(coreMessages.getMessage("core.away.error.awayMessageTooLong", Constants.MESSAGE_MAX_BYTES)); } final String trimmedAwayMessage = awaymsg.trim(); if (code == me.getCode()) { if (away) { networkMessages.sendAwayMessage(trimmedAwayMessage); } else { networkMessages.sendBackMessage(); } } userListController.changeAwayStatus(code, away, trimmedAwayMessage); }
public static String replaceWord(String word, String replacement, String searchString) { if (word == null || word.isEmpty()) { return searchString; } word = word.toLowerCase(); String searchStringLc = searchString.toLowerCase(); int oldIndex = 0; int index; do { index = searchStringLc.indexOf(word, oldIndex); if (index == -1) { return searchString; } oldIndex = index + word.length(); boolean leftBorder; if (index == 0) { leftBorder = true; } else { char prevChar = searchStringLc.charAt(index - 1); leftBorder = !(Character.isLetter(prevChar) || Character.isDigit(prevChar) || Character.getType(prevChar) == Character.DASH_PUNCTUATION); } boolean rightBorder; if (index + word.length() == searchStringLc.length()) { rightBorder = true; } else { char nextChar = searchStringLc.charAt(index + word.length()); rightBorder = !(Character.isLetter(nextChar) || Character.isDigit(nextChar) || Character.getType(nextChar) == Character.DASH_PUNCTUATION); } if (leftBorder && rightBorder) { String before = searchString.substring(0, index); String after = searchString.substring(oldIndex); searchString = before + replacement + after; searchStringLc = searchString.toLowerCase(); oldIndex = index + replacement.length(); } } while (index > -1); return searchString; }
@Override public Long sCard(byte[] key) { return helper.doInScope(RedisCommand.SCARD, key, () -> connection.sCard(key)); }
public void insertNode(BinaryTree node, Integer value) { if (node != null) { if (value <= Integer.valueOf(node.data) && node.left != null) { node.left.insertNode(node.left, value); } else if (value <= Integer.valueOf(node.data)) { node.left = new BinaryTree(String.valueOf(value)); } else if (value > Integer.valueOf(node.data) && node.right != null) { node.right.insertNode(node.right, value); } else { node.right = new BinaryTree(String.valueOf(value)); } } }
public void await() throws InterruptedException { do { stopper.checkCancelInProgress(null); } while (!delegate.await(retryIntervalNanos, NANOSECONDS)); }
public int markDependentEntitlementsDirty(Iterable<String> entitlementIds) { if (entitlementIds != null && entitlementIds.iterator().hasNext()) { Set<String> eids = new HashSet<>(); if (entitlementIds != null && entitlementIds.iterator().hasNext()) { eids.addAll(findDependentEntitlementsByProvidedProduct(entitlementIds)); Set<String> distributorEntitlements = filterDistributorEntitlementIds(entitlementIds); if (!distributorEntitlements.isEmpty()) { eids.addAll(findDependentEntitlementsByDerivedProvidedProduct(distributorEntitlements)); } } return eids.isEmpty() ? 0 : this.markEntitlementsDirty(eids); } return 0; }
@Override public Optional<String> create(String host, String clientId, Identity identity, Long ttl, DateTime instant) { List<IdentityKeyPair> keys = keyStore.getKeys(); if (keys == null || keys.isEmpty()) { return Optional.absent(); } IdentityKeyPair signingKey = randomKey(keys); Map<String, Object> claims = new LinkedHashMap<>(); claims.put("iss", host); claims.put("aud", clientId); claims.put("sub", identity.id()); claims.put("name", identity.name()); claims.put("email", identity.email()); claims.put("given_name", identity.givenName()); claims.put("family_name", identity.familyName()); claims.putAll(identity.claims()); return Optional.of(Jwts.builder() .setHeaderParam("cid", signingKey.keyId) .setClaims(claims) .setIssuedAt(new Date(instant.timestamp())) .setExpiration(new Date(instant.timestamp() + ttl)) .signWith(SignatureAlgorithm.RS256, signingKey.privateKey) .compact()); }
public static String diff(IChemObject first, IChemObject second) { IDifference difference = difference(first, second); if (difference == null) { return ""; } else { return difference.toString(); } }
@Override public <R, Q> CompletableFuture<R> query(String queryName, Q query, ResponseType<R> responseType) { CompletableFuture<QueryResponseMessage<R>> queryResponse = queryBus .query(processInterceptors(new GenericQueryMessage<>(asMessage(query), queryName, responseType))); CompletableFuture<R> result = new CompletableFuture<>(); queryResponse.exceptionally(cause -> asResponseMessage(responseType.responseMessagePayloadType(), cause)) .thenAccept(queryResponseMessage -> { try { if (queryResponseMessage.isExceptional()) { result.completeExceptionally(queryResponseMessage.exceptionResult()); } else { result.complete(queryResponseMessage.getPayload()); } } catch (Exception e) { result.completeExceptionally(e); } }); return result; }
public void update(final Map<String, String> properties) { if (properties != null) { LOG.info("Custom filter properties updated: {}", properties); this.namedFilterDTOs = getCustomFilterList(properties); updateListeners(); } }
public String getValidator() { return validator; }
@Override public boolean isBroadcast() { return false; }
public static void warn(@NonNull String tag, @NonNull String message) { if (sLogLevel <= Log.WARN) { Log.w(tag, message); } }
@Override public <T> void validateAndSetDefaults(ClassCacheMgr cacheMgr, CFMappingDef<T> cfMapDef) { if (cfMapDef.isBaseEntity()) { validateBaseClassInheritance(cfMapDef); } else if (cfMapDef.isPersistableDerivedEntity()) { validateDerivedClassInheritance(cfMapDef); } else if (!cfMapDef.isNonPersistableDerivedEntity()) { if (null != cacheMgr.findBaseClassViaMappings(cfMapDef)) throw new HectorObjectMapperException("@" + Inheritance.class.getSimpleName() + " found in class hierarchy, but no @" + DiscriminatorValue.class.getSimpleName() + " - quitting"); } }
synchronized List<List<Measurement>> getBatches(long t) { List<List<Measurement>> batches = new ArrayList<>(); publishTaskTimer("getBatches").record(() -> { int n = atlasMeasurements.size(); debugRegistry.distributionSummary("spectator.registrySize").record(n); List<Measurement> input = new ArrayList<>(n); Iterator<Map.Entry<Id, Consolidator>> it = atlasMeasurements.entrySet().iterator(); while (it.hasNext()) { Map.Entry<Id, Consolidator> entry = it.next(); Consolidator consolidator = entry.getValue(); consolidator.update(t, Double.NaN); double v = consolidator.value(t); if (!Double.isNaN(v)) { input.add(new Measurement(entry.getKey(), t, v)); } if (consolidator.isEmpty()) { it.remove(); } } List<Measurement> ms = rollupPolicy.apply(input); debugRegistry.distributionSummary("spectator.rollupResultSize").record(ms.size()); for (int i = 0; i < ms.size(); i += batchSize) { List<Measurement> batch = ms.subList(i, Math.min(ms.size(), i + batchSize)); batches.add(batch); } }); return batches; }
String verse(int verseNumber) { throw new UnsupportedOperationException("Delete this statement and write your own implementation."); }
@Override public LinkMethod get(Object key) { return new LinkMethod((Class<?>) key); }
public static Instruction failTwice() { return FAIL_TWICE; }
public String getName() { return name; }
@Override public String toString(Type type, Instant value, Map<String, String> attributes) { requireNonNull(type, "type cannot be null"); if (value == null) { return null; } String format = null; ZoneId zoneId = DEFAULT_ZONE; if (attributes != null) { format = attributes.get(FORMAT); String zone = attributes.get(ZONE); if (ZoneId.getAvailableZoneIds().contains(zone)) { zoneId = ZoneId.of(zone); } } try { return format == null ? value.toString() : getFormatterForPattern(format).withZone(zoneId).format(value); } catch (DateTimeException e) { throw new IllegalArgumentException(format("Unable to convert %s to String. ", getSimpleClassName(type)) + "Error occurred during printing.", e); } catch (IllegalArgumentException e) { throw new IllegalArgumentException(format("Unable to convert %s to String. " + "Invalid format: '%s'", getSimpleClassName(type), format), e); } }
@NonNull public static DiffResult calculateDiff(@NonNull Callback cb) { return calculateDiff(cb, true); }
static String getEscapedValue(String value) { if (StringUtils.isEmpty(value)) { return value; } String escapedValue = null; if (value.charAt(0) == '"' && value.charAt(value.length() - 1) == '"' && value.length() > 2) { escapedValue = '"' + ClientUtils.escapeQueryChars(value.substring(1, value.length() - 1)) + '"'; } else { escapedValue = ClientUtils.escapeQueryChars(value); } if (escapedValue.contains(" ") && !escapedValue.startsWith("\"") && !escapedValue.endsWith("\"")) { escapedValue = '"' + escapedValue + '"'; } return escapedValue; }
@Override public void subscribeLevel1(Ticker ticker, Level1QuoteListener listener) { super.subscribeLevel1(ticker, listener); tickerMap.put(ticker.getSymbol(), ticker); websocketClient.subscribeQuotes(ticker, this); websocketClient.subscribeTrades(ticker, this); }
protected List<RectangleLong> getTileBoundsFor(Query query, long z) throws SQLException { RectangleLong levelBounds = mbtiles.getTileBounds(z, false); if (query == null || query.getFilter() == null || query.getFilter() == Filter.INCLUDE) { return Collections.singletonList(levelBounds); } List<RectangleLong> rectangles = Optional.ofNullable(ExtractMultiBoundsFilterVisitor.getBounds(query.getFilter())) .map(o -> o.stream()) .orElse(Stream.empty()) .filter(e -> !Double.isInfinite(e.getWidth())) .map( e -> { try { return mbtiles.toTilesRectangle(e, z); } catch (SQLException ex) { throw new RuntimeException(ex); } }) .map(tr -> tr.intersection(levelBounds)) .collect(Collectors.toList()); if (rectangles.isEmpty()) { return Collections.singletonList(levelBounds); } List<RectangleLong> result = new ArrayList<>(); for (RectangleLong rect : rectangles) { if (result.isEmpty()) { result.add(rect); continue; } boolean mergedAny = false; do { mergedAny = false; ListIterator<RectangleLong> it = result.listIterator(); while (it.hasNext()) { RectangleLong next = it.next(); if (next.intersects(rect)) { it.remove(); rect.expandToInclude(next); mergedAny = true; } } } while (mergedAny); result.add(rect); } return result; }
@VisibleForTesting static JibContainerBuilder processCommonConfiguration( RawConfiguration rawConfiguration, InferredAuthProvider inferredAuthProvider, ProjectProperties projectProperties) throws InvalidFilesModificationTimeException, InvalidAppRootException, IncompatibleBaseImageJavaVersionException, IOException, InvalidImageReferenceException, InvalidContainerizingModeException, MainClassInferenceException, InvalidContainerVolumeException, InvalidWorkingDirectoryException, InvalidCreationTimeException { BiFunction<Path, AbsoluteUnixPath, Instant> modificationTimeProvider = createModificationTimeProvider(rawConfiguration.getFilesModificationTime()); JavaContainerBuilder javaContainerBuilder = getJavaContainerBuilderWithBaseImage( rawConfiguration, projectProperties, inferredAuthProvider) .setAppRoot(getAppRootChecked(rawConfiguration, projectProperties)) .setModificationTimeProvider(modificationTimeProvider); JibContainerBuilder jibContainerBuilder = projectProperties .createJibContainerBuilder( javaContainerBuilder, getContainerizingModeChecked(rawConfiguration, projectProperties)) .setFormat(rawConfiguration.getImageFormat()) .setEntrypoint(computeEntrypoint(rawConfiguration, projectProperties)) .setProgramArguments(rawConfiguration.getProgramArguments().orElse(null)) .setEnvironment(rawConfiguration.getEnvironment()) .setExposedPorts(Ports.parse(rawConfiguration.getPorts())) .setVolumes(getVolumesSet(rawConfiguration)) .setLabels(rawConfiguration.getLabels()) .setUser(rawConfiguration.getUser().orElse(null)); getWorkingDirectoryChecked(rawConfiguration) .ifPresent(jibContainerBuilder::setWorkingDirectory); jibContainerBuilder.setCreationTime( getCreationTime(rawConfiguration.getCreationTime(), projectProperties)); for (Map.Entry<Path, AbsoluteUnixPath> entry : rawConfiguration.getExtraDirectories().entrySet()) { Path sourceDirectory = entry.getKey(); AbsoluteUnixPath targetDirectory = entry.getValue(); if (Files.exists(sourceDirectory)) { jibContainerBuilder.addFileEntriesLayer( JavaContainerBuilderHelper.extraDirectoryLayerConfiguration( sourceDirectory, targetDirectory, rawConfiguration.getExtraDirectoryPermissions(), modificationTimeProvider)); } } return jibContainerBuilder; }
public Point2D.Double translateToField(Point2D.Double p) { return new Point2D.Double(DiaUtils.limit(18, p.x, width - 18), DiaUtils.limit(18, p.y, height - 18)); }
public static <T> String toString( Iterable<T> iterable, String start, String sep, String end) { final StringBuilder buf = new StringBuilder(); buf.append(start); for (Ord<T> ord : Ord.zip(iterable)) { if (ord.i > 0) { buf.append(sep); } buf.append(ord.e); } buf.append(end); return buf.toString(); }
@NonNull @SuppressWarnings("WeakerAccess") public SnackbarWrapper setActionTextAllCaps(boolean allCaps) { actionViewExtension.setAllCaps(allCaps); return this; }
@Override public void init() throws MessagingException { filteredMimeTypeParameters = parseConfigurationString(Optional.ofNullable(getCondition())); }
List<String> translate(String rnaSequence) { throw new UnsupportedOperationException("Delete this statement and write your own implementation."); }
public Single<TokenRequest> resolve(TokenRequest tokenRequest, Client client, User endUser) { return resolveAuthorizedScopes(tokenRequest, client, endUser); }
public boolean isEnabled() { return enabled; }
@Override public boolean storeMetadata(final Node obj) throws MetadataIoException { return storeMetadata(obj, null); }
@Override public Observable<Boolean> loadForm(String formId, String deviceId) { final DatabaseDataSource dataBaseDataSource = dataSourceFactory.getDataBaseDataSource(); if (TEST_FORM_ID.equals(formId)) { return dataBaseDataSource.installTestForm(); } else { return downloadFormHeader(formId, deviceId); } }
public static Dictionary parseOneEntryPerLine(Reader in) throws IOException { BufferedReader lineReader = new BufferedReader(in); Dictionary dictionary = new Dictionary(); String line; while ((line = lineReader.readLine()) != null) { StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, " "); String[] tokens = new String[whiteSpaceTokenizer.countTokens()]; if (tokens.length > 0) { int tokenIndex = 0; while (whiteSpaceTokenizer.hasMoreTokens()) { tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken(); } dictionary.put(new StringList(tokens)); } } return dictionary; }
public void logout(Session session) throws SessionException { SessionID sessionID = session.getID(); if (sessionService.checkSessionLocal(sessionID)) { throw new SessionException("CTSOperations received a local session (only remote sessions expected)"); } remote.logout(session); }
@Override public ValidationResult validate(Token token) { Set<String> allowedAudiences = extractAudiencesFromToken(token); if (validateDefault(allowedAudiences) || validateAudienceOfXsuaaBrokerClone(allowedAudiences)) { return ValidationResults.createValid(); } return ValidationResults.createInvalid( "Jwt token with audience {} is not issued for these clientIds: {}.", token.getAudiences(), clientIds); }
public boolean completedOrMarkedAsComplete(QuestionResource questionResource, SectionResource sectionResource) throws ExecutionException, InterruptedException { return (questionResource.isMarkAsCompletedEnabled() && getMarkedAsComplete().contains(questionResource.getId())) || completedSectionsByUserOrganisation.contains(sectionResource.getId()); }
public static <T> Read<T> read() { return new AutoValue_CassandraIO_Read.Builder<T>().build(); }
@Deprecated public static <P> KeyManager<P> getKeyManager(String typeUrl) throws GeneralSecurityException { return getKeyManagerInternal(typeUrl, null); }
public void setParameters(Object[] parameters) { this.parameters = parameters; }
@Override public Response bindApplication( String applicationName, String externalExportPrefix, String boundApp ) { this.logger.fine( "Binding " + boundApp + " to the " + externalExportPrefix + " prefix in application " + applicationName + "." ); String lang = lang( this.manager ); Response response; try { ManagedApplication ma = this.manager.applicationMngr().findManagedApplicationByName( applicationName ); if( ma == null ) { response = handleError( Status.NOT_FOUND, new RestError( REST_INEXISTING, application( applicationName )), lang ).build(); } else { this.manager.applicationMngr().bindOrUnbindApplication( ma, externalExportPrefix, boundApp, true ); response = Response.ok().build(); } } catch( UnauthorizedActionException | IOException e ) { response = RestServicesUtils.handleError( Status.FORBIDDEN, new RestError( ErrorCode.REST_UNDETAILED_ERROR, e ), lang ).build(); } return response; }
public TextUnitDTO getTextUnitDTO(ITextUnit textUnit) { TextUnitDTO textUnitDTO = null; TextUnitDTOAnnotation annotation = textUnit.getAnnotation(TextUnitDTOAnnotation.class); if (annotation != null) { textUnitDTO = annotation.getTextUnitDTO(); } return textUnitDTO; }
@Override public void returnSet( @NotNull final ArrayBitSet set) { throw new UnsupportedOperationException(); }
@Override public Double month(LocalDate date) { return this.feelLib.month(date); }
public Task<FetchResponse> fetch() { return fetch(frcMetadata.getMinimumFetchIntervalInSeconds()); }
protected void publishArtifactsViaWarDeploy(final DeployTarget target, final String stagingDirectoryPath, final List<File> warArtifacts) throws AzureExecutionException { if (warArtifacts == null || warArtifacts.size() == 0) { throw new AzureExecutionException( String.format("There is no war artifacts to deploy in staging path %s.", stagingDirectoryPath)); } for (final File warArtifact : warArtifacts) { final String contextPath = getContextPathFromFileName(stagingDirectoryPath, warArtifact.getAbsolutePath()); publishWarArtifact(target, warArtifact, contextPath); } }
public void setDlt(DataLinkType dlt) throws PcapNativeException, NotOpenException { if (dlt == null) { throw new NullPointerException("dlt must not be null."); } if (!open) { throw new NotOpenException(); } if (!handleLock.readLock().tryLock()) { throw new NotOpenException(); } try { if (!open) { throw new NotOpenException(); } int rc = NativeMappings.pcap_set_datalink(handle, dlt.value()); if (rc < 0) { throw new PcapNativeException(getError(), rc); } } finally { handleLock.readLock().unlock(); } this.dlt = dlt; }
@Override public DataBag exec(Tuple input) throws IOException { if (input == null || input.size() < 2) { int errCode = 2107; String msg = "Over expected 2 or more inputs but received " + input.size(); throw new ExecException(msg, errCode, PigException.INPUT); } DataBag inbag = null; try { inbag = (DataBag)input.get(0); } catch (ClassCastException cce) { int errCode = 2107; String msg = "Over expected a bag for arg 1 but received " + DataType.findTypeName(input.get(0)); throw new ExecException(msg, errCode, PigException.INPUT); } if (!initialized) { init(input); } else { if (func instanceof ResetableEvalFunc) { ((ResetableEvalFunc)func).reset(); } } OverBag tmpbag = new OverBag(inbag, rowsBefore, rowsAfter); Tuple tmptuple = mTupleFactory.newTuple(1); tmptuple.set(0, tmpbag); DataBag outbag = BagFactory.getInstance().newDefaultBag(); for (int i = 0; i < inbag.size(); i++) { tmpbag.setCurrentRow(i); Tuple t = mTupleFactory.newTuple(1); t.set(0, func.exec(tmptuple)); outbag.add(t); } return outbag; }
public void registerChild(SafeMap reportData) { String id = reportData.get(ChildReportingService.CHILD_ID_FIELD); Child child = allChildren.findByCaseId(id); List<String> immunizations = child.immunizationsGiven(); Location location = loadLocationOfChild(child); String submissionDate = reportData.get(SUBMISSION_DATE_FIELD_NAME); reportImmunizations(child, immunizations, location, child.dateOfBirth(), submissionDate); reportNRHMImmunizations(reportData, child, immunizations, location); reportBirthWeight(child, submissionDate, location); reportBFPostBirth(reportData.get(BF_POSTBIRTH), child, location, reportData.get(DELIVERY_PLACE), submissionDate); reportToBoth(child, INFANT_REGISTRATION, child.dateOfBirth(), submissionDate, location); reportLiveBirthByGender(reportData, child, location); reportToBoth(child, INFANT_BALANCE_TOTAL, child.dateOfBirth(), submissionDate, location); reportMCTSIndicators(reportData, child, immunizations); }
public ComplexJobTriggerProxy createComplexJobTriggerProxy() { return new ComplexJobTriggerProxy(); }
public static TimeWindow of(int resolution, long period, String name) { return new TimeWindow(resolution, period, name); }
@VisibleForTesting OkHttpClient modifyClient(OkHttpClient client, boolean loggingEnabled, boolean tls12Enforced, int connectTimeout, int readTimeout, int writeTimeout) { if (loggingEnabled) { enableLogging(client); } if (tls12Enforced) { enforceTls12(client); } if(connectTimeout > 0){ client.setConnectTimeout(connectTimeout, TimeUnit.SECONDS); } if(readTimeout > 0){ client.setReadTimeout(readTimeout, TimeUnit.SECONDS); } if(writeTimeout > 0){ client.setWriteTimeout(writeTimeout, TimeUnit.SECONDS); } client.setProtocols(Arrays.asList(Protocol.HTTP_1_1, Protocol.SPDY_3)); return client; }
public List<Message> receiveMessages() throws AmazonClientException { return doReceiveRequest(new ReceiveMessageRequest(queueUrl)); }
@Override public int compare(BindingSet o1, BindingSet o2) { try { for (OrderElem element : order.getElements()) { Value v1 = evaluate(element.getExpr(), o1); Value v2 = evaluate(element.getExpr(), o2); int compare = cmp.compare(v1, v2); if (compare != 0) { return element.isAscending() ? compare : -compare; } } if (o1 == null || o2 == null) { if (o1 == null) { return o2 == null ? 0 : 1; } if (o2 == null) { return o1 == null ? 0 : -1; } } if (o2.size() != o1.size()) { return o1.size() < o2.size() ? 1 : -1; } final ArrayList<String> o1bindingNamesOrdered = new ArrayList<>(o1.getBindingNames()); Collections.sort(o1bindingNamesOrdered); if (!o1.getBindingNames().equals(o2.getBindingNames())) { final ArrayList<String> o2bindingNamesOrdered = new ArrayList<>(o2.getBindingNames()); Collections.sort(o2bindingNamesOrdered); for (int i = 0; i < o1bindingNamesOrdered.size(); i++) { String o1bn = o1bindingNamesOrdered.get(i); String o2bn = o2bindingNamesOrdered.get(i); int compare = o1bn.compareTo(o2bn); if (compare != 0) { return compare; } } } for (String bindingName : o1bindingNamesOrdered) { final Value v1 = o1.getValue(bindingName); final Value v2 = o2.getValue(bindingName); final int compare = cmp.compare(v1, v2); if (compare != 0) { return compare; } } return 0; } catch (QueryEvaluationException e) { logger.debug(e.getMessage(), e); return 0; } catch (IllegalArgumentException e) { logger.debug(e.getMessage(), e); return 0; } }
public static List<Class<?>> findClassesByParentClass(Class<?> parentClass, String... packageNames) { List<Class<?>> classes = new ArrayList<>(); for (Class<?> targetClass : findClasses(packageNames)) { if (!targetClass.equals(parentClass) && parentClass.isAssignableFrom(targetClass) && !Modifier.isAbstract(targetClass.getModifiers())) { classes.add(targetClass); } } return classes; }
@Override public InvocationContext preInvocation(@Nonnull Object instance, @Nonnull Method method, @Nonnull Object[] args) { InvocationContext context = DefaultInvocationContext.of(instance, method, args); String operationName = getOperationName(method); Tracer.fastStartSpan(operationName); return context; }
@Override public void serialize(CategoryPoints categoryPoints, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { jgen.writeStartObject(); super.serialize(categoryPoints, jgen, provider); if (categoryPoints.getSizes() != null) { jgen.writeObjectField("sizes", categoryPoints.getSizes()); } else { jgen.writeObjectField("size", categoryPoints.getSize()); } if (categoryPoints.getShapes() != null) { jgen.writeObjectField("shaps", categoryPoints.getShapes()); } else { jgen.writeObjectField("shape", categoryPoints.getShape()); } if (categoryPoints.getFills() != null) { jgen.writeObjectField("fills", categoryPoints.getFills()); } else { jgen.writeObjectField("fill", categoryPoints.getFill()); } if (categoryPoints.getOutlineColors() != null) { jgen.writeObjectField("outline_colors", categoryPoints.getOutlineColors()); } else { jgen.writeObjectField("outline_color", categoryPoints.getOutlineColor()); } jgen.writeEndObject(); }
public static Object getNativeValue(Value value) { return getNativeValue(getApiValue(value)); }
@Override public PartitionStatus combine(IntArray curPar, IntArray newPar) { int[] arr1 = curPar.get(); int size1 = curPar.size(); int[] arr2 = newPar.get(); int size2 = newPar.size(); if (size1 != size2) { return PartitionStatus.COMBINE_FAILED; } switch (operation) { case SUM: for (int i = 0; i < size2; i++) { arr1[i] += arr2[i]; } break; case MINUS: for (int i = 0; i < size2; i++) { arr1[i] -= arr2[i]; } break; case MAX: for (int i = 0; i < size2; i++) { if (arr1[i] < arr2[i]) { arr1[i] = arr2[i]; } } break; case MIN: for (int i = 0; i < size2; i++) { if (arr1[i] > arr2[i]) { arr1[i] = arr2[i]; } } break; case MULTIPLY: for (int i = 0; i < size2; i++) { arr1[i] *= arr2[i]; } break; } return PartitionStatus.COMBINED; }
@SuppressWarnings("unchecked") @Override public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request) throws YarnException, IOException { NodeStatus remoteNodeStatus = request.getNodeStatus(); NodeId nodeId = remoteNodeStatus.getNodeId(); if (!this.nodesListManager.isValidNode(nodeId.getHost()) && !isNodeInDecommissioning(nodeId)) { String message = "Disallowed NodeManager nodeId: " + nodeId + " hostname: " + nodeId.getHost(); LOG.info(message); return YarnServerBuilderUtils.newNodeHeartbeatResponse( NodeAction.SHUTDOWN, message); } RMNode rmNode = this.rmContext.getRMNodes().get(nodeId); if (rmNode == null) { String message = "Node not found resyncing " + remoteNodeStatus.getNodeId(); LOG.info(message); return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC, message); } this.nmLivelinessMonitor.receivedPing(nodeId); this.decommissioningWatcher.update(rmNode, remoteNodeStatus); if (isHopsTLSEnabled()) { Set<ApplicationId> updatedApps = request.getUpdatedApplicationsWithNewCryptoMaterial(); if (updatedApps != null) { for (ApplicationId appId : updatedApps) { rmNode.getAppX509ToUpdate().remove(appId); RMApp rmApp = rmContext.getRMApps().get(appId); rmApp.rmNodeHasUpdatedCryptoMaterial(rmNode.getNodeID()); } } } NodeHeartbeatResponse lastNodeHeartbeatResponse = rmNode.getLastNodeHeartBeatResponse(); if (getNextResponseId( remoteNodeStatus.getResponseId()) == lastNodeHeartbeatResponse .getResponseId()) { LOG.info("Received duplicate heartbeat from node " + rmNode.getNodeAddress()+ " responseId=" + remoteNodeStatus.getResponseId()); return lastNodeHeartbeatResponse; } else if (remoteNodeStatus.getResponseId() != lastNodeHeartbeatResponse .getResponseId()) { String message = "Too far behind rm response id:" + lastNodeHeartbeatResponse.getResponseId() + " nm response id:" + remoteNodeStatus.getResponseId(); LOG.info(message); this.rmContext.getDispatcher().getEventHandler().handle( new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING)); return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC, message); } if (rmNode.getState() == NodeState.DECOMMISSIONING && decommissioningWatcher.checkReadyToBeDecommissioned( rmNode.getNodeID())) { String message = "DECOMMISSIONING " + nodeId + " is ready to be decommissioned"; LOG.info(message); this.rmContext.getDispatcher().getEventHandler().handle( new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION)); this.nmLivelinessMonitor.unregister(nodeId); return YarnServerBuilderUtils.newNodeHeartbeatResponse( NodeAction.SHUTDOWN, message); } boolean timelineV2Enabled = YarnConfiguration.timelineServiceV2Enabled(getConfig()); if (timelineV2Enabled) { updateAppCollectorsMap(request); } NodeHeartbeatResponse nodeHeartBeatResponse = YarnServerBuilderUtils.newNodeHeartbeatResponse( getNextResponseId(lastNodeHeartbeatResponse.getResponseId()), NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval); rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse); populateKeys(request, nodeHeartBeatResponse); if (isHopsTLSEnabled() || isJWTEnabled()) { Map<ApplicationId, UpdatedCryptoForApp> mergedUpdates = mergeNewSecurityMaterialForApps(rmNode); nodeHeartBeatResponse.setUpdatedCryptoForApps(mergedUpdates); } ConcurrentMap<ApplicationId, ByteBuffer> systemCredentials = rmContext.getSystemCredentialsForApps(); if (!systemCredentials.isEmpty()) { nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials); } if (timelineV2Enabled) { setAppCollectorsMapToResponse(rmNode.getRunningApps(), nodeHeartBeatResponse); } RMNodeStatusEvent nodeStatusEvent = new RMNodeStatusEvent(nodeId, remoteNodeStatus); if (request.getLogAggregationReportsForApps() != null && !request.getLogAggregationReportsForApps().isEmpty()) { nodeStatusEvent.setLogAggregationReportsForApps(request .getLogAggregationReportsForApps()); } this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent); if (isDistributedNodeLabelsConf && request.getNodeLabels() != null) { try { updateNodeLabelsFromNMReport( NodeLabelsUtils.convertToStringSet(request.getNodeLabels()), nodeId); nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true); } catch (IOException ex) { nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage()); nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false); } } String nid = nodeId.toString(); Resource capability = loadNodeResourceFromDRConfiguration(nid); if (capability != null) { nodeHeartBeatResponse.setResource(capability); } if (this.rmContext.getNodeManagerQueueLimitCalculator() != null) { nodeHeartBeatResponse.setContainerQueuingLimit( this.rmContext.getNodeManagerQueueLimitCalculator() .createContainerQueuingLimit()); } Set<NodeAttribute> nodeAttributes = request.getNodeAttributes(); if (nodeAttributes != null && !nodeAttributes.isEmpty()) { nodeAttributes.forEach(nodeAttribute -> LOG.debug(nodeId.toString() + " ATTRIBUTE : " + nodeAttribute.toString())); if (!nodeAttributes.stream().allMatch( nodeAttribute -> NodeAttribute.PREFIX_DISTRIBUTED .equals(nodeAttribute.getAttributeKey().getAttributePrefix()))) { LOG.warn("Reject invalid node attributes from host: " + nodeId.toString() + ", attributes in HB must have prefix " + NodeAttribute.PREFIX_DISTRIBUTED); } else { this.rmContext.getNodeAttributesManager() .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED, ImmutableMap.of(nodeId.getHost(), nodeAttributes)); } } return nodeHeartBeatResponse; }
public void route(String instanceId) throws Exception { FormSubmission submission = formDataRepository.fetchFromSubmission(instanceId); FormSubmissionHandler handler = handlerMap.get(submission.formName()); if (handler == null) { logWarn("Could not find a handler due to unknown form submission: " + submission); } else { try { handler.handle(submission); } catch (Exception e) { Log.logError(format("Handling {0} form submission with instance Id: {1} for " + "entity: {2} failed with exception : {3}", submission.formName(), submission.instanceId(), submission.entityId(), ExceptionUtils.getStackTrace(e))); throw e; } } FORM_SUBMITTED.notifyListeners(instanceId); }
@Override public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { Document document = Document.newBuilder().addField(Field.newBuilder().setName("f").setText("v")).build(); try { Utils.indexADocument(SEARCH_INDEX, document); } catch (InterruptedException e) { } try { while (true) { List<String> docIds = new ArrayList<>(); GetRequest request = GetRequest.newBuilder().setReturningIdsOnly(true).build(); GetResponse<Document> response = getIndex().getRange(request); if (response.getResults().isEmpty()) { break; } for (Document doc : response) { docIds.add(doc.getId()); } getIndex().delete(docIds); } } catch (RuntimeException e) { LOG.log(Level.SEVERE, "Failed to delete documents", e); } PrintWriter out = resp.getWriter(); out.println("Deleted documents."); }
@Override public String getName() { return NAME; }
@Override public void serialiseRuleSet(final OutputStream outputStream, final DecisionTreeRuleSet decisionTreeRuleSet) { toJsonWriter(outputStream, decisionTreeRuleSet); }
public Boolean accepts (Object value) { return (value == null || value instanceof String); }
@Override public Optional<SubsystemExecutor> loadByPlace(UUID placeId) { if(placeId == null) { return Optional.empty(); } try { SubsystemExecutor executor = executors.get(placeId, () -> doLoadByPlace(placeId)); return Optional.of(executor); } catch(Exception e) { logger.debug("Unable to load cache entry for placeId {}", placeId, e); return Optional.empty(); } }
public Map<String, Object> convert(String selectorString) throws SelectorParseException { Map<String, Object> converted = new HashMap<String, Object>(); Matcher matcher = SELECTOR_PATTERN.matcher(selectorString); if (matcher.find()) { int groups = matcher.groupCount(); for (int i = 0; i < groups; i++) { String data = matcher.group(i + 1); while (!data.isEmpty()) { int indexOfComma = data.indexOf(","); int indexOfParen = data.indexOf("("); if (indexOfComma == -1 && indexOfParen == -1) { parseKeyAndAddValueToMap(data, converted); data = ""; } else if (indexOfComma == -1) { String key = data.substring(0, indexOfParen - 1); String value = data.substring(indexOfParen - 1); addKeyValueToMap(key, convert(value), converted); data = ""; } else if (indexOfParen == -1) { String value = data.substring(0, indexOfComma); parseKeyAndAddValueToMap(value, converted); data = data.substring(indexOfComma + 1); } else if (indexOfComma < indexOfParen) { String value = data.substring(0, indexOfComma); parseKeyAndAddValueToMap(value, converted); data = data.substring(indexOfComma + 1); } else { int endOfSubMap = getMatchingClosingParenIndex(data, indexOfParen); String key = data.substring(0, indexOfParen - 1); String value = data.substring(indexOfParen - 1, endOfSubMap + 1); addKeyValueToMap(key, convert(value), converted); data = data.substring(endOfSubMap + 1); if (data.startsWith(",")) { data = data.substring(1); } } } } } else { throw new SelectorParseException("Invalid selector syntax"); } return converted; }
@GetMapping("/{id}") public RestResult<AlertResource> findById(@PathVariable("id") Long id) { return alertService.findById(id).toGetResponse(); }
@Override public Flux<String> createServiceInstance(List<BackingService> backingServices) { return Flux.fromIterable(backingServices) .parallel() .runOn(Schedulers.parallel()) .flatMap(deployerClient::createServiceInstance) .sequential() .doOnRequest(l -> { LOG.info("Creating backing services"); LOG.debug(BACKINGSERVICES_LOG_TEMPLATE, backingServices); }) .doOnComplete(() -> { LOG.info("Finish creating backing services"); LOG.debug(BACKINGSERVICES_LOG_TEMPLATE, backingServices); }) .doOnError(e -> LOG.error(String.format("Error creating backing services. error=%s", e.getMessage()), e)); }
@Override public void clone( String srcWorkspace, String srcAbsPath, String destAbsPath, boolean removeExisting ) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, RepositoryException { internalClone(srcWorkspace, srcAbsPath, destAbsPath, removeExisting, false); }
public static JsonObject read(String filename) { try (InputStream in = IO.openFileEx(filename)) { return JSON.parse(in) ; } catch (FileNotFoundException ex) { IO.exception("File not found: " + filename, ex) ; return null ; } catch (IOException ex) { IO.exception("IOException: " + filename, ex) ; return null ; } }
static long getCount(String label, String units) { if (MonitorFactory.exists(label, units)) { Monitor mon = MonitorFactory.getMonitor(label, units); return (long) mon.getHits(); } return 0; }
@Override public void setID(String identifier) { logger.debug("Setting ID: ", identifier); super.setID(identifier); }
@Override public VisualizedGraph create(ILayer... layers) { boolean singleNode = layers.length == 1 && layers[0].getNodes().hasOnlyOneNode(); return new AgnosticVisualizedGraph(createCascade(layers), calculateSize(layers), singleNode); }
public CurrencyAmount presentValue( ResolvedSwaption swaption, RatesProvider ratesProvider, HullWhiteOneFactorPiecewiseConstantParametersProvider hwProvider) { validate(swaption, ratesProvider, hwProvider); ResolvedSwap swap = swaption.getUnderlying(); LocalDate expiryDate = swaption.getExpiryDate(); if (expiryDate.isBefore(ratesProvider.getValuationDate())) { return CurrencyAmount.of(swap.getLegs().get(0).getCurrency(), 0d); } ResolvedSwapLeg cashFlowEquiv = CashFlowEquivalentCalculator.cashFlowEquivalentSwap(swap, ratesProvider); int nPayments = cashFlowEquiv.getPaymentEvents().size(); double[] alpha = new double[nPayments]; double[] discountedCashFlow = new double[nPayments]; for (int loopcf = 0; loopcf < nPayments; loopcf++) { NotionalExchange payment = (NotionalExchange) cashFlowEquiv.getPaymentEvents().get(loopcf); LocalDate maturityDate = payment.getPaymentDate(); alpha[loopcf] = hwProvider.alpha(ratesProvider.getValuationDate(), expiryDate, expiryDate, maturityDate); discountedCashFlow[loopcf] = paymentPricer.presentValueAmount(payment.getPayment(), ratesProvider); } double omega = (swap.getLegs(SwapLegType.FIXED).get(0).getPayReceive().isPay() ? -1d : 1d); double kappa = computeKappa(hwProvider, discountedCashFlow, alpha, omega); double pv = 0.0; for (int loopcf = 0; loopcf < nPayments; loopcf++) { pv += discountedCashFlow[loopcf] * NORMAL.getCDF(omega * (kappa + alpha[loopcf])); } return CurrencyAmount.of(cashFlowEquiv.getCurrency(), pv * (swaption.getLongShort().isLong() ? 1d : -1d)); }
@Override public void customize() { if (logstash.enabled()) { Properties handlerProps = new Properties(); handlerProps.put("hostname", this.logstash.hostname()); handlerProps.put("port", "" + this.logstash.port()); final CustomHandler<?> logstashHandler = new CustomHandler<>("logstash-handler") .module("org.jboss.logmanager.ext") .attributeClass("org.jboss.logmanager.ext.handlers.SocketHandler") .namedFormatter("logstash") .properties(handlerProps) .level(this.logstash.level()); this.logging .customFormatter("logstash", "org.jboss.logmanager.ext", "org.jboss.logmanager.ext.formatters.LogstashFormatter", this.logstash.formatterProperties()) .customHandler(logstashHandler) .subresources() .rootLogger() .handler(logstashHandler.getKey()); } }
@Override public synchronized String execute(SampleResult previousResult, Sampler currentSampler) throws InvalidVariableException { String sourceString = values[0].execute(); String decodedValue = new String(Base64.encodeBase64(sourceString.getBytes())); if (values.length > 1) { String variableName = values[1].execute(); if (variableName.length() > 0) { final JMeterVariables variables = getVariables(); if (variables != null) { variables.put(variableName, decodedValue); } } } return decodedValue; }
@Nonnull @Override public SearchResultsSet getSearchResultsSet() { if (searchResultsSet == null) { searchResultsSet = searchResultsService.performSearch(searchOptions, resource, productPage, request); } return searchResultsSet; }
public void setName(String name) { this.name = name; }
public static String decryptDES(SecretKey desKey, String encrypted) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException { Cipher cipher = Cipher.getInstance(CIPHER_DES_INSTANCE); cipher.init(Cipher.DECRYPT_MODE, desKey); byte[] original = cipher.doFinal(Base64.getDecoder().decode(encrypted)); return new String(original); }
static boolean isLandsat4Filename(String filename) { if (filename.matches(L4_FILENAME_REGEX + "_MTL" + getTxtExtension())) { return true; } else if (filename.matches(L4_FILENAME_REGEX + getCompressionExtension())) { return true; } return false; }
@Override protected SpatialArguments extractObjectArguments(Node predicate, PropFuncArg object, SRSInfo indexSRSInfo) { try { List<Node> objectArgs = object.getArgList(); if (objectArgs.size() < 2) { throw new ExprEvalException(FmtUtils.stringForNode(predicate) + ": Minimum of 2 arguments."); } else if (objectArgs.size() > 3) { throw new ExprEvalException(FmtUtils.stringForNode(predicate) + ": Maximum of 3 arguments."); } Node lat = objectArgs.get(LAT_POS); Node lon = objectArgs.get(LON_POS); if (lat.isVariable() || lon.isVariable()) { throw new ExprEvalException("Arguments are not all concrete: " + FmtUtils.stringForNode(lat) + ", " + FmtUtils.stringForNode(lon)); } int limit; if (objectArgs.size() > LIMIT_POS) { NodeValue limitNode = NodeValue.makeNode(objectArgs.get(LIMIT_POS)); if (!limitNode.isInteger()) { throw new ExprEvalException("Not an integer: " + FmtUtils.stringForNode(limitNode.getNode())); } limit = limitNode.getInteger().intValue(); } else { limit = DEFAULT_LIMIT; } GeometryWrapper geometryWrapper = ConvertLatLon.toGeometryWrapper(lat, lon); SearchEnvelope searchEnvelope = buildSearchEnvelope(geometryWrapper, indexSRSInfo); return new SpatialArguments(limit, geometryWrapper, searchEnvelope); } catch (DatatypeFormatException ex) { throw new ExprEvalException(ex.getMessage(), ex); } }
public static String truncate( Object obj, int maxLength ) { return truncate(obj, maxLength, null); }
public static String getVersion() { String version = Version.class.getPackage().getImplementationVersion(); return StringUtils.isBlank(version) ? "dev" : version; }
@Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception { if (StringUtils.isBlank(msg)) { ctx.writeAndFlush(QosProcessHandler.PROMPT); } else { CommandContext commandContext = TelnetCommandDecoder.decode(msg); commandContext.setRemote(ctx.channel()); try { String result = commandExecutor.execute(commandContext); if (StringUtils.isEquals(QosConstants.CLOSE, result)) { ctx.writeAndFlush(getByeLabel()).addListener(ChannelFutureListener.CLOSE); } else { ctx.writeAndFlush(result + QosConstants.BR_STR + QosProcessHandler.PROMPT); } } catch (NoSuchCommandException ex) { ctx.writeAndFlush(msg + " :no such command"); ctx.writeAndFlush(QosConstants.BR_STR + QosProcessHandler.PROMPT); log.error("can not found command " + commandContext, ex); } catch (Exception ex) { ctx.writeAndFlush(msg + " :fail to execute commandContext by " + ex.getMessage()); ctx.writeAndFlush(QosConstants.BR_STR + QosProcessHandler.PROMPT); log.error("execute commandContext got exception " + commandContext, ex); } } }
public static List<WeightedHostAddress> prioritize(WeightedHostAddress[] records) { final List<WeightedHostAddress> result = new LinkedList<>(); SortedMap<Integer, Set<WeightedHostAddress>> byPriority = new TreeMap<>(); for(final WeightedHostAddress record : records) { if (byPriority.containsKey(record.getPriority())) { byPriority.get(record.getPriority()).add(record); } else { final Set<WeightedHostAddress> set = new HashSet<>(); set.add(record); byPriority.put(record.getPriority(), set); } } for(Map.Entry<Integer, Set<WeightedHostAddress>> weights : byPriority.entrySet()) { List<WeightedHostAddress> zeroWeights = new LinkedList<>(); int totalWeight = 0; final Iterator<WeightedHostAddress> i = weights.getValue().iterator(); while (i.hasNext()) { final WeightedHostAddress next = i.next(); if (next.weight == 0) { zeroWeights.add(next); i.remove(); continue; } totalWeight += next.getWeight(); } int iterationWeight = totalWeight; Iterator<WeightedHostAddress> iter = weights.getValue().iterator(); while (iter.hasNext()) { int needle = new Random().nextInt(iterationWeight); while (true) { final WeightedHostAddress record = iter.next(); needle -= record.getWeight(); if (needle <= 0) { result.add(record); iter.remove(); iterationWeight -= record.getWeight(); break; } } iter = weights.getValue().iterator(); } Collections.shuffle(zeroWeights); for(WeightedHostAddress zero : zeroWeights) { result.add(zero); } } return result; }
public static JsonObject getConfigUpdateInfo(String option, String newValue) { LoggingService.logInfo(MODULE_NAME, "Start getting config update information"); JsonObject info = null; if (option != null && newValue != null){ info = Json.createObjectBuilder() .add(option, newValue) .build(); } else { LoggingService.logError(MODULE_NAME, "can't update config info : option or value must not be null", new AgentSystemException("can't update config info : option or value must not be null")); info = Json.createObjectBuilder() .add("error", "can't update config info : option or value must not be null") .build(); } LoggingService.logInfo(MODULE_NAME, "Finished getting config update information"); return info; }
public static void checkIndexPutOptionIsNotUsed(KVStore.KVStoreOption... options) { if (null == options || options.length == 0) { return; } for (KVStore.KVStoreOption option : options) { if (option instanceof IndexPutOption) { throw new IllegalArgumentException("IndexPutOption not supported."); } } }
public void layout(Container container) { Info[] infos = getInfo(container); Rectangle2D bounds = container.getBounds(); Insets2D insets = container.getInsets(); if (insets == null) { insets = new Insets2D.Double(); } Integer lastCol = infos[COLS].size - 1; int compIndex = 0; double x = bounds.getX() + insets.getLeft(); double y = bounds.getY() + insets.getTop(); for (Drawable component : container) { Integer col = compIndex%infos[COLS].size; Integer row = compIndex/infos[COLS].size; double colWidth = infos[COLS].sizes.get(col); double rowHeight = infos[ROWS].sizes.get(row); double w = Math.max(infos[COLS].sizeMean - infos[COLS].unsizeableSpace, colWidth); double h = Math.max(infos[ROWS].sizeMean - infos[ROWS].unsizeableSpace, rowHeight); if (component != null) { component.setBounds(x, y, w, h); } if (col.equals(lastCol)) { x = bounds.getX() + insets.getLeft(); y += h + getGapY(); } else { x += w + getGapX(); } compIndex++; } }
public static void setLogger(@Nullable final Logger logger) { if (logger == TI_LOG) { throw new IllegalArgumentException( "Recursion warning: You can't use TI_LOG as Logger for TiLog"); } TiLog.logger = logger; }
public static String extractX509CertSubjectOUField(X509Certificate x509Cert) { return extractX509CertSubjectField(x509Cert, BCStyle.OU); }
public static ITextWrapper get(final TextWrapperStrategy strategy, final Text text) { switch (strategy) { case BOUNDS_AND_LINE_BREAKS: return new TextBoundsAndLineBreaksWrap(text); case LINE_BREAK: return new TextLineBreakWrap(text); case NO_WRAP: return new TextNoWrap(text); case TRUNCATE: return new TextLineBreakTruncateWrapper(text, new BoundingBox()); case TRUNCATE_WITH_LINE_BREAK: return new TextLineBreakTruncateWrapper(text, new BoundingBox()); default: return new TextBoundsWrap(text); } }
public static DateRangeCondition dateRange(String field) { return new DateRangeCondition(field); }
public void validate(Iterable<? extends ApiConfig> apiConfigs) throws ApiConfigInvalidException, ApiClassConfigInvalidException, ApiMethodConfigInvalidException, ApiParameterConfigInvalidException { if (Iterables.isEmpty(apiConfigs)) { return; } Map<String, ApiMethodConfig> restfulSignatures = Maps.newHashMap(); Iterator<? extends ApiConfig> i = apiConfigs.iterator(); ApiConfig first = i.next(); validate(first, restfulSignatures); while (i.hasNext()) { ApiConfig config = i.next(); Iterable<ApiConfigInconsistency<Object>> inconsistencies = config.getConfigurationInconsistencies(first); if (!Iterables.isEmpty(inconsistencies)) { throw new InconsistentApiConfigurationException(config, first, inconsistencies); } validate(config, restfulSignatures); } }
@SuppressWarnings("unchecked") public static void removeMapping( String parent, String key, Map<String, Object> data, String currentParent) { Iterator<Entry<String, Object>> it = data.entrySet().iterator(); while (it.hasNext()) { Entry<String, Object> entry = it.next(); if (Objects.equals(currentParent, parent) && entry.getKey().equals(key)) { it.remove(); } else if (entry.getValue() instanceof Map) { removeMapping(parent, key, (Map<String, Object>) entry.getValue(), entry.getKey()); } else if (entry.getValue() instanceof List) { ((List<Object>) entry.getValue()) .stream() .filter(item -> item instanceof Map) .forEach( item -> removeMapping( parent, key, (Map<String, Object>) item, currentParent)); } } }
@Override public int markAsUnusedAllSegmentsInDataSource(final String dataSource) { try { final int numUpdatedDatabaseEntries = connector.getDBI().withHandle( (Handle handle) -> handle .createStatement( StringUtils.format("UPDATE %s SET used=false WHERE dataSource = :dataSource", getSegmentsTable()) ) .bind("dataSource", dataSource) .execute() ); return numUpdatedDatabaseEntries; } catch (RuntimeException e) { log.error(e, "Exception marking all segments as unused in data source [%s]", dataSource); throw e; } }
public static FeatureLayers from(Spatial.FeatureLayers sc2ApiFeatureLayers) { require("sc2api feature layers", sc2ApiFeatureLayers); return new FeatureLayers(sc2ApiFeatureLayers); }
@Override public ResponseEntity<Profile> createAccount(CreateAccountRequest request) { if (workbenchConfigProvider.get().captcha.enableCaptcha) { verifyCaptcha(request.getCaptchaVerificationToken()); } if (workbenchConfigProvider.get().access.requireInvitationKey) { verifyInvitationKey(request.getInvitationKey()); } profileService.validateInstitutionalAffiliation(request.getProfile()); final Profile profile = request.getProfile(); profileService.cleanProfile(profile); profileService.validateNewProfile(profile); com.google.api.services.directory.model.User googleUser = directoryService.createUser( profile.getGivenName(), profile.getFamilyName(), profile.getUsername() + "@" + workbenchConfigProvider.get().googleDirectoryService.gSuiteDomain, profile.getContactEmail()); DbUser user = userService.createUser( profile.getGivenName(), profile.getFamilyName(), googleUser.getPrimaryEmail(), profile.getContactEmail(), profile.getCurrentPosition(), profile.getOrganization(), profile.getAreaOfResearch(), profile.getProfessionalUrl(), profile.getDegrees(), FROM_CLIENT_ADDRESS.apply(profile.getAddress()), demographicSurveyMapper.demographicSurveyToDbDemographicSurvey( profile.getDemographicSurvey()), profile.getInstitutionalAffiliations().stream() .map(institutionService::legacyInstitutionToDbInstitution) .collect(Collectors.toList()), verifiedInstitutionalAffiliationMapper.modelToDbWithoutUser( profile.getVerifiedInstitutionalAffiliation(), institutionService)); if (request.getTermsOfServiceVersion() != null) { userService.submitTermsOfService(user, request.getTermsOfServiceVersion()); } final MailService mail = mailServiceProvider.get(); try { mail.sendWelcomeEmail(profile.getContactEmail(), googleUser.getPassword(), googleUser); } catch (MessagingException e) { throw new WorkbenchException(e); } institutionService .getInstitutionUserInstructions( profile.getVerifiedInstitutionalAffiliation().getInstitutionShortName()) .ifPresent( instructions -> { try { mail.sendInstitutionUserInstructions(profile.getContactEmail(), instructions); } catch (MessagingException e) { throw new WorkbenchException(e); } }); final Profile createdProfile = profileService.getProfile(user); profileAuditor.fireCreateAction(createdProfile); return ResponseEntity.ok(createdProfile); }
public static XmlMessageHeader fromXml(String xml) { try { XmlMessageHeader xmlRequest = XmlObjectMapper.defaultMapper().fromXml(xml, XmlMessageHeader.class); switch (xmlRequest.getMsgType()) { case text: return XmlObjectMapper.defaultMapper().fromXml(xml, QyTextRequest.class); case image: return XmlObjectMapper.defaultMapper().fromXml(xml, QyImageRequest.class); case voice: return XmlObjectMapper.defaultMapper().fromXml(xml, QyVoiceRequest.class); case video: return XmlObjectMapper.defaultMapper().fromXml(xml, QyVideoRequest.class); case shortvideo: return XmlObjectMapper.defaultMapper().fromXml(xml, QyShortVideoRequest.class); case location: return XmlObjectMapper.defaultMapper().fromXml(xml, QyLocationRequest.class); case event: return toEvent(xml); default: logger.warn("xml to bean failed, unknown message type {}.", xmlRequest.getMsgType()); throw new WxRuntimeException(999, "xml to bean failed, unknown message type " + xmlRequest.getMsgType()); } } catch (IOException e) { logger.error("xml to message request failed", e); throw new WxRuntimeException(999, "xml to message request failed," + e.getMessage()); } }
public Builder toBuilder() { return new Builder(this); }
public void setRouterDeadIntervalTime(int routerDeadIntervalTime) { this.routerDeadIntervalTime = routerDeadIntervalTime; }
@Nullable static TaskProvider<Task> getWarTaskProvider(Project project) { if (project.getPlugins().hasPlugin(WarPlugin.class)) { return project.getTasks().named(WarPlugin.WAR_TASK_NAME); } return null; }
public static Duration max(Duration d1, Duration d2) { return d1.compareTo(d2) == 1 ? d1 : d2; }
@VisibleForTesting void condition(ConditionDefinition def, DegradedConditionType type, String bucket, Double percentile, int value, QueryBuilder query) { condition(new DegradedCondition(def, type, bucket, percentile, value, query)); }
@Override public final int compareTo(Generator<T> o) { return name.compareTo(o.name); }
void setContext(HttpSession httpSession) { ThreadLocalContextHolder.put(Constants.HTTPREQUEST, request); ThreadLocalContextHolder.put(Constants.HTTPSESSION, httpSession); }
public static byte[] toByteArray(BigInteger value) { return toByteArray(value, -1); }
public void readProperties(final Object object) { final JCommanderPrefixTranslator translator = new JCommanderPrefixTranslator(); translator.addObject(object); final JCommanderTranslationMap map = translator.translate(); for (final TranslationEntry entry : map.getEntries().values()) { final AnnotatedElement element = entry.getMember(); final CentroidParameter centroid = element.getAnnotation(CentroidParameter.class); final ClusteringParameter clustering = element.getAnnotation(ClusteringParameter.class); final CommonParameter common = element.getAnnotation(CommonParameter.class); final ExtractParameter extract = element.getAnnotation(ExtractParameter.class); final GlobalParameter global = element.getAnnotation(GlobalParameter.class); final HullParameter hull = element.getAnnotation(HullParameter.class); final InputParameter input = element.getAnnotation(InputParameter.class); final JumpParameter jump = element.getAnnotation(JumpParameter.class); final MapReduceParameter mapReduce = element.getAnnotation(MapReduceParameter.class); final OutputParameter output = element.getAnnotation(OutputParameter.class); final PartitionParameter partition = element.getAnnotation(PartitionParameter.class); final SampleParameter sample = element.getAnnotation(SampleParameter.class); if (centroid != null) { handleEnum(entry, centroid.value()); } if (clustering != null) { handleEnum(entry, clustering.value()); } if (common != null) { handleEnum(entry, common.value()); } if (extract != null) { handleEnum(entry, extract.value()); } if (global != null) { handleEnum(entry, global.value()); } if (hull != null) { handleEnum(entry, hull.value()); } if (input != null) { handleEnum(entry, input.value()); } if (jump != null) { handleEnum(entry, jump.value()); } if (mapReduce != null) { handleEnum(entry, mapReduce.value()); } if (output != null) { handleEnum(entry, output.value()); } if (partition != null) { handleEnum(entry, partition.value()); } if (sample != null) { handleEnum(entry, sample.value()); } } }
public RenderingResults render(GadgetContext context) { if (!validateParent(context)) { return RenderingResults.error("Unsupported parent parameter. Check your container code.", HttpServletResponse.SC_BAD_REQUEST); } try { Gadget gadget = processor.process(context); GadgetSpec gadgetSpec = gadget.getSpec(); if (gadget.getCurrentView() == null) { return RenderingResults.error("Unable to locate an appropriate view in this gadget. " + "Requested: '" + gadget.getContext().getView() + "' Available: " + gadgetSpec.getViews().keySet(), HttpServletResponse.SC_NOT_FOUND); } if (gadget.getCurrentView().getType() == View.ContentType.URL) { if (gadget.requiresCaja()) { return RenderingResults.error("Caja does not support url type gadgets.", HttpServletResponse.SC_BAD_REQUEST); } else if (gadget.sanitizeOutput()) { return RenderingResults.error("Type=url gadgets cannot be sanitized.", HttpServletResponse.SC_BAD_REQUEST); } return RenderingResults.mustRedirect(gadget.getCurrentView().getHref()); } if (!lockedDomainService.isGadgetValidForHost(context.getHost(), gadget, context.getContainer())) { return RenderingResults.error("Invalid domain for host (" + context.getHost() + ") and gadget (" + gadgetSpec.getUrl() + ")", HttpServletResponse.SC_BAD_REQUEST); } return RenderingResults.ok(renderer.render(gadget)); } catch (RenderingException e) { return logError("render", context.getUrl(), e.getHttpStatusCode(), e); } catch (ProcessingException e) { return logError("render", context.getUrl(), e.getHttpStatusCode(), e); } catch (RuntimeException e) { if (e.getCause() instanceof GadgetException) { return logError("render", context.getUrl(), ((GadgetException)e.getCause()).getHttpStatusCode(), e.getCause()); } throw e; } }
protected AutonomiccsSystemVm createTheAutonomiccsSystemVm(VMTemplateVO systemVmTemplate, Account systemAcct, long id, String name) { AutonomiccsSystemVm autonomiccsSystemVm = new AutonomiccsSystemVm(id, autonomiccsSystemVmServiceOffering.getId(), name, systemVmTemplate.getId(), systemVmTemplate.getHypervisorType(), systemVmTemplate.getGuestOSId(), systemAcct.getDomainId(), systemAcct.getId(), accountManager.getSystemUser().getId(), autonomiccsSystemVmServiceOffering.getOfferHA()); autonomiccsSystemVm.setDynamicallyScalable(systemVmTemplate.isDynamicallyScalable()); autonomiccsSystemVm = autonomiccsSystemVmDao.persist(autonomiccsSystemVm); return autonomiccsSystemVm; }
@Override public CloseableIterable<AdaptrisMessage> splitMessage(final AdaptrisMessage msg) throws CoreException { logR.trace("LineCountSplitter splits every {} lines", splitOnLine()); try { BufferedReader buf = new BufferedReader(msg.getReader(), bufferSize()); return new LineCountSplitGenerator(buf, msg, selectFactory(msg), readHeader(buf)); } catch (IOException e) { throw new CoreException(e); } }
@Override public Table transform(Table table) { Map<String, String> tableParameters = getTableParameters(); if (tableParameters == null || tableParameters.isEmpty()) { return table; } tableParameters = mergeTableParameters(tableParameters, table); table.setParameters(tableParameters); return table; }
@NotNull @Override public Iterable<CommandLineSetup> build(@NotNull final CommandLineSetup commandLineSetup) { final UserCredentials userCredentials = myUserCredentialsService.tryGetUserCredentials(); if(userCredentials == null) { return Collections.singleton(commandLineSetup); } if(!myRunAsAccessService.getIsRunAsEnabled()) { throw new BuildStartException("RunAs is not enabled"); } final ArrayList<CommandLineResource> resources = new ArrayList<CommandLineResource>(); resources.addAll(commandLineSetup.getResources()); final File settingsFile = myFileService.getTempFileName(ARGS_EXT); resources.add(new CommandLineFile(myBeforeBuildPublisher, settingsFile.getAbsoluteFile(), myUserCredentialsGenerator.create(userCredentials))); List<CommandLineArgument> cmdLineArgs = new ArrayList<CommandLineArgument>(); cmdLineArgs.add(new CommandLineArgument(commandLineSetup.getToolPath(), CommandLineArgument.Type.PARAMETER)); cmdLineArgs.addAll(commandLineSetup.getArgs()); final RunAsParams params = new RunAsParams(cmdLineArgs); final File commandFile = myFileService.getTempFileName(myCommandFileExtension); resources.add(new CommandLineFile(myBeforeBuildPublisher, commandFile.getAbsoluteFile(), myRunAsCmdGenerator.create(params))); final ArrayList<AccessControlEntry> acl = new ArrayList<AccessControlEntry>(); for (AccessControlEntry ace: myAccessControlListProvider.getAcl(userCredentials)) { acl.add(ace); } acl.add(new AccessControlEntry(commandFile, AccessControlAccount.forUser(userCredentials.getUser()), EnumSet.of(AccessPermissions.GrantExecute), AccessControlScope.Step)); final File runAsToolPath = getTool(); final AccessControlEntry runAsToolAce = new AccessControlEntry(runAsToolPath, AccessControlAccount.forUser(userCredentials.getUser()), EnumSet.of(AccessPermissions.GrantExecute), AccessControlScope.Build); acl.add(runAsToolAce); myAccessControlResource.setAcl(new AccessControlList(acl)); resources.add(myAccessControlResource); final CommandLineSetup runAsCommandLineSetup = new CommandLineSetup( runAsToolPath.getAbsolutePath(), Arrays.asList( new CommandLineArgument(settingsFile.getAbsolutePath(), CommandLineArgument.Type.PARAMETER), new CommandLineArgument(commandFile.getAbsolutePath(), CommandLineArgument.Type.PARAMETER), new CommandLineArgument(myBuildAgentSystemInfo.bitness().toString(), CommandLineArgument.Type.PARAMETER), new CommandLineArgument(myArgumentConverter.convert(userCredentials.getPassword()), CommandLineArgument.Type.PARAMETER)), resources); myRunAsLogger.LogRunAs(userCredentials, commandLineSetup, runAsCommandLineSetup); return Collections.singleton(runAsCommandLineSetup); }
@Override public Set<String> validate(String entityType, Set<String> ids) throws IllegalStateException { if (!areParametersValid(EntityNames.PROGRAM, entityType, ids)) { return new HashSet<String>(); } NeutralQuery nq = new NeutralQuery(new NeutralCriteria("body.staffId", "=", SecurityUtil.getSLIPrincipal().getEntity().getEntityId(), false)); if (SecurityUtil.getSLIPrincipal().isStudentAccessFlag()) { nq.addCriteria(new NeutralCriteria(ParameterConstants.STUDENT_RECORD_ACCESS, NeutralCriteria.OPERATOR_EQUAL, true)); } addEndDateToQuery(nq, false); Set<String> validIds = new HashSet<String>(); Iterable<Entity> assocs = getRepo().findAll(EntityNames.STAFF_PROGRAM_ASSOCIATION, nq); for (Entity assoc : assocs) { validIds.add((String) assoc.getBody().get("programId")); } validIds.retainAll(ids); return validIds; }
public static JSONArray getSingleStepFormfields(JSONObject jsonForm) { JSONObject step1 = jsonForm.optJSONObject(STEP1); if (step1 == null) { return null; } return step1.optJSONArray(FIELDS); }
@Override public final ItemSource toSerializable(LogEvent event) { return serialize(event); }
@Override public List<Emit> select(final Collection<Emit> emits) { if (emits == null) { return null; } List<Emit> results = new ArrayList<Emit>(emits); Collections.sort(results, HIT_COMPARATOR); int endValueToRemove = -1; Set<Emit> emitToRemove = new TreeSet<Emit>(); for (Emit emit : results) { if (emit.getStart() > endValueToRemove && emit.getEnd() > endValueToRemove) { endValueToRemove = emit.getEnd(); } else { emitToRemove.add(emit); } } results.removeAll(emitToRemove); return results; }
public String assignAppToQueue(String requestedQueue, String user) throws IOException { for (QueuePlacementRule rule : rules) { String queue = rule.assignAppToQueue(requestedQueue, user, groups, configuredQueues); if (queue == null || !queue.isEmpty()) { return queue; } } throw new IllegalStateException("Should have applied a rule before " + "reaching here"); }
@SafeVarargs public static <K, V> Hashtable<K, V> newHashTable(final Pair<K, V>... pairs) { Hashtable<K, V> map = new Hashtable<>(); if (pairs == null || pairs.length == 0) { return map; } for (Pair<K, V> pair : pairs) { if (pair == null) continue; map.put(pair.first, pair.second); } return map; }
@Override public RegistryResponseType provideAndRegisterDocumentSetB(MimeMessage message) { LOG.debug("Begin provideAndRegisterDocumentSetB"); RegistryResponseType response = null; try { ProvideAndRegisterDocumentSetRequestType prdsrt = null; if (message instanceof MimeMessage) { prdsrt = new MimeMessageTransformer().transform(message); } else { LOG.warn("MimeMessage was expected but not recieved."); } String url = oProxyHelper .getAdapterEndPointFromConnectionManager(NhincConstants.DIRECT_SOAP_EDGE_SERVICE_NAME); if (NullChecker.isNotNullish(url)) { ServicePortDescriptor<DocumentRepositoryPortType> portDescriptor = new DirectEdgeSoapServicePortDescriptor(); CONNECTClient<DocumentRepositoryPortType> client = getClient(portDescriptor, url); response = (RegistryResponseType) client.invokePort(DocumentRepositoryPortType.class, "documentRepositoryProvideAndRegisterDocumentSetB", prdsrt); } else { handleError("Failed to call the web service (" + NhincConstants.DIRECT_SOAP_EDGE_SERVICE_NAME + "). The URL is null.", message); } } catch (Exception ex) { handleError("Error sending Adapter Doc Submission Unsecured message: ", ex, message); } LOG.debug("End provideAndRegisterDocumentSetB"); return response; }
public void stepDown() { changeValue(value - buttonStepSize); updateView(); }
public static String toStringAddress(SocketAddress address) { if (address == null) { return StringUtils.EMPTY; } return toStringAddress((InetSocketAddress) address); }
@SafeVarargs public static <T> TupleDomain<T> columnWiseUnion(TupleDomain<T> first, TupleDomain<T> second, TupleDomain<T>... rest) { List<TupleDomain<T>> domains = new ArrayList<>(rest.length + 2); domains.add(first); domains.add(second); domains.addAll(Arrays.asList(rest)); return columnWiseUnion(domains); }
@Nonnull public static String extractClassName(@Nonnull final String canonicalJavaClassName) { final int lastDot = canonicalJavaClassName.lastIndexOf('.'); if (lastDot < 0) { return canonicalJavaClassName.trim(); } return canonicalJavaClassName.substring(lastDot + 1).trim(); }
public IsotopePattern getIsotopes(IMolecularFormula molFor) { if (builder == null) { try { isoFactory = Isotopes.getInstance(); builder = molFor.getBuilder(); } catch (Exception e) { e.printStackTrace(); } } String mf = MolecularFormulaManipulator.getString(molFor, true); IMolecularFormula molecularFormula = MolecularFormulaManipulator.getMajorIsotopeMolecularFormula(mf, builder); IsotopePattern abundance_Mass = null; for (IIsotope isos : molecularFormula.isotopes()) { String elementSymbol = isos.getSymbol(); int atomCount = molecularFormula.getIsotopeCount(isos); List<IsotopeContainer> additional = new ArrayList<>(); for (IIsotope isotope : isoFactory.getIsotopes(elementSymbol)) { double mass = isotope.getExactMass(); double abundance = isotope.getNaturalAbundance(); if (abundance <= 0.000000001) continue; IsotopeContainer container = new IsotopeContainer(mass, abundance); if (storeFormula) container.setFormula(asFormula(isotope)); additional.add(container); } for (int i = 0; i < atomCount; i++) abundance_Mass = calculateAbundanceAndMass(abundance_Mass, additional); } IsotopePattern isoP = IsotopePatternManipulator.sortAndNormalizedByIntensity(abundance_Mass); isoP = cleanAbundance(isoP, minIntensity); IsotopePattern isoPattern = IsotopePatternManipulator.sortByMass(isoP); return isoPattern; }
@Override public Neighbor<double[], E> nearest(double[] q) { NeighborBuilder<double[], E> neighbor = new NeighborBuilder<>(); search(q, root, neighbor); neighbor.key = keys[neighbor.index]; neighbor.value = data[neighbor.index]; return neighbor.toNeighbor(); }
public boolean shouldIncludeFeatured() { return category() != null && category().parent() == null && page() != null && page() == 1 && (sort() == null || sort() == Sort.MAGIC); }
@Override public ArrayList<String> extractCourtReporters(SourceCcJudgment sourceJudgment, ImportCorrectionList correctionList) { if (StringUtils.isBlank(sourceJudgment.getRecorder())) { return Lists.newArrayList(); } return Lists.newArrayList(sourceJudgment.getRecorder()); }
@SuppressWarnings("unchecked") public <T> T getValue(final ShardingPropertiesConstant shardingPropertiesConstant) { String result = props.getProperty(shardingPropertiesConstant.getKey(), shardingPropertiesConstant.getDefaultValue()); if (boolean.class == shardingPropertiesConstant.getType()) { return (T) Boolean.valueOf(result); } if (int.class == shardingPropertiesConstant.getType()) { return (T) Integer.valueOf(result); } if (long.class == shardingPropertiesConstant.getType()) { return (T) Long.valueOf(result); } return (T) result; }
@Override public PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException { Object result = message; Map<String,Object> parameters = null; ParameterList parameterList = getParameterList(); if (parameterList != null) { try { parameters = parameterList.getValues(message, session).getValueMap(); } catch (ParameterException e) { throw new PipeRunException(this, "Could not resolve parameters", e); } } InputStream inputStream = null; OutputStream outputStream = null; HttpServletRequest httpRequest = null; HttpServletResponse httpResponse = null; String contentType = null; String contentDisposition = null; String redirectLocation = null; if (parameters != null) { if (parameters.get("inputStream") != null) { inputStream = (InputStream) parameters.get("inputStream"); } if (parameters.get("outputStream") != null) { outputStream = (OutputStream) parameters.get("outputStream"); } if (parameters.get("httpRequest") != null) { httpRequest = (HttpServletRequest) parameters.get("httpRequest"); } if (parameters.get("httpResponse") != null) { httpResponse = (HttpServletResponse) parameters.get("httpResponse"); } if (parameters.get("contentType") != null) { contentType = (String) parameters.get("contentType"); } if (parameters.get("contentDisposition") != null) { contentDisposition = (String) parameters.get("contentDisposition"); } if (parameters.get("redirectLocation") != null) { redirectLocation = (String) parameters.get("redirectLocation"); } } try { if (inputStream == null) { inputStream = message.asInputStream(); } if (httpResponse != null) { HttpSender.streamResponseBody(inputStream, contentType, contentDisposition, httpResponse, log, getLogPrefix(session), redirectLocation); } else if (httpRequest != null) { StringBuilder partsString = new StringBuilder("<parts>"); String firstStringPart = null; List<AntiVirusObject> antiVirusObjects = new ArrayList<AntiVirusObject>(); if (ServletFileUpload.isMultipartContent(httpRequest)) { log.debug(getLogPrefix(session) + "request with content type [" + httpRequest.getContentType() + "] and length [" + httpRequest.getContentLength() + "] contains multipart content"); DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory(); ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory); List<FileItem> items = servletFileUpload.parseRequest(httpRequest); int fileCounter = 0; int stringCounter = 0; log.debug(getLogPrefix(session) + "multipart request items size [" + items.size() + "]"); String lastFoundFileName = null; String lastFoundAVStatus = null; String lastFoundAVMessage = null; for (FileItem item : items) { if (item.isFormField()) { String fieldValue = item.getString(); String fieldName = item.getFieldName(); if (isCheckAntiVirus() && fieldName.equalsIgnoreCase(getAntiVirusPartName())) { log.debug(getLogPrefix(session) + "found antivirus status part [" + fieldName + "] with value [" + fieldValue + "]"); lastFoundAVStatus = fieldValue; } else if (isCheckAntiVirus() && fieldName.equalsIgnoreCase(getAntiVirusMessagePartName())) { log.debug(getLogPrefix(session) + "found antivirus message part [" + fieldName + "] with value [" + fieldValue + "]"); lastFoundAVMessage = fieldValue; } else { log.debug(getLogPrefix(session) + "found string part [" + fieldName + "] with value [" + fieldValue + "]"); if (isExtractFirstStringPart() && firstStringPart == null) { firstStringPart = fieldValue; } else { String sessionKeyName = "part_string" + (++stringCounter > 1 ? stringCounter : ""); addSessionKey(session, sessionKeyName, fieldValue); partsString.append("<part type=\"string\" name=\"" + fieldName + "\" sessionKey=\"" + sessionKeyName + "\" size=\"" + fieldValue.length() + "\"/>"); } } } else { if (lastFoundFileName != null && lastFoundAVStatus != null) { antiVirusObjects.add(new AntiVirusObject( lastFoundFileName, lastFoundAVStatus, lastFoundAVMessage)); lastFoundFileName = null; lastFoundAVStatus = null; lastFoundAVMessage = null; } log.debug(getLogPrefix(session) + "found file part [" + item.getName() + "]"); String sessionKeyName = "part_file" + (++fileCounter > 1 ? fileCounter : ""); String fileName = FilenameUtils.getName(item.getName()); InputStream is = item.getInputStream(); int size = is.available(); String mimeType = item.getContentType(); if (size > 0) { addSessionKey(session, sessionKeyName, is, fileName); } else { addSessionKey(session, sessionKeyName, null); } partsString.append("<part type=\"file\" name=\"" + fileName + "\" sessionKey=\"" + sessionKeyName + "\" size=\"" + size + "\" mimeType=\"" + mimeType + "\"/>"); lastFoundFileName = fileName; } } if (lastFoundFileName != null && lastFoundAVStatus != null) { antiVirusObjects.add(new AntiVirusObject(lastFoundFileName, lastFoundAVStatus, lastFoundAVMessage)); } } else { log.debug(getLogPrefix(session) + "request with content type [" + httpRequest.getContentType() + "] and length [" + httpRequest.getContentLength() + "] does NOT contain multipart content"); } partsString.append("</parts>"); if (isExtractFirstStringPart()) { result = adjustFirstStringPart(firstStringPart, session); session.put(getMultipartXmlSessionKey(), partsString.toString()); } else { result = partsString.toString(); } if (!antiVirusObjects.isEmpty()) { for (AntiVirusObject antiVirusObject : antiVirusObjects) { if (!antiVirusObject.getStatus().equalsIgnoreCase(getAntiVirusPassedMessage())) { String errorMessage = "multipart contains file [" + antiVirusObject.getFileName() + "] with antivirus status [" + antiVirusObject.getStatus() + "] and message [" + StringUtils.defaultString(antiVirusObject.getMessage()) + "]"; PipeForward antiVirusFailedForward = findForward(ANTIVIRUS_FAILED_FORWARD); if (antiVirusFailedForward == null) { throw new PipeRunException(this, errorMessage); } else { if (antiVirusFailureAsSoapFault) { errorMessage = createSoapFaultMessage(errorMessage); } if (StringUtils.isEmpty(getAntiVirusFailureReasonSessionKey())) { return new PipeRunResult(antiVirusFailedForward, errorMessage); } else { session.put(getAntiVirusFailureReasonSessionKey(), errorMessage); return new PipeRunResult(antiVirusFailedForward, result); } } } } } } else { Misc.streamToStream(inputStream, outputStream); } } catch (IOException e) { throw new PipeRunException(this, "IOException streaming input to output", e); } catch (FileUploadException e) { throw new PipeRunException(this, "FileUploadException getting multiparts from httpServletRequest", e); } return new PipeRunResult(getForward(), result); }
public final MerchantCenterLink getMerchantCenterLink(String resourceName) { MERCHANT_CENTER_LINK_PATH_TEMPLATE.validate(resourceName, "getMerchantCenterLink"); GetMerchantCenterLinkRequest request = GetMerchantCenterLinkRequest.newBuilder().setResourceName(resourceName).build(); return getMerchantCenterLink(request); }
public void setPasswordVisible(boolean visible) { passwordVisible = visible; setPasswordVisibility(); }
public boolean isPriorityDisabled() { return this.priority <= ElectionPriority.Disabled; }
public boolean canSave(TileLayer tl) { if (tl.isTransientLayer()) { return false; } return canSaveIfNotTransient(tl); }
@Override public void execute(WikiCreationRequest request) throws WikiCreationException { try { String wikiId = request.getWikiId(); WikiDescriptor descriptor = wikiDescriptorManager.getById(wikiId); descriptor.setDescription(request.getDescription()); descriptor.setPrettyName(request.getPrettyName()); wikiDescriptorManager.saveDescriptor(descriptor); wikiTemplateManager.setTemplate(wikiId, request.isTemplate()); wikiUserManager.setUserScope(wikiId, request.getUserScope()); wikiUserManager.setMembershipType(wikiId, request.getMembershipType()); } catch (WikiManagerException | WikiTemplateManagerException | WikiUserManagerException e) { throw new WikiCreationException( String.format("Failed to set metadata to the wiki [%s].", request.getWikiId()), e); } }
@Override public String getNodeLoad(String nodeId) throws MonitorException{ try{ Vector<Object> argList = new Vector<Object>(); argList.add(nodeId); return (String)client.execute("resourcemgr.getNodeLoad", argList); }catch(Exception e){ throw new MonitorException(e.getMessage(), e); } }
public void removeArchetype(final String archetype) { archetypePreferences.load(); if (removeArchetypePreference(archetype)) { archetypePreferences.save(getGlobalScope()); } getOuIdentifiers().forEach(identifier -> { final PreferenceScopeResolutionStrategyInfo info = workbenchPreferenceScopeResolutionStrategies.getSpaceInfoFor(identifier); archetypePreferences.load(info); if (removeArchetypePreference(archetype)) { archetypePreferences.save(info); } }); }
public void initSearchMechanism(Collection<HostToken> hostTokens) { for (HostToken hostToken : hostTokens) { tokenMap.put(hostToken.getToken(), hostToken); } initBinarySearch(); }
@Override public byte[] fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; } JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
@Override protected BaseQueryBuilder build(final AssetState context, final BaseQueryBuilder builder) { return builder .where() .openBracket() .addAndCondition(NAME_CONDITION, context.getName()) .closeBracket(); }
@Override public JenaTypes types() { ensureOpen(); return new JenaTypes(adapter, this::ensureOpen, this::commitIfAuto); }
public static int max(int[] array) { int mu = array[0]; for (int n = 1; n < array.length; ++n) { mu = Math.max(mu, array[n]); } return mu; }
public Activity asSuggestionActivity() { return isActivity(ActivityTypes.SUGGESTION) ? this : null; }
@Override public T getSecond() { return atIndex(1); }
@Override public void encode(FetchResponse fetchResponse, ImapResponseComposer composer) throws IOException { MessageSequenceNumber messageNumber = fetchResponse.getMessageNumber(); composer.untagged().message(messageNumber.asInt()).message(ImapConstants.FETCH_COMMAND.getName()).openParen(); encodeModSeq(composer, fetchResponse); encodeFlags(composer, fetchResponse); encodeInternalDate(composer, fetchResponse); encodeSize(composer, fetchResponse); encodeEnvelope(composer, fetchResponse); encodeBody(composer, fetchResponse.getBody()); encodeBodyStructure(composer, fetchResponse.getBodyStructure()); encodeUid(composer, fetchResponse); encodeBodyElements(composer, fetchResponse.getElements()); composer.closeParen().end(); }
public static List<FieldVector> toArrowColumns(final BufferAllocator bufferAllocator, final Schema schema, List<List<Writable>> dataVecRecord) { int numRows = dataVecRecord.size(); List<FieldVector> ret = createFieldVectors(bufferAllocator,schema,numRows); for(int j = 0; j < schema.numColumns(); j++) { FieldVector fieldVector = ret.get(j); int row = 0; for(List<Writable> record : dataVecRecord) { Writable writable = record.get(j); setValue(schema.getType(j),fieldVector,writable,row); row++; } } return ret; }
@Override public FilteredNode showDefault() { return showVisible().showHasAccess(PortalRequest.getInstance().getUser()); }
public long getContentLength() { return contentLength; }
public void show(final DataSetDef def, final String parentPanelId) { this.def = def; if (def != null) { final String name = def.getName(); final SafeUri typeIconUri = getTypeIconUri(def); final String typeName = getTypeIconTitle(def); view.showHeader(def.getUUID(), parentPanelId, typeIconUri, typeName, name); } }
public CombinedConfiguration createCombinedConfiguration( @Nullable List<ConfigurationInfo<String>> paths, @Nullable List<ConfigurationInfo<URL>> urls) throws ConfigurationLoadException { CombinedConfiguration combinedConfiguration = setupConfiguration(new CombinedConfiguration(new OverrideCombiner())); addConfiguration(combinedConfiguration, fromSystem()); if (paths != null) { for (ConfigurationInfo<String> path : paths) { if (path != null && path.getLocation() != null) { try { addConfiguration(combinedConfiguration, fromFile(path.getLocation())); } catch (ConfigurationLoadException e) { if (!path.isOptional) { throw e; } else { AdsServiceLoggers.ADS_API_LIB_LOG.debug( "Could not load optional configuration: " + path); } } } } } if (urls != null) { for (ConfigurationInfo<URL> url : urls) { if (url != null && url.getLocation() != null) { try { addConfiguration(combinedConfiguration, fromFile(url.getLocation())); } catch (ConfigurationLoadException e) { if (!url.isOptional) { throw e; } else { AdsServiceLoggers.ADS_API_LIB_LOG.debug( "Did not load optional configuration" + url.getLocation() + ":", e); } } } } } return combinedConfiguration; }
static double getDoubleOrDefault(Object object, double defaultValue) { if (object == null) { return defaultValue; } if (object instanceof Number) { return ((Number) object).doubleValue(); } Matcher matcher = PATTERN_NUMBER.matcher(object.toString()); if (!matcher.find()) { LOG.debug("Parse double failed. Not number: {}", object); return defaultValue; } try { return Double.parseDouble(matcher.group()); } catch (Exception e) { LOG.debug("Parse double failed: {}", object); return defaultValue; } }
@Override public Set<byte[]> hKeys(byte[] key) { return helper.doInScope(RedisCommand.HKEYS, key, () -> connection.hKeys(key)); }
public String join(final Stream<?> parts) { return join(parts.iterator()); }
@Override public boolean callSaveHook(final Entity entity) { return entity.isValid() && callHooks(entity, getSaveHooks()); }
@Override public NovaTemplateOptions blockOnPort(int port, int seconds) { return NovaTemplateOptions.class.cast(super.blockOnPort(port, seconds)); }
public void tempbanPlayer(final Player player) { if (isEnabled) { final String name = player.getName(); final String ip = PlayerUtils.getPlayerIp(player); final String reason = messages.retrieveSingle(player, MessageKey.TEMPBAN_MAX_LOGINS); final Date expires = new Date(); long newTime = expires.getTime() + (length * MILLIS_PER_MINUTE); expires.setTime(newTime); bukkitService.scheduleSyncDelayedTask(() -> { if(customCommand.isEmpty()) { bukkitService.banIp(ip, reason, expires, "AuthMe"); player.kickPlayer(reason); } else { String command = customCommand .replace("%player%", name) .replace("%ip%", ip); bukkitService.dispatchConsoleCommand(command); } }); ipLoginFailureCounts.remove(ip); } }
@Override public void validate(Process process) throws FalconException { validate(process, true); }
public void check(FreeResourcesLimitDto freeResourcesLimit) throws BadRequestException { if (freeResourcesLimit == null) { throw new BadRequestException("Missed free resources limit description."); } if (freeResourcesLimit.getAccountId() == null) { throw new BadRequestException("Missed account id."); } Set<String> resourcesToSet = new HashSet<>(); for (ResourceDto resource : freeResourcesLimit.getResources()) { if (!resourcesToSet.add(resource.getType())) { throw new BadRequestException( format( "Free resources limit should contain only one resources with type '%s'.", resource.getType())); } resourceValidator.validate(resource); } }
@Override public TimestampRange getFreshTimestamps(int numTimestampsRequested) { return timestampService.getFreshTimestamps(numTimestampsRequested); }
static ByteBuffer directBufferFor(long address, long offset, long len, boolean readOnly) { if (len > Integer.MAX_VALUE || len < 0L) throw new IllegalArgumentException(); try { ByteBuffer bb = (ByteBuffer) unsafe.allocateInstance(readOnly ? DIRECT_BYTE_BUFFER_CLASS_R : DIRECT_BYTE_BUFFER_CLASS); unsafe.putLong(bb, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET, address + offset); unsafe.putInt(bb, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET, (int) len); unsafe.putInt(bb, DIRECT_BYTE_BUFFER_LIMIT_OFFSET, (int) len); bb.order(ByteOrder.BIG_ENDIAN); return bb; } catch (Error e) { throw e; } catch (Throwable t) { throw new RuntimeException(t); } }
@CrossOrigin @PostMapping(value = "/tim/query") public synchronized ResponseEntity<String> bulkQuery(@RequestBody String jsonString) { if (null == jsonString || jsonString.isEmpty()) { logger.error("Empty request."); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(JsonUtils.jsonKeyValue(ERRSTR, "Empty request.")); } RSU queryTarget = (RSU) JsonUtils.fromJson(jsonString, RSU.class); TimTransmogrifier.updateRsuCreds(queryTarget, odeProperties); SnmpSession snmpSession = null; try { snmpSession = new SnmpSession(queryTarget); snmpSession.startListen(); } catch (IOException e) { logger.error("Error creating SNMP session.", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(JsonUtils.jsonKeyValue(ERRSTR, "Failed to create SNMP session.")); } PDU pdu0 = new ScopedPDU(); pdu0.setType(PDU.GET); PDU pdu1 = new ScopedPDU(); pdu1.setType(PDU.GET); for (int i = 0; i < odeProperties.getRsuSrmSlots() - 50; i++) { pdu0.add(new VariableBinding(new OID("1.0.15628.4.1.4.1.11.".concat(Integer.toString(i))))); } for (int i = 50; i < odeProperties.getRsuSrmSlots(); i++) { pdu1.add(new VariableBinding(new OID("1.0.15628.4.1.4.1.11.".concat(Integer.toString(i))))); } ResponseEvent response0 = null; ResponseEvent response1 = null; try { response0 = snmpSession.getSnmp().send(pdu0, snmpSession.getTarget()); response1 = snmpSession.getSnmp().send(pdu1, snmpSession.getTarget()); } catch (IOException e) { logger.error("Error creating SNMP session.", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(JsonUtils.jsonKeyValue(ERRSTR, "Failed to create SNMP session.")); } if (response0 == null || response0.getResponse() == null || response1 == null || response1.getResponse() == null) { logger.error("RSU query failed, timeout."); return ResponseEntity.status(HttpStatus.BAD_REQUEST) .body(JsonUtils.jsonKeyValue(ERRSTR, "Timeout, no response from RSU.")); } HashMap<String, Boolean> resultsMap = new HashMap<>(); for (Object vbo : response0.getResponse().getVariableBindings().toArray()) { VariableBinding vb = (VariableBinding) vbo; if (vb.getVariable().toInt() == 1) { resultsMap.put(vb.getOid().toString().substring(21), true); } } for (Object vbo : response1.getResponse().getVariableBindings().toArray()) { VariableBinding vb = (VariableBinding) vbo; if (vb.getVariable().toInt() == 1) { resultsMap.put(vb.getOid().toString().substring(21), true); } } try { snmpSession.endSession(); } catch (IOException e) { logger.error("Error closing SNMP session.", e); } logger.info("RSU query successful: {}", resultsMap.keySet()); return ResponseEntity.status(HttpStatus.OK).body(JsonUtils.jsonKeyValue("indicies_set", resultsMap.keySet().toString())); }
@Override public Map<String, Long> getTagging(String assetGroup, String targetType) throws ServiceException { try { return repository.getTagging(assetGroup, targetType); } catch (DataException e) { throw new ServiceException(e); } }
@Override public synchronized void onRepositoryChange(String namespace, Properties newProperties) { if (newProperties.equals(m_configProperties.get())) { return; } ConfigSourceType sourceType = m_configRepository.getSourceType(); Properties newConfigProperties = new Properties(); newConfigProperties.putAll(newProperties); Map<String, ConfigChange> actualChanges = updateAndCalcConfigChanges(newConfigProperties, sourceType); if (actualChanges.isEmpty()) { return; } this.fireConfigChange(new ConfigChangeEvent(m_namespace, actualChanges)); Tracer.logEvent("Apollo.Client.ConfigChanges", m_namespace); }
public RemoteCommandReturnInfo executeCommand(Jvm jvm, JvmControlOperation operation) throws ApplicationServiceException { if (commands.containsKey(operation.getExternalValue())) { return commands.get(operation.getExternalValue()).execute(jvm); } throw new ApplicationServiceException("JvmCommand not implemented: " + operation.getExternalValue()); }
@Override public EntityReference resolve(String entityReferenceRepresentation, EntityType type, Object... parameters) { EntityType[] entityTypesForType = ENTITY_TYPES.get(type); if (entityTypesForType == null) { throw new RuntimeException("No parsing definition found for Entity Type [" + type + "]"); } EntityReference entityReference = null; int entityTypeOffset = 0; int offset = entityReferenceRepresentation.length() - 1; while (offset >= 0) { entityTypeOffset = Math.min(entityTypeOffset, entityTypesForType.length - 2); StringBuilder entityName = new StringBuilder(); offset = readEntityName(entityReferenceRepresentation, entityName, offset); EntityReference parent = getNewEntityReference(entityName.reverse().toString(), entityTypesForType[entityTypeOffset++], parameters); entityReference = entityReference == null ? parent : entityReference.appendParent(parent); } for (int i = entityTypeOffset; i < entityTypesForType.length; i++) { EntityReference parent = resolveDefaultReference(entityTypesForType[i], parameters); if (parent != null) { entityReference = entityReference == null ? parent : entityReference.appendParent(parent); } else { break; } } return entityReference; }
@Override public <C > SpanContext extract(C carrier, Getter<C> getter) throws SpanContextParseException { checkNotNull(carrier, "carrier"); checkNotNull(getter, "getter"); TraceId traceId; SpanId spanId; TraceOptions traceOptions; String traceparent = getter.get(carrier, TRACEPARENT); if (traceparent == null) { throw new SpanContextParseException("Traceparent not present"); } try { checkArgument( traceparent.charAt(TRACE_OPTION_OFFSET - 1) == TRACEPARENT_DELIMITER && (traceparent.length() == TRACEPARENT_HEADER_SIZE || (traceparent.length() > TRACEPARENT_HEADER_SIZE && traceparent.charAt(TRACEPARENT_HEADER_SIZE) == TRACEPARENT_DELIMITER)) && traceparent.charAt(SPAN_ID_OFFSET - 1) == TRACEPARENT_DELIMITER && traceparent.charAt(TRACE_OPTION_OFFSET - 1) == TRACEPARENT_DELIMITER, "Missing or malformed TRACEPARENT."); traceId = TraceId.fromLowerBase16(traceparent, TRACE_ID_OFFSET); spanId = SpanId.fromLowerBase16(traceparent, SPAN_ID_OFFSET); traceOptions = TraceOptions.fromLowerBase16(traceparent, TRACE_OPTION_OFFSET); } catch (IllegalArgumentException e) { throw new SpanContextParseException("Invalid traceparent: " + traceparent, e); } String tracestate = getter.get(carrier, TRACESTATE); try { if (tracestate == null || tracestate.isEmpty()) { return SpanContext.create(traceId, spanId, traceOptions, TRACESTATE_DEFAULT); } Tracestate.Builder tracestateBuilder = Tracestate.builder(); List<String> listMembers = TRACESTATE_ENTRY_DELIMITER_SPLITTER.splitToList(tracestate); checkArgument( listMembers.size() <= TRACESTATE_MAX_MEMBERS, "Tracestate has too many elements."); for (int i = listMembers.size() - 1; i >= 0; i--) { String listMember = listMembers.get(i); int index = listMember.indexOf(TRACESTATE_KEY_VALUE_DELIMITER); checkArgument(index != -1, "Invalid tracestate list-member format."); tracestateBuilder.set( listMember.substring(0, index), listMember.substring(index + 1, listMember.length())); } return SpanContext.create(traceId, spanId, traceOptions, tracestateBuilder.build()); } catch (IllegalArgumentException e) { throw new SpanContextParseException("Invalid tracestate: " + tracestate, e); } }
public ConnectionReport getConnections() { return getConnectionsByUrl(""); }
@Override public final List<FileSystemPath> files() throws FileSystemException { return fileSystem.files(); }
public POSSample read() throws IOException { Sentence paragraph; while ((paragraph = this.adSentenceStream.read()) != null) { Node root = paragraph.getRoot(); List<String> sentence = new ArrayList<String>(); List<String> tags = new ArrayList<String>(); process(root, sentence, tags); return new POSSample(sentence, tags); } return null; }
public DefinitionGraph transform(Map<String, List<ModuleContext>> moduleMap) { definition(null, RootDefinition.builder(), builder -> moduleMap.keySet().forEach( moduleName -> builder.withModule(transformModules(moduleName, moduleMap.get(moduleName))))); return createGraph(definitions).build(); }
@Override public int run(String[] args) throws Exception { int exitCode = 0; try { exitCode = init(args); if (exitCode != 0) { return exitCode; } if (command != null && command.validate()) { initializeServices( command instanceof MasterCreateCommand ); command.execute(); } else if (!(command instanceof MasterCreateCommand)){ out.println("ERROR: Invalid Command" + "\n" + "Unrecognized option:" + args[0] + "\n" + "A fatal exception has occurred. Program will exit."); exitCode = -2; } } catch (ServiceLifecycleException sle) { out.println("ERROR: Internal Error: Please refer to the knoxcli.log " + "file for details. " + sle.getMessage()); } catch (Exception e) { e.printStackTrace( err ); err.flush(); return -3; } return exitCode; }
@Transactional public List<Fund> update(List<Fund> funds, RequestInfo requestInfo) { ModelMapper mapper = new ModelMapper(); Map<String, Object> message = new HashMap<>(); FundRequest request = new FundRequest(); FundContract contract; if (persistThroughKafka != null && !persistThroughKafka.isEmpty() && persistThroughKafka.equalsIgnoreCase("yes")) { request.setRequestInfo(requestInfo); request.setFunds(new ArrayList<>()); for (Fund f : funds) { contract = new FundContract(); contract.setCreatedDate(new Date()); mapper.map(f, contract); request.getFunds().add(contract); } message.put("fund_update", request); fundQueueRepository.add(message); return funds; } else { List<Fund> resultList = new ArrayList<Fund>(); for (Fund f : funds) { resultList.add(update(f)); } request.setRequestInfo(requestInfo); request.setFunds(new ArrayList<>()); for (Fund f : resultList) { contract = new FundContract(); contract.setCreatedDate(new Date()); mapper.map(f, contract); request.getFunds().add(contract); } message.put("fund_persisted", request); fundQueueRepository.addToSearch(message); return resultList; } }
@Override public String getFileContents() { return fileUploadPopup.getFileContents(); }
public void save(RegimenTemplate regimenTemplate, Long userId) { for (Column regimenColumn : regimenTemplate.getColumns()) { regimenColumn.setModifiedBy(userId); if (regimenColumn.getId() == null) { regimenColumn.setCreatedBy(userId); mapper.insert((RegimenColumn) regimenColumn, regimenTemplate.getProgramId()); } mapper.update((RegimenColumn) regimenColumn); } }
public static String decodeBase64(String content, TestContext context) { return new DecodeBase64Function().execute(Collections.singletonList(content), context); }
<U> Stage<U> thenComposeCompleted( final Function<? super T, ? extends Stage<U>> fn, final T value ) { try { return fn.apply(value); } catch (final Exception e) { return new ImmediateFailed<>(caller, e); } }
@Override public Optional<Resource> getUsedResource(String accountId) throws NotFoundException, ServerException { final Account account = accountManager.getById(accountId); final long currentlyUsedRuntimes = Pages.stream( (maxItems, skipCount) -> workspaceManagerProvider .get() .getByNamespace(account.getName(), false, maxItems, skipCount)) .filter(ws -> STOPPED != ws.getStatus()) .count(); if (currentlyUsedRuntimes > 0) { return Optional.of( new ResourceImpl( RuntimeResourceType.ID, currentlyUsedRuntimes, RuntimeResourceType.UNIT)); } else { return Optional.empty(); } }
public synchronized static String getFullClassName(String shortName) { if (NAME_TO_CLASS != null) { return NAME_TO_CLASS.get(shortName); } NAME_TO_CLASS = new HashMap<String, String>(); for (File file : getClassPathAsList()) { if (file.length() > MAX_FILE_SIZE) { LOG.debug("skipping looking for providers in large file " + file); continue; } ClassFinder finder = new ClassFinder(); finder.add(file); ClassFilter filter = new AndClassFilter( new RegexClassFilter(WIKIBRAIN_CLASS_PATTERN.pattern()), new NotClassFilter(new RegexClassFilter(WIKIBRAIN_CLASS_BLACKLIST.pattern())) ); Collection<ClassInfo> foundClasses = new ArrayList<ClassInfo>(); finder.findClasses(foundClasses,filter); for (ClassInfo info : foundClasses) { String tokens[] = info.getClassName().split("[.]"); if (tokens.length == 0) { continue; } String n = tokens[tokens.length - 1]; if (!NAME_TO_CLASS.containsKey(n)) { NAME_TO_CLASS.put(n, info.getClassName()); } } } LOG.info("found " + NAME_TO_CLASS.size() + " classes when constructing short to full class name mapping"); return NAME_TO_CLASS.get(shortName); }
public static String getRelativeToCanonical(String path, String canonical) throws IOException { try { return getRelativeToCanonical(path, canonical, null, null); } catch (ForbiddenSymlinkException e) { return path; } }
public static boolean contentEquals( @Nonnull final InputStream input1, @Nonnull final InputStream input2 ) throws IOException { final InputStream bufferedInput1 = new BufferedInputStream( input1 ); final InputStream bufferedInput2 = new BufferedInputStream( input2 ); int ch = bufferedInput1.read(); while ( -1 != ch ) { final int ch2 = bufferedInput2.read(); if ( ch != ch2 ) { return false; } ch = bufferedInput1.read(); } final int ch2 = bufferedInput2.read(); return -1 == ch2; }
public String createKey(HttpRequest request) { if ((request.getAuthType() != AuthType.NONE) && (request.getSecurityToken() == null)) { throw new IllegalArgumentException( "Cannot sign request without security token: [" + request + ']'); } CacheKeyBuilder keyBuilder = new CacheKeyBuilder() .setLegacyParam(0, request.getUri()) .setLegacyParam(1, request.getAuthType()) .setLegacyParam(2, getOwnerId(request)) .setLegacyParam(3, getViewerId(request)) .setLegacyParam(4, getTokenOwner(request)) .setLegacyParam(5, getAppUrl(request)) .setLegacyParam(6, getInstanceId(request)) .setLegacyParam(7, getServiceName(request)) .setLegacyParam(8, getTokenName(request)) .setParam("rh", request.getParam(RESIZE_HEIGHT)) .setParam("rw", request.getParam(RESIZE_WIDTH)) .setParam("rq", request.getParam(RESIZE_QUALITY)) .setParam("ne", request.getParam(NO_EXPAND)) .setParam("rm", request.getRewriteMimeType()) .setParam("ua", request.getHeader("User-Agent")); return keyBuilder.build(); }
public static <T> ChoiceOfTwoLoadBalancer<T> create(final Comparator<T> func) { return new ChoiceOfTwoLoadBalancer<T>(func); }
public final Converter getPrimitiveTypeConverter() { return new ConverterImpl(); }
protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) { if (optional) { return true; } else { WebSecurityPlugin.sendErrorToClient((HttpServletResponse) response, LOGGER, HttpServletResponse.SC_UNAUTHORIZED, "A valid certificate is required to gain access", e); return false; } }
public double getLineCoverageFitness( ExecutionResult result , int lineNumber) { StackTrace trace = targetCrash; return getLineCoverageFitness(result, trace, lineNumber); }
public String toGeneralizedTime() { return toGeneralizedTime( upFormat, upFractionDelimiter, upFractionLength, upTimeZoneFormat ); }
public static FilePattern compile(String patternString) { if (patternString == null) { throw new IllegalArgumentException("patternString must not be null"); } if (patternString.isEmpty()) { throw new IllegalArgumentException("patternString must not be empty"); } List<Segment> segments = compileSegments(patternString); return new FilePattern(segments, patternString); }
boolean addDetector(Class<?> clazz) { List<WarningDefinition> wds = getDefinitions(clazz); if (wds.isEmpty()) return false; try { wds.forEach(wd -> ctx.incStat("WarningTypes.Total")); Map<String, WarningType> wts = createWarningMap(wds.stream().map(WarningType::new)); Detector detector = createDetector(clazz, wts); if (detector == null) return false; detectors.add(detector); } catch (Exception e) { ctx.addError(new ErrorMessage(clazz.getName(), null, null, null, -1, e)); } return true; }
public UiResponse findByInstanceId(String instanceId) { UiResponse uiResponse = new UiResponse(); Long count; List<AppClusterEntity> appClusterList; count = uiAppClusterRepository.appClusterCount(instanceId); appClusterList = uiAppClusterRepository.findByInstanceId(instanceId); return UiResponseHelper.setUiResponse(uiResponse, count, appClusterList); }
@Override public int countChars (Note note) { String titleAndContent = note.getTitle() + "\n" + note.getContent(); return Observable .from(sanitizeTextForWordsAndCharsCount(note, titleAndContent).split("")) .filter(s -> !s.matches("\\s")) .count().toBlocking().single(); }
@Override public boolean isOpen() { throw new UnsupportedOperationException(); }
public static DefaultConstructorStrategy byDefaultConstructor() { return new DefaultConstructorStrategy(new Class<?>[0], new Object[0]); }
@Override public boolean isEnabled() { return metaResource.isReadable() && metaResourceField.isUpdatable(); }
@Override public DoubleStream asDoubleStream() { return DoubleStream.of(element); }
@Override public ProcessResult process(Doc doc) { List<String> missingFields = new ArrayList<>(); for (Map.Entry<Template, Template> rename : renames.entrySet()) { String renderedFrom = rename.getKey().render(doc); if (!doc.hasField(renderedFrom)) { missingFields.add(renderedFrom); continue; } String renderedTo = rename.getValue().render(doc); Object fieldValue = doc.getField(renderedFrom); doc.removeField(renderedFrom); doc.addField(renderedTo, fieldValue); } if (!missingFields.isEmpty()) { return ProcessResult.failure(String.format("failed to rename fields [%s], fields are missing", missingFields)); } return ProcessResult.success(); }
public static <T> Supplier<T> unchecked(Callable<T> func){ return () -> { try { return func.call(); } catch (Exception ex) { throw propagate(ex); } }; }
@Override public boolean hasStatement(Statement statement) { if (statement == null) { return false; } Model graph = null; GraphConnection graphConnection = null; try { graphConnection = openGraph(); graph = graphConnection.getGraph(); graph.enterCriticalSection(Lock.READ); SimpleSelector selector = getJenaSelector(graph, statement); return graph.contains(selector.getSubject(), selector.getPredicate(), selector.getObject()); } finally { if (graph != null) { graph.leaveCriticalSection(); } if (graphConnection != null) { graphConnection.close(); } } }
public static byte parseChr(String field) { if (field.startsWith("chr")) { return chr(field.substring(3)); } return chr(field); }
@Pure public Iterable<BusLine> busLines() { return Collections.unmodifiableList(this.busLines); }
public long getRampTime() { return rampTime != null ? rampTime : rampTimeSeconds * 1000; }
public static Integer parserInteger(JsonPullParser parser) throws IOException, JsonFormatException { State eventType = parser.getEventType(); if (eventType == State.VALUE_NULL) { return null; } else if (eventType == State.VALUE_LONG) { return (int) parser.getValueLong(); } else { throw new IllegalStateException("unexpected state. expected=VALUE_LONG, but get=" + eventType.toString()); } }
@GET public Response list() { return Response.ok(legumes).build(); }
@Override public List<String> getAccept() { return Collections.emptyList(); }
public static Expression compile( String expression ) { return new Expression( expression ); }
@Override public Optional<MemberId> upstreamDatabase() { return strategyImpl.upstreamDatabase(); }
public void refreshConnection() throws SQLException{ this.connection.close(); try{ this.connection = this.pool.obtainRawInternalConnection(); } catch(SQLException e){ throw markPossiblyBroken(e); } }
public final void trimToSize() { delegate.trimToSize(); }
public static Matcher<JsonNode> jsonArray() { return new IsJsonArray(is(anything())); }
public static Binder stringBinder() { return STRING_BINDER; }
public static Expression absExp(Expression exp) { return new ASTAbs(exp); }
@Override public CompletableFuture<KieCompilationResponse> build(Path projectPath, String mavenRepoPath, String settingXML) { return internalBuild(projectPath, mavenRepoPath, settingXML, Boolean.FALSE, MavenCLIArgs.COMPILE); }
@Override public void destroy() { proxy.destroy(); targetNode = null; edge = null; sourceNode = null; }
public List<FileMetadata> getAllFiles(String streamName) { List<FileMetadata> ret = new ArrayList<>(); try { Path streamPath = new Path(streamName); FileSystem fileSystem = streamPath.getFileSystem(new Configuration()); FileStatus[] fileStatuses = fileSystem.listStatus(streamPath); for (FileStatus fileStatus : fileStatuses) { if (!fileStatus.isDirectory()) { ret.add(new FileMetadata(fileStatus.getPath().toString(), fileStatus.getLen())); } else { ret.addAll(getAllFiles(fileStatus.getPath().toString())); } } } catch (IOException e) { LOG.error("Failed to get the list of files for " + streamName, e); throw new SamzaException(e); } return ret; }
public static void isFalse(boolean validIfFalse, String message) { if (validIfFalse) { throw new IllegalArgumentException(message); } }
@Override public Matrix backPropagate(final Matrix input, final Matrix activation, final Matrix nextError) { final Matrix error = matrixFactory.create(input.getRows(), input.getColumns()); for (int n = 0; n < input.getColumns(); ++n) { final Matrix singleNextError = nextError.getColumn(n).reshape(outputShape[1] * outputShape[2], outputShape[0]); final Matrix row = singleNextError.mmul(getLayerParameter().getWeightParam().transpose()); final Matrix im = row2im(row); error.putColumn(n, im); } return error; }
public static int countWords(String content) { return ofNullable(stripToNull(stripHtml(content))).map(contentValue -> contentValue.split("\\s+").length).orElse(0); }
@Override public int insertAuthRoleAdminAll(List<AuthRoleAdmin> authRoleAdminList) { if (authRoleAdminList == null || authRoleAdminList.isEmpty()) { return 0; } return authRoleAdminDao.insertAuthRoleAdminAll(authRoleAdminList); }
public static int getDimensionCount(String className) { String baseClassName = className.replace("[", ""); return className.length() - baseClassName.length(); }
@Override public void configure(ResourceInfo resourceInfo, FeatureContext context) { Secured securedAnnotation = resourceInfo.getResourceMethod().getAnnotation(Secured.class); if (securedAnnotation == null) { LOGGER.debug(String.format("Ignoring Non-@%s annotated method %s.%s", Secured.class.getName(), resourceInfo.getResourceClass().getName(), resourceInfo.getResourceMethod().getName())); return; } LOGGER .debug(String.format("Registering authorization filters with '%s' permission for %s annotated method %s.%s", securedAnnotation.permission(), Secured.class.getName(), resourceInfo.getResourceClass().getName(), resourceInfo.getResourceMethod().getName())); context.register(new EndpointAdminOnlyAuthorizationFilter(securedAnnotation.isAdminOnly()), Priorities.AUTHORIZATION + 10); context.register(new EndpointPermissionAuthorizationFilter(securedAnnotation.permission()), Priorities.AUTHORIZATION + 20); context.register(new EndpointPersonalCertificateAuthorizationFilter(securedAnnotation.permission()), Priorities.AUTHORIZATION + 30); }
public BestTransportResult fromTo(String origin, String destination, TravelMode mode) { DirectionsRoute[] routes = this.calls.fromTo(origin, destination, mode); if (mode == TravelMode.TRANSIT) { return new BestTransportResult(mode, findBestArrivalTime(routes)); } return new BestTransportResult(mode, findBestRoute(routes)); }
public List<String> getPatterns() { return patterns; }
@Override public void clearIgnoringIndexes() { size = 0; }
@Override public JFrame getErrorFrame(Component owner) { reinit(); expandedHeight = 0; collapsedHeight = 0; JXErrorFrame frame = new JXErrorFrame(pane); centerWindow(frame, owner); return frame; }
public static String getShortName(final Step step, final int maxLength) { final String name = step.toString(); if (name.length() > maxLength) return name.substring(0, maxLength - 3) + "..."; return name; }
void scheduleInstanceTask(@Nonnull DockerInstanceTask instanceTask) { DockerCloudUtils.requireNonNull(instanceTask, "Instance task cannot be null."); LOG.debug("Scheduling instance task: " + clientTasks); submitTaskWithInitialDelay(instanceTask); }
@Override public String getName() { return name; }
@Override public ValidationFailure validate(V value, Object valueSource) { if ((value == null) && (this.propertyType != null) && this.propertyType.isPrimitive()) { return new ValidationFailureImpl(Mandatory.class.getSimpleName(), valueSource, createBundle(NlsBundleUtilValidationRoot.class).errorMandatory()); } Set<ConstraintViolation<?>> violationSet = validateJsr303(value); int size = violationSet.size(); if (size == 1) { ConstraintViolation<?> violation = violationSet.iterator().next(); return createValidationFailure(violation, valueSource); } else if (size > 1) { ValidationFailure[] failures = new ValidationFailure[size]; int i = 0; for (ConstraintViolation<?> violation : violationSet) { failures[i++] = createValidationFailure(violation, valueSource); } return new ComposedValidationFailure(getCode(), valueSource, failures); } return null; }
@NotNull public String create() { append("# GENERATED FILE. DO NOT EDIT.\n"); append(readCmakeLibraryFunctions()); for (Coordinate coordinate : table.orderOfReferences) { StatementExpression findFunction = table.getFindFunction(coordinate); indent = 0; visit(findFunction); require(indent == 0); } append("\nfunction(add_all_cdep_dependencies target)\n"); for (Coordinate coordinate : table.orderOfReferences) { StatementExpression findFunction = table.getFindFunction(coordinate); FindModuleExpression finder = getFindFunction(findFunction); String function = getAddDependencyFunctionName(finder.coordinate); append(" %s(${target})\n", function); } append("endfunction(add_all_cdep_dependencies)\n"); return sb.toString(); }
static int quantize(double value) { if (value <= 1) { return 1; } int exp = MathUtil.orderOf(value); double order = Math.pow(10, exp); double normalizedValue = value / order; if (normalizedValue <= 1) { normalizedValue = 1; } else if (normalizedValue <= 2) { normalizedValue = 2; } else if (normalizedValue <= 5) { normalizedValue = 5; } else if (normalizedValue <= 10) { normalizedValue = 10; } else { throw new IllegalStateException("Logic error: this should be unreachable"); } return (int) (normalizedValue * order); }
@Override public double rate( OvernightAveragedRateComputation computation, LocalDate startDate, LocalDate endDate, RatesProvider provider) { OvernightIndexRates rates = provider.overnightIndexRates(computation.getIndex()); LocalDate valuationDate = rates.getValuationDate(); LocalDate startFixingDate = computation.getStartDate(); LocalDate startPublicationDate = computation.calculatePublicationFromFixing(startFixingDate); if (valuationDate.isBefore(startPublicationDate)) { return rateForward(computation, rates); } ObservationDetails details = new ObservationDetails(computation, rates); return details.calculateRate(); }
public static boolean isStrictPassword(final String password) { if (password != null) { return password.matches("^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\d!@#$%^&*\\s\\(\\)_\\+=-]{8,}$"); } return false; }
public static Path createUniqueDir(Path parentDir, long sequence) throws IOException { Files.createDirectories(parentDir); while (true) { Path path = parentDir.resolve(Long.toString(sequence)); try { return Files.createDirectory(path); } catch (FileAlreadyExistsException e) { sequence++; } } }
public String format(String raw) throws Exception { raw = formatComments(raw); IDocument doc = new Document(raw); TextEdit edit = formatter.format(CodeFormatter.K_JAVASCRIPT_UNIT, raw, 0, raw.length(), 0, LINE_DELIMITER); if (edit == null) { throw new IllegalArgumentException("Invalid JavaScript syntax for formatting."); } else { edit.apply(doc); } return doc.get(); }
@NonNull @Override public ActionHandle then(@Nullable ResultListener<R> listener) { final R result = mResult; final ResourceCleaner<R> cleaner = mCleaner; mResult = null; if (listener != null) { listener.onResult(result); } else if (cleaner != null && result != null) { cleaner.clean(result); } mResult = null; mCleaner = null; return this; }
@Transactional public List<Budget> delete(List<Budget> budgets, final BindingResult errors, final RequestInfo requestInfo) { try { validate(budgets, ACTION_DELETE, errors); if (errors.hasErrors()) throw new CustomBindException(errors); } catch (final CustomBindException e) { throw new CustomBindException(errors); } return budgetRepository.delete(budgets, requestInfo); }
@Override public void rollback() throws SQLException { if (isTransActionAlive()) { getTransaction().rollback(); } }
public long getTimeout() { return timeout; }
@Override protected void executeInternal( ApplicationContext context, JobKey jobKey, Map<String, Object> configuration) { String url = configuration.get(PARAM_URL).toString(); boolean enableSslVerify = isSslVerificationEnabled(configuration); CredentialsProvider credentialsProvider = configureBasicAuthentication(configuration); HttpClientContext clientContext = configureContext(credentialsProvider, url); HashMap<String, Object> data = new HashMap<>(); List<String> errors = new ArrayList<>(); try (CloseableHttpClient httpClient = configureHttpClient(enableSslVerify)) { HttpGet httpGet = new HttpGet(url); CloseableHttpResponse response; if (clientContext != null) { response = httpClient.execute(httpGet, clientContext); } else { response = httpClient.execute(httpGet); } data.put(PARAM_STATUS, response.getStatusLine().getStatusCode()); if (response.getEntity() != null) { data.put(PARAM_CONTENT, IOUtils.toString(response.getEntity().getContent())); } else { data.put(PARAM_CONTENT, response.getStatusLine().getReasonPhrase()); } } catch (SSLHandshakeException e) { String msg = logConnectionError( "Could not establish SSL connection to '%s'. '%s' is set to '%s'. Cause: '%s'", url, enableSslVerify, e); errors.add(msg); } catch (HttpHostConnectException e) { String msg = logConnectionError( "Could not establish connection to '%s'. '%s' is set to '%s'. Cause: '%s'", url, enableSslVerify, e); errors.add(msg); } catch (UnknownHostException e) { String msg = String.format("Could not establish connection to unknown host '%s'", e.getMessage()); errors.add(msg); LOG.error(msg); } catch (IOException e) { String msg = String.format("could not fetch url '%s'", url); errors.add(msg); LOG.error(msg, e); } if (!errors.isEmpty()) { data.put(PARAM_ERRORS, errors); } upsertResults(context, jobKey, data); }
@OnTransit public void onInstanceHardRebooting(@Event InstanceHardRebootingEvent event) { Instance instance = event.getInstance(); String cloudId = instance.getCloudId(); Cloud cloud = cloudConfigurationProvider.getCloud(cloudId); LOG.info("Hard rebooting cloud {} instance {}", cloudId, instance.getId()); if (event.isSync() || operationProcessor.supply(cloud, OperationType.HARD_REBOOT_INSTANCE, () -> instance)) { instance.setState(InstanceState.HARD_REBOOTING); } else { throw new RuntimeException(String.format("Failed to hard reboot %s", instance)); } instancesAware.saveInstance(instance); }
public static String join(String separator, Collection<? extends Object> objects) { String s; if (objects == null || objects.isEmpty()) { s = EMPTY; } else if (objects.size() == 1) { s = objects.iterator().next().toString(); } else { s = join(new StringBuilder(), separator, objects).toString(); } return s; }
public BooleanExp and(NestedExp exp) { return new BooleanExp("(" + code + " && " + exp.getCode() + ")"); }
@Override public Element getElement() { assert element != null : "getElement() must not be called before the element has been set"; return element; }
@SuppressWarnings("SameReturnValue") public static String retrieveResourceIdResolverBeanName( BeanDefinitionRegistry registry) { registerResourceIdResolverBeanIfNeeded(registry); return RESOURCE_ID_RESOLVER_BEAN_NAME; }
@Override @SuppressWarnings({"unchecked", "unused"}) public List<JSONObject> parse(byte[] msg) { JSONObject outputMessage = new JSONObject(); String toParse = ""; List<JSONObject> messages = new ArrayList<>(); try { toParse = new String(msg, getReadCharset()); _LOG.debug("Received message: {}", toParse); parseMessage(toParse, outputMessage); long timestamp = System.currentTimeMillis(); outputMessage.put("timestamp", System.currentTimeMillis()); outputMessage.put("original_string", toParse); messages.add(outputMessage); return messages; } catch (Exception e) { e.printStackTrace(); _LOG.error("Failed to parse: {}", toParse); return null; } }
public Map < String, RootCompositeType > build(XmlSchema xmlSchema) throws Xsd2ConverterException { log.debug("visit XML Schema started"); Map < String, RootCompositeType > rootComplexTypes = new LinkedHashMap < String, RootCompositeType >(); for (Entry < QName, XmlSchemaElement > entry : xmlSchema.getElements() .entrySet()) { if (entry.getValue().getSchemaType() instanceof XmlSchemaComplexType) { CobolAnnotations cobolAnnotations = new CobolAnnotations( entry.getValue()); XmlSchemaComplexType xsdComplexType = (XmlSchemaComplexType) entry .getValue().getSchemaType(); RootCompositeType compositeTypes = new RootCompositeType( cobolAnnotations.getCobolName()); String complexTypeName = getComplexTypeName(xsdComplexType); rootComplexTypes.put(complexTypeName, compositeTypes); visit(xsdComplexType, compositeTypes, complexTypeName); } } log.debug("visit XML Schema ended"); return rootComplexTypes; }
public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) { List<PartitionInfo> partitions = cluster.partitionsForTopic(topic); int numPartitions = partitions.size(); if (keyBytes == null) { int nextValue = nextValue(topic); List<PartitionInfo> availablePartitions = cluster.availablePartitionsForTopic(topic); if (availablePartitions.size() > 0) { int part = Utils.toPositive(nextValue) % availablePartitions.size(); return availablePartitions.get(part).partition(); } else { return Utils.toPositive(nextValue) % numPartitions; } } else { return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; } }
public Location getLocationById(String id) { return getLocationById(id, getLocationTableName()); }
static public Boolean evaluateSimpleSetPredicate(SimpleSetPredicate simpleSetPredicate, EvaluationContext context){ FieldName name = simpleSetPredicate.getField(); if(name == null){ throw new MissingAttributeException(simpleSetPredicate, PMMLAttributes.SIMPLESETPREDICATE_FIELD); } SimpleSetPredicate.BooleanOperator booleanOperator = simpleSetPredicate.getBooleanOperator(); if(booleanOperator == null){ throw new MissingAttributeException(simpleSetPredicate, PMMLAttributes.SIMPLESETPREDICATE_BOOLEANOPERATOR); } FieldValue value = context.evaluate(name); if(FieldValueUtil.isMissing(value)){ return null; } Array array = simpleSetPredicate.getArray(); if(array == null){ throw new MissingElementException(simpleSetPredicate, PMMLElements.SIMPLESETPREDICATE_ARRAY); } switch(booleanOperator){ case IS_IN: return value.isIn(simpleSetPredicate); case IS_NOT_IN: return !value.isIn(simpleSetPredicate); default: throw new UnsupportedAttributeException(simpleSetPredicate, booleanOperator); } }
@VisibleForTesting public ClusterManager getClusterManagerInstance(ClusterType clusterType, Configuration config) throws ClusterManagerInitilizationException { String clusterManagerClassName = CacheConfig.getClusterManagerClass(conf, clusterType); log.info("Initializing cluster manager : " + clusterManagerClassName); ClusterManager manager = null; try { Class clusterManagerClass = conf.getClassByName(clusterManagerClassName); Constructor constructor = clusterManagerClass.getConstructor(); manager = (ClusterManager) constructor.newInstance(); } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) { String errorMessage = String.format("Not able to initialize ClusterManager class : %s ", clusterManagerClassName); log.error(errorMessage); throw new ClusterManagerInitilizationException(errorMessage, ex); } return manager; }
@Override public EditableRepositoryGroup createRepositoryGroup(String id, String name) { return createRepositoryGroup(id, name, archivaConfiguration.getRepositoryBaseDir()); }
public <R> R executeFunction(ManagedTransactionFunction.Arg0<R> fn) throws Exception { return executeTransactionBlockInternal(() -> fn.apply()); }
@Override public void convert(Object source, Object target, String... tags) throws JTransfoException { try { doConvert(source, target, tags); } catch (IllegalAccessException iae) { throw new JTransfoException(accessExceptionMessage(), iae); } catch (IllegalArgumentException iae) { if (null != iae.getStackTrace() && iae.getStackTrace().length > 0) { String throwingClass = iae.getStackTrace()[0].getClassName(); if (throwingClass.startsWith("sun.reflect.") || iae.getMessage().contains("Can not set ")) { throw new JTransfoException(argumentExceptionMessage(), iae); } } throw new JTransfoException(accessExceptionMessage(), iae); } }
protected InputStream getConfigurationStream(final Properties props) { InputStream result = getConfigStreamFromProperties(props); if (result != null) { return result; } result = getConfigStreamFromProperties(System.getProperties()); if (result != null) { return result; } result = resourceClassLoader.getResourceAsStream(CONFIG_FILE_NAME); if (result != null) { return result; } return null; }
public Cookie decode(String header) { final int headerLen = checkNotNull(header, "header").length(); if (headerLen == 0) { return null; } CookieBuilder cookieBuilder = null; loop: for (int i = 0;;) { for (;;) { if (i == headerLen) { break loop; } char c = header.charAt(i); if (c == ',') { break loop; } else if (c == '\t' || c == '\n' || c == 0x0b || c == '\f' || c == '\r' || c == ' ' || c == ';') { i++; continue; } break; } int nameBegin = i; int nameEnd = i; int valueBegin = -1; int valueEnd = -1; if (i != headerLen) { keyValLoop: for (;;) { char curChar = header.charAt(i); if (curChar == ';') { nameEnd = i; valueBegin = valueEnd = -1; break keyValLoop; } else if (curChar == '=') { nameEnd = i; i++; if (i == headerLen) { valueBegin = valueEnd = 0; break keyValLoop; } valueBegin = i; int semiPos = header.indexOf(';', i); valueEnd = i = semiPos > 0 ? semiPos : headerLen; break keyValLoop; } else { i++; } if (i == headerLen) { nameEnd = headerLen; valueBegin = valueEnd = -1; break; } } } if (valueEnd > 0 && header.charAt(valueEnd - 1) == ',') { valueEnd--; } if (cookieBuilder == null) { DefaultCookie cookie = initCookie(header, nameBegin, nameEnd, valueBegin, valueEnd); if (cookie == null) { return null; } cookieBuilder = new CookieBuilder(cookie, header); } else { cookieBuilder.appendAttribute(nameBegin, nameEnd, valueBegin, valueEnd); } } return cookieBuilder.cookie(); }
@Override public DomainObject get() throws PromiseBrokenException, InterruptedException { try { ServiceResponse<DomainObject> serviceResponse = new ServiceResponse<>(); for (Future<TaskResult> futureResult : futureList) { TaskResult result = futureResult.get(); if (result == null) { throw new PromiseBrokenException("Task result is null"); } ServiceResponse<DomainObject> response = (ServiceResponse<DomainObject>) result.getData(); if (!response.getIsSuccess()) throw response.getException(); serviceResponse.addData(response.getDataList()); } if (responseMerger != null) { return responseMerger.mergeResponse(serviceResponse.getDataList()); } else { return serviceResponse.getDataList().get(0); } } catch (ExecutionException exception) { checkAndThrowServiceClientException(exception); checkAndThrowOriginalException(exception); throw new InterruptedException(exception.getMessage()); } catch (CancellationException exception) { throw new PromiseBrokenException(exception); } }
public Iterator<OfferLog> getListing(String strategy, DataCategory category, Long offset, Integer limit, Order order, int batchSize) { LOGGER.info(String.format( "[Reconstruction]: Retrieve listing of {%s} Collection on {%s} Vitam strategy from {%s} offset with {%s} limit", category, strategy, offset, limit)); return OfferLogHelper.getListing( storageClientFactory, strategy, category, offset, order, batchSize, limit); }
public static @Nullable FamilyResourceEntry parse(XmlPullParser parser, Resources resources) throws XmlPullParserException, IOException { int type; while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) { } if (type != XmlPullParser.START_TAG) { throw new XmlPullParserException("No start tag found"); } return readFamilies(parser, resources); }
static String extractMatchingContent(String string, Pattern pattern) { Matcher matcher = pattern.matcher(string); if (matcher.matches()) { return matcher.group(1); } return null; }
static List<Range> sort(List<Range> list) { RangeSorter sorter = new RangeSorter(list); sorter.sortRanges(); return sorter.ranges; }
@Nonnull public static DeleteAttributeLiveCommandImpl of(final Command<?> command) { return new DeleteAttributeLiveCommandImpl((DeleteAttribute) command); }
private static MonitorConfig newObjectConfig(Class<?> c, String id, TagList tags) { final MonitorConfig.Builder builder = MonitorConfig.builder(id); final String className = className(c); if (!className.isEmpty()) { builder.withTag("class", className); } if (tags != null) { builder.withTags(tags); } return builder.build(); }
@Override public synchronized ProgressStatusMirroringImpl createMirroringChild(int allocatedSteps) { allocateStapsForChildProcess(allocatedSteps); String childId = (id == null ? "" : id) + "." + (children.size() + 1); ProgressStatusMirroringImpl result = new ProgressStatusMirroringImpl(null, this, childId); children.add(new ChildProgressStatus(allocatedSteps, result)); fireEvent(new ProgressStatusEventCreateChild(id, null, result.getId(), allocatedSteps, -1)); return result; }
@Override public boolean onCommand(CommonSender sender, CommandParser parser) { final boolean isSilent = parser.isSilent(); if (isSilent && !sender.hasPermission(getPermission() + ".silent")) { sender.sendMessage(Message.getString("sender.error.noPermission")); return true; } if (parser.args.length < 2) { return false; } if (parser.isInvalidReason()) { Message.get("sender.error.invalidReason") .set("reason", parser.getReason().getMessage()) .sendTo(sender); return true; } if (parser.args[0].equalsIgnoreCase(sender.getName())) { sender.sendMessage(Message.getString("sender.error.noSelf")); return true; } final String ipStr = parser.args[0]; final boolean isName = !IPUtils.isValid(ipStr); if (isName && ipStr.length() > 16) { Message message = Message.get("sender.error.invalidIp"); message.set("ip", ipStr); sender.sendMessage(message.toString()); return true; } if (isName) { CommonPlayer onlinePlayer = getPlugin().getServer().getPlayer(ipStr); if (onlinePlayer != null && !sender.hasPermission("bm.exempt.override.banip") && onlinePlayer.hasPermission("bm.exempt.banip")) { Message.get("sender.error.exempt").set("player", onlinePlayer.getName()).sendTo(sender); return true; } } getPlugin().getScheduler().runAsync(() -> { final IPAddress ip = getIp(ipStr); if (ip == null) { sender.sendMessage(Message.get("sender.error.notFound").set("player", ipStr).toString()); return; } final boolean isBanned = getPlugin().getIpBanStorage().isBanned(ip); if (isBanned && !sender.hasPermission("bm.command.banip.override")) { Message message = Message.get("banip.error.exists"); message.set("ip", ipStr); sender.sendMessage(message.toString()); return; } try { if (getPlugin().getIpBanStorage().isRecentlyBanned(ip, getCooldown())) { Message.get("banip.error.cooldown").sendTo(sender); return; } } catch (SQLException e) { sender.sendMessage(Message.get("sender.error.exception").toString()); e.printStackTrace(); return; } final PlayerData actor = sender.getData(); if (isBanned) { IpBanData ban = getPlugin().getIpBanStorage().getBan(ip); if (ban != null) { try { getPlugin().getIpBanStorage().unban(ban, actor); } catch (SQLException e) { sender.sendMessage(Message.get("sender.error.exception").toString()); e.printStackTrace(); return; } } } final IpBanData ban = new IpBanData(ip, actor, parser.getReason().getMessage(), isSilent); boolean created; try { created = getPlugin().getIpBanStorage().ban(ban); } catch (SQLException e) { handlePunishmentCreateException(e, sender, Message.get("banip.error.exists").set("ip", ipStr)); return; } if (!created) { return; } getPlugin().getScheduler().runSync(() -> { Message kickMessage = Message.get("banip.ip.kick") .set("reason", ban.getReason()) .set("actor", actor.getName()); for (CommonPlayer onlinePlayer : getPlugin().getServer().getOnlinePlayers()) { if (IPUtils.toIPAddress(onlinePlayer.getAddress()).equals(ip)) { onlinePlayer.kick(kickMessage.toString()); } } }); }); return true; }
@Override public List<ReplaceEntity> getReplacements(ScriptStep step, String searchQuery, String replaceString, SearchMode searchMode) { return getReplacementInValue(searchQuery, replaceString, step.getLoggingKey(), step.getType()); }
@Override public Response convert(SwaggerInvocation swaggerInvocation, InvocationException e) { return Response.failResp(e); }
@NonNull @Override public ActionHandle then(@Nullable ResultListener<R> listener) { final R result = mResult; final ResourceCleaner<R> cleaner = mCleaner; mResult = null; if (listener != null) { listener.onResult(result); } else if (cleaner != null && result != null) { cleaner.clean(result); } mResult = null; mCleaner = null; return this; }
public SpaceReference createSpaceReference(String spaceName, WikiReference parent) { return new SpaceReference(spaceName, parent); }
public static List<Map<String, Object>> parseTasks(InputStream in, String frameworkId) throws IOException { ObjectMapper mapper = new ObjectMapper(); List<Map<String, Object>> ret = new ArrayList<>(); Map<String, List<Map<String, Object>>> map = mapper.readValue(in, Map.class); List<Map<String, Object>> tasks = map.get("tasks"); for (Map<String, Object> task : tasks) { String fid = (String) task.get("framework_id"); if (!frameworkId.equals(fid)) { continue; } ret.add(task); } return ret; }
@VisibleForTesting void globalUpdates(String args, SchedConfUpdateInfo updateInfo) { if (args == null) { return; } HashMap<String, String> globalUpdates = new HashMap<>(); for (String globalUpdate : args.split(",")) { putKeyValuePair(globalUpdates, globalUpdate); } updateInfo.setGlobalParams(globalUpdates); }
public ClassMapping create(Class<?> entityClass) { long start = System.currentTimeMillis(); String entityName = reflections.getEntityName(entityClass); List<FieldMapping> fields = reflections.getFields(entityClass) .stream().map(this::to).collect(toList()); List<String> fieldsName = fields.stream().map(FieldMapping::getName).collect(toList()); Map<String, NativeMapping> nativeFieldGroupByJavaField = getNativeFieldGroupByJavaField(fields, "", ""); Map<String, FieldMapping> fieldsGroupedByName = fields.stream() .collect(collectingAndThen(toMap(FieldMapping::getName, Function.identity()), Collections::unmodifiableMap)); InstanceSupplier instanceSupplier = instanceSupplierFactory.apply(reflections.makeAccessible(entityClass)); ClassMapping mapping = DefaultClassMapping.builder().withName(entityName) .withClassInstance(entityClass) .withFields(fields) .withFieldsName(fieldsName) .withInstanceSupplier(instanceSupplier) .withJavaFieldGroupedByColumn(nativeFieldGroupByJavaField) .withFieldsGroupedByName(fieldsGroupedByName) .build(); long end = System.currentTimeMillis() - start; LOGGER.info(String.format("Scanned %s loaded with time %d ms", entityClass.getName(), end)); return mapping; }
@Deprecated public static ClientQueryAggregatedField aggregatedField(ClientDataSourceField field, String aggregateExpression) { return new ClientQueryAggregatedField() .setDataSourceField(field) .setExpressionContainer(new ClientExpressionContainer(aggregateExpression)); }
@Override public T apply(BufferedReader json) { return gson.fromJson(json,getType()); }
TabShownHandler getTabShownHandler() { return event -> { onResize(); final TabListItem tab = event.getTab(); final TabPanelEntry tabPanelEntry = findEntryForTabWidget(tab); final PageViewImpl page = (PageViewImpl) tabPanelEntry.getContentPane().getWidget(0); getSelectedPageEvent().ifPresent(selectedPageEvent -> { selectedPageEvent.fire(new MultiPageEditorSelectedPageEvent(tab.getTabIndex())); }); page.onLostFocus(); }; }
public static KafkaBridgeCluster fromCrd(KafkaBridge kafkaBridge, KafkaVersion.Lookup versions) { KafkaBridgeCluster kafkaBridgeCluster = new KafkaBridgeCluster(kafkaBridge); KafkaBridgeSpec spec = kafkaBridge.getSpec(); kafkaBridgeCluster.tracing = spec.getTracing(); kafkaBridgeCluster.setResources(spec.getResources()); kafkaBridgeCluster.setLogging(spec.getLogging()); kafkaBridgeCluster.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled()); if (spec.getJvmOptions() != null) { kafkaBridgeCluster.setJavaSystemProperties(spec.getJvmOptions().getJavaSystemProperties()); } String image = spec.getImage(); if (image == null) { image = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_KAFKA_BRIDGE_IMAGE, "strimzi/kafka-bridge:latest"); } kafkaBridgeCluster.setImage(image); kafkaBridgeCluster.setReplicas(spec.getReplicas()); kafkaBridgeCluster.setBootstrapServers(spec.getBootstrapServers()); kafkaBridgeCluster.setKafkaConsumerConfiguration(spec.getConsumer()); kafkaBridgeCluster.setKafkaProducerConfiguration(spec.getProducer()); if (kafkaBridge.getSpec().getLivenessProbe() != null) { kafkaBridgeCluster.setLivenessProbe(kafkaBridge.getSpec().getLivenessProbe()); } if (kafkaBridge.getSpec().getReadinessProbe() != null) { kafkaBridgeCluster.setReadinessProbe(kafkaBridge.getSpec().getReadinessProbe()); } kafkaBridgeCluster.setMetricsEnabled(spec.getEnableMetrics()); kafkaBridgeCluster.setTls(spec.getTls() != null ? spec.getTls() : null); AuthenticationUtils.validateClientAuthentication(spec.getAuthentication(), spec.getTls() != null); kafkaBridgeCluster.setAuthentication(spec.getAuthentication()); if (spec.getTemplate() != null) { KafkaBridgeTemplate template = spec.getTemplate(); if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) { kafkaBridgeCluster.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels(); kafkaBridgeCluster.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations(); } ModelUtils.parsePodTemplate(kafkaBridgeCluster, template.getPod()); if (template.getApiService() != null && template.getApiService().getMetadata() != null) { kafkaBridgeCluster.templateServiceLabels = Util.mergeLabelsOrAnnotations(template.getApiService().getMetadata().getLabels(), ModelUtils.getCustomLabelsOrAnnotations(CO_ENV_VAR_CUSTOM_LABELS)); kafkaBridgeCluster.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations(); } if (template.getBridgeContainer() != null && template.getBridgeContainer().getEnv() != null) { kafkaBridgeCluster.templateContainerEnvVars = template.getBridgeContainer().getEnv(); } if (template.getBridgeContainer() != null && template.getBridgeContainer().getSecurityContext() != null) { kafkaBridgeCluster.templateContainerSecurityContext = template.getBridgeContainer().getSecurityContext(); } ModelUtils.parsePodDisruptionBudgetTemplate(kafkaBridgeCluster, template.getPodDisruptionBudget()); } if (spec.getHttp() != null) { kafkaBridgeCluster.setHttpEnabled(true); kafkaBridgeCluster.setKafkaBridgeHttpConfig(spec.getHttp()); } else { log.warn("No protocol specified."); throw new InvalidResourceException("No protocol for communication with Bridge specified. Use HTTP."); } kafkaBridgeCluster.setOwnerReference(kafkaBridge); return kafkaBridgeCluster; }
@Override public B2ListBucketsResponse listBuckets(B2AccountAuthorization accountAuth, B2ListBucketsRequest request) throws B2Exception { return webApiClient.postJsonReturnJson( makeUrl(accountAuth, "b2_list_buckets"), makeHeaders(accountAuth), request, B2ListBucketsResponse.class); }
@Override public WindowStore<K, V> build() { return new MeteredWindowStore<>(maybeWrapCaching(maybeWrapLogging(storeSupplier.get())), storeSupplier.metricsScope(), time, keySerde, valueSerde); }
@Override protected int getOxmFieldCode() { return OxmMatchConstants.TUNNEL_ID; }
@Override public List<String> listDataTypes() throws JargonException { log.info("listDataTypes()"); IRODSGenQueryBuilder builder = new IRODSGenQueryBuilder(true, null); IRODSQueryResultSet resultSet = null; try { builder.addSelectAsGenQueryValue(RodsGenQueryEnum.COL_TOKEN_NAME); builder.addConditionAsGenQueryField(RodsGenQueryEnum.COL_TOKEN_NAMESPACE, QueryConditionOperators.EQUAL, "data_type"); IRODSGenQueryFromBuilder irodsQuery = builder .exportIRODSQueryFromBuilder(getJargonProperties().getMaxFilesAndDirsQueryMax()); resultSet = irodsGenQueryExecutor.executeIRODSQueryAndCloseResult(irodsQuery, 0); final List<String> types = new ArrayList<>(); for (IRODSQueryResultRow row : resultSet.getResults()) { types.add(row.getColumn(0)); } return types; } catch (JargonQueryException e) { log.error("query exception for query", e); throw new JargonException("error in query for data types", e); } catch (GenQueryBuilderException e) { log.error("query exception for query", e); throw new JargonException("error in query for data types", e); } }
@Override @SuppressWarnings({ "unchecked", "rawtypes" }) public <G extends Genotype> G newInstance() { try { Constructor<? extends DoubleMapGenotype> cstr = this.getClass().getConstructor(List.class, Bounds.class); return (G) cstr.newInstance(keys, bounds); } catch (Exception e) { throw new RuntimeException(e); } }
public Expiration guess(String maybeIso) { for (Map.Entry<Expiration, List<String>> value : patterns.entrySet()) { for (String pattern : value.getValue()) { if (checkIfPatternMatch.apply(pattern, maybeIso).isPresent()) { return value.getKey(); } } } return Expiration.EXPRESSION; }
public boolean matches(T target) { return target.isVisibleTo(typeDescription); }
@Override public boolean equals(Object objectToCompare) { if (this == objectToCompare) { return true; } if (!(objectToCompare instanceof SchemaImplementationQuery)) { return false; } SchemaImplementationQuery that = (SchemaImplementationQuery) objectToCompare; return Objects.equals(getQueryId(), that.getQueryId()) && Objects.equals(getQuery(), that.getQuery()) && Objects.equals(getQueryType(), that.getQueryType()) && Objects.equals(getQueryTargetGUID(), that.getQueryTargetGUID()); }
public static RangePredicate<?> range( int propertyKeyId, Number from, boolean fromInclusive, Number to, boolean toInclusive ) { return new NumberRangePredicate( propertyKeyId, from == null ? null : Values.numberValue( from ), fromInclusive, to == null ? null : Values.numberValue( to ), toInclusive ); }
@Override public int compare(T m1, T m2) { return m1.getName().compareTo(m2.getName()); }
@Override public CurrencyExchange convert(YahooQuote yahooQuote) { CurrencyExchange currencyExchange = currencyExchangeRepository.findOne(yahooQuote.getId()); if(currencyExchange == null){ currencyExchange = new CurrencyExchange(); currencyExchange.setId(yahooQuote.getId()); } currencyExchange.setName(yahooQuote.getName()); currencyExchange.setBid(BigDecimal.valueOf(yahooQuote.getBid())); currencyExchange.setAsk(BigDecimal.valueOf(yahooQuote.getAsk())); currencyExchange.setDailyLatestChange(BigDecimal.valueOf(yahooQuote.getLastChange())); currencyExchange.setDailyLatestChangePercent(BigDecimal.valueOf(yahooQuote.getLastChangePercent())); currencyExchange.setDailyLatestValue(BigDecimal.valueOf(yahooQuote.getLast())); currencyExchange.setPreviousClose(BigDecimal.valueOf(yahooQuote.getPreviousClose())); currencyExchange.setOpen(BigDecimal.valueOf(yahooQuote.getOpen())); return currencyExchange; }
@Override public void customize() { List<Server> servers = fraction.subresources().servers(); servers.stream() .filter(e -> e instanceof EnhancedServer) .forEach(server -> { ((EnhancedServer) server).remoteConnections() .forEach(connection -> { server.remoteConnector(connection.name(), connector -> { connector.socketBinding(connection.name()); }); server.pooledConnectionFactory(connection.name(), factory -> { factory.connectors(connection.name()); factory.entry(connection.jndiName()); }); }); }); }
public void init() { init(Preconditions.checkNotNull(Strings.emptyToNull(directoryFlag.get()))); }
public void putInt(long index, int value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addInt(getPageOffset(index), value); numProperties += page.getSize() - n; }
@VisibleForTesting void setFunctionsToExclude(String functionsToExclude) { this.functionsToExclude = functionsToExclude; }
@Override public double statistics(Stats name) { switch ((StatsNum) name) { case MAX: if (Double.isInfinite(maximum)) { recalculate(); } return maximum; case MIN: if (Double.isInfinite(minimum)) { recalculate(); } return minimum; case RANGE: if (Double.isInfinite(minimum) || Double.isInfinite(maximum)) { recalculate(); } return maximum - minimum; case AVG: case MEAN: return avg(); case VARIANCE: return stdUnbiased(); case SUM: return sum; case BVAR: return stdBiased(); case SQSUM: return squaredSum; case STD_DEV: return Math.sqrt(stdUnbiased()); case STD_BIA: return Math.sqrt(stdBiased()); case ABS_DEV: if (Double.isNaN(absdev)) { absdev = absDev(); } return absdev; case Q1: if (Double.isNaN(q1)) { computeQuartiles(); } return q1; case Q2: case MEDIAN: if (Double.isNaN(median)) { computeQuartiles(); } return median; case Q3: if (Double.isNaN(q3)) { computeQuartiles(); } return q3; case QCD: if (Double.isNaN(q3) || Double.isNaN(q1)) { computeQuartiles(); } return (q3 - q1) / (q3 + q1); } throw new RuntimeException("unknown statistics " + name); }
public Set<CIString> getNewValues(final AttributeType attributeType) { final Set<CIString> newValues = updatedObject.getValuesForAttribute(attributeType); if (originalObject != null) { newValues.removeAll(originalObject.getValuesForAttribute(attributeType)); } return newValues; }
public static FileOutputStream openOutputStream(File file, boolean append) throws IOException { if (file.exists()) { if (file.isDirectory()) { throw new IOException("File '" + file + "' exists but is a directory"); } if (!file.canWrite()) { throw new IOException("File '" + file + "' cannot be written to"); } } else { File parent = file.getParentFile(); if (parent != null) { if (!parent.mkdirs() && !parent.isDirectory()) { throw new IOException("Directory '" + parent + "' could not be created"); } } } return new FileOutputStream(file, append); }
public static int ones(int d1, int d2, int d3, int d4, int d5) { int sum = 0; if (d1 == 1) sum++; if (d2 == 1) sum++; if (d3 == 1) sum++; if (d4 == 1) sum++; if (d5 == 1) sum++; return sum; }
public void setReportProcessor( final PageableReportProcessor proc ) { this.proc = proc; }
@Override public void clear() { themes.clear(); updateThemeAttribute(); }
public Mono<Task.Result> fixMessageInconsistencies(Context context, RunningOptions runningOptions) { return Flux.concat( fixInconsistenciesInMessageId(context, runningOptions), fixInconsistenciesInImapUid(context, runningOptions)) .reduce(Task.Result.COMPLETED, Task::combine); }
public static String formatValues(String name, String value) { return Ansi.ansi().a(" ").a(Ansi.Attribute.INTENSITY_BOLD).a(name) .a(spaces(padding - name.length())).a(Ansi.Attribute.RESET).a(" ").a(value).toString(); }
public Map<Collection<T>, T> createResult() { for(T node : nodes) { clusterAssignment.put(node, Q.toSet(node)); } if(log) { printNodes(); } Map<Set<T>, Map<Set<T>, Pair<Double, Double>>> clusterEdges = new HashMap<>(); for(Triple<T, T, Double> e : positiveEdges) { Pair<Double,Double> scores = new Pair<Double, Double>(e.getThird(), 0.0); Map<Set<T>, Pair<Double, Double>> map2 = MapUtils.get(clusterEdges, clusterAssignment.get(e.getFirst()), new HashMap<>()); map2.put(clusterAssignment.get(e.getSecond()), scores); map2 = MapUtils.get(clusterEdges, clusterAssignment.get(e.getSecond()), new HashMap<>()); map2.put(clusterAssignment.get(e.getFirst()), scores); } for(Triple<T, T, Double> e : negativeEdges) { Map<Set<T>, Pair<Double, Double>> map2 = MapUtils.get(clusterEdges, clusterAssignment.get(e.getFirst()), new HashMap<>()); Pair<Double,Double> scores = MapUtils.get(map2, clusterAssignment.get(e.getSecond()), new Pair<>(0.0,0.0)); scores = new Pair<Double, Double>(scores.getFirst(), e.getThird()); map2.put(clusterAssignment.get(e.getSecond()), scores); map2 = MapUtils.get(clusterEdges, clusterAssignment.get(e.getSecond()), new HashMap<>()); map2.put(clusterAssignment.get(e.getFirst()), scores); } while(true) { Triple<Set<T>, Set<T>, Pair<Double, Double>> bestEdge = getMaxPositiveEdgeSatisfyingThreshold(clusterEdges); if(bestEdge==null) { break; } if(log) { logger.info(String.format("merge {%s} and {%s}", StringUtils.join(bestEdge.getFirst(), ","), StringUtils.join(bestEdge.getSecond(), ","))); } Set<T> mergedPartition = Q.union(bestEdge.getFirst(), bestEdge.getSecond()); for(T n : mergedPartition) { clusterAssignment.put(n, mergedPartition); } updateEdges(clusterEdges, bestEdge, mergedPartition); removeAllEdges(bestEdge, clusterEdges); } Map<Collection<T>, T> result = new HashMap<>(); for(Collection<T> cluster : clusterAssignment.values()) { result.put(cluster, null); } return result; }
public static Color fromRGB(int red, int green, int blue) throws IllegalArgumentException { return new Color(red, green, blue); }
public void setRetryContext(int maxRetries, int retryInterval, long failuresValidityInterval) { ContainerRetryContext retryContext = ContainerRetryContext .newInstance(ContainerRetryPolicy.RETRY_ON_ALL_ERRORS, null, maxRetries, retryInterval, failuresValidityInterval); containerLaunchContext.setContainerRetryContext(retryContext); }
@VisibleForTesting static List<String> tokenizeArguments(@Nullable final String args) { if (args == null) { return Collections.emptyList(); } final Matcher matcher = ARGUMENTS_TOKENIZE_PATTERN.matcher(args); final List<String> tokens = new ArrayList<>(); while (matcher.find()) { tokens.add(matcher.group() .trim() .replace("\"", "") .replace("\'", "")); } return tokens; }
public boolean overlap(final Window other) throws IllegalArgumentException { if (getClass() != other.getClass()) { throw new IllegalArgumentException("Cannot compare windows of different type. Other window has type " + other.getClass() + "."); } final SessionWindow otherWindow = (SessionWindow) other; return !(otherWindow.endMs < startMs || endMs < otherWindow.startMs); }
public static BigInteger decodeQuantity(String value) { if (!isValidHexQuantity(value)) { throw new MessageDecodingException("Value must be in format 0x[1-9]+[0-9]* or 0x0"); } try { return new BigInteger(value.substring(2), 16); } catch (NumberFormatException e) { throw new MessageDecodingException("Negative ", e); } }
public void ensureOwnerPermissions() throws TaskPermissionsException { if (!Boolean.getBoolean(Sejda.UNETHICAL_READ_PROPERTY_NAME) && !permissions.isOwnerPermission()) { throw new TaskPermissionsException("Owner permission is required."); } }
public void unpack(CharSequence data) throws IllegalArgumentException { if (data == null) throw new IllegalArgumentException("TLV data are required to unpack"); CharBuffer buffer = CharBuffer.wrap(data); CharTag currentTag; while (buffer.hasRemaining()) { currentTag = getTLVMsg(buffer); put(currentTag.getTagId(), currentTag); } }
@Override public boolean equals(@Nullable Object obj) { if (this == obj) { return true; } if (!(obj instanceof HaGroupPool)) { return false; } HaGroupPool rhs = (HaGroupPool) obj; return _name.equals(rhs._name) && Objects.equals(_weight, rhs._weight); }
public List<? extends TextEdit> format(TextDocument textDocument, Range range, SharedSettings sharedSettings) { try { XMLFormatterDocument formatterDocument = new XMLFormatterDocument(textDocument, range, sharedSettings); return formatterDocument.format(); } catch (BadLocationException e) { LOGGER.log(Level.SEVERE, "Formatting failed due to BadLocation", e); } return null; }
public static String readUntilNull(ByteBuffer buffer) { StringBuilder sb = new StringBuilder(buffer.remaining()); while (buffer.hasRemaining()) { byte b = buffer.get(); if (b == Constants.NULL) { return sb.toString(); } sb.append((char) b); } throw new IllegalArgumentException("End of buffer reached before NULL"); }
@SuppressWarnings("unchecked") @VisibleForTesting void handleNMContainerStatus(NMContainerStatus containerStatus, NodeId nodeId) { ApplicationAttemptId appAttemptId = containerStatus.getContainerId().getApplicationAttemptId(); RMApp rmApp = rmContext.getRMApps().get(appAttemptId.getApplicationId()); if (rmApp == null) { LOG.error("Received finished container : " + containerStatus.getContainerId() + " for unknown application " + appAttemptId.getApplicationId() + " Skipping."); return; } if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) { if (LOG.isDebugEnabled()) { LOG.debug("Ignoring container completion status for unmanaged AM " + rmApp.getApplicationId()); } return; } RMAppAttempt rmAppAttempt = rmApp.getRMAppAttempt(appAttemptId); Container masterContainer = rmAppAttempt.getMasterContainer(); if (masterContainer.getId().equals(containerStatus.getContainerId()) && containerStatus.getContainerState() == ContainerState.COMPLETE) { ContainerStatus status = ContainerStatus.newInstance(containerStatus.getContainerId(), containerStatus.getContainerState(), containerStatus.getDiagnostics(), containerStatus.getContainerExitStatus()); RMAppAttemptContainerFinishedEvent evt = new RMAppAttemptContainerFinishedEvent(appAttemptId, status, nodeId); rmContext.getDispatcher().getEventHandler().handle(evt); } }
public static String normalizeFormName(String formName, boolean returnNullIfNothingChanged) { if (formName == null) { return null; } Matcher matcher = CONTROL_CHAR_PATTERN.matcher(formName); return matcher.find() ? matcher.replaceAll(" ") : (returnNullIfNothingChanged ? null : formName); }
PathAttributeConfiguration parseConfiguration(HierarchicalConfiguration config) throws ConfigurationException { PathAttributeConfigurationImpl result = new PathAttributeConfigurationImpl(); for(String key : stripKeys(config.getKeys())) { parseConfiguration(config.configurationsAt(key), key, result); } return result; }
private RegionFactory getRegionFactory(Cache cache, RegionAttributesType regionAttributes) { RegionFactory factory = cache.createRegionFactory(); factory.setDataPolicy(DataPolicy.fromString(regionAttributes.getDataPolicy().name())); if (regionAttributes.getScope() != null) { factory.setScope(Scope.fromString(regionAttributes.getScope().name())); } if (regionAttributes.getCacheLoader() != null) { ((RegionFactory<Object, Object>) factory) .setCacheLoader(DeclarableTypeInstantiator.newInstance(regionAttributes.getCacheLoader(), cache)); } if (regionAttributes.getCacheWriter() != null) { ((RegionFactory<Object, Object>) factory) .setCacheWriter(DeclarableTypeInstantiator.newInstance(regionAttributes.getCacheWriter(), cache)); } if (regionAttributes.getCacheListeners() != null) { List<DeclarableType> configListeners = regionAttributes.getCacheListeners(); CacheListener[] listeners = new CacheListener[configListeners.size()]; for (int i = 0; i < configListeners.size(); i++) { listeners[i] = DeclarableTypeInstantiator.newInstance(configListeners.get(i), cache); } ((RegionFactory<Object, Object>) factory).initCacheListeners(listeners); } final String keyConstraint = regionAttributes.getKeyConstraint(); final String valueConstraint = regionAttributes.getValueConstraint(); if (keyConstraint != null && !keyConstraint.isEmpty()) { Class<Object> keyConstraintClass = ManagementUtils.forName(keyConstraint, CliStrings.CREATE_REGION__KEYCONSTRAINT); ((RegionFactory<Object, Object>) factory).setKeyConstraint(keyConstraintClass); } if (valueConstraint != null && !valueConstraint.isEmpty()) { Class<Object> valueConstraintClass = ManagementUtils.forName(valueConstraint, CliStrings.CREATE_REGION__VALUECONSTRAINT); ((RegionFactory<Object, Object>) factory).setValueConstraint(valueConstraintClass); } if (regionAttributes.getCompressor() != null) { ((RegionFactory<Object, Object>) factory) .setCompressor(DeclarableTypeInstantiator.newInstance(regionAttributes.getCompressor())); } if (regionAttributes.getPartitionAttributes() != null) { factory.setPartitionAttributes( convertToRegionFactoryPartitionAttributes(regionAttributes.getPartitionAttributes(), cache)); } if (regionAttributes.getEntryIdleTime() != null) { RegionAttributesType.ExpirationAttributesType eitl = regionAttributes.getEntryIdleTime(); ((RegionFactory<Object, Object>) factory).setEntryIdleTimeout( new ExpirationAttributes(Integer.valueOf(eitl.getTimeout()), ExpirationAction.fromXmlString(eitl.getAction()))); if (eitl.getCustomExpiry() != null) { ((RegionFactory<Object, Object>) factory).setCustomEntryIdleTimeout( DeclarableTypeInstantiator.newInstance(eitl.getCustomExpiry(), cache)); } } if (regionAttributes.getEntryTimeToLive() != null) { RegionAttributesType.ExpirationAttributesType ettl = regionAttributes.getEntryTimeToLive(); ((RegionFactory<Object, Object>) factory).setEntryTimeToLive( new ExpirationAttributes(Integer.valueOf(ettl.getTimeout()), ExpirationAction.fromXmlString(ettl.getAction()))); if (ettl.getCustomExpiry() != null) { ((RegionFactory<Object, Object>) factory) .setCustomEntryTimeToLive(DeclarableTypeInstantiator.newInstance(ettl.getCustomExpiry(), cache)); } } if (regionAttributes.getRegionIdleTime() != null) { RegionAttributesType.ExpirationAttributesType ritl = regionAttributes.getRegionIdleTime(); ((RegionFactory<Object, Object>) factory).setRegionIdleTimeout( new ExpirationAttributes(Integer.valueOf(ritl.getTimeout()), ExpirationAction.fromXmlString(ritl.getAction()))); } if (regionAttributes.getRegionTimeToLive() != null) { RegionAttributesType.ExpirationAttributesType rttl = regionAttributes.getRegionTimeToLive(); ((RegionFactory<Object, Object>) factory).setRegionTimeToLive( new ExpirationAttributes(Integer.valueOf(rttl.getTimeout()), ExpirationAction.fromXmlString(rttl.getAction()))); } if (regionAttributes.getEvictionAttributes() != null) { try { factory.setEvictionAttributes( EvictionAttributesImpl.fromConfig(regionAttributes.getEvictionAttributes())); } catch (Exception e) { throw new IllegalArgumentException( CliStrings.CREATE_REGION__MSG__OBJECT_SIZER_MUST_BE_OBJECTSIZER_AND_DECLARABLE); } } if (regionAttributes.getDiskStoreName() != null) { factory.setDiskStoreName(regionAttributes.getDiskStoreName()); } if (regionAttributes.isDiskSynchronous() != null) { factory.setDiskSynchronous(regionAttributes.isDiskSynchronous()); } if (regionAttributes.isOffHeap() != null) { factory.setOffHeap(regionAttributes.isOffHeap()); } if (regionAttributes.isStatisticsEnabled() != null) { factory.setStatisticsEnabled(regionAttributes.isStatisticsEnabled()); } if (regionAttributes.isEnableAsyncConflation() != null) { factory.setEnableAsyncConflation(regionAttributes.isEnableAsyncConflation()); } if (regionAttributes.isEnableSubscriptionConflation() != null) { factory.setEnableSubscriptionConflation(regionAttributes.isEnableSubscriptionConflation()); } if (regionAttributes.getGatewaySenderIds() != null) { Arrays.stream(regionAttributes.getGatewaySenderIds().split(",")) .forEach(gsi -> factory.addGatewaySenderId(gsi)); } if (regionAttributes.getAsyncEventQueueIds() != null) { Arrays.stream(regionAttributes.getAsyncEventQueueIds().split(",")) .forEach(gsi -> factory.addAsyncEventQueueId(gsi)); } factory.setConcurrencyChecksEnabled(regionAttributes.isConcurrencyChecksEnabled()); if (regionAttributes.getConcurrencyLevel() != null) { factory.setConcurrencyLevel(Integer.valueOf(regionAttributes.getConcurrencyLevel())); } if (regionAttributes.isCloningEnabled() != null) { factory.setCloningEnabled(regionAttributes.isCloningEnabled()); } if (regionAttributes.isMulticastEnabled() != null) { factory.setMulticastEnabled(regionAttributes.isMulticastEnabled()); } return factory; }
@Override public void populate(final AddressData source, final AddressModel target) throws ConversionException { super.populate(source, target); target.setEmail(source.getEmail()); }
public ListNode sortList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode fast = head.next; ListNode slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; } ListNode second = slow.next; slow.next = null; ListNode head1 = sortList(head); ListNode head2 = sortList(second); ListNode dummy = new ListNode(-1); ListNode node = dummy; while (head1 != null && head2 != null) { if (head1.val < head2.val) { node.next = head1; head1 = head1.next; } else { node.next = head2; head2 = head2.next; } node = node.next; } node.next = head1 != null ? head1 : head2; return dummy.next; }
@Override public ObjectOutput serialize(URL url, OutputStream out) throws IOException { return new FstObjectOutput(out); }
@Override public PublicContentSectionType getType() { return PublicContentSectionType.SUPPORTING_INFORMATION; }
@Override public String begin(String applicationId, String transactionServiceGroup, String name, int timeout) throws TransactionException { GlobalSession session = GlobalSession.createGlobalSession(applicationId, transactionServiceGroup, name, timeout); session.addSessionLifecycleListener(SessionHolder.getRootSessionManager()); session.begin(); eventBus.post(new GlobalTransactionEvent(session.getTransactionId(), GlobalTransactionEvent.ROLE_TC, session.getTransactionName(), session.getBeginTime(), null, session.getStatus())); return session.getXid(); }
@Override protected void onPinch(float ds, float dsx, float dsy) { if (mGestureListener != null) { mGestureListener.onPinch(this, ds, dsx, dsy); } }
public static void main(String[] args) { try (Scanner in = new Scanner(System.in)) { String potentialWord = in.nextLine(); Map<String, Integer> map = new HashMap<>(); for (Integer i = 0; i < potentialWord.length(); ++i) { String character = potentialWord.substring(i, i + 1); if (map.containsKey(character)) { map.put(character, map.get(character) + 1); } else { map.put(character, 1); } } Boolean possible = true; Boolean unevenOccurences = false; for (String key : map.keySet()) { if (map.get(key) % 2 != 0) { if (unevenOccurences) { possible = false; break; } unevenOccurences = true; } } System.out.println(possible ? "YES" : "NO"); } }
@Override public Node<?> getParentNode() { return null; }
String[] getLatestIndices(List<String> includeIndices) throws IOException { LOG.debug("Getting latest indices; indices={}", includeIndices); Map<String, String> latestIndices = new HashMap<>(); String[] indices = esClient.getIndices(); for (String index : indices) { int prefixEnd = index.indexOf(INDEX_NAME_DELIMITER); if (prefixEnd != -1) { String prefix = index.substring(0, prefixEnd); if (includeIndices.contains(prefix)) { String latestIndex = latestIndices.get(prefix); if (latestIndex == null || index.compareTo(latestIndex) > 0) { latestIndices.put(prefix, index); } } } } return latestIndices.values().toArray(new String[latestIndices.size()]); }
public static boolean isActivated() { String color = System.getProperty("maven.color"); if (color != null) { return Boolean.valueOf(color); } String activation = System.getProperty("style.color"); if ("always".equals(activation)) { return true; } if ("never".equals(activation)) { return false; } Set<String> args = split(System.getenv("MAVEN_CMD_LINE_ARGS")); return !isBatchMode(args) && !isLogFile(args) && !isDumbTerminal(); }
@Override public String toString() { return name; }
public InetSocketAddress getSocketInetAddress() { if (socketInetAddress.isUnresolved()) { return new InetSocketAddress(socketInetAddress.getHostString(), socketInetAddress.getPort()); } else { return this.socketInetAddress; } }
@Override public Map<String, List<TopicPartition>> assign(Map<String, Integer> partitionsPerTopic, Map<String, Subscription> subscriptions) { Map<String, List<MemberInfo>> consumersPerTopic = consumersPerTopic(subscriptions); Map<String, List<TopicPartition>> assignment = new HashMap<>(); for (String memberId : subscriptions.keySet()) assignment.put(memberId, new ArrayList<>()); for (Map.Entry<String, List<MemberInfo>> topicEntry : consumersPerTopic.entrySet()) { String topic = topicEntry.getKey(); List<MemberInfo> consumersForTopic = topicEntry.getValue(); Integer numPartitionsForTopic = partitionsPerTopic.get(topic); if (numPartitionsForTopic == null) continue; Collections.sort(consumersForTopic); int numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size(); int consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size(); List<TopicPartition> partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic); for (int i = 0, n = consumersForTopic.size(); i < n; i++) { int start = numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition); int length = numPartitionsPerConsumer + (i + 1 > consumersWithExtraPartition ? 0 : 1); assignment.get(consumersForTopic.get(i).memberId).addAll(partitions.subList(start, start + length)); } } return assignment; }
@Override @Loggable(value = Loggable.DEBUG, skipResult = true, name = INVOCATION_LOG_NAME) public ColumnStatistics get_table_column_statistics(String db_name, String tbl_name, String col_name) throws NoSuchObjectException, MetaException, InvalidInputException, InvalidObjectException, TException { DatabaseMapping mapping = databaseMappingService.databaseMapping(db_name); ColumnStatistics result = mapping .getClient() .get_table_column_statistics(mapping.transformInboundDatabaseName(db_name), tbl_name, col_name); return mapping.transformOutboundColumnStatistics(result); }
boolean isLookupNeeded(Set<TraceeBackendProvider> classLoaderProviders) { return classLoaderProviders == null || !(classLoaderProviders instanceof EmptyBackendProviderSet) && classLoaderProviders.isEmpty(); }
public void parseAcls(String resourceRole, String acls) throws InvalidACLException { if (acls != null) { String[] parts = acls.split(";"); if (parts.length != 3) { log.invalidAclsFoundForResource(resourceRole); throw new InvalidACLException("Invalid ACLs specified for requested resource: " + resourceRole); } else { log.aclsFoundForResource(resourceRole); } parseUserAcls(parts); parseGroupAcls(parts); parseIpAddressAcls(parts); } else { log.noAclsFoundForResource(resourceRole); } }
@Override public void refresh() { if (profilesConfigFile != null) { profilesConfigFile.refresh(); lastRefreshed = System.nanoTime(); } }
@Provides Credentials get(denominator.Provider provider) { return checkValidForProvider(MapCredentials.from(parseJson(iipJsonProvider.get())), provider); }
@Override public WidgetDto addWidget(WidgetRequest widgetRequest) { WidgetType widgetType = new WidgetType(); this.processWidgetType(widgetType, widgetRequest); WidgetType oldWidgetType = this.getWidgetManager().getWidgetType(widgetType.getCode()); BeanPropertyBindingResult bindingResult = new BeanPropertyBindingResult(widgetType, "widget"); if (null != oldWidgetType) { bindingResult.reject(WidgetValidator.ERRCODE_WIDGET_ALREADY_EXISTS, new String[]{widgetType.getCode()}, "widgettype.exists"); throw new ValidationGenericException(bindingResult); } else if (null == this.getGroupManager().getGroup(widgetRequest.getGroup())) { bindingResult.reject(WidgetValidator.ERRCODE_WIDGET_GROUP_INVALID, new String[]{widgetRequest.getGroup()}, "widgettype.group.invalid"); throw new ValidationGenericException(bindingResult); } try { this.getWidgetManager().addWidgetType(widgetType); this.createAndAddFragment(widgetType, widgetRequest); WidgetDto widgetDto = this.dtoBuilder.convert(widgetType); this.addFragments(widgetDto); return widgetDto; } catch (Exception e) { logger.error("Failed to add widget type for request {} ", widgetRequest, e); throw new RestServerError("error in add widget", e); } }
@Override public synchronized Connection reserveConnection() throws SQLException { if (!initialized) { initializeConnections(); } if (availableConnections.isEmpty()) { if (reservedConnections.size() < maxConnections) { availableConnections.add(createConnection()); } else { throw new SQLException("Connection limit has been reached."); } } Connection c = availableConnections.iterator().next(); availableConnections.remove(c); reservedConnections.add(c); return c; }
public static boolean compareObjectsAndNull(Object object1, Object object2) { if ((object1 == null && object2 == null) || (object1 != null && object1.equals(object2))) { return true; } else { return false; } }
public List<Text> getSplits(String table) throws IOException { if (null == this.splits) read(); List<Text> tableSplits = this.splits.get(table); if (tableSplits == null) { return Collections.emptyList(); } return tableSplits; }
public boolean evaluate(final Condition condition, final WilmaHttpRequest request) { boolean fulfilled = false; if (condition instanceof CompositeCondition) { if (condition.getConditionType() == ConditionType.AND) { fulfilled = evaluateAndCondition(condition, request); } else if (condition.getConditionType() == ConditionType.OR) { fulfilled = evaluateOrCondition(condition, request); } else if (condition.getConditionType() == ConditionType.NOT) { fulfilled = evaluateNotCondition(condition, request); } } else if (condition instanceof SimpleCondition) { SimpleCondition simpleCondition = (SimpleCondition) condition; ConditionChecker conditionChecker = simpleCondition.getConditionChecker(); boolean negate = simpleCondition.isNegate(); fulfilled = !negate && conditionChecker.checkCondition(request, simpleCondition.getParameters()); } return fulfilled; }
public String getOutputFeedNames() { return getValue(WorkflowExecutionArgs.OUTPUT_FEED_NAMES); }
public ParsedUrlTemplate parse(String input) { String noQueryInput; List<NameValuePair> queryParameters; try { URIBuilder uriBuilder = new URIBuilder(input); queryParameters = uriBuilder.getQueryParams(); uriBuilder.setCustomQuery(null); noQueryInput = uriBuilder.toString(); } catch (URISyntaxException e) { throw new IllegalArgumentException(e.getMessage(), e); } Pattern pathRegex = Pattern.compile(buildParsePattern()); Matcher matcherFullInput = pathRegex.matcher(input); Matcher matcherNoQueryInput = pathRegex.matcher(noQueryInput); boolean matches = true; Map<String, String> parsedValues = new LinkedHashMap<>(); if (matcherNoQueryInput.matches()) { populateParsedValues(parsedValues, matcherNoQueryInput); } else if (matcherFullInput.matches()) { populateParsedValues(parsedValues, matcherFullInput); } else { matches = false; } return new ParsedUrlTemplate(matches, parsedValues, queryParameters); }
public static CompletionException logErrorAndThrow(Throwable t, Function<Throwable, String> m, Class c) { logException(t, Level.SEVERE, m, c); return wrap(t); }
public static void getClassesWithAnnotation(String packageName, Class<? extends Annotation> annotationClass, ClassVisitor visitor) throws ClassLoadingException { LOGGER.trace("Finding classes with annotation: {}, in package: {}", annotationClass, packageName); try { ClassLoader classLoader = getClassLoader(); String packagePath = packageName.replace(DOT, SLASH); Enumeration<URL> resources = classLoader.getResources(packagePath); while (resources.hasMoreElements()) { URL resource = resources.nextElement(); String protocol = resource.getProtocol(); String path = URLDecoder.decode(resource.getPath(), CHARSET); if ("jar".equals(protocol)) { int startIndex = path.startsWith("file:") ? "file:".length() : 0; int endIndex = path.endsWith("jar") ? 0 : path.indexOf("!"); File jarFilePath = new File(path.substring(startIndex, endIndex)); findClassesInJar(jarFilePath, packagePath, annotationClass, visitor); } else if ("file".equals(protocol)) { findClassesInFile(new File(path), packageName, annotationClass, visitor); } else { throw new UnsupportedOperationException("Not supported reading from: " + protocol); } } } catch (IOException e) { throw new ClassLoadingException(e); } }
public static List<FileStatus> listAll(FileSystem fs, Path path, boolean recursive, PathFilter... filters) throws IOException { List<FileStatus> statuses = new ArrayList<>(); listAll(fs, path, recursive, statuses, mergeFilters(filters)); return statuses; }
@Override public Optional<ProgramState> constrainDependencies(ProgramState state, Constraint constraint) { if (constraint.isStricterOrEqualTo(Constraint.TRUTHY)) { return checkRelationsAndConstrain(state, relationWhenTrue); } else if (constraint.isStricterOrEqualTo(Constraint.FALSY)) { return checkRelationsAndConstrain(state, relationWhenTrue.not()); } return Optional.of(state); }
@Override public int run(String[] args) throws IOException, ClassNotFoundException, InterruptedException { prepareArguments(args); groupAndCountByKeyAndValue(); calculateSpecificConditionalEntropy(); calculateConditionalEntropy(); return 0; }
public <T> T invoke(Context context, Class<T> classOfT) { return invoke(context, classOfT, null); }
@Override public String replaceImportContentReferences( PortletDataContext portletDataContext, StagedModel stagedModel, String content) throws Exception { AMEmbeddedReferenceSet amEmbeddedReferenceSet = _amEmbeddedReferenceSetFactory.create( portletDataContext, stagedModel); return _replace(content, amEmbeddedReferenceSet); }
public byte[] toByteArray() { ByteArrayOutputStream stream = new ByteArrayOutputStream(); try { write(stream); } catch (IOException e) { throw new RuntimeException(e); } return stream.toByteArray(); }
public void run() { LOGGER.debug("Leader election started"); if (!acquire()) { return; } leaderElectionConfig.getLeaderCallbacks().onStartLeading(); renewWithTimeout(); leaderElectionConfig.getLeaderCallbacks().onStopLeading(); }
protected void removeElement( final Element element ) { if ( element == null ) { throw new NullPointerException(); } if ( footer == element ) { this.footer.setParent( null ); this.footer = new GroupFooter(); this.footer.setParent( this ); notifyNodeChildRemoved( element ); notifyNodeChildAdded( this.footer ); } else if ( header == element ) { this.header.setParent( null ); this.header = new GroupHeader(); this.header.setParent( this ); notifyNodeChildRemoved( element ); notifyNodeChildAdded( this.header ); } else { super.removeElement( element ); } }
public static ShadowRoot get(StateNode node) { assert node != null; if (isShadowRoot(node)) { return new ShadowRoot(node); } else { throw new IllegalArgumentException( "Node is not valid as an element"); } }
@Override protected String getOwner(final Issue entity) { return entity.getAuthor(); }
@SuppressWarnings("unchecked") @Override public void handle(LogHandlerEvent event) { switch (event.getType()) { case APPLICATION_STARTED: LogHandlerAppStartedEvent appStartedEvent = (LogHandlerAppStartedEvent) event; this.appOwners.put(appStartedEvent.getApplicationId(), appStartedEvent.getUser()); this.dispatcher.getEventHandler().handle( new ApplicationEvent(appStartedEvent.getApplicationId(), ApplicationEventType.APPLICATION_LOG_HANDLING_INITED)); break; case CONTAINER_FINISHED: break; case APPLICATION_FINISHED: LogHandlerAppFinishedEvent appFinishedEvent = (LogHandlerAppFinishedEvent) event; ApplicationId appId = appFinishedEvent.getApplicationId(); LOG.info("Scheduling Log Deletion for application: " + appId + ", with delay of " + this.deleteDelaySeconds + " seconds"); String user = appOwners.remove(appId); if (user == null) { LOG.error("Unable to locate user for " + appId); break; } LogDeleterRunnable logDeleter = new LogDeleterRunnable(user, appId); long deletionTimestamp = System.currentTimeMillis() + this.deleteDelaySeconds * 1000; LogDeleterProto deleterProto = LogDeleterProto.newBuilder() .setUser(user) .setDeletionTime(deletionTimestamp) .build(); try { stateStore.storeLogDeleter(appId, deleterProto); } catch (IOException e) { LOG.error("Unable to record log deleter state", e); } try { sched.schedule(logDeleter, this.deleteDelaySeconds, TimeUnit.SECONDS); } catch (RejectedExecutionException e) { logDeleter.run(); } break; default: ; } }
public static int getRemainingDays(String startDateString, int noDays) { Date endDate = getEndDate(startDateString, noDays); Calendar cal = Calendar.getInstance(); cal.setTime(endDate); long remainingMills = cal.getTimeInMillis() - Calendar.getInstance().getTimeInMillis(); long days = remainingMills / (24 * 60 * 60 * 1000); return Math.round(days); }
private String display(Syntax targetSyntax, boolean executionContextIsolated, boolean transformationContextIsolated, boolean transformationContextRestricted, boolean translate) throws XWikiException { getProgress().startStep(this, "document.progress.render", "Render document [{}] in syntax [{}]", getDocumentReference(), targetSyntax); try { getProgress().pushLevelProgress(3, getDocumentReference()); getProgress().startStep(getDocumentReference(), "document.progress.render.translatedcontent", "Get translated content"); XWikiContext xcontext = getXWikiContext(); XWikiDocument tdoc = translate ? getTranslatedDocument(xcontext) : this; String translatedContent = tdoc.getContent(); getProgress().startStep(getDocumentReference(), "document.progress.render.cache", "Try to get content from the cache"); String renderedContent = getRenderingCache().getRenderedContent(tdoc.getDocumentReferenceWithLocale(), translatedContent, xcontext); if (renderedContent == null) { getProgress().startStep(getDocumentReference(), "document.progress.render.execute", "Execute content"); DocumentDisplayerParameters parameters = new DocumentDisplayerParameters(); parameters.setExecutionContextIsolated(executionContextIsolated); parameters.setTransformationContextIsolated(transformationContextIsolated); parameters.setTransformationContextRestricted(transformationContextRestricted); parameters.setContentTranslated(tdoc != this); parameters.setTargetSyntax(targetSyntax); XDOM contentXDOM = getDocumentDisplayer().display(this, parameters); renderedContent = renderXDOM(contentXDOM, targetSyntax); getRenderingCache().setRenderedContent(getDocumentReference(), translatedContent, renderedContent, xcontext); } return renderedContent; } finally { getProgress().popLevelProgress(getDocumentReference()); getProgress().endStep(this); } }
@Override public ChannelFuture writeGoAway(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData, ChannelPromise promise) { return lifecycleManager.goAway(ctx, lastStreamId, errorCode, debugData, promise); }
@Nullable public static File getRelativeFile(@NonNull File[] paths, @NonNull File file) { if (!file.isAbsolute()) { return file; } String path = file.getAbsolutePath(); for (File parent : paths) { String parentPath = parent.getAbsolutePath() + File.separator; if (path.startsWith(parentPath)) { return new File(path.substring(parentPath.length())); } } return null; }
public Set<JavaSourceFile> generateFromFile(String file) { String ext = getExtOfFile(file); return generateFrom(parserOf(ext).parseFile(file)); }
@Override public String getPath() { return namePathMapper.getJcrPath(oakPath); }
@Nonnull public CardCommandAPDU evaluate(@Nonnull Map<String, Object> context) throws APDUTemplateException { byte[] head = evalTemplate(template.getHeaderTemplate(), context); byte[] data = evalTemplate(template.getDataTemplate(), context); BigInteger length = template.getExpectedLength(); if (head.length != 4) { throw new APDUTemplateException("The computed command APDU header is not valid."); } CardCommandAPDU apdu = new CardCommandAPDU(); apdu.setCLA(head[0]); apdu.setINS(head[1]); apdu.setP1(head[2]); apdu.setP2(head[3]); if (data.length > 0) { apdu.setData(data); } if (length != null) { apdu.setLE(length.intValue()); } return apdu; }
@Override public List<?> next() throws TranslatorException, DataNotAvailableException { SortedMap<Key, Value> rowItems = readNextRow(); boolean rowIdAdded = false; LinkedHashMap<String, byte[]> values = new LinkedHashMap<String, byte[]>(); for (Key key:rowItems.keySet()) { Text cf = key.getColumnFamily(); Text cq = key.getColumnQualifier(); Text rowid = key.getRow(); Value value = rowItems.get(key); Column match = findMatchingColumn(cf, cq); if (!rowIdAdded) { values.put(AccumuloMetadataProcessor.ROWID, rowid.getBytes()); rowIdAdded = true; } if (match != null) { String valueIn = match.getProperty(AccumuloMetadataProcessor.VALUE_IN, false); if (values.get(match.getName()) == null) { values.put(match.getName(), buildValue(valueIn, cq, value)); } } } return nextRow(values); }
public Invite getInvite(String domainId, String instanceId, String email) throws NotFoundException, ServerException { requireNonNull(domainId, "Required non-null domain id"); requireNonNull(instanceId, "Required non-null instance id"); requireNonNull(email, "Required non-null email"); return inviteDao.getInvite(domainId, instanceId, email); }
public Ellipse safetyZone(Position geodeticReference, Position position, float cog, float sog, float loa, float beam, float dimStern, float dimStarboard) { final double v = 1.0; final double l1 = max(safetyEllipseLength*v, 1.0 + safetyEllipseBehind*v*2.0); final double b1 = max(safetyEllipseBreadth*v, 1.5); final double xc = -safetyEllipseBehind*v + 0.5*l1; return createEllipse(geodeticReference, position, cog, loa, beam, dimStern, dimStarboard, l1, b1, xc); }
@Override public RecognizedIntent process(RecognizedIntent recognizedIntent, XatkitSession session) { recognizedIntent.getOutContextInstances().forEach(c -> { c.getValues().forEach(v -> { EntityDefinition referredEntity = v.getContextParameter().getEntity().getReferredEntity(); if (referredEntity instanceof BaseEntityDefinition) { BaseEntityDefinition baseEntityDefinition = (BaseEntityDefinition) referredEntity; if (baseEntityDefinition.getEntityType().equals(EntityType.ANY)) { if(v.getValue() instanceof String) { String processedValue = removeStopWords((String) v.getValue()); v.setValue(processedValue); } else { Log.error("Found {1} parameter value for an any entity", v.getClass().getSimpleName()); } } } }); }); return recognizedIntent; }
@Override public void connectRead(ReadRecipe readRecipe) { super.connectRead(readRecipe); for (ChannelReadRecipe channelReadRecipe : readRecipe.getChannelReadRecipes()) { initialize(channelReadRecipe.getChannelName()); } }
public Revision incrementRevision(final String clientId) { return new Revision(version + 1, clientId, componentId); }
static void detect(List<Component<?>> components) { Set<ComponentNode> graph = toGraph(components); Set<ComponentNode> roots = getRoots(graph); int numVisited = 0; while (!roots.isEmpty()) { ComponentNode node = roots.iterator().next(); roots.remove(node); numVisited++; for (ComponentNode dependent : node.getDependencies()) { dependent.removeDependent(node); if (dependent.isRoot()) { roots.add(dependent); } } } if (numVisited == components.size()) { return; } List<Component<?>> componentsInCycle = new ArrayList<>(); for (ComponentNode node : graph) { if (!node.isRoot() && !node.isLeaf()) { componentsInCycle.add(node.getComponent()); } } throw new DependencyCycleException(componentsInCycle); }
@SuppressWarnings("checkstyle:indentation") public CandlepinQuery<Product> getProductsByVersions(Owner owner, Map<String, Integer> productVersions) { if (productVersions == null || productVersions.isEmpty()) { return this.cpQueryFactory.<Product>buildQuery(); } Disjunction disjunction = Restrictions.disjunction(); Criteria uuidCriteria = this.createSecureCriteria("op") .createAlias("op.product", "p") .add(disjunction) .setProjection(Projections.distinct(Projections.property("p.uuid"))); for (Map.Entry<String, Integer> entry : productVersions.entrySet()) { disjunction.add(Restrictions.and( Restrictions.eq("p.id", entry.getKey()), Restrictions.eq("p.entityVersion", entry.getValue()) )); } if (owner != null) { uuidCriteria.add(Restrictions.not(Restrictions.eq("op.owner", owner))); } List<String> uuids = uuidCriteria.list(); if (uuids != null && !uuids.isEmpty()) { DetachedCriteria criteria = this.createSecureDetachedCriteria(Product.class, null) .add(CPRestrictions.in("uuid", uuids)); return this.cpQueryFactory.<Product>buildQuery(this.currentSession(), criteria); } return this.cpQueryFactory.<Product>buildQuery(); }
public EnumBasedFeatureProvider addFeatureEnum(Class<? extends Feature> featureEnum) { if (featureEnum == null || !featureEnum.isEnum()) { throw new IllegalArgumentException("The featureEnum argument must be an enum"); } addFeatures(Arrays.asList(featureEnum.getEnumConstants())); return this; }
@Override public void doService(AdaptrisMessage msg) throws ServiceException { String metadataKey = metadataKey(msg); String metadataValue = getGenerator().create(msg); MetadataElement e = new MetadataElement(metadataKey, metadataValue); msg.addMetadata(e); logMetadata("Added {}", e); }
@GetMapping("/status") public String viewStatus(@ModelAttribute(name = "form") ChangeRoleProfileForm form, @PathVariable long userId, Model model) { RoleProfileStatusResource roleProfileStatus = getRoleProfileViewModel(userId).getRoleProfileStatus(); if (form.getRoleProfileState() == null) { form.setRoleProfileState(roleProfileStatus.getRoleProfileState()); if (form.getRoleProfileState() == UNAVAILABLE) { form.setUnavailableReason(roleProfileStatus.getDescription()); } if (form.getRoleProfileState() == DISABLED) { form.setDisabledReason(roleProfileStatus.getDescription()); } } model.addAttribute("state", roleProfileStatus.getRoleProfileState().getDescription().toLowerCase()); model.addAttribute("userId", userId); return "roleprofile/change-status"; }
public static int velocity(BigDecimal vel) { int convertedValue = 8191; if (vel != null) { convertedValue = vel.multiply(BigDecimal.valueOf(50)).intValue(); } return convertedValue; }
@SuppressWarnings("unchecked") public PerformanceTimingMetrics createFor(Object performanceTiming) { PerformanceTimingMetrics metrics; if (performanceTiming instanceof Map) { metrics = new DefaultPerformanceTimingMetrics((Map<String, Object>) performanceTiming); } else if (performanceTiming instanceof PerformanceTiming) { metrics = new HtmlUnitPerformanceTimingMetrics((PerformanceTiming) performanceTiming); } else { throw new UnknownPerformanceTimingImplementationException("There is no suitable adapter implementation" + " for the argument performance timing object." + "\n" + "Please create a GitHub issue for FluentLenium" + " if you think that browser/implementation should be supported." + "\n" + "The object was of type: " + performanceTiming.getClass() + " with value: " + performanceTiming); } return metrics; }
public static String dumpString(byte[] b) { StringBuilder d = new StringBuilder(b.length * 2); for (byte aB : b) { char c = (char) aB; if (Character.isISOControl(c)) { switch (c) { case '\r': d.append("{CR}"); break; case '\n': d.append("{LF}"); break; case '\000': d.append("{NULL}"); break; case '\001': d.append("{SOH}"); break; case '\002': d.append("{STX}"); break; case '\003': d.append("{ETX}"); break; case '\004': d.append("{EOT}"); break; case '\005': d.append("{ENQ}"); break; case '\006': d.append("{ACK}"); break; case '\007': d.append("{BEL}"); break; case '\020': d.append("{DLE}"); break; case '\025': d.append("{NAK}"); break; case '\026': d.append("{SYN}"); break; case '\034': d.append("{FS}"); break; case '\036': d.append("{RS}"); break; default: d.append('['); d.append(hexStrings[(int) aB & 0xFF]); d.append(']'); break; } } else d.append(c); } return d.toString(); }
@Override public void initialize(RequestContext requestContext) { this.context = requestContext; this.configuration = configurationFactory. initConfiguration(context.getConfig(), context.getServerName(), context.getUser(), context.getAdditionalConfigProps()); this.initialized = true; }
public JavaPairRDD<String, MatchableEntity> attachDocuments(JavaPairRDD<String, String> matchedCitations, JavaPairRDD<String, MatchableEntity> documents) { return matchedCitations .mapToPair(x -> x.swap()) .join(documents) .mapToPair(x -> new Tuple2<String, MatchableEntity>(x._2._1, x._2._2)); }
@Override public String html(@NotNull final String txt) { final Configuration conf = Configuration.builder() .enableSafeMode() .build(); return MarkdownTxtmark.fixedCodeBlocks( Processor.process( MarkdownTxtmark.formatLinks( MarkdownTxtmark.makeLineBreakExcludeCode( txt, Arrays.asList("```", "``", "`").iterator() ) ), conf ) ); }
public void setXpath(String s) { xpath = Args.notNull(s, "xpath"); }
public String parseErrorCode(Node in) throws Exception { return XpathUtils.asString("ErrorResponse/Error/Code", in); }
public MatchType matches(Version version) { return matches(version, null); }
@Override public RequestResponse<WorkFlow> getWorkflowDefinitions() throws VitamClientException { Response response = null; try { response = make(get() .withPath(WORKFLOWS_URI) .withJsonAccept() ); check(response); return RequestResponse.parseFromResponse(response, WorkFlow.class); } catch (InvalidParseOperationException | NotAcceptableClientException | WorkspaceClientServerException e) { throw new VitamClientException(e); } catch (VitamClientInternalException | IngestInternalClientServerException | IngestInternalClientNotFoundException | IngestInternalClientConflictException e) { throw new VitamClientInternalException(e); } finally { if (response != null) { response.close(); } } }
@Override public boolean matches(IAtom atom) { return invariants(atom).connectivity() - invariants(atom).totalHydrogenCount() == degree; }
@Override protected boolean permittedTopology(DimensionInfo sourceDimensionInfo, DimensionInfo targetDimensionInfo) { return sourceDimensionInfo.isArea() && targetDimensionInfo.isArea(); }
@Override @Deprecated @SuppressWarnings("BooleanParameter") @Contract(value = "_, _, _ -> fail", pure = true) public @NotNull DmaMemory dmaAllocate(final long bytes, final boolean huge, final boolean lock) { if (!OPTIMIZED) { if (unsafe == null) throw new NullPointerException("The Unsafe object is not available."); if (bytes <= 0) throw new IllegalArgumentException("The parameter 'bytes' MUST BE positive."); } throw new UnsupportedOperationException("The Unsafe object does not implement this operation."); }
@Override public void renderRhythm(String queueItemId, String rhythmTargetPath, String rhythmFileName, BeatLoopRenderTransport beatLoopRenderTransport) { concatenateAndFinalizeRendering(queueItemId, rhythmTargetPath, rhythmFileName, beatLoopRenderTransport.getBeatLoops()); }
public Response tryUploadSourceFile(GlobalDocumentId id, DocumentFileUploadForm uploadForm) { try { failIfSourceUploadNotValid(id, uploadForm); util.failIfHashNotPresent(uploadForm); } catch (DocumentUploadException e) { return Response.status(e.getStatusCode()) .entity(new ChunkUploadResponse(e.getMessage())).build(); } return tryValidatedUploadSourceFile(id, uploadForm); }
private boolean noManagedRequired(Exchange exchange) { return PolicyUtil.isRequired(exchange, TransactionPolicy.NO_MANAGED_TRANSACTION); }
@SuppressWarnings({"rawtypes", "unchecked"}) @Override public PagedMetadata<LabelDto> getLabelGroups(final RestListRequest restRequest) { final List<LabelDto> dtoList = this.getDtoBuilder().convert(this.i18nManager.getLabelGroups()); final List<LabelDto> subList = new LabelRequestListProcessor(restRequest, dtoList).filterAndSort().toList(); final SearcherDaoPaginatedResult<LabelDto> result = new SearcherDaoPaginatedResult(dtoList.size(), subList); final PagedMetadata<LabelDto> pagedMetadata = new PagedMetadata<>(restRequest, result); pagedMetadata.setBody(subList); pagedMetadata.imposeLimits(); return pagedMetadata; }
@Override public Observable<Pair<List<Task>, Integer>> retrieveTasksForJob(String jobId) { return Observable.fromCallable(() -> { checkIfJobIsActive(jobId); return retrieveActiveTaskIdsForJobStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE); }).flatMap(retrieveActiveTaskIdsForJob -> execute(retrieveActiveTaskIdsForJob).flatMap(taskIdsResultSet -> { List<String> taskIds = taskIdsResultSet.all().stream() .map(row -> row.getString(0)) .flatMap(taskId -> { if (fitBadDataInjection.isPresent()) { List<String> effectiveTaskIds = new ArrayList<>(); String effectiveTaskId = fitBadDataInjection.get().afterImmediate(JobStoreFitAction.ErrorKind.LostTaskIds.name(), taskId); if (effectiveTaskId != null) { effectiveTaskIds.add(effectiveTaskId); } String phantomId = fitBadDataInjection.get().afterImmediate(JobStoreFitAction.ErrorKind.PhantomTaskIds.name(), taskId); if (phantomId != null && !phantomId.equals(taskId)) { effectiveTaskIds.add(phantomId); } return effectiveTaskIds.stream(); } return Stream.of(taskId); }) .collect(Collectors.toList()); List<Observable<ResultSet>> observables = taskIds.stream().map(retrieveActiveTaskStatement::bind).map(this::execute).collect(Collectors.toList()); return Observable.merge(observables, getConcurrencyLimit()).flatMapIterable(tasksResultSet -> { List<Either<Task, Throwable>> tasks = new ArrayList<>(); for (Row row : tasksResultSet.all()) { String value = row.getString(0); String effectiveValue; if (fitBadDataInjection.isPresent()) { effectiveValue = fitBadDataInjection.get().afterImmediate(JobStoreFitAction.ErrorKind.CorruptedRawTaskRecords.name(), value); } else { effectiveValue = value; } Task task; try { task = deserializeTask(effectiveValue); if (!fitBadDataInjection.isPresent()) { tasks.add(Either.ofValue(task)); } else { Task effectiveTask = fitBadDataInjection.get().afterImmediate(JobStoreFitAction.ErrorKind.CorruptedTaskRecords.name(), task); effectiveTask = fitBadDataInjection.get().afterImmediate(JobStoreFitAction.ErrorKind.DuplicatedEni.name(), effectiveTask); effectiveTask = fitBadDataInjection.get().afterImmediate(JobStoreFitAction.ErrorKind.CorruptedTaskPlacementData.name(), effectiveTask); tasks.add(Either.ofValue(effectiveTask)); } transactionLogger().logAfterRead(retrieveActiveTaskStatement, "retrieveTasksForJob", task); } catch (Exception e) { logger.error("Cannot map serialized task data to Task class: {}", effectiveValue, e); tasks.add(Either.ofError(e)); } } return tasks; }); })).toList().map(taskErrorPairs -> { List<Task> tasks = taskErrorPairs.stream().filter(Either::hasValue).map(Either::getValue).collect(Collectors.toList()); int errors = (int) taskErrorPairs.stream().filter(Either::hasError).count(); return Pair.of(tasks, errors); }); }
@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; DayOfWeek dayOfWeek = (DayOfWeek) o; return Objects.equals(slot, dayOfWeek.slot) && value == dayOfWeek.value; }
@Override public VduInstance deleteVdu(CloudInfo cloudInfo, String instanceId, int timeoutMinutes) throws VduException { String cloudSiteId = cloudInfo.getCloudSiteId(); String cloudOwner = cloudInfo.getCloudOwner(); String tenantId = cloudInfo.getTenantId(); try { StackInfo stackInfo = deleteStack(cloudSiteId, cloudOwner, tenantId, instanceId); VduInstance vduInstance = stackInfoToVduInstance(stackInfo); vduInstance.getStatus().setState(VduStateType.DELETED); return vduInstance; } catch (Exception e) { throw new VduException("Delete VDU Exception", e); } }
@Override public String toString() { return "SimplifyGeometryFunction{}"; }
public static String percentEncode(String s) { try { return URLEncoder.encode(s, UTF8).replace("%2F", "/"); } catch (UnsupportedEncodingException e) { throw new RuntimeException("UTF8 isn't supported? " + e.getMessage(), e); } }
@Override public ActionResponse execute(StatsTrendRequest parameter) { SearchRequestBuilder searchRequestBuilder = getRequestBuilder(parameter); try { SearchResponse response = searchRequestBuilder.execute() .actionGet(getGetQueryTimeout()); return getResponse(response, parameter); } catch (ElasticsearchException e) { throw FoxtrotExceptions.createQueryExecutionException(parameter, e); } }
@Override public String getVersion( ) { return version; }
@SuppressWarnings("rawtypes") @Override public Object exec(List arguments) throws TemplateModelException { Object val = arguments.isEmpty() ? null : arguments.get(0); if (val == null) return ""; try { return format(Long.parseLong(val.toString().trim()) * 60); } catch (NumberFormatException e) { return val.toString(); } }
@Override public Single<Certificate> create(Certificate item) { CertificateMongo certificate = convert(item); certificate.setId(certificate.getId() == null ? RandomString.generate() : certificate.getId()); return Single.fromPublisher(certificatesCollection.insertOne(certificate)).flatMap(success -> findById(certificate.getId()).toSingle()); }
public static <K, V> AsMultimap<K, V> asMultimap() { return new AsMultimap<>(); }
public boolean matches( @Nonnull String name, boolean isCaseSensitive ) { String[] tokenized = MatchPattern.tokenizePathToString( name, File.separator ); for ( MatchPattern pattern : patterns ) { if ( pattern.matchPath( name, tokenized, isCaseSensitive ) ) { return true; } } return false; }
@Override public void prepare() throws CoreException { try { Args.notNull(getExceptionSerializer(), "exceptionSerializer"); } catch (IllegalArgumentException e) { throw ExceptionHelper.wrapCoreException(e); } }
public boolean removeUser(KixmppJid address) { KixmppJid bareJid = address.withoutResource(); String nickname = nicknamesByBareJid.get(bareJid); if (nickname == null) { return false; } User user = usersByNickname.get(nickname); if (user == null) { return false; } user.removeClients(); removeDisconnectedUser(user); return true; }
@RequestMapping(params = "pause", method = RequestMethod.GET) public String pauseGame(Model model) { timerService.pause(); return getAdminPage(model); }
public long getAuthTokenLifetimeMillis() { return mAuthTokenLifetimeMillis; }
Symbol getSymbol(QualifiedName qualifiedName) { return symbolByQualifiedName.get(qualifiedName); }
public Optional<Node> localCorpusDispatchTarget() { if ( localCorpusDispatchTarget.isEmpty()) return Optional.empty(); Group localSearchGroup = groups().get(localCorpusDispatchTarget.get().group()); if ( ! localSearchGroup.hasSufficientCoverage()) return Optional.empty(); if ( localCorpusDispatchTarget.get().isWorking() == Boolean.FALSE) return Optional.empty(); return localCorpusDispatchTarget; }
public static ProjectInfo loadProjectInfo(Path projectPath) throws Exception { ProjectInfo projectInfo = null; GradleConnector connector = GradleConnector.newConnector(); connector.forProjectDirectory(projectPath.toFile()); ProjectConnection connection = null; try { connection = connector.connect(); ModelBuilder<ProjectInfo> modelBuilder = connection.model(ProjectInfo.class); Path tempPath = Files.createTempDirectory("tooling"); InputStream in = GradleTooling.class.getResourceAsStream("/tooling.zip"); FileUtil.unzip(in, tempPath.toFile()); try (Stream<Path> toolingFiles = Files.list(tempPath)) { String files = toolingFiles.map( Path::toAbsolutePath ).map( Path::toString ).map( path -> "\"" + path.replaceAll("\\\\", "/") + "\"" ).collect( Collectors.joining(", ") ); String initScriptTemplate = FileUtil.collect(GradleTooling.class.getResourceAsStream("init.gradle")); String initScriptContents = initScriptTemplate.replaceAll("%files%", files); Path initPath = tempPath.resolve("init.gradle"); Files.write(initPath, initScriptContents.getBytes()); modelBuilder.withArguments("--init-script", initPath.toString(), "--stacktrace"); projectInfo = modelBuilder.get(); } } finally { if (connection != null) { connection.close(); } } return projectInfo; }
public static boolean isPrecisionApplicable(String typeName) { return isScaleApplicable(typeName) || DataType.STRING_FAMILY.contains(typeName); }
private Server merge(Server firstServer, Server secondServer) { return Server.builder(firstServer) .addQueries(secondServer.getQueries()) .build(); }
@Override public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) { if (!(obj instanceof List<?>)) { throw new IllegalArgumentException(); } List<?> list = (List<?>) obj; if(list.size() >= 1) { toAppendTo.append(list.get(0)); for (int i = 1; i < list.size(); i++) { toAppendTo.append(", "); toAppendTo.append(list.get(i)); } } return toAppendTo; }
protected static List<JobDefinition> getSortedToSatisfyDependencies(List<JobDefinition> jobs){ Queue<JobDefinition> toAssign = new LinkedList<JobDefinition>(jobs); List<JobDefinition> postponed = new LinkedList<JobDefinition>(); List<JobDefinition> out = new ArrayList<JobDefinition>(jobs.size()); Set<String> assigned = new HashSet<String>(); mainLoop: while(!toAssign.isEmpty() || !postponed.isEmpty()){ JobDefinition chosenJob = null; if(!postponed.isEmpty()){ Iterator<JobDefinition> iterator = postponed.iterator(); postponedLoop : while(iterator.hasNext()){ JobDefinition job = iterator.next(); if(job.areDependenciesSatisfied(jobs,assigned)){ chosenJob = job; iterator.remove(); break postponedLoop; } } } if(chosenJob == null && toAssign.isEmpty()){ assert !postponed.isEmpty(); chosenJob = postponed.remove((int) 0); } if(chosenJob == null){ assert !toAssign.isEmpty(); toExecuteLoop : while(!toAssign.isEmpty()){ JobDefinition job = toAssign.poll(); if(job.areDependenciesSatisfied(jobs,assigned)){ chosenJob = job; break toExecuteLoop; } else { postponed.add(job); } } if(chosenJob == null){ assert !postponed.isEmpty() && toAssign.isEmpty(); continue mainLoop; } } out.add(chosenJob); assigned.add(chosenJob.cut); } return out; }
protected boolean hasNhinTargetHomeCommunityId( RespondingGatewayProvideAndRegisterDocumentSetSecuredRequestType request) { return request != null && request.getNhinTargetCommunities() != null && NullChecker.isNotNullish(request.getNhinTargetCommunities().getNhinTargetCommunity()) && request.getNhinTargetCommunities().getNhinTargetCommunity().get(0) != null && request.getNhinTargetCommunities().getNhinTargetCommunity().get(0).getHomeCommunity() != null && NullChecker.isNotNullish(request.getNhinTargetCommunities().getNhinTargetCommunity().get(0) .getHomeCommunity().getHomeCommunityId()); }
@MotechListener(subjects = DATA_PROVIDER_UPDATE_SUBJECT) @Transactional public void validateTasksAfterTaskDataProviderUpdate(MotechEvent event) { String providerName = event.getParameters().get(DATA_PROVIDER_NAME).toString(); TaskDataProvider provider = providerService.getProvider(providerName); LOGGER.debug("Handling a task data provider update: {}", providerName); for (Task task : getAllTasks()) { SortedSet<DataSource> dataSources = task.getTaskConfig().getDataSources(provider.getName()); if (isNotEmpty(dataSources)) { Set<TaskError> errors = new HashSet<>(); for (DataSource dataSource : dataSources) { errors.addAll(validateProvider( provider, dataSource, task, new HashMap<Long, TaskDataProvider>() )); } errors.addAll(validateActions(task)); handleValidationErrors(task, errors, TASK_DATA_PROVIDER_VALIDATION_ERRORS); } } }
@Override public void resourceableDeleted(final RepositoryEntry repositoryEntry) { log.debug("sourceableDeleted start... repositoryEntry=" + repositoryEntry); final List references = catalogDao.getCatalogEntriesReferencing(repositoryEntry); if (references != null && !references.isEmpty()) { for (int i = 0; i < references.size(); i++) { deleteCatalogEntry((CatalogEntry) references.get(i)); } } }
public static Node[] parse(String id) { if (id.length() == 0) { return EMPTY_NODES_ARRAY; } List<Node> result = Lists.newArrayList(); Iterable<String> split = SeparatorChar.SPLITTER.split(id); for (String s : split) { if (s.charAt(0) == META_COMPONENT_SEPARATOR_CHAR) { int startImageIdx = s.indexOf(FUNCTION_IMAGE_START_TOKEN); if (startImageIdx < 0) { result.add(new Node(s)); } else { if (s.charAt(s.length() - 1) != FUNCTION_IMAGE_END_TOKEN) { throw new IllegalArgumentException(id); } if (startImageIdx + 1 > s.length() - 1) { throw new IllegalArgumentException(id); } String image = s.substring(startImageIdx + 1, s.length() - 1); String functionName = s.substring(1, startImageIdx); result.add(new Node(image, functionName)); } } else { result.add(new Node(s)); } } return result.toArray(new Node[result.size()]); }
@Override public void install(File artifact) { String filePath = artifact.getAbsolutePath(); logger.info("Installing list provider {}", filePath); Properties properties; try { properties = readProperties(artifact); } catch (IOException e) { logger.error("Unable to read file " + filePath); return; } addResourceListProvider(filePath, properties); }
private String safeDescription(ProductInterface product) { ComplexTextValue description = product.getDescription(); if (description == null) { return null; } return xssApi.filterHTML(description.getHtml()); }
public void processAllVars(CmsCI ci,CmsCI env , CmsCI cloud, CmsCI plat) { processAllVars(ci, getCloudVars(cloud), getGlobalVars(env), getLocalVars(plat)); }
@Override public InputStreamResource getFileById(String fileId) { Metadata metadata = getMetadataById(fileId); if (isAnUnprocessedCpcFile(metadata)) { return new InputStreamResource(storageService.getFileByLocationId(metadata.getSubmissionLocator())); } throw new NoFileInDatabaseException(FILE_NOT_FOUND); }
public int register(String key) { Integer id = store.get(key); if (id != null) { return id; } int localId = nextId.getAndIncrement(); while (localId < maxId) { if (store.setIfAbsent(key, localId)) { return localId; } Integer storeId = store.get(key); if (storeId != null) { return storeId; } localId = nextId.getAndIncrement(); } throw new IllegalStateException("StringMap id space exhausted"); }
@Override public void handleUpdate(String key, M oldValue, M newValue) { if (!oldValue.equals(newValue)) { List<PatchOperation> operations = agent.updatedModel(key, oldValue, newValue); if (!operations.isEmpty()) { emitter.emit(new PatchSet(key, operations)); } } }
@Override public String decrypt(final String encryptedData) { LOGGER.debug("decrypting data"); String decryptedData = encryptor.decrypt(encryptedData); LOGGER.debug("decrypted data"); return decryptedData; }
@Override @CheckReturnValue @Nonnull public WebDriver getAndCheckWebDriver() { WebDriver webDriver = threadWebDriver.get(currentThread().getId()); if (webDriver != null && reopenBrowserOnFail && !browserHealthChecker.isBrowserStillOpen(webDriver)) { log.info("Webdriver has been closed meanwhile. Let's re-create it."); closeWebDriver(); webDriver = createDriver(); } else if (webDriver == null) { log.info("No webdriver is bound to current thread: {} - let's create a new webdriver", currentThread().getId()); webDriver = createDriver(); } return webDriver; }
@Override public String getCounter(final String counterName) throws ConnectionException, RequestException, AccessException { try { return getCounter(counterName, null); } catch (final ConnectionException | AccessException | RequestException exc) { throw exc; } catch (P4JavaException exc) { throw new RequestException(exc.getMessage(), exc); } }
public void textBindMappingChanged(org.apache.pivot.wtk.TextArea arg0, org.apache.pivot.wtk.TextArea.TextBindMapping arg1) { if (textBindMappingChanged != null) { textBindMappingChanged.call(arg0, arg1); } }
@Override public LinearProgram<E> convert(LinearProgram<E> original) { Objects.requireNonNull(original); if (original.isSlack()) { throw new IllegalArgumentException("Input is not a standard form linear program"); } final List<LinearProgramConstraint<E>> constraints = new ArrayList<>(); for (LinearProgramConstraint<E> constraint : original.getConstraints()) { if (ConstraintType.GREATER_THAN_OR_EQUAL_TO.equals(constraint.getConstraintType())) { final List<E> coefficients = new ArrayList<>(); for (int i = 0; i < constraint.size(); i++) { coefficients.add(NumberUtils.negate(constraint.getCoefficient(i))); } constraints.add(new DefaultLinearProgramConstraint<>(type, coefficients, ConstraintType.LESS_THAN_OR_EQUAL_TO, NumberUtils.negate(constraint.getValue()), NumberUtils.negate(constraint.getOffset()))); } else { constraints.add(constraint); } } return new DefaultLinearProgram<>(constraints, original.getObjective()); }
@NotNull public static String getWorkspacePath(@NotNull final String organizationName) { StringBuilder pathString = new StringBuilder() .append(API) .append(API_VERSION) .append(ORGANIZATION_PATH) .append(organizationName) .append(WORKSPACE_PATH); return pathString.toString(); }
public void removeTrackedQuery(QuerySpec query) { query = normalizeQuery(query); TrackedQuery trackedQuery = findTrackedQuery(query); assert trackedQuery != null : "Query must exist to be removed."; this.storageLayer.deleteTrackedQuery(trackedQuery.id); Map<QueryParams, TrackedQuery> trackedQueries = this.trackedQueryTree.get(query.getPath()); trackedQueries.remove(query.getParams()); if (trackedQueries.isEmpty()) { this.trackedQueryTree = this.trackedQueryTree.remove(query.getPath()); } }
public Boolean updateActivity(PromotionActivity promotionActivity){ return activityMapper.updateActivity(promotionActivity); }
public Builder asBuilder() { return new Builder(columns); }
@Override public Collection<String> getScopeAliases(long companyId) { Collection<String> scopesAliases = new HashSet<>(); Set<String> applicationNames = _scopeFinderByNameServiceTrackerMap.keySet(); for (String applicationName : applicationNames) { scopesAliases.addAll(getScopeAliases(companyId, applicationName)); } return scopesAliases; }
@Override public Ring<T> createRing(Map<T, Integer> pointsMap) { return _ringFactory.createRing(pointsMap); }
public static JsonValue createJsonObject(Object object) throws JsonException { if (object == null) { return new NullValue(); } Class<?> aClass = object.getClass(); JsonValue jsonRootValue = new ObjectValue(); JsonMethod[] getters; try { getters = methodsCache.get(aClass); } catch (ExecutionException e) { propagateIfPossible(e.getCause()); throw new JsonException(e.getCause()); } for (JsonMethod getter : getters) { try { Object getterResult = getter.method.invoke(object); Types getterResultType = JsonUtils.getType(getterResult); if (getterResultType == null) { jsonRootValue.addElement(getter.field, createJsonObject(getterResult)); } else { jsonRootValue.addElement(getter.field, createJsonValue(getterResult, getterResultType)); } } catch (InvocationTargetException | IllegalAccessException e) { throw new JsonException(e.getMessage(), e); } } return jsonRootValue; }
public void decode(ByteBuf buffer) { boolean last; int statusCode; while (true) { switch(state) { case READ_COMMON_HEADER: if (buffer.readableBytes() < SPDY_HEADER_SIZE) { return; } int frameOffset = buffer.readerIndex(); int flagsOffset = frameOffset + SPDY_HEADER_FLAGS_OFFSET; int lengthOffset = frameOffset + SPDY_HEADER_LENGTH_OFFSET; buffer.skipBytes(SPDY_HEADER_SIZE); boolean control = (buffer.getByte(frameOffset) & 0x80) != 0; int version; int type; if (control) { version = getUnsignedShort(buffer, frameOffset) & 0x7FFF; type = getUnsignedShort(buffer, frameOffset + SPDY_HEADER_TYPE_OFFSET); streamId = 0; } else { version = spdyVersion; type = SPDY_DATA_FRAME; streamId = getUnsignedInt(buffer, frameOffset); } flags = buffer.getByte(flagsOffset); length = getUnsignedMedium(buffer, lengthOffset); if (version != spdyVersion) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SPDY Version"); } else if (!isValidFrameHeader(streamId, type, flags, length)) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid Frame Error"); } else { state = getNextState(type, length); } break; case READ_DATA_FRAME: if (length == 0) { state = State.READ_COMMON_HEADER; delegate.readDataFrame(streamId, hasFlag(flags, SPDY_DATA_FLAG_FIN), Unpooled.buffer(0)); break; } int dataLength = Math.min(maxChunkSize, length); if (buffer.readableBytes() < dataLength) { return; } ByteBuf data = buffer.alloc().buffer(dataLength); data.writeBytes(buffer, dataLength); length -= dataLength; if (length == 0) { state = State.READ_COMMON_HEADER; } last = length == 0 && hasFlag(flags, SPDY_DATA_FLAG_FIN); delegate.readDataFrame(streamId, last, data); break; case READ_SYN_STREAM_FRAME: if (buffer.readableBytes() < 10) { return; } int offset = buffer.readerIndex(); streamId = getUnsignedInt(buffer, offset); int associatedToStreamId = getUnsignedInt(buffer, offset + 4); byte priority = (byte) (buffer.getByte(offset + 8) >> 5 & 0x07); last = hasFlag(flags, SPDY_FLAG_FIN); boolean unidirectional = hasFlag(flags, SPDY_FLAG_UNIDIRECTIONAL); buffer.skipBytes(10); length -= 10; if (streamId == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SYN_STREAM Frame"); } else { state = State.READ_HEADER_BLOCK; delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, last, unidirectional); } break; case READ_SYN_REPLY_FRAME: if (buffer.readableBytes() < 4) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); last = hasFlag(flags, SPDY_FLAG_FIN); buffer.skipBytes(4); length -= 4; if (streamId == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SYN_REPLY Frame"); } else { state = State.READ_HEADER_BLOCK; delegate.readSynReplyFrame(streamId, last); } break; case READ_RST_STREAM_FRAME: if (buffer.readableBytes() < 8) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); statusCode = getSignedInt(buffer, buffer.readerIndex() + 4); buffer.skipBytes(8); if (streamId == 0 || statusCode == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid RST_STREAM Frame"); } else { state = State.READ_COMMON_HEADER; delegate.readRstStreamFrame(streamId, statusCode); } break; case READ_SETTINGS_FRAME: if (buffer.readableBytes() < 4) { return; } boolean clear = hasFlag(flags, SPDY_SETTINGS_CLEAR); numSettings = getUnsignedInt(buffer, buffer.readerIndex()); buffer.skipBytes(4); length -= 4; if ((length & 0x07) != 0 || length >> 3 != numSettings) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid SETTINGS Frame"); } else { state = State.READ_SETTING; delegate.readSettingsFrame(clear); } break; case READ_SETTING: if (numSettings == 0) { state = State.READ_COMMON_HEADER; delegate.readSettingsEnd(); break; } if (buffer.readableBytes() < 8) { return; } byte settingsFlags = buffer.getByte(buffer.readerIndex()); int id = getUnsignedMedium(buffer, buffer.readerIndex() + 1); int value = getSignedInt(buffer, buffer.readerIndex() + 4); boolean persistValue = hasFlag(settingsFlags, SPDY_SETTINGS_PERSIST_VALUE); boolean persisted = hasFlag(settingsFlags, SPDY_SETTINGS_PERSISTED); buffer.skipBytes(8); --numSettings; delegate.readSetting(id, value, persistValue, persisted); break; case READ_PING_FRAME: if (buffer.readableBytes() < 4) { return; } int pingId = getSignedInt(buffer, buffer.readerIndex()); buffer.skipBytes(4); state = State.READ_COMMON_HEADER; delegate.readPingFrame(pingId); break; case READ_GOAWAY_FRAME: if (buffer.readableBytes() < 8) { return; } int lastGoodStreamId = getUnsignedInt(buffer, buffer.readerIndex()); statusCode = getSignedInt(buffer, buffer.readerIndex() + 4); buffer.skipBytes(8); state = State.READ_COMMON_HEADER; delegate.readGoAwayFrame(lastGoodStreamId, statusCode); break; case READ_HEADERS_FRAME: if (buffer.readableBytes() < 4) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); last = hasFlag(flags, SPDY_FLAG_FIN); buffer.skipBytes(4); length -= 4; if (streamId == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid HEADERS Frame"); } else { state = State.READ_HEADER_BLOCK; delegate.readHeadersFrame(streamId, last); } break; case READ_WINDOW_UPDATE_FRAME: if (buffer.readableBytes() < 8) { return; } streamId = getUnsignedInt(buffer, buffer.readerIndex()); int deltaWindowSize = getUnsignedInt(buffer, buffer.readerIndex() + 4); buffer.skipBytes(8); if (deltaWindowSize == 0) { state = State.FRAME_ERROR; delegate.readFrameError("Invalid WINDOW_UPDATE Frame"); } else { state = State.READ_COMMON_HEADER; delegate.readWindowUpdateFrame(streamId, deltaWindowSize); } break; case READ_HEADER_BLOCK: if (length == 0) { state = State.READ_COMMON_HEADER; delegate.readHeaderBlockEnd(); break; } if (!buffer.isReadable()) { return; } int compressedBytes = Math.min(buffer.readableBytes(), length); ByteBuf headerBlock = buffer.alloc().buffer(compressedBytes); headerBlock.writeBytes(buffer, compressedBytes); length -= compressedBytes; delegate.readHeaderBlock(headerBlock); break; case DISCARD_FRAME: int numBytes = Math.min(buffer.readableBytes(), length); buffer.skipBytes(numBytes); length -= numBytes; if (length == 0) { state = State.READ_COMMON_HEADER; break; } return; case FRAME_ERROR: buffer.skipBytes(buffer.readableBytes()); return; default: throw new Error("Shouldn't reach here."); } } }
@Override public CompletableFuture<V> getAsync(K key, Object ... args) { Preconditions.checkNotNull(readFn, "null readFn"); return args.length > 0 ? readFn.getAsync(key, args) : readFn.getAsync(key); }
public static CoAPTxRequestPacket createPacket(byte[] payload) { if (payload == null) throw new NullPointerException(ERROR_PAYLOAD_NULL); if (payload.length < MIN_API_PAYLOAD_LENGTH) throw new IllegalArgumentException(ERROR_INCOMPLETE_PACKET); if ((payload[0] & 0xFF) != APIFrameType.COAP_TX_REQUEST.getValue()) throw new IllegalArgumentException(ERROR_NOT_COAP_TX_REQ); int index = 1; int frameID = payload[index] & 0xFF; index = index + 1; int transmitOptions = payload[index] & 0xFF; index = index + 1; HTTPMethodEnum method = HTTPMethodEnum.get(payload[index] & 0xFF); index = index + 1; Inet6Address destAddress; try { destAddress = (Inet6Address) Inet6Address.getByAddress(Arrays.copyOfRange(payload, index, index + 16)); } catch (UnknownHostException e) { throw new IllegalArgumentException(e); } index = index + 16; int uriLength = payload[index] & 0xFF; index = index + 1; String uri = null; if (index < index + uriLength) uri = new String(Arrays.copyOfRange(payload, index, index + uriLength)); index = index + uriLength; byte[] data = null; if (index < payload.length) data = Arrays.copyOfRange(payload, index, payload.length); return new CoAPTxRequestPacket(frameID, transmitOptions, method, destAddress, uri, data); }
public static OktaIdToken parseIdToken(@NonNull String token) throws IllegalArgumentException { String[] sections = token.split("\\."); if (sections.length < NUMBER_OF_SECTIONS) { throw new IllegalArgumentException("IdToken missing header, claims or" + " signature section"); } Gson gson = new GsonBuilder().registerTypeAdapterFactory(ArrayTypeAdapter.CREATE).create(); String headerSection = new String(Base64.decode(sections[0], Base64.URL_SAFE)); Header header = gson.fromJson(headerSection, Header.class); String claimsSection = new String(Base64.decode(sections[1], Base64.URL_SAFE)); Claims claims = gson.fromJson(claimsSection, Claims.class); String signature = new String(Base64.decode(sections[2], Base64.URL_SAFE)); return new OktaIdToken(header, claims, signature); }
public static void floorInPlace(double[] var, double minValue) { for (int k = 0; k < var.length; k++) { if (var[k] < minValue) { var[k] = minValue; } } }
public boolean canBeSubsumed() { return !props.forceCheckpoint(); }
@RequestMapping(value = "/v1/names/{name}", consumes = MediaType.APPLICATION_JSON_VALUE, method = RequestMethod.PUT) public ResponseEntity<Map> updateName(@PathVariable String name, @Valid @RequestBody NameEntry newNameEntry, BindingResult bindingResult) { if (!bindingResult.hasErrors()) { NameEntry oldNameEntry = entryService.loadName(name); if (oldNameEntry == null) { throw new GenericApiCallException(name + " not in database", HttpStatus.INTERNAL_SERVER_ERROR); } entryService.updateName(oldNameEntry, newNameEntry); return new ResponseEntity<>(response("Name successfully updated"), HttpStatus.CREATED); } throw new GenericApiCallException(formatErrorMessage(bindingResult), HttpStatus.BAD_REQUEST); }
public void validate(Resource resc) throws InvalidAssignmentException { Resource objType = getValidObjectTypeResc(resc); if (objType == null) { throw new InvalidAssignmentException( "Object " + resc.getURI() + " is not applicable for access restrictions."); } if (objType.equals(Cdr.FileObject) || objType.equals(Cdr.Work) || objType.equals(Cdr.Folder)) { assertApplicableProperties(resc, objType, contentProperties); assertValidPrincipals(resc); } else if (objType.equals(Cdr.Collection)) { assertApplicableProperties(resc, Cdr.Collection, collectionProperties); assertValidPrincipals(resc); } else { assertApplicableProperties(resc, Cdr.AdminUnit, adminUnitProperties); assertValidPrincipals(resc); } }
@Override public StorageContainerRegistryImpl getRegistry() { return this.scRegistry; }
public static Date yesterdayZero(Date period) { Calendar cal = Calendar.getInstance(); cal.setTime(period); cal.add(Calendar.DAY_OF_YEAR, -1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); return cal.getTime(); }
public byte[] fromUTF8(String contents) throws UnsupportedEncodingException { Reject.ifNull(contents); return contents.getBytes(ENCODING); }
public static TableReference parseTableSpec(String tableSpec) { Matcher match = BigQueryIO.TABLE_SPEC.matcher(tableSpec); if (!match.matches()) { throw new IllegalArgumentException( "Table reference is not in [project_id]:[dataset_id].[table_id] " + "format: " + tableSpec); } TableReference ref = new TableReference(); ref.setProjectId(match.group("PROJECT")); return ref.setDatasetId(match.group("DATASET")).setTableId(match.group("TABLE")); }
@Override public ImmutableSortedMap<K, V> insert(K key, V value) { int pos = findKey(key); if (pos != -1) { if (this.keys[pos] == key && this.values[pos] == value) { return this; } else { K[] newKeys = replaceInArray(this.keys, pos, key); V[] newValues = replaceInArray(this.values, pos, value); return new ArraySortedMap<K, V>(this.comparator, newKeys, newValues); } } else { if (this.keys.length > Builder.ARRAY_TO_RB_TREE_SIZE_THRESHOLD) { @SuppressWarnings("unchecked") Map<K, V> map = new HashMap<K, V>(this.keys.length + 1); for (int i = 0; i < this.keys.length; i++) { map.put(this.keys[i], this.values[i]); } map.put(key, value); return RBTreeSortedMap.fromMap(map, this.comparator); } else { int newPos = findKeyOrInsertPosition(key); K[] keys = addToArray(this.keys, newPos, key); V[] values = addToArray(this.values, newPos, value); return new ArraySortedMap<K, V>(this.comparator, keys, values); } } }
@Override public ResourceList<Flavor> listAll() throws IOException { ResourceList<Flavor> flavorResourceList = new ResourceList<>(); ResourceList<Flavor> resourceList = getFlavorResourceList(getBasePath()); flavorResourceList.setItems(resourceList.getItems()); while (resourceList.getNextPageLink() != null && !resourceList.getNextPageLink().isEmpty()) { resourceList = getFlavorResourceList(resourceList.getNextPageLink()); flavorResourceList.getItems().addAll(resourceList.getItems()); } return flavorResourceList; }
public List<SystemSetting> readAll() { Response response = cassandraOperation.getAllRecords(KEYSPACE_NAME, TABLE_NAME); List<Map<String, Object>> list = (List<Map<String, Object>>) response.get(JsonKey.RESPONSE); List<SystemSetting> systemSettings = new ArrayList<>(); ObjectMapper mapper = new ObjectMapper(); list.forEach( map -> { SystemSetting systemSetting = mapper.convertValue(map, SystemSetting.class); systemSettings.add(systemSetting); }); return systemSettings; }
public int maxPoints(Point[] points) { if (points.length == 0) { return 0; } int max = 1; for (int i = 0; i < points.length; i++) { Point a = points[i]; List<Segment> segmentsStartWithA = new ArrayList<>(); for (int j = i + 1; j < points.length; j++) { Point b = points[j]; Segment seg = new Segment(a, b); segmentsStartWithA.add(seg); } Map<Angle, List<Segment>> sameAngleSegGroups = segmentsStartWithA.stream() .collect(groupingBy(Segment::getAngle)); final int samePointSegCount; if (sameAngleSegGroups.containsKey(Same.instance())) { samePointSegCount = sameAngleSegGroups.get(Same.instance()).size(); } else { samePointSegCount = 0; } Optional<Integer> maxNumOptional = sameAngleSegGroups.values().stream().map(group -> { if (group.get(0).getAngle() instanceof Same) { return samePointSegCount + 1; } return group.size() + 1 + samePointSegCount; }).max((i1, i2) -> i1 - i2); if (maxNumOptional.isPresent()) { int maxNum = maxNumOptional.get(); if (maxNum > max) { max = maxNum; } } } return max; }
public Task create(String parentId, String parentKind, VirtualNetworkCreateSpec spec) throws ExternalException { if (spec.getReservedStaticIpSize() + DEFAULT_RESERVED_IP_LIST_SIZE > spec.getSize()) { throw new InvalidReservedStaticIpSizeException( String.format("Static IP size (%s) exceeds total IP size (%s) minus reserved IP size (%s)", spec.getReservedStaticIpSize(), spec.getSize(), DEFAULT_RESERVED_IP_LIST_SIZE)); } CreateVirtualNetworkWorkflowDocument startState = new CreateVirtualNetworkWorkflowDocument(); startState.parentId = parentId; startState.parentKind = parentKind; startState.name = spec.getName(); startState.description = spec.getDescription(); startState.routingType = spec.getRoutingType(); startState.size = spec.getSize(); startState.reservedStaticIpSize = spec.getReservedStaticIpSize(); CreateVirtualNetworkWorkflowDocument finalState = backendClient.post( CreateVirtualNetworkWorkflowService.FACTORY_LINK, startState).getBody(CreateVirtualNetworkWorkflowDocument.class); return TaskUtils.convertBackEndToFrontEnd(finalState.taskServiceState); }
@Override public void authorize(HttpRequestBase httpRequest) throws FMSException { try { oAuthConsumer.sign(httpRequest); } catch (OAuthMessageSignerException e) { throw new FMSException(e); } catch (OAuthExpectationFailedException e) { throw new FMSException(e); } catch (OAuthCommunicationException e) { throw new FMSException(e); } }
public void forEach(IntConsumer action) { java.util.Objects.requireNonNull(action); for (int i = 0; i < _limit; i++) { action.accept(_array[i]); } }
public Expression getExpression() { return expression; }
public static int decodeInt(InputStream buf) throws IOException { long r = decodeLong(buf); if (r < 0 || r >= 1L << 32) { throw new IOException("var int overflow " + r); } return (int) r; }
public Range findZBounds(XYZDataset dataset) { if (dataset != null) { return DatasetUtilities.findZBounds(dataset); } else { return null; } }
@Override public AdaptrisMessage newMessage(byte[] payload) { return newMessage(defaultPayloadId(), payload, null); }
public Column columnOrThrow() { return column().orElseThrow(() -> new IllegalStateException( getClass().getSimpleName() + MUST_HAVE_A + Column.class.getSimpleName() + DOCUMENT_TEXT )); }
@Override public ByteBuffer encode(CoapMessage message, Void context) { LOG.debug("encoding {}", message); int size = HEADER_SIZE + message.getToken().length; int delta = 0; for (CoapOption opt : message.getOptions()) { int code = opt.getType().getCode(); delta = code - delta; if (delta < 13) { size += 1; } else if (delta < 256 + 13) { size += 2; } else if (delta < 65536 + 269) { size += 3; } int optLength = opt.getData().length; if (optLength < 13) { size += 0; } else if (optLength < 256 + 13) { size += 1; } else if (optLength < 65536 + 269) { size += 2; } size += optLength; } if (message.getPayload() != null && message.getPayload().length > 0) { size += 1; size += message.getPayload().length; } ByteBuffer buffer = ByteBuffer.allocate(size); buffer.order(ByteOrder.BIG_ENDIAN); buffer.put((byte) (((message.getVersion() & 0x03) << 6) | (message.getType().getCode() & 0x03) << 4 | (message .getToken().length & 0x0F))); buffer.put((byte) message.getCode()); buffer.putShort((short) message.getId()); buffer.put(message.getToken()); int lastOptCode = 0; for (CoapOption opt : message.getOptions()) { int optionDelta = opt.getType().getCode() - lastOptCode; int deltaQuartet = getQuartet(optionDelta); int optionLength = opt.getData().length; int optionQuartet = getQuartet(optionLength); buffer.put((byte) ((deltaQuartet << 4) | optionQuartet)); if (deltaQuartet == 13) { buffer.put((byte) (optionDelta - 13)); } else if (deltaQuartet == 14) { buffer.putShort((short) (optionDelta - 269)); } if (optionQuartet == 13) { buffer.put((byte) (optionLength - 13)); } else if (optionQuartet == 14) { buffer.putShort((short) (optionLength - 269)); } buffer.put(opt.getData()); lastOptCode = opt.getType().getCode(); } if (message.getPayload() != null && message.getPayload().length > 0) { buffer.put((byte) 0xFF); buffer.put(message.getPayload()); } buffer.flip(); return buffer; }
public Map<String,String> refund(Map<String, String> paramMap){ return UnionPayConfig.getInstance().refund(paramMap); }
public static RecordBuilder record() { return new RecordBuilderImpl(); }
@VisibleForTesting static TableMetadata getTableMetadata(EdgeType edgeType) { ImmutableList.Builder<ColumnMetadata> columnBuilder = ImmutableList.builder(); switch (edgeType) { case LAYER3: columnBuilder.add( new ColumnMetadata( COL_INTERFACE, Schema.INTERFACE, "Interface from which the edge originates", Boolean.TRUE, Boolean.FALSE)); columnBuilder.add( new ColumnMetadata(COL_IPS, Schema.set(Schema.IP), "IPs", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_INTERFACE, Schema.INTERFACE, "Interface at which the edge terminates", Boolean.TRUE, Boolean.FALSE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_IPS, Schema.set(Schema.IP), "Remote IPs", Boolean.FALSE, Boolean.TRUE)); break; case BGP: columnBuilder.add( new ColumnMetadata( COL_NODE, Schema.NODE, "Node from which the edge originates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_IP, Schema.IP, "IP at the side of originator", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_INTERFACE, Schema.STRING, "Interface at which the edge originates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_AS_NUMBER, Schema.STRING, "AS Number at the side of originator", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_NODE, Schema.NODE, "Node at which the edge terminates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_IP, Schema.IP, "IP at the side of the responder", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_INTERFACE, Schema.STRING, "Interface at which the edge terminates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_AS_NUMBER, Schema.STRING, "AS Number at the side of responder", Boolean.FALSE, Boolean.TRUE)); break; case VXLAN: columnBuilder.add( new ColumnMetadata( COL_VNI, Schema.INTEGER, "VNI of the VXLAN tunnel edge", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_NODE, Schema.NODE, "Node from which the edge originates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_NODE, Schema.NODE, "Node at which the edge terminates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_VTEP_ADDRESS, Schema.IP, "VTEP IP of node from which the edge originates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_VTEP_ADDRESS, Schema.IP, "VTEP IP of node at which the edge terminates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_VLAN, Schema.INTEGER, "VLAN associated with VNI on node from which the edge originates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_VLAN, Schema.INTEGER, "VLAN associated with VNI on node at which the edge terminates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_UDP_PORT, Schema.INTEGER, "UDP port of the VXLAN tunnel transport", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_MULTICAST_GROUP, Schema.IP, "Multicast group of the VXLAN tunnel transport", Boolean.FALSE, Boolean.TRUE)); break; case IPSEC: columnBuilder.add( new ColumnMetadata( COL_SOURCE_INTERFACE, Schema.INTERFACE, "Source interface used in the IPsec session", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_TUNNEL_INTERFACE, Schema.INTERFACE, "Tunnel interface (if any) used in the IPsec session", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_SOURCE_INTERFACE, Schema.INTERFACE, "Remote source interface used in the IPsec session", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_TUNNEL_INTERFACE, Schema.INTERFACE, "Remote tunnel interface (if any) used in the IPsec session", Boolean.FALSE, Boolean.TRUE)); break; case OSPF: case ISIS: case EIGRP: case LAYER1: default: columnBuilder.add( new ColumnMetadata( COL_INTERFACE, Schema.INTERFACE, "Interface from which the edge originates", Boolean.FALSE, Boolean.TRUE)); columnBuilder.add( new ColumnMetadata( COL_REMOTE_INTERFACE, Schema.INTERFACE, "Interface at which the edge terminates", Boolean.FALSE, Boolean.TRUE)); } return new TableMetadata(columnBuilder.build(), "Display Edges"); }
@Override public <C, R> SimpleCase<C, R> selectCase(final Expression<? extends C> expression) { throw new UnsupportedOperationException(); }
@Override public void handle(String callId, GetMonitoringReportRequest request) { if (request.getMonitoringCriteria() != null && request.getMonitoringCriteria().contains(MonitoringCriterium.PERIODIC_MONITORING)) { stationMessageSender.sendCallResult(callId, new GetMonitoringReportResponse().withStatus(GetMonitoringReportResponse.Status.NOT_SUPPORTED)); return; } Map<ComponentVariable, List<SetMonitoringDatum>> monitoredComponents; if (request.getComponentVariable() != null && !request.getComponentVariable().isEmpty()) { monitoredComponents = stationComponentsHolder.getByComponentAndVariable(request.getComponentVariable()); } else { monitoredComponents = stationComponentsHolder.getAllMonitoredComponents(); } Set<SetMonitoringDatum.Type> requestedType = convertCriteriaToMonitorType(Optional.ofNullable(request.getMonitoringCriteria()).orElseGet(ArrayList::new)); monitoredComponents.replaceAll((k, v) -> v.stream().filter(d -> requestedType.contains(d.getType())).collect(Collectors.toList())); if (monitoredComponents.isEmpty() || monitoredComponents.values().stream().allMatch(List::isEmpty)) { stationMessageSender.sendCallResult(callId, new GetMonitoringReportResponse().withStatus(GetMonitoringReportResponse.Status.REJECTED)); } else { stationMessageSender.sendCallResult(callId, new GetMonitoringReportResponse().withStatus(GetMonitoringReportResponse.Status.ACCEPTED)); stationMessageSender.sendNotifyMonitoringReport(request.getRequestId(), monitoredComponents); } }
protected Name getReverseZoneName(Configuration conf) { Name name = null; String zoneSubnet = getZoneSubnet(conf); if (zoneSubnet == null) { LOG.warn("Zone subnet is not configured. Reverse lookups disabled"); } else { String mask = conf.get(KEY_DNS_ZONE_MASK); if (mask != null) { SubnetUtils utils = new SubnetUtils(zoneSubnet, mask); name = getReverseZoneName(utils, zoneSubnet); } else { name = getReverseZoneName(zoneSubnet); } } return name; }
@Override public void linesRemoved(int amount) { removedLinesWithoutOverflown += amount; super.linesRemoved(amount); }
protected Color getAtomColor(IAtom atom, RendererModel model) { Color atomColor = model.get(AtomColor.class); if ((Boolean) model.get(ColorByType.class)) { atomColor = ((IAtomColorer) model.get(AtomColorer.class)).getAtomColor(atom); } return atomColor; }
public boolean includes(@Nullable Integer integer) { return integer != null && includes(integer.intValue()); }
protected void enableCreateCollectionContainer(boolean toEnable) { showCreateCollectionContainer(toEnable); showDefineCollectionContainer(!toEnable); showAddItemButton(toEnable); createCollectionRadio.setChecked(toEnable); defineCollectionRadio.setChecked(!toEnable); if (listWidget) { createLabel.setInnerText(ScenarioSimulationEditorConstants.INSTANCE.createLabelList()); } else { createLabel.setInnerText(ScenarioSimulationEditorConstants.INSTANCE.createLabelMap()); } }
@Override protected Map<String, String> getInternalAddressesAndPorts( ContainerInfo containerInfo, String internalHost) { Map<String, List<PortBinding>> portBindings = containerInfo.getNetworkSettings().getPorts(); return getExposedPortsToAddressPorts(internalHost, portBindings); }
@Override public boolean canReadProperties() { return false; }
public static boolean getOptionalBooleanParameter(Map<String, String> parameters, String parameterName, boolean defaultValue) throws JournalException { validateParameters(parameters); validateParameterName(parameterName); String string = parameters.get(parameterName); if (string == null) { return defaultValue; } else if (string.equals(VALUE_FALSE)) { return false; } else if (string.equals(VALUE_TRUE)) { return true; } else { throw new JournalException("'" + parameterName + "' parameter must be '" + VALUE_FALSE + "'(default) or '" + VALUE_TRUE + "'"); } }
@Override public Optional<DataSet> find(com.thinkbiganalytics.metadata.api.catalog.DataSet.ID id) { return Optional.ofNullable(findById(id)); }
@Override public BigDecimal hour(XMLGregorianCalendar dateTime) { return this.feelLib.hour(dateTime); }
@Override public AMQMessage convert(Message_1_0 serverMsg, NamedAddressSpace addressSpace) { return new AMQMessage(convertToStoredMessage(serverMsg, addressSpace), null); }
List<File> getMatchingFiles() { long now = TimeUnit.SECONDS.toMillis( TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis())); long currentParentDirMTime = parentDir.lastModified(); List<File> result; if (!cachePatternMatching || lastSeenParentDirMTime < currentParentDirMTime || !(currentParentDirMTime < lastCheckedTime)) { lastMatchedFiles = sortByLastModifiedTime(getMatchingFilesNoCache()); lastSeenParentDirMTime = currentParentDirMTime; lastCheckedTime = now; } return lastMatchedFiles; }
@GetMapping(value = "/{applicationId}/view") public String viewInvite(Model model, @PathVariable("competitionId") long competitionId, @PathVariable("applicationId") long applicationId) { InterviewAssignmentApplicationsSentInviteViewModel viewModel = interviewApplicationSentInviteModelPopulator.populate(competitionId, applicationId); model.addAttribute("model", viewModel); return "assessors/interview/application-view-invite"; }
public static String getPattern(Locale locale) { requireNonNull(locale, "locale must not be null"); String registeredPattern = LANGUAGE_PATTERNS.get(locale.getLanguage()); if (registeredPattern != null) { return registeredPattern; } else { return defaultLocalePattern(locale); } }
protected boolean checkForInequality(Object left, Object right) { if (left == right) { return false; } if (left == null) { return true; } return !left.equals(right); }
public String linkId() { return linkId; }
public static InetAddress getLocalAddress() { if (LOCAL_ADDRESS != null) { return LOCAL_ADDRESS; } InetAddress localAddress = getLocalAddress0(); LOCAL_ADDRESS = localAddress; return localAddress; }
public String getCode() { return code != null ? code : UNKNOWN_ERROR; }
public String get(String input) { if (input.contains(", ")) { String[] inputs = input.split(", "); int[] ints = new int[inputs.length]; try { for (int index = 0; index < inputs.length; index++) { ints[index] = Integer.parseInt(inputs[index]); } return get(ints); } catch (NumberFormatException e) { return get(inputs); } } try { int number = Integer.parseInt(input); return get(number); } catch (NumberFormatException e) { throw new IllegalStateException("You should override one of 'get' methods"); } }
public static Region parseRegion(String value) { if (StringUtils.isEmpty(value)) { throw new IllegalArgumentException(String.format(ExceptionMsgs.INVALID_VALUE_FOR_INPUT, value, InputNames.REGION)); } String[] coords = value.split("[,]"); if (coords.length != 4) { throw new IllegalArgumentException(ExceptionMsgs.INVALID_NR_OF_COORDS); } int left = Integer.parseInt(coords[0]); int top = Integer.parseInt(coords[1]); int right = Integer.parseInt(coords[2]); int bottom = Integer.parseInt(coords[3]); return new Region(left, top, right, bottom); }
public ProcessingItem createPi(Processor processor, int paralellism) { return new SimpleProcessingItem(processor, paralellism); }
public StifRecord read() throws IOException { int recordStart; int end = -1; StifRecordFactory<?> factory; while (true) { end = -1; while (end == -1) { for (int i = start; i < bufferEnd; ++i) { if (buffer[i] == '\r') { end = i; break; } } if (end != -1) { break; } ByteBuffer bbuffer = ByteBuffer.wrap(buffer); if (start < BUFFER_SIZE) { bbuffer.put(buffer, start, BUFFER_SIZE - start); bufferEnd = bufferEnd - start; } else { bufferEnd = 0; inputStream.read(buffer, bufferEnd, start - BUFFER_SIZE); } if (BUFFER_SIZE == bufferEnd) { throw new IOException("Too-long line trying to read STIF"); } int bytesRead = inputStream.read(buffer, bufferEnd, BUFFER_SIZE - bufferEnd); if (bytesRead == -1) { if (start >= bufferEnd) { return null; } else { throw new RuntimeException( "Parse error: stif requires trailing newline"); } } bufferEnd += bytesRead; start = 0; } recordStart = start; start = end + 2; int recordType = Integer .parseInt(new String(buffer, recordStart, 2)); factory = recordFactories.get(recordType); if (factory != null) { break; } } return factory.createRecord(buffer, recordStart, end); }
@Override protected @NonNull JobData migrate(@NonNull JobData jobData) { switch(jobData.getFactoryKey()) { case "MultiDeviceContactUpdateJob": return migrateMultiDeviceContactUpdateJob(jobData); case "MultiDeviceRevealUpdateJob": return migrateMultiDeviceViewOnceOpenJob(jobData); case "RequestGroupInfoJob": return migrateRequestGroupInfoJob(jobData); case "SendDeliveryReceiptJob": return migrateSendDeliveryReceiptJob(jobData); case "MultiDeviceVerifiedUpdateJob": return migrateMultiDeviceVerifiedUpdateJob(jobData); case "RetrieveProfileJob": return migrateRetrieveProfileJob(jobData); case "PushGroupSendJob": return migratePushGroupSendJob(jobData); case "PushGroupUpdateJob": return migratePushGroupUpdateJob(jobData); case "DirectoryRefreshJob": return migrateDirectoryRefreshJob(jobData); case "RetrieveProfileAvatarJob": return migrateRetrieveProfileAvatarJob(jobData); case "MultiDeviceReadUpdateJob": return migrateMultiDeviceReadUpdateJob(jobData); case "PushTextSendJob": return migratePushTextSendJob(jobData); case "PushMediaSendJob": return migratePushMediaSendJob(jobData); case "SmsSendJob": return migrateSmsSendJob(jobData); default: return jobData; } }
@Override public DiscoveredResourceDetails discoverResource(Configuration pluginConfiguration, ResourceDiscoveryContext context) throws InvalidPluginConfigurationException { PortNetServiceComponentConfiguration componentConfiguration = PortNetServiceComponent .createComponentConfiguration(pluginConfiguration); String resourceKey = createResourceKey(componentConfiguration); return new DiscoveredResourceDetails(context.getResourceType(), resourceKey, resourceKey, null, null, pluginConfiguration, null); }
@Override public void flushPluginMap() { throw new UnsupportedOperationException(); }
public IBencodedValue decode(InStream inStream) { try { charactersRead = 0; return decodeNextValue(inStream); } catch (IOException e) { throw new IllegalArgumentException("Failed to decode bencoded values.", e); } }
public static String convertToString(Locale locale) { if (locale == null) { return null; } String languageCountry = locale.getCountry(); return locale.getLanguage() + (isNotBlank(languageCountry) ? "-" + languageCountry : EMPTY); }
public void endOnline(String redirectLink) throws IOException { String uri = address + "api/active/receiver/stop"; LinkedList<FormBodyPart> partsList = new LinkedList<>(); partsList.add(new FormBodyPart("redirect", new StringBody(redirectLink))); query(createPost(uri, partsList), 205); }
boolean isTab(final KeyDownEvent event) { return Objects.equals(event.getNativeKeyCode(), KeyCodes.KEY_TAB); }
public void validateRpd1s3() { Elements linkElements = getElements("a"); for (String hrefValue : getAttributeValues(linkElements, "href")) { assertFalse(Type.ERROR, "rpd1s3.javascript", hrefValue.startsWith("javascript:")); } List<String> forbiddenAttributes = Arrays.asList(ATTR_BLUR, ATTR_CHANGE, ATTR_CLICK, ATTR_FOCUS, ATTR_LOAD, ATTR_MOUSEOVER, ATTR_SELECT, ATTR_SELECT, ATTR_UNLOAD); for (Element linkElement : linkElements) { if (!ListUtils.intersection(getAttributeNames(linkElement), forbiddenAttributes).isEmpty()) { assertFalse(Type.ERROR, "rpd1s3.inlineEventHandlers", getAttributeValue(linkElement, ATTR_HREF).equals( "") || getAttributeValue(linkElement, ATTR_HREF).equals("#")); } } validateRpd1s3AboutForms(); }
public boolean isDag() { DirectedGraph<T, Pair> graph = new DefaultDirectedGraph<>(Pair.class); Set<? extends T> initialNodes = initialNodes(); Set<T> knownNodes = new HashSet<>(initialNodes.size() * 10); Deque<T> nodePath = new ArrayDeque<>(20); boolean isDag = tryAdd(initialNodes, graph, knownNodes, new CycleDetector<>(graph), nodePath); if (!isDag) { this.badNodes = nodePath; } return isDag; }
public static LiveHttpRequest doOnComplete(LiveHttpRequest request, Runnable action) { return request.newBuilder() .body(it -> it.doOnEnd(ifSuccessful(action))) .build(); }
@Override public List<GlobMatcher> getResult() { return globMatchers; }
public static ByteBuf wrappedBuffer(byte[] array) { if (array.length == 0) { return EMPTY_BUFFER; } return new UnpooledHeapByteBuf(ALLOC, array, array.length); }
@Override public String getName() { return name; }
public byte[] getUnitTopics() { TopicList topicList = new TopicList(); try { try { this.lock.readLock().lockInterruptibly(); Iterator<Entry<String, List<QueueData>>> topicTableIt = this.topicQueueTable.entrySet().iterator(); while (topicTableIt.hasNext()) { Entry<String, List<QueueData>> topicEntry = topicTableIt.next(); String topic = topicEntry.getKey(); List<QueueData> queueDatas = topicEntry.getValue(); if (queueDatas != null && queueDatas.size() > 0 && TopicSysFlag.hasUnitFlag(queueDatas.get(0).getTopicSynFlag())) { topicList.getTopicList().add(topic); } } } finally { this.lock.readLock().unlock(); } } catch (Exception e) { log.error("getAllTopicList Exception", e); } return topicList.encode(); }
@Override public PreferenceScopeResolutionStrategyInfo getUserInfoFor(final String scopeType, final String scopeKey) { return preferenceScopeResolutionStrategy.getInfo(); }
@Override public int hashCode() { int result = 193; result = 37 * result + HashUtilities.hashCodeForPaint(this.paint); result = 37 * result + this.gradientPaintTransformer.hashCode(); return result; }
@Inline(value = "add($1, $2, $3, false, false)") public static <E> int addIfAbsent(List<E> list, Comparator<? super E> comparator, E data) { return add(list, comparator, data, false, false); }
public static VitalScoreDetails from(ScoreOuterClass.VitalScoreDetails sc2ApiVitalScoreDetails) { require("sc2api vital score details", sc2ApiVitalScoreDetails); return new VitalScoreDetails(sc2ApiVitalScoreDetails); }
public int getAndSet(int index, int value) { Validate.inclusiveBetween(0, maxEntryValue, value); int bitStartIndex = index * bitsPreEntry; int arrayStartIndex = bitStartIndex >>> 6; int arrayEndIndex = (bitStartIndex + bitsPreEntry - 1) >>> 6; Validate.inclusiveBetween(0, array.length - 1, arrayEndIndex); int offset = bitStartIndex & 63; long oldValue = array[arrayStartIndex] >>> offset; array[arrayStartIndex] = array[arrayStartIndex] & ~(maxEntryValue << offset) | (long) value << offset; if (arrayStartIndex != arrayEndIndex) { offset = 64 - offset; oldValue |= array[arrayEndIndex] << offset; int offsetEnd = bitsPreEntry - offset; this.array[arrayEndIndex] = this.array[arrayEndIndex] >>> offsetEnd << offsetEnd | (long) value >> offset; } return (int) (oldValue & maxEntryValue); }
public Version version() { return version; }
private static JsonValue wrapJSONArray(@NonNull JSONArray jsonArray) throws JsonException { List<JsonValue> list = new ArrayList<>(jsonArray.length()); for (int i = 0; i < jsonArray.length(); i++) { if (!jsonArray.isNull(i)) { list.add(wrap(jsonArray.opt(i))); } } return new JsonValue(new JsonList(list)); }
public double getNorthing() { return northing; }
public static OpenApiModelInfo parse(final String specification, final APIValidationContext validationContext) { final OpenApiModelInfo.Builder resultBuilder = new OpenApiModelInfo.Builder(); final String resolvedSpecification; try { resolvedSpecification = resolve(specification); resultBuilder.resolvedSpecification(resolvedSpecification); } catch (final Exception e) { LOG.debug("Unable to resolve OpenAPI document\n{}\n", specification, e); return resultBuilder .addError(new Violation.Builder().error("error").property("").message("Unable to resolve OpenAPI document from: " + ofNullable(specification).map(s -> StringUtils.abbreviate(s, 100)).orElse("")).build()) .build(); } final JsonNode tree; try { tree = JsonUtils.reader().readTree(resolvedSpecification); } catch (final IOException e) { return new OpenApiModelInfo.Builder() .addError(new Violation.Builder() .property("") .error("unreadable-document") .message("Unable to read OpenAPI document: " + e.getMessage()) .build()) .build(); } OpenApiVersion openApiVersion = getOpenApiVersion(tree); if (openApiVersion == null) { return new OpenApiModelInfo.Builder() .addError(new Violation.Builder() .property("") .error("unsupported-version") .message(String.format("This document cannot be uploaded. " + "Provide an OpenAPI document (supported versions are %s).", OpenApiVersion.getSupportedVersions())) .build()) .build(); } final Document parsed = Library.readDocumentFromJSONString(resolvedSpecification); if (!(parsed instanceof OasDocument)) { LOG.debug("Unable to read OpenAPI document\n{}\n", specification); return resultBuilder .addError(new Violation.Builder() .error("error") .property("") .message("Unable to read OpenAPI document from: '" + StringUtils.abbreviate(resolvedSpecification, 100)).build()) .build(); } resultBuilder.model((OasDocument) parsed); if (validationContext != APIValidationContext.NONE) { try { validateJsonSchema(convertToJson(resolvedSpecification), resultBuilder, openApiVersion, parsed.getClass()); } catch (IOException e) { return resultBuilder .addError(new Violation.Builder() .error("error") .property("") .message("Unable to read OpenAPI document from: '" + StringUtils.abbreviate(resolvedSpecification, 100)).build()) .build(); } return applyValidationRules(validationContext, resultBuilder.build(), openApiVersion); } return resultBuilder.build(); }
@Nonnull protected Optional<ProcessGroupDTO> deleteWithRetries(@Nonnull final ProcessGroupDTO processGroup, final int retries, final int timeout, @Nonnull final TimeUnit timeUnit) { schedule(processGroup.getId(), processGroup.getParentGroupId(), NiFiComponentState.STOPPED); Exception lastError = null; for (int count = 0; count <= retries; ++count) { try { return doDelete(processGroup); } catch (final WebApplicationException e) { if (e.getResponse().getStatus() == 409) { lastError = e; Uninterruptibles.sleepUninterruptibly(timeout, timeUnit); } else { throw new NifiClientRuntimeException(e); } } } throw new NifiClientRuntimeException("Unable to delete process group: " + processGroup.getId(), lastError); }
public void parse() throws AisMessageException, SixbitException { BinArray binArray = vdm.getBinArray(); if (binArray.getLength() != 96) { throw new AisMessageException("Message 27 wrong length " + binArray.getLength()); } super.parse(binArray); this.posAcc = (int) binArray.getVal(1); this.raim = (int) binArray.getVal(1); this.navStatus = (int) binArray.getVal(4); this.pos = new AisPosition(); this.pos.setRawLongitude(binArray.getVal(18)); this.pos.setRawLatitude(binArray.getVal(17)); this.pos.set1817(); this.sog = (int) binArray.getVal(6); this.cog = (int) binArray.getVal(9); this.gnssPosStatus = (int) binArray.getVal(1); this.spare = (int) binArray.getVal(1); }
@Override public PartitionsStatsRequest transformInboundPartitionsStatsRequest(PartitionsStatsRequest request) { request.setDbName(metaStoreMapping.transformInboundDatabaseName(request.getDbName())); return request; }
@Override public String generateId() { return uuidStrategy.generateId(); }
@Override public boolean canRead(Type type) { return type instanceof Class && (((Class<?>) type).isAnnotationPresent(XmlRootElement.class) || ((Class<?>) type).isAnnotationPresent(XmlType.class)); }
@Override public void handle(CommitterEvent event) { try { eventQueue.put(event); } catch (InterruptedException e) { throw new YarnRuntimeException(e); } }
@Override public Optional<Integer> findSingle(int appReleaseId) { List<AppReleaseRelation> result = appReleaseRelationDao.findByAppReleaseId(appReleaseId); if(result.isEmpty()) { return Optional.empty(); } if(result.size() == 1) { return Optional.of(result.get(0).getDependAppReleaseId()); } logger.error("期望最多找到一个依赖的 APP，但是却找到了 {} 个", result.size()); return Optional.empty(); }
@Override public Class[] getInputTypes() { return new Class[]{String.class, File.class}; }
@Override public boolean equals(Object obj) { if (obj == this) { return true; } if (obj instanceof DefaultBoxAndWhiskerCategoryDataset) { DefaultBoxAndWhiskerCategoryDataset dataset = (DefaultBoxAndWhiskerCategoryDataset) obj; return ObjectUtilities.equal(this.data, dataset.data); } return false; }
public List<ConsumerRole> assignNamespaceRoleToConsumer(String token, String appId, String namespaceName) { return assignNamespaceRoleToConsumer(token, appId, namespaceName, null); }
protected static List<GafferScannerProcessor> createProcessors( final Scan scan, final Schema schema, final ElementSerialisation serialisation) { final List<GafferScannerProcessor> processors = new ArrayList<>(); final Set<Class<? extends GafferScannerProcessor>> extraProcessors = getExtraProcessors(scan); final View view = getView(scan); if (null != view) { processors.add(new GroupFilterProcessor(view)); if (extraProcessors.remove(ElementDedupeFilterProcessor.class)) { processors.add(new ElementDedupeFilterProcessor(view.hasEntities(), view.hasEdges(), getDirectedType(scan))); } } if (schema.isAggregationEnabled()) { processors.add(new StoreAggregationProcessor(serialisation, schema)); } processors.add(new ValidationProcessor(schema)); if (null != view) { processors.add(new PreAggregationFilterProcessor(view)); if (schema.isAggregationEnabled()) { processors.add(new QueryAggregationProcessor(serialisation, schema, view)); } processors.add(new PostAggregationFilterProcessor(view)); } if (!extraProcessors.isEmpty()) { throw new RuntimeException("Unrecognised extra processors: " + extraProcessors); } return processors; }
@Override public boolean isAllowed() { boolean allowed = false; boolean canTrasmitOnWAN = context.getConfiguration().optBoolean(ALLOW_WAN_KEY, ALLOW_WAN_DEFAULT) && isWanAllowed; if (connectivity.isConnected()) { allowed = connectivity.hasWifi() || connectivity.hasWired() || (connectivity.hasWAN() && canTrasmitOnWAN); } return allowed; }
@Override public void setRowIndex(int rowIndex) { ensureOpen(); if (rowIndex == currentIndex) { return; } if (rowIndex < 0) { throw new IllegalArgumentException("Cannot set row index to a number less than 0."); } if (rowIndex < currentIndex) { first(); } while (rowIndex > currentIndex && hasNext()) { next(); } }
public void addTreeModelListener(TreeModelListener listener) { if (!d_listeners.contains(listener)) { d_listeners.add(listener); } }
public static ParsedTemporal parse(String rawDate) { return parse("", "", "", rawDate); }
public List<Image> findBootloaderImages(String hardware, String model, String key, String current) throws JSONException { JSONObject models= root.getJSONObject(hardware); JSONObject builds = models.getJSONObject(model); JSONObject versions = builds.getJSONObject("bootloader"); ArrayList<Image> acc = new ArrayList<>(); Version keyVersion = new Version(key); while(new Version(current).compareTo(keyVersion) > 0) { acc.add(0, verifyImage( hardware, model, "bootloader", current, versions.getJSONObject(current) )); current = acc.get(0).requiredBootloader; } return acc; }
@Override public Object create(Object request, SpecimenContext context) { if (!this.specification.isSatisfiedBy(request)) { return new NoSpecimen(); } if(!(request instanceof SpecimenType)) { return new NoSpecimen(); } SpecimenType specimenType = (SpecimenType)request; List<Method> factoryMethods = this.factoryMethodQuery.getFactoryMethodsForType(specimenType); if (factoryMethods.isEmpty()) { return new NoSpecimen(); } for (Method method : factoryMethods) { try { Object specimen = context.resolve(new FactoryMethodRequest(method, specimenType)); if (!(specimen instanceof NoSpecimen)) { return specimen; } } catch (ObjectCreationException e) { } } return new NoSpecimen(); }
public GadgetsHandlerApi.JsResponse getJs(GadgetsHandlerApi.JsRequest request) throws ProcessingException { verifyBaseParams(request, false); Set<String> fields = beanFilter.processBeanFields(request.getFields()); JsUri jsUri = createJsUri(request); Uri servedUri = jsUriManager.makeExternJsUri(jsUri); String content = null; Long expireMs = null; if (isFieldIncluded(fields, "jsContent")) { JsResponse response; try { response = jsPipeline.execute(jsRequestBuilder.build(jsUri, servedUri.getAuthority())); } catch (JsException e) { throw new ProcessingException(e.getMessage(), e.getStatusCode()); } content = response.toJsString(); if (response.isProxyCacheable()) { expireMs = getDefaultExpiration(); } } else { expireMs = getDefaultExpiration(); } return createJsResponse(request.getUrl(), servedUri, content, fields, expireMs); }
public static Integer tryParse(String value, int defaultValue) { try { return Integer.parseInt(value); } catch (NumberFormatException e) { return defaultValue; } }
public static String extractValueFromQueryStringAndKey(String key, String queryString) throws IllegallyFormattedQueryStringException { if (queryString == null) { queryString = ""; } if (queryString.endsWith("/")) { queryString = queryString.substring(0, queryString.length() - 1); } StringTokenizer queryItems = new StringTokenizer(queryString, "&"); while (queryItems.hasMoreTokens()) { String queryParameter = queryItems.nextToken(); StringTokenizer paramTokenizer = new StringTokenizer(queryParameter, "="); if (paramTokenizer.countTokens() != 2) { continue; } String currentKey = paramTokenizer.nextToken(); String currentValue = paramTokenizer.nextToken(); if (currentKey.equalsIgnoreCase(key)) { return currentValue; } } throw new IllegallyFormattedQueryStringException( "Expected key '" + key + "' not found in query string" + queryString + "'"); }
public String sendRequest(final String sessionId, Request request) throws SDKBadRequestException { if (request.getType() == null) { throw new SDKBadRequestException(SDKErrorEnum.badRequestError, "Request type (method) is missing!"); } URI uri = buildURI(request); LOGGER.debug("Using URL: " + uri.toString()); HttpRequestBase requestBase; switch (request.getType()) { case POST: HttpPost post = new HttpPost(uri); fillRequestEntity(post, request); requestBase = post; break; case GET: requestBase = new HttpGet(uri); break; case PATCH: HttpPatch patch = new HttpPatch(uri); fillRequestEntity(patch, request); requestBase = patch; break; case PUT: HttpPut put = new HttpPut(uri); fillRequestEntity(put, request); requestBase = put; break; case DELETE: requestBase = new HttpDelete(uri); break; default: LOGGER.error("Request type not supported."); throw new SDKBadRequestException(SDKErrorEnum.badRequestError, SdkConstants.APPLIANCE); } for (Header header : request.getHeaders()) { requestBase.addHeader(header); } if (StringUtils.isNotBlank(sessionId)) { requestBase.setHeader(SdkConstants.AUTH_HEADER, sessionId); } return getResponse(sessionId, requestBase, request.isForceReturnTask(), request.getDownloadPath()); }
protected Map<DDMFormEvaluatorFieldContextKey, Map<String, Object>> getDDMFormFieldsPropertyChanges() { return _ddmFormFieldsPropertyChanges; }
public void addFamilyWithNestedRule() { System.out.printf("%nCreating column family %s with a nested GC rule%n", COLUMN_FAMILY_5); VersionRule versionRule1 = GCRULES.maxVersions(10); VersionRule versionRule2 = GCRULES.maxVersions(2); DurationRule maxAgeRule = GCRULES.maxAge(30, TimeUnit.DAYS); IntersectionRule intersectionRule = GCRULES.intersection().rule(maxAgeRule).rule(versionRule2); UnionRule unionRule = GCRULES.union().rule(intersectionRule).rule(versionRule1); try { ModifyColumnFamiliesRequest columnFamiliesRequest = ModifyColumnFamiliesRequest.of(tableId).addFamily(COLUMN_FAMILY_5, unionRule); adminClient.modifyFamilies(columnFamiliesRequest); System.out.println("Created column family: " + COLUMN_FAMILY_5); } catch (AlreadyExistsException e) { System.err.println( "Failed to create column family with rule, already exists: " + e.getMessage()); } }
void schedule(TriggerTask task, ZonedDateTime time) { ZonedDateTime now = ZonedDateTime.now(clock); Duration delay = Duration.between(now, time); scheduler.schedule(() -> executeTask(task, time), delay.toNanos(), TimeUnit.NANOSECONDS); }
TreeNode buildTree(ArrayList<Record> records) throws InvalidRecordsException { records.sort(Comparator.comparing(Record::getRecordId)); ArrayList<Integer> orderedRecordIds = new ArrayList<>(); for (Record record : records) { orderedRecordIds.add(record.getRecordId()); } if (records.size() > 0) { if (orderedRecordIds.get(orderedRecordIds.size() - 1) != orderedRecordIds.size() - 1) { throw new InvalidRecordsException("Invalid Records"); } if (orderedRecordIds.get(0) != 0) { throw new InvalidRecordsException("Invalid Records"); } } ArrayList<TreeNode> treeNodes = new ArrayList<>(); for (int i = 0; i < orderedRecordIds.size(); i++) { for (Record record : records) { if (orderedRecordIds.get(i) == record.getRecordId()) { if (record.getRecordId() == 0 && record.getParentId() != 0) { throw new InvalidRecordsException("Invalid Records"); } if (record.getRecordId() < record.getParentId()) { throw new InvalidRecordsException("Invalid Records"); } if (record.getRecordId() == record.getParentId() && record.getRecordId() != 0) { throw new InvalidRecordsException("Invalid Records"); } treeNodes.add(new TreeNode(record.getRecordId())); } } } for (int i = 0; i < orderedRecordIds.size(); i++) { TreeNode parent; for (TreeNode n: treeNodes) { if (i == n.getNodeId()) { parent = n; for (Record record : records) { if (record.getParentId() == i) { for (TreeNode node : treeNodes) { if (node.getNodeId() == 0) { continue; } if (record.getRecordId() == node.getNodeId()) { parent.getChildren().add(node); } } } } break; } } } if (treeNodes.size() > 0) { return treeNodes.get(0); } return null; }
public static MethodMatchers methodMatchers(String descriptor) { Matcher matcher = METHOD_PATTERN.matcher(descriptor); if (!matcher.find()) { throw new IllegalArgumentException("Illegal method specification: " + descriptor); } MethodMatchers.ParametersBuilder methodMatcher = MethodMatchers.create().ofTypes(matcher.group(1)).names(matcher.group(2)); return collectArguments(descriptor, matcher, 3, methodMatcher); }
public static boolean getEnforcedBooleanCondition(String input, boolean enforcedBoolean) { return (enforcedBoolean) ? isTrueOrFalse(input) == Boolean.parseBoolean(input) : Boolean.parseBoolean(input); }
static FileType parseFileExtension(String fileExtension) { return Arrays.stream(FileType.values()) .filter(fileType -> fileType.name().equalsIgnoreCase(fileExtension)) .findFirst() .orElse(null); }
public void setRoleName(String roleName) { if (null == roleName) { throw new NullPointerException("You must specifiy a valid role name."); } this.roleName = roleName; setCredentialUrl(); }
@RequestMapping(method = RequestMethod.POST) public Widget create(@RequestBody Widget widget, @RequestParam(value = "duplicata", required = false) String sourceWidgetId) throws IllegalArgumentException { Widget newWidget = widgetRepository.create(widget); if(isNotEmpty(sourceWidgetId)) { assetService.duplicateAsset(widgetPath, widgetRepository.resolvePath(sourceWidgetId), sourceWidgetId, newWidget.getId()); } return newWidget; }
public Mono<DocumentEntity> archiveDocument(final DocumentArchivingContext documentArchivingContext) { return documentCreationContextFactory.newContext(documentArchivingContext) .flatMap(documentEntityFactory::newDocumentEntity) .doOnNext(documentEntity -> vaultDocumentStorage.persistDocument(documentEntity, documentArchivingContext.getContent())) .doOnError(throwable -> handleError(throwable, documentArchivingContext)) .retry(throwable -> !isDuplicateIndexError(throwable)); }
public static MethodCall invokeSuper() { return invokeSelf().onSuper(); }
public static Short buildPort(String port, boolean mandatory) throws Exception { if (StringUtils.isEmpty(port)) { if (!mandatory) { return null; } else { throw new Exception(ExceptionMsgs.PORT_NOT_SPECIFIED); } } else { Short p = Short.parseShort(port); if (p < 1) { throw new Exception(ExceptionMsgs.INVALID_PORT_NUMBER); } return p; } }
public ProviderConfiguration discover() { Map responseAttributes = this.restTemplate.getForObject(this.providerLocation, Map.class); ProviderConfiguration.Builder builder = new ProviderConfiguration.Builder(); builder.issuer((String)responseAttributes.get(ISSUER_ATTR_NAME)); builder.authorizationEndpoint((String)responseAttributes.get(AUTHORIZATION_ENDPOINT_ATTR_NAME)); if (responseAttributes.containsKey(TOKEN_ENDPOINT_ATTR_NAME)) { builder.tokenEndpoint((String)responseAttributes.get(TOKEN_ENDPOINT_ATTR_NAME)); } if (responseAttributes.containsKey(USERINFO_ENDPOINT_ATTR_NAME)) { builder.userInfoEndpoint((String)responseAttributes.get(USERINFO_ENDPOINT_ATTR_NAME)); } if (responseAttributes.containsKey(JWK_SET_URI_ATTR_NAME)) { builder.jwkSetUri((String)responseAttributes.get(JWK_SET_URI_ATTR_NAME)); } return builder.build(); }
public static Http2Headers toHttp2Headers(final HttpMessage in, final boolean validateHeaders) { final HttpHeaders inHeaders = in.headers(); final Http2Headers out = new DefaultHttp2Headers(validateHeaders, inHeaders.size()); if (in instanceof HttpRequest) { final HttpRequest request = (HttpRequest) in; final URI requestTargetUri = URI.create(request.uri()); out.path(toHttp2Path(requestTargetUri)); out.method(request.method().asciiName()); setHttp2Scheme(inHeaders, requestTargetUri, out); if (!isOriginForm(requestTargetUri) && !isAsteriskForm(requestTargetUri)) { final String host = inHeaders.getAsString(HttpHeaderNames.HOST); setHttp2Authority( (host == null || host.isEmpty()) ? requestTargetUri.getAuthority() : host, out); } } else if (in instanceof HttpResponse) { final HttpResponse response = (HttpResponse) in; out.status(response.status().codeAsText()); } toHttp2Headers(inHeaders, out); return out; }
public void setMessage(Consumer c, ComplianceReason reason, Date onDate) { String marketingName, id; if (reason.isStacked()) { id = reason.getAttributes().get(ComplianceReason.Attributes.STACKING_ID); marketingName = getStackedMarketingName(id, c, onDate); reason.getAttributes().put(ComplianceReason.Attributes.MARKETING_NAME, marketingName); } else if (reason.isNonCovered()) { id = reason.getAttributes().get(ComplianceReason.Attributes.PRODUCT_ID); marketingName = getInstalledMarketingName(id, c); reason.getAttributes().put(ComplianceReason.Attributes.MARKETING_NAME, marketingName); } else { id = reason.getAttributes().get(ComplianceReason.Attributes.ENTITLEMENT_ID); marketingName = getMarketingName(id, c, onDate); reason.getAttributes().put(ComplianceReason.Attributes.MARKETING_NAME, marketingName); } String key = reason.getKey(); reason.setMessage(i18n.tr(getReasonMessage(key), key, reason.getAttributes().get(ComplianceReason.Attributes.COVERED), reason.getAttributes().get(ComplianceReason.Attributes.PRESENT) )); }
public static List<Token> lex(String input) { final List<Token> result = new ArrayList<>(); for (int i = 0; i < input.length();) { char c = input.charAt(i); switch (c) { case '#': result.add(HASH_TOKEN); String comment = readComment(input, i); i += comment.length() + 1; result.add(new Token(TokenType.COMMENT, comment)); break; case 'p': case 'P': result.add(PREFIX_KEYWORD_TOKEN); String prefix = readPrefix(input, i); result.add(new Token(TokenType.PREFIX, prefix.trim())); i = i + prefix.length() + 7; break; case 'b': case 'B': result.add(BASE_KEYWORD_TOKEN); i += 4; break; case '<': result.add(LBRACKET_TOKEN); String iri = readIRI(input, i); result.add(new Token(TokenType.IRI, iri)); result.add(RBRACKET_TOKEN); i += iri.length() + 2; break; default: if (Character.isWhitespace(c)) { i++; } else { String restOfQuery = input.substring(i); result.add(new Token(TokenType.REST_OF_QUERY, restOfQuery)); i += restOfQuery.length(); } break; } } return result; }
@CheckResult @NonNull public static Completable confirmPasswordReset( @NonNull FirebaseAuth instance, @NonNull String code, @NonNull String newPassword) { return Completable.create(new ConfirmPasswordResetOnSubscribe(instance, code, newPassword)); }
@Override public <T> T in(final IObject obj) throws ReadValueException, InvalidArgumentException { if (null == obj) { throw new InvalidArgumentException("Argument should not be null."); } Object value = obj.getValue(fieldName); if (null == value) { return null; } return (T) value; }
@Override public Collection<V> getAll() throws Exception { return getAll(ReadPolicy.READ_ALL); }
@Override @Transactional public ServiceResult<FinanceRowItem> update(final long financeRowId, final FinanceRowItem newCostItem) { Application application = financeRowRepository.findById(financeRowId).get().getTarget().getApplication(); return getOpenApplication(application.getId()).andOnSuccess(app -> doUpdate(financeRowId, newCostItem).andOnSuccessReturn(cost -> { OrganisationTypeFinanceHandler organisationFinanceHandler = organisationFinanceDelegate.getOrganisationFinanceHandler(((ApplicationFinanceRow) cost).getTarget().getApplication().getCompetition().getId(), ((ApplicationFinanceRow) cost).getTarget().getOrganisation().getOrganisationType().getId()); return organisationFinanceHandler.toResource((ApplicationFinanceRow) cost); }) ); }
@GetMapping("/get-monitoring-officer-invite/{inviteHash}") public RestResult<MonitoringOfficerInviteResource> getInvite(@PathVariable("inviteHash") String inviteHash) { return monitoringOfficerInviteService.getInviteByHash(inviteHash).toGetResponse(); }
@Override public void removeUserFromSuperAdminRole(UserInfo candidateUser) { LOGGER.debug("Removing user {} from user admin role", candidateUser); String userID = candidateUser.getUsername().toString(); userRoleAccessor.deleteUserRoleBy(userID, ALL_APPLICATIONS); appRoleAccessor.deleteAppRoleBy(ALL_APPLICATIONS, userID); }
@Override public V get(final K key) { Objects.requireNonNull(key); final List<ReadOnlyKeyValueStore<K, V>> stores = storeProvider.stores(storeName, storeType); for (ReadOnlyKeyValueStore<K, V> store : stores) { try { final V result = store.get(key); if (result != null) { return result; } } catch (InvalidStateStoreException e) { throw new InvalidStateStoreException("State store is not available anymore and may have been migrated to another instance; please re-discover its location from the state metadata."); } } return null; }
private List<String> lemmatize(String word, String postag) { List<WordData> dictMap = dictLookup.lookup(word.toLowerCase()); Set<String> lemmas = new HashSet<>(); for (WordData wordData : dictMap) { if (Objects.equals(postag, asString(wordData.getTag()))) { lemmas.add(asString(wordData.getStem())); } } return Collections.unmodifiableList(new ArrayList<>(lemmas)); }
public boolean matchesPackage(String packageName) { return matchesPattern(loc.pack, packageName) && matchesAll(loc.clazz) && matchesAll(loc.method); }
JsonArray groupOrganismPartOntologyTerms(Collection<OntologyTerm> ontologyTermsInAllFactors) { JsonArray result = new JsonArray(); groupingAsJson( organismPartGroupingService.getOrgansGrouping(ontologyTermsInAllFactors), "Organs", "Organ") .ifPresent(result::add); groupingAsJson( organismPartGroupingService.getAnatomicalSystemsGrouping(ontologyTermsInAllFactors), "Anatomical Systems", "Anatomical system") .ifPresent(result::add); return result; }
@Override public void service(HttpRequest request, HttpResponse response) throws IOException { if (!"POST".equals(request.getMethod())) { response.setStatusCode(HttpURLConnection.HTTP_BAD_METHOD); return; } String bodyString = request.getReader().lines().collect(Collectors.joining()); JsonObject body = gson.fromJson(bodyString, JsonObject.class); if (body == null || !body.has("text")) { response.setStatusCode(HttpURLConnection.HTTP_BAD_REQUEST); return; } if (!isValidSlackWebhook(request, bodyString)) { response.setStatusCode(HttpURLConnection.HTTP_UNAUTHORIZED); return; } String query = body.get("text").getAsString(); JsonObject kgResponse = searchKnowledgeGraph(query); BufferedWriter writer = response.getWriter(); writer.write(formatSlackMessage(kgResponse, query)); }
static Logger getParentLogger(final String name) { return getLogger(reduce(name)); }
public static Body from(JsonNode body) { requireNonNull(body, BODY_REQUIRED_ERR_MSG); return new Body(body); }
@Override protected KeySource keySource() { return keySource; }
public int getMostLikelyReasonCode(String jobId) { if (!this.failedConstraintNamesFrequencyMapping.containsKey(jobId)) return -1; Frequency reasons = this.failedConstraintNamesFrequencyMapping.get(jobId); String mostLikelyReason = getMostLikelyFailedConstraintName(reasons); return toCode(mostLikelyReason); }
public List<ModifierSupportedProtocols> createSupportedModifierProtocols() { ModifierSupportedProtocols supportedCompression = compressionProtocolVersions(); return Stream.of( supportedCompression ) .filter( supportedProtocols -> !supportedProtocols.versions().isEmpty() ) .collect( Collectors.toList() ); }
@Override public boolean test(TypeSupplier<?> typeReference) { Type type = typeReference.get(); if (ParameterizedType.class.isInstance(type)) { ParameterizedType parameterizedType = ParameterizedType.class.cast(type); return Map.class.equals(parameterizedType.getRawType()) && Class.class.isInstance(parameterizedType.getActualTypeArguments()[0]) && Class.class.isInstance(parameterizedType.getActualTypeArguments()[1]); } return false; }
@Override public void setID(String identifier) { logger.debug("Setting ID: ", identifier); super.setID(identifier); }
public Optional<String> getStreamJobFactoryClass() { return Optional.ofNullable(get(STREAM_JOB_FACTORY_CLASS)); }
public static boolean isDns1123Required(String fieldName) { if (fieldName != null) { for (String dns1123Field: getDns1123Fields()) { if (dns1123Field.equalsIgnoreCase(fieldName)) { return true; } } } return false; }
public static boolean isExcluded(Module module, String[] excludedModules) { if (excludedModules == null) { return false; } List<String> stringList = Arrays.asList(excludedModules); return stringList.contains(module.getSymbolicName()); }
@Override public Date getRandomValue() { long minDateTime = min.getTime(); long maxDateTime = max.getTime(); long randomDateTime = (long) nextDouble(minDateTime, maxDateTime); return new Date(randomDateTime); }
public static List<Argument> split(String... typesAndNames) { List<Argument> arguments = new ArrayList<Argument>(); if (typesAndNames.length == 1) { String line = typesAndNames[0].trim(); if (line.length() == 0) { return arguments; } int last = 0; int parenCount = 0; int current = 0; for (; current < line.length(); current++) { if (line.charAt(current) == '<') { parenCount++; } else if (line.charAt(current) == '>') { parenCount--; } else if (line.charAt(current) == ',' && parenCount == 0) { arguments.add(new Argument(line.substring(last, current))); last = current + 1; } } arguments.add(new Argument(line.substring(last, current))); } else { for (String typeAndName : typesAndNames) { arguments.add(new Argument(typeAndName)); } } return arguments; }
static public String[] parseKey(String groupKey) { StringBuilder sb = new StringBuilder(); String dataId = null; String group = null; String tenant = null; for (int i = 0; i < groupKey.length(); ++i) { char c = groupKey.charAt(i); if ('+' == c) { if (null == dataId) { dataId = sb.toString(); sb.setLength(0); } else if (null == group) { group = sb.toString(); sb.setLength(0); } else { throw new IllegalArgumentException("invalid groupkey:" + groupKey); } } else if ('%' == c) { char next = groupKey.charAt(++i); char nextnext = groupKey.charAt(++i); if ('2' == next && 'B' == nextnext) { sb.append('+'); } else if ('2' == next && '5' == nextnext) { sb.append('%'); } else { throw new IllegalArgumentException("invalid groupkey:" + groupKey); } } else { sb.append(c); } } if (StringUtils.isBlank(group)) { group = sb.toString(); if (group.length() == 0) { throw new IllegalArgumentException("invalid groupkey:" + groupKey); } } else { tenant = sb.toString(); if (group.length() == 0) { throw new IllegalArgumentException("invalid groupkey:" + groupKey); } } return new String[] {dataId, group, tenant}; }
public SecurityReference getWikiReference() { SecurityReference result = this; while (result != null && result.getType() != EntityType.WIKI) { result = result.getParentSecurityReference(); } return result; }
public static boolean isUnclosedQuote(final String line) { int quoteStart = -1; for (int i = 0; i < line.length(); ++i) { if (quoteStart < 0 && isQuoteChar(line, i)) { quoteStart = i; } else if (quoteStart >= 0 && isTwoQuoteStart(line, i) && !isEscaped(line, i)) { i++; } else if (quoteStart >= 0 && isQuoteChar(line, i) && !isEscaped(line, i)) { quoteStart = -1; } } final int commentInd = line.indexOf(COMMENT); if (commentInd < 0) { return quoteStart >= 0; } else if (quoteStart < 0) { return false; } else { return commentInd > quoteStart; } }
@Deprecated public static AclModified of(final String thingId, final AccessControlList accessControlList, final long revision, final DittoHeaders dittoHeaders) { return of(ThingId.of(thingId), accessControlList, revision, dittoHeaders); }
public static byte[] packNibbles(byte[] nibbles) { int terminator = 0; if (nibbles[nibbles.length - 1] == TERMINATOR) { terminator = 1; nibbles = copyOf(nibbles, nibbles.length - 1); } int oddlen = nibbles.length % 2; int flag = 2 * terminator + oddlen; if (oddlen != 0) { byte[] flags = new byte[]{(byte) flag}; nibbles = concatenate(flags, nibbles); } else { byte[] flags = new byte[]{(byte) flag, 0}; nibbles = concatenate(flags, nibbles); } ByteArrayOutputStream buffer = new ByteArrayOutputStream(); for (int i = 0; i < nibbles.length; i += 2) { buffer.write(16 * nibbles[i] + nibbles[i + 1]); } return buffer.toByteArray(); }
public static byte[] complement(final byte[] data) { return increment(invert(data)); }
@Override public SchemaResult getValueSchema(final String topicName, final Optional<Integer> schemaId) { try { final String subject = topicName + KsqlConstants.SCHEMA_REGISTRY_VALUE_SUFFIX; final int id; if (schemaId.isPresent()) { id = schemaId.get(); } else { id = srClient.getLatestSchemaMetadata(subject).getId(); } final ParsedSchema schema = srClient.getSchemaBySubjectAndId(subject, id); return fromParsedSchema(topicName, id, schema); } catch (final RestClientException e) { switch (e.getStatus()) { case HttpStatus.SC_NOT_FOUND: case HttpStatus.SC_UNAUTHORIZED: case HttpStatus.SC_FORBIDDEN: return notFound(topicName); default: throw new KsqlException("Schema registry fetch for topic " + topicName + " request failed.", e); } } catch (final Exception e) { throw new KsqlException("Schema registry fetch for topic " + topicName + " request failed.", e); } }
public String formatCommand(String command) { if (!containsOption(command)) { return command; } this.formatted = new StringBuilder(); List<String> strings = split(command); for (String string : strings) { if (string.contains(EQUAL_HYPHEN)) { int indexOfEquals = string.indexOf(EQUAL); formatted.append(string.substring(0, indexOfEquals + 1)); formatted.append(QUOTE); formatted.append(string.substring(indexOfEquals + 1)); formatted.append(QUOTE); } else { formatted.append(string); } formatted.append(SPACE); } return formatted.toString().trim(); }
public KB getBottomId() { return this.f1; }
public static final PType<TupleN> tuples(PType... ptypes) { TypeInfo tupleInfo = createTupleTypeInfo(ptypes); return derived(TupleN.class, new TupleInFn<TupleN>(TupleFactory.TUPLEN, ptypes), new TupleOutFn<TupleN>(ptypes), orcs(tupleInfo), ptypes); }
public static KsqlWindowExpression parseWindowExpression(final String expressionText) { final ParserRuleContext parseTree = GrammarParseUtil.getParseTree( expressionText, SqlBaseParser::windowExpression ); final WindowExpression windowExpression = new AstBuilder(TypeRegistry.EMPTY).buildWindowExpression(parseTree); return windowExpression.getKsqlWindowExpression(); }
@Override public VariantQueryResult executeQuery(String sequence, int startPos, int stopPos) { if (startPos < 0) throw new IllegalArgumentException("StartPos must be bigger then 0"); if (stopPos <= startPos) throw new IllegalArgumentException("StopPos must be bigger then startPos "); try { TabixIterator tabixIterator = index.queryTabixIndex(sequence, startPos, stopPos, inputStream); return new TabixQueryResult(inputStream, new TabixQueryIterator(tabixIterator, variantLineMapper)); } catch (IOException e) { throw new GenotypeDataException(e); } }
public List<GeometryBuilder> createBuilders(PlatformMetadata model) { List<GeometryBuilder> builders = New.list(); if (model instanceof PlatformMetadataAndImage) { builders.add(myImageBuilder); } else { builders.add(myFootprintBuilder); builders.add(myVehicleBuilder); } return builders; }
@Override public void createPackage(Path originFolderPath, Path destinationPath) throws ArchiverException, IOException { checkArgument(originFolderPath != null, "The origin path must not be null"); checkArgument(originFolderPath.toFile().exists(), "The origin path must exists"); Path metaInfPath = originFolderPath.resolve(META_INF.value()); this .withClasses(originFolderPath.resolve(CLASSES.value()).toFile()) .withMaven(metaInfPath.resolve(MAVEN.value()).toFile()) .withMuleArtifact(metaInfPath.resolve(MULE_ARTIFACT.value()).toFile()) .withTestClasses(originFolderPath.resolve(TEST_CLASSES.value()).toFile()) .withTestMule(originFolderPath.resolve(TEST_MULE.value()).resolve(MUNIT.value()).toFile()) .withRepository(originFolderPath.resolve(REPOSITORY.value()).toFile()) .withMuleSrc(metaInfPath.resolve(MULE_SRC.value()).toFile()); this.createArchive(destinationPath); }
public InputStream getStream() { return stream; }
@Override public String toString() { return methodDescriptor.toString(index); }
@Override public boolean synchronizedHandleRequest(VaadinSession session, VaadinRequest request, VaadinResponse response) throws IOException { Document indexDocument = getIndexHtmlDocument(request); prependBaseHref(request, indexDocument); JsonObject initialJson = Json.createObject(); if (request.getService().getBootstrapInitialPredicate() .includeInitialUidl(request)) { includeInitialUidl(initialJson, session, request, response); indexHtmlResponse = new IndexHtmlResponse(request, response, indexDocument, UI.getCurrent()); session.setAttribute(SERVER_ROUTING, Boolean.TRUE); } else { indexHtmlResponse = new IndexHtmlResponse(request, response, indexDocument); } addInitialFlow(initialJson, indexDocument, session); configureErrorDialogStyles(indexDocument); showWebpackErrors(indexDocument); response.setContentType(CONTENT_TYPE_TEXT_HTML_UTF_8); VaadinContext context = session.getService().getContext(); AppShellRegistry registry = AppShellRegistry.getInstance(context); DeploymentConfiguration config = session.getConfiguration(); if (!config.isProductionMode()) { UsageStatisticsExporter.exportUsageStatisticsToDocument(indexDocument); } setupPwa(indexDocument, session.getService()); registry.modifyIndexHtml(indexDocument, request); request.getService().modifyIndexHtmlResponse(indexHtmlResponse); try { response.getOutputStream() .write(indexDocument.html().getBytes(UTF_8)); } catch (IOException e) { getLogger().error("Error writing 'index.html' to response", e); return false; } return true; }
public Query query(Schema schema, Query range) { BooleanQuery.Builder builder = new BooleanQuery.Builder(); if (range != null) { builder.add(range, FILTER); } filter.forEach(condition -> builder.add(condition.query(schema), FILTER)); query.forEach(condition -> builder.add(condition.query(schema), MUST)); BooleanQuery booleanQuery = builder.build(); return booleanQuery.clauses().isEmpty() ? new MatchAllDocsQuery() : booleanQuery; }
public static MavenProject parseMavenPom(File pomFile) { return parseMavenPom(pomFile, false); }
public List<FlowDetails> processClassifier( final SclServiceFunctionForwarder theClassifier, final Acl theAcl, final boolean addClassifierScenario) { addClassifier = addClassifierScenario; Optional<ServiceFunctionForwarder> sff = Optional.of(new SffName(theClassifier.getName())) .map(SfcProviderServiceForwarderAPI::readServiceFunctionForwarder); Optional<String> itfName = classifierHandler.getInterfaceNameFromClassifier(theClassifier); if (!sff.isPresent() || !itfName.isPresent()) { LOG.error("createdServiceFunctionClassifier: " + "Cannot install ACL rules in classifier. SFF exists? {}; Interface exists? {}", sff.isPresent(), itfName.isPresent()); return Collections.emptyList(); } classifierInterface = classifierHandler.usesLogicalInterfaces(sff.get()) ? logicallyAttachedClassifier : bareClassifier.setSff(sff.get()); Optional<String> nodeName = itfName.flatMap(classifierInterface::getNodeName); if(!nodeName.isPresent()) { LOG.error("createdServiceFunctionClassifier: Could not extract the node name from the OVS interface"); return Collections.emptyList(); } if (classifierHandler.usesLogicalInterfaces(sff.get())) { if (addClassifierScenario) { ClassifierGeniusIntegration.performGeniusServiceBinding(tx, itfName.get()); LOG.info("processClassifier - Bound interface {}", itfName.get()); } else { ClassifierGeniusIntegration.performGeniusServiceUnbinding(tx, itfName.get()); LOG.info("processClassifier - Unbound interface {}", itfName.get()); } } return theAcl .getAccessListEntries() .getAce() .stream() .map(theAce -> processAce(nodeName.get(), sff.get(), theClassifier.getName(), theAcl.getAclName(), itfName.get(), theAce)) .reduce(new ArrayList<>(), (dstList, theList) -> Stream.concat(dstList.stream(), theList.stream()).collect(Collectors.toList())); }
@Override public Map<String, Object> getParameters(final MarkScaleExchange entity, final Map<String, Object> parameters) { addParameter(entity.getMarkScale(), markScaleDao, "markScale", parameters); addParameter(entity.getMarkScaleValue(), markScaleValueDao, "markScaleValue", parameters); addParameter(entity.getMarkScaleExchange(), markScaleDao, "markScaleExchange", parameters); addParameter(entity.getMarkScaleExchangeValue(), markScaleValueDao, "markScaleExchangeValue", parameters); addParameter(entity.getMarkMin(), "markMin", parameters); addParameter(entity.getMarkMax(), "markMax", parameters); addParameter(entity.getMarkExchange(), "markExchange", parameters); return parameters; }
boolean isTimeReached(final UnsignedLong currentTime, final UnsignedLong earliestTime) { return currentTime.compareTo(earliestTime) >= 0; }
@Override public String toString() { Context context = stringContexts.get(); if (CharsetSupport.isStringEquivalent()) { header.setField(context.bodyLength); trailer.setField(context.checkSum); } else { header.setInt(BodyLength.FIELD, bodyLength()); trailer.setString(CheckSum.FIELD, checksum()); } StringBuilder stringBuilder = context.stringBuilder; try { header.calculateString(stringBuilder, null, null); calculateString(stringBuilder, null, null); trailer.calculateString(stringBuilder, null, null); if (CharsetSupport.isStringEquivalent()) { setBodyLength(stringBuilder); setChecksum(stringBuilder); } return stringBuilder.toString(); } finally { stringBuilder.setLength(0); } }
static void requireMinimumJavaVersion() { if (isNotSupportedVersion(System.getProperty("java.version"))) { System.err.println("Nexus requires minimum java.version: " + MINIMUM_JAVA_VERSION); if (versionCheckRequired()) { System.exit(-1); } } }
public static boolean containsContentType(String contentType, String[] allowedContentTypes) { if (allowedContentTypes == null) { return false; } for (int i = 0; i < allowedContentTypes.length; i++) { if (allowedContentTypes[i].contains(contentType)) { return true; } } return false; }
public static Collection<String> permute(String regexp) { regexp = regexp.replaceAll("\\)\\?([^()]+)\\(", ")($1)("); regexp = regexp.replaceAll("\\)([^?][^()]*)\\(", ")($1)("); List<String> bracketMatches = StringHelper.getRegexpMatches("\\(.*?\\)\\??", regexp); List<String[]> bracketSplits = new ArrayList<>(); for (String bracket : bracketMatches) { bracket = bracket.replace("(", "").replace(")", ""); if (bracket.endsWith("?")) { bracket = bracket.replace("?", "").trim(); bracket += "|_"; } String[] splits = bracket.split("\\|"); bracketSplits.add(splits); } List<String> permutations = new ArrayList<>(); permuteRecursively(permutations, bracketSplits, ""); return permutations; }
public static List<Configuration> split(HbaseSQLReaderConfig readerConfig) { PhoenixInputFormat inputFormat = new PhoenixInputFormat<PhoenixRecordWritable>(); org.apache.hadoop.conf.Configuration conf = generatePhoenixConf(readerConfig); JobID jobId = new JobID(Key.MOCK_JOBID_IDENTIFIER, Key.MOCK_JOBID); JobContextImpl jobContext = new JobContextImpl(conf, jobId); List<Configuration> resultConfigurations = new ArrayList<Configuration>(); List<InputSplit> rawSplits = null; try { rawSplits = inputFormat.getSplits(jobContext); LOG.info("split size is " + rawSplits.size()); for (InputSplit split : rawSplits) { Configuration cfg = readerConfig.getOriginalConfig().clone(); byte[] splitSer = HadoopSerializationUtil.serialize((PhoenixInputSplit) split); String splitBase64Str = org.apache.commons.codec.binary.Base64.encodeBase64String(splitSer); cfg.set(Key.SPLIT_KEY, splitBase64Str); resultConfigurations.add(cfg); } } catch (IOException e) { throw DataXException.asDataXException( HbaseSQLReaderErrorCode.GET_PHOENIX_SPLITS_ERROR, "获取表的split信息时出现了异常，请检查hbase集群服务是否正常," + e.getMessage(), e); } catch (InterruptedException e) { throw DataXException.asDataXException( HbaseSQLReaderErrorCode.GET_PHOENIX_SPLITS_ERROR, "获取表的split信息时被中断，请重试，若还有问题请联系datax管理员," + e.getMessage(), e); } return resultConfigurations; }
public static String sha3(String hexInput) { byte[] bytes = Numeric.hexStringToByteArray(hexInput); byte[] result = sha3(bytes); return Numeric.toHexString(result); }
public static Xpp3Dom build( @WillClose @Nonnull Reader reader ) throws XmlPullParserException { return build( reader, DEFAULT_TRIM ); }
public void setHeartbeatMode(HeartbeatMode heartbeatMode) { this.heartbeatMode = heartbeatMode; }
@Nullable @Override public Server pick() { final ServiceInstance instance; try { instance = serviceProvider.getInstance(); } catch (Exception e) { log.info(e, "Exception getting instance for [%s]", name); return null; } if (instance == null) { log.error("No server instance found for [%s]", name); return null; } return TO_SERVER.apply(instance); }
@Override public MgcpCommandResult call() { DlcxContext context = new DlcxContext(); try { validateParameters(this.requestParameters, context); executeCommand(context); context.code = MgcpResponseCode.TRANSACTION_WAS_EXECUTED.code(); context.message = MgcpResponseCode.TRANSACTION_WAS_EXECUTED.message(); } catch (RuntimeException e) { log.error("Unexpected error occurred during tx=" + this.transactionId + " execution. Rolling back."); context.code = MgcpResponseCode.PROTOCOL_ERROR.code(); context.message = MgcpResponseCode.PROTOCOL_ERROR.message(); } catch (MgcpCallNotFoundException e) { log.error("Protocol error occurred during tx=" + this.transactionId + " execution: " + e.getMessage()); context.code = MgcpResponseCode.INCORRECT_CALL_ID.code(); context.message = MgcpResponseCode.INCORRECT_CALL_ID.message(); } catch (MgcpConnectionNotFoundException e) { log.error("Protocol error occurred during tx=" + this.transactionId + " execution: " + e.getMessage()); context.code = MgcpResponseCode.INCORRECT_CONNECTION_ID.code(); context.message = MgcpResponseCode.INCORRECT_CONNECTION_ID.message(); } catch (MgcpCommandException e) { log.error("Protocol error occurred during tx=" + this.transactionId + " execution: " + e.getMessage()); context.code = e.getCode(); context.message = e.getMessage(); } return respond(context); }
public void updateRow(int row, Line data) { for (int index = 0; index < 3; index ++) { colors[index][row] = data.get(index); } }
@Deprecated public <T> T doRequest(UrlConnector urlConnector, String httpMethod, byte[] body, Map<String, String> headers, Class<T> resourceClass) throws ResourceException, IOException { SignedRequestResponse signedRequestResponse = rawResourceFetcher.doRequest(urlConnector, httpMethod, body, headers); return objectMapper.readValue(signedRequestResponse.getResponseBody(), resourceClass); }
public Optional<Long> getValueSatisfying(BDD bdd) { BDD satAssignment = bdd.fullSatOne(); return satAssignment.isZero() ? Optional.empty() : Optional.of(satAssignmentToLong(satAssignment)); }
public Sender toAPISender() { if ( optionalAccountMember.isPresent()) { Sender result = new Sender(); if ( optionalAccountMember.get().getAddress() != null ) { result.setAddress( new AddressConverter( optionalAccountMember.get().getAddress() ).toAPIAddress() ); } result.setCompany( optionalAccountMember.get().getCompany() ); result.setEmail( optionalAccountMember.get().getEmail() ); result.setFirstName( optionalAccountMember.get().getFirstName() ); result.setLastName( optionalAccountMember.get().getLastName() ); result.setTitle( optionalAccountMember.get().getTitle() ); result.setLanguage( optionalAccountMember.get().getLanguage() ); result.setPhone( optionalAccountMember.get().getPhoneNumber() ); if ( optionalAccountMember.get().getTimezoneId() != null ) { result.setTimezoneId(optionalAccountMember.get().getTimezoneId()); } if (optionalAccountMember.get().getStatus().isPresent()) { result.setStatus( new SenderStatusConverter(optionalAccountMember.get().getStatus().get()).toAPISenderStatus() ); } return result; } else { return optionalSender.get(); } }
public static CdsIndexTrade.Builder builder() { return new CdsIndexTrade.Builder(); }
List<String> parse(String s) { List<String> words = new ArrayList<>(); String field = ""; Matcher matcher = SHELLWORDS.matcher(s); while (matcher.find()) { String word = matcher.group(1); String sq = matcher.group(2); String dq = matcher.group(3); String esc = matcher.group(4); String garbage = matcher.group(5); String sep = matcher.group(6); if (garbage != null) { throw new IllegalArgumentException("Unmatched double quote: " + s); } if (word != null) { field = word; } else if (sq != null) { field = sq; } else if (dq != null) { field = dq.replaceAll("\\\\(?=.)", ""); } else if (esc != null) { field = esc.replaceAll("\\\\(?=.)", ""); } if (sep != null) { words.add(field); field = ""; } } return words; }
@Override public void activateOptions() { String containerName = System.getProperty(JAVA_OPTS_CONTAINER_NAME); if (containerName != null) { isApplicationMaster = containerName.contains(JOB_COORDINATOR_TAG); } else { throw new SamzaException("Got null container name from system property: " + JAVA_OPTS_CONTAINER_NAME + ". This is used as the key for the log appender, so can't proceed."); } key = containerName; if (isApplicationMaster) { systemInitialized = false; } else { setupSystem(); systemInitialized = true; } }
public static ExtractionResult fromPredicate( Metadata metadata, Session session, Expression predicate, TypeProvider types) { return new Visitor(metadata, session, types, new TypeAnalyzer(new SqlParser(), metadata)).process(predicate, false); }
@Override public Template getTemplate() throws PeerException { return getLocalPeer().getTemplateById( templateId ); }
public static void validateMappingRequest(Object srcObj) { if (srcObj == null) { MappingUtils.throwMappingException("Source object must not be null"); } }
public KinoDto createOrUpdate(KinoDto kinoDto) { LocalKino localKino = kinoDtoToDbBuilder.build(kinoDto); if(kinoDto.getTmdbKinoId() != null) { tmdbKinoRepository.createOrUpdate(localKino.getKino()); } localKinoRepository.createOrUpdate(localKino); return kinoDtoBuilder.build(localKino); }
@DescribeResult(description = "Output raster") public GridCoverage2D execute( @DescribeParameter(name = "data", description = "Input features") SimpleFeatureCollection obsFeatures, @DescribeParameter( name = "pixelsPerCell", description = "Resolution used for upsampling (in pixels)", defaultValue = "1", min = 1 ) Integer argPixelsPerCell, @DescribeParameter( name = "gridStrategy", description = "GeoHash grid strategy", defaultValue = "Basic", min = 1 ) String gridStrategy, @DescribeParameter( name = "gridStrategyArgs", description = "Grid strategy arguments", min = 0 ) List<String> gridStrategyArgs, @DescribeParameter(name = "emptyCellValue", description = "Default cell value", min = 0) Float emptyCellValue, @DescribeParameter(name = "scaleMin", description = "Scale minimum", defaultValue = "0") Float scaleMin, @DescribeParameter(name = "scaleMax", description = "Scale maximum", min = 0) Float scaleMax, @DescribeParameter( name = "useLog", description = "Whether to use log values (default=false)", defaultValue = "false" ) Boolean useLog, @DescribeParameter(name = "outputBBOX", description = "Bounding box of the output") ReferencedEnvelope argOutputEnv, @DescribeParameter( name = "outputWidth", description = "Width of output raster in pixels" ) Integer argOutputWidth, @DescribeParameter( name = "outputHeight", description = "Height of output raster in pixels" ) Integer argOutputHeight, ProgressListener monitor) throws ProcessException { try { final GeoHashGrid geoHashGrid = Strategy.valueOf(gridStrategy.toUpperCase()).createNewInstance(); geoHashGrid.setParams(gridStrategyArgs); geoHashGrid.setEmptyCellValue(emptyCellValue); geoHashGrid.setScale(new RasterScale(scaleMin, scaleMax, useLog)); geoHashGrid.initalize(argOutputEnv, obsFeatures); final GridCoverage2D nativeCoverage = geoHashGrid.toGridCoverage2D(); final GridCoverage2D transformedCoverage = (GridCoverage2D) Operations.DEFAULT.resample( nativeCoverage, argOutputEnv.getCoordinateReferenceSystem()); final GridCoverage2D scaledCoverage = GridCoverageUtil.scale( transformedCoverage, argOutputWidth * argPixelsPerCell, argOutputHeight * argPixelsPerCell); final GridCoverage2D croppedCoverage = GridCoverageUtil.crop(scaledCoverage, argOutputEnv); return GridCoverageUtil.scale(croppedCoverage, argOutputWidth, argOutputHeight); } catch (Exception e) { throw new ProcessException("Error executing GeoHashGridProcess", e); } }
public Result getMail(@PathParam("mailId") @DbId final Long mailId, @Attribute("userId") @DbId final Long userId, final Context context) { return performAction(mailId, userId, context, mail -> { try { final MailData mailData = new MailData(mail); return ApiResults.ok().render(mailData); } catch (final Exception e) { log.error("Failed to parse MIME message", e); return ApiResults.internalServerError(); } }); }
@Override public RequestContext parseRequest(HttpHeaders request, RequestContext.RequestType requestType) { RequestMap params = new RequestMap(request.getRequestHeaders()); if (LOG.isDebugEnabled()) { LOG.debug("Parsing request parameters: " + params.keySet()); } RequestContext context = new RequestContext(); context.setRequestType(requestType); String profile = params.removeUserProperty("PROFILE"); context.setProfile(profile); addProfilePlugins(profile, params); String wireFormat = params.removeProperty("FORMAT"); context.setOutputFormat(OutputFormat.valueOf(wireFormat)); String format = params.removeUserProperty("FORMAT"); format = StringUtils.isNotBlank(format) ? format : context.inferFormatName(); context.setFormat(format); context.setAccessor(params.removeUserProperty("ACCESSOR")); context.setAggType(EnumAggregationType.getAggregationType(params.removeOptionalProperty("AGG-TYPE"))); String fragmentStr = params.removeOptionalProperty("DATA-FRAGMENT"); if (StringUtils.isNotBlank(fragmentStr)) { context.setDataFragment(Integer.parseInt(fragmentStr)); } context.setDataSource(params.removeProperty("DATA-DIR")); String filterString = params.removeOptionalProperty("FILTER"); String hasFilter = params.removeProperty("HAS-FILTER"); if (filterString != null) { context.setFilterString(filterString); } else if ("1".equals(hasFilter)) { LOG.info("Original query has filter, but it was not propagated to PXF"); } context.setFragmenter(params.removeUserProperty("FRAGMENTER")); String fragmentIndexStr = params.removeOptionalProperty("FRAGMENT-INDEX"); if (StringUtils.isNotBlank(fragmentIndexStr)) { context.setFragmentIndex(Integer.parseInt(fragmentIndexStr)); } String encodedFragmentMetadata = params.removeOptionalProperty("FRAGMENT-METADATA"); context.setFragmentMetadata(Utilities.parseBase64(encodedFragmentMetadata, "Fragment metadata information")); context.setHost(params.removeProperty("URL-HOST")); context.setMetadata(params.removeUserProperty("METADATA")); context.setPort(params.removeIntProperty("URL-PORT")); context.setProfileScheme(params.removeUserProperty(PROFILE_SCHEME)); context.setProtocol(params.removeUserProperty("PROTOCOL")); context.setRemoteLogin(params.removeOptionalProperty("REMOTE-USER")); context.setRemoteSecret(params.removeOptionalProperty("REMOTE-PASS")); context.setResolver(params.removeUserProperty("RESOLVER")); context.setSegmentId(params.removeIntProperty("SEGMENT-ID")); context.setServerName(params.removeUserProperty("SERVER")); String config = params.removeUserProperty("CONFIG"); context.setConfig(StringUtils.isNotBlank(config) ? config : context.getServerName()); String maxFrags = params.removeUserProperty("STATS-MAX-FRAGMENTS"); if (!StringUtils.isBlank(maxFrags)) { context.setStatsMaxFragments(Integer.parseInt(maxFrags)); } String sampleRatioStr = params.removeUserProperty("STATS-SAMPLE-RATIO"); if (!StringUtils.isBlank(sampleRatioStr)) { context.setStatsSampleRatio(Float.parseFloat(sampleRatioStr)); } String threadSafeStr = params.removeUserProperty("THREAD-SAFE"); if (!StringUtils.isBlank(threadSafeStr)) { context.setThreadSafe(parseBooleanValue(threadSafeStr)); } context.setTotalSegments(params.removeIntProperty("SEGMENT-COUNT")); context.setTransactionId(params.removeProperty("XID")); parseTupleDescription(params, context); if (context.getOutputFormat() == OutputFormat.TEXT) { parseGreenplumCSV(params, context); if (context.getTupleDescription().size() != 1 && context.getGreenplumCSV().getDelimiter() == null) { throw new IllegalArgumentException(String.format("using no delimiter is only possible for a single column table. %d columns found", context.getTupleDescription().size())); } } context.setUser(params.removeProperty("USER")); String encodedFragmentUserData = params.removeOptionalProperty("FRAGMENT-USER-DATA"); context.setUserData(Utilities.parseBase64(encodedFragmentUserData, "Fragment user data")); System.setProperty("greenplum.alignment", params.removeProperty("ALIGNMENT")); Map<String, String> optionMappings = null; if (StringUtils.isNotBlank(profile)) { optionMappings = pluginConf.getOptionMappings(profile); } if (optionMappings == null) { optionMappings = Collections.emptyMap(); } Map<String, String> additionalConfigProps = new HashMap<>(); List<String> paramNames = new ArrayList<>(params.keySet()); for (String param : paramNames) { if (StringUtils.startsWithIgnoreCase(param, RequestMap.USER_PROP_PREFIX)) { String optionName = param.toLowerCase().replace(RequestMap.USER_PROP_PREFIX_LOWERCASE, ""); String optionValue = params.removeUserProperty(optionName); context.addOption(optionName, optionValue); LOG.debug("Added option {} to request context", optionName); String propertyName = optionMappings.get(optionName); if (StringUtils.isNotBlank(propertyName)) { if (optionValue != null) { additionalConfigProps.put(propertyName, optionValue); LOG.debug("Added extra config property {} from option {}", propertyName, optionName); } } } else if (StringUtils.startsWithIgnoreCase(param, RequestMap.PROP_PREFIX)) { LOG.debug("Unused property {}", param); } } context.setAdditionalConfigProps(additionalConfigProps); context.setPluginConf(pluginConf); if (StringUtils.isNotBlank(profile)) { String handlerClassName = pluginConf.getHandler(profile); if (StringUtils.isNotBlank(handlerClassName)) { Class<?> clazz; try { clazz = Class.forName(handlerClassName); ProtocolHandler handler = (ProtocolHandler) clazz.getDeclaredConstructor().newInstance(); context.setFragmenter(handler.getFragmenterClassName(context)); context.setAccessor(handler.getAccessorClassName(context)); context.setResolver(handler.getResolverClassName(context)); } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) { throw new RuntimeException(String.format("Error when invoking handlerClass '%s' : %s", handlerClassName, e), e); } } } context.validate(); return context; }
@Nonnull public static Optional<List<String>> getPaths(@Nonnull final DataSource dataSource) { List<String> paths = new ArrayList<>(); if (dataSource.getTemplate() != null && dataSource.getTemplate().getOptions() != null && dataSource.getTemplate().getOptions().get("path") != null) { paths.add(dataSource.getTemplate().getOptions().get("path")); } else { Optional.of(dataSource).map(DataSource::getConnector).map(Connector::getTemplate).map(DataSetTemplate::getOptions).map(options -> options.get("path")).ifPresent(paths::add); } if (dataSource.getTemplate() != null && dataSource.getTemplate().getPaths() != null) { paths.addAll(dataSource.getTemplate().getPaths()); } else if (dataSource.getConnector() != null && dataSource.getConnector().getTemplate() != null && dataSource.getConnector().getTemplate().getPaths() != null) { paths.addAll(dataSource.getConnector().getTemplate().getPaths()); } else if (paths.isEmpty()) { paths = null; } return Optional.ofNullable(paths); }
public int stringToColor(String color) { @ColorRes int colorInt; switch (color) { case "green": colorInt = R.color.glucosio_reading_ok; break; case "red": colorInt = R.color.glucosio_reading_hyper; break; case "blue": colorInt = R.color.glucosio_reading_low; break; case "orange": colorInt = R.color.glucosio_reading_high; break; default: colorInt = R.color.glucosio_reading_hypo; } return ContextCompat.getColor(mContext, colorInt); }
public String convert(SchoolLevelType schoolLevelType) { if (schoolLevelType == null) { return null; } return SCHOOL_LEVEL_TYPE_MAP.get(schoolLevelType); }
public static String getPropertyOrDefault( Class<?> referenceClass, String propertyFile, String key, String defaultValue) { try (InputStream stream = referenceClass.getResourceAsStream(propertyFile)) { if (stream == null) { logger.atSevere().log("Could not load properties file '%s'", propertyFile); return defaultValue; } Properties properties = new Properties(); properties.load(stream); String value = properties.getProperty(key); if (value == null) { logger.atSevere().log("Key %s not found in properties file %s.", key, propertyFile); return defaultValue; } return value; } catch (IOException e) { logger.atSevere().withCause(e).log( "Error while trying to get property value for key %s", key); return defaultValue; } }
public List<Expectation> add(OpenAPIExpectation openAPIExpectation) { return getOpenAPIConverter().buildExpectations(openAPIExpectation.getSpecUrlOrPayload(), openAPIExpectation.getOperationsAndResponses()).stream().map(this::add).flatMap(List::stream).collect(Collectors.toList()); }
public Cookie []toArray() { Cookie []cookies=new Cookie[cookieMap.size()]; return toArray(cookies); }
public static int getHeight(Layout layout) { if (layout == null) { return 0; } int extra = 0; if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT_WATCH && layout instanceof StaticLayout) { int line = Math.max(0, layout.getLineCount() - 1); int above = layout.getLineAscent(line); int below = layout.getLineDescent(line); float originalSize = (below - above - layout.getSpacingAdd()) / layout.getSpacingMultiplier(); float ex = below - above - originalSize; if (ex >= 0) { extra = (int) (ex + 0.5); } else { extra = -(int) (-ex + 0.5); } } return layout.getHeight() - extra; }
public static Object truncate(Object value, int maxStringLength, int maxArrayLength, int maxDepth) { if (value == null) { return null; } return trunc(value, 0, maxStringLength, maxArrayLength, maxDepth); }
@Override public Optional<MarketDirection> indicate(final MP marketPrice) { return original.indicate(marketPrice).map(signal -> signal == UP ? DOWN : UP); }
@Override @Nonnull public DescribeGlobalResult describeGlobal() throws IOException { Timer.Context context = describeGlobalTimer.time(); String describeGlobalJson; try { describeGlobalJson = this.getHttpApiClient().describeGlobal(); } finally { context.stop(); } ObjectNode objectNode = this.objectReader.withType(ObjectNode.class).readValue(describeGlobalJson); String encoding = objectNode.get("encoding").textValue(); int maxBatchSize = objectNode.get("maxBatchSize").intValue(); ArrayNode descriptionsNode = this.objectReader.withType(ArrayNode.class).readValue(objectNode.get("sobjects")); Iterator<JsonNode> elements = descriptionsNode.elements(); List<GlobalSObjectDescription> descriptions = Lists.newArrayList(); while (elements.hasNext()) { JsonNode node = elements.next(); descriptions.add(this.objectReader.readValue(node.traverse(), BasicSObjectMetadata.class)); } return new DescribeGlobalResult(encoding, maxBatchSize, descriptions); }
void verify(@NonNull JWT token, @NonNull IdTokenVerificationOptions verifyOptions) throws TokenValidationException { verifyOptions.getSignatureVerifier().verify(token); if (isEmpty(token.getIssuer())) { throw new TokenValidationException("Issuer (iss) claim must be a string present in the ID token"); } if (!token.getIssuer().equals(verifyOptions.getIssuer())) { throw new TokenValidationException(String.format("Issuer (iss) claim mismatch in the ID token, expected \"%s\", found \"%s\"", verifyOptions.getIssuer(), token.getIssuer())); } if (isEmpty(token.getSubject())) { throw new TokenValidationException("Subject (sub) claim must be a string present in the ID token"); } final List<String> audience = token.getAudience(); if (audience == null || audience.isEmpty()) { throw new TokenValidationException("Audience (aud) claim must be a string or array of strings present in the ID token"); } if (!audience.contains(verifyOptions.getAudience())) { throw new TokenValidationException(String.format("Audience (aud) claim mismatch in the ID token; expected \"%s\" but was not one of \"%s\"", verifyOptions.getAudience(), token.getAudience())); } final Calendar cal = Calendar.getInstance(); final Date now = verifyOptions.getClock() != null ? verifyOptions.getClock() : cal.getTime(); final int clockSkew = verifyOptions.getClockSkew() != null ? verifyOptions.getClockSkew() : DEFAULT_CLOCK_SKEW; if (token.getExpiresAt() == null) { throw new TokenValidationException("Expiration Time (exp) claim must be a number present in the ID token"); } cal.setTime(token.getExpiresAt()); cal.add(Calendar.SECOND, clockSkew); Date expDate = cal.getTime(); if (now.after(expDate)) { throw new TokenValidationException(String.format("Expiration Time (exp) claim error in the ID token; current time (%d) is after expiration time (%d)", now.getTime() / 1000, expDate.getTime() / 1000)); } if (token.getIssuedAt() == null) { throw new TokenValidationException("Issued At (iat) claim must be a number present in the ID token"); } if (verifyOptions.getNonce() != null) { String nonceClaim = token.getClaim(NONCE_CLAIM).asString(); if (isEmpty(nonceClaim)) { throw new TokenValidationException("Nonce (nonce) claim must be a string present in the ID token"); } if (!verifyOptions.getNonce().equals(nonceClaim)) { throw new TokenValidationException(String.format("Nonce (nonce) claim mismatch in the ID token; expected \"%s\", found \"%s\"", verifyOptions.getNonce(), nonceClaim)); } } if (audience.size() > 1) { String azpClaim = token.getClaim(AZP_CLAIM).asString(); if (isEmpty(azpClaim)) { throw new TokenValidationException("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values"); } if (!verifyOptions.getAudience().equals(azpClaim)) { throw new TokenValidationException(String.format("Authorized Party (azp) claim mismatch in the ID token; expected \"%s\", found \"%s\"", verifyOptions.getAudience(), azpClaim)); } } if (verifyOptions.getMaxAge() != null) { Date authTime = token.getClaim(AUTH_TIME_CLAIM).asDate(); if (authTime == null) { throw new TokenValidationException("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified"); } cal.setTime(authTime); cal.add(Calendar.SECOND, verifyOptions.getMaxAge()); cal.add(Calendar.SECOND, clockSkew); Date authTimeDate = cal.getTime(); if (now.after(authTimeDate)) { throw new TokenValidationException(String.format("Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (%d) is after last auth at (%d)", now.getTime() / 1000, authTimeDate.getTime() / 1000)); } } }
@Override protected boolean permittedTopology(DimensionInfo sourceDimensionInfo, DimensionInfo targetDimensionInfo) { return true; }
public String verifyNotEquals(String value, String matcher) { return "verifyNotEquals(" + value + ", " + matcher + ")"; }
public StringBuffer encode(StringBuffer buff) { buff.append("(!"); filter.encode(buff); buff.append(')'); return buff; }
public static <T extends Annotation> Optional<T> getAnnotation(Class<?> beanClass, Class<T> annotationClass) { Class<?> currentClass = beanClass; while (currentClass != null && currentClass != Object.class) { if (currentClass.isAnnotationPresent(annotationClass)) { return Optional.of(currentClass.getAnnotation(annotationClass)); } currentClass = currentClass.getSuperclass(); } return Optional.empty(); }
@Override public UpdateHostResponse suspend(String hostNameString) { HostName hostName = new HostName(hostNameString); try { orchestrator.suspend(hostName); } catch (HostNameNotFoundException e) { log.log(Level.FINE, "Host not found: " + hostName); throw new NotFoundException(e); } catch (UncheckedTimeoutException e) { log.log(Level.FINE, "Failed to suspend " + hostName + ": " + e.getMessage()); throw webExceptionFromTimeout("suspend", hostName, e); } catch (HostStateChangeDeniedException e) { log.log(Level.FINE, "Failed to suspend " + hostName + ": " + e.getMessage()); throw webExceptionWithDenialReason("suspend", hostName, e); } return new UpdateHostResponse(hostName.s(), null); }
@Override public Iterator<E> iterator() { return getData().iterator(); }
@Override public long getCompleteRequestTime() { return responseBodyCompleted - createdRequest; }
@Override public void onPropertyModified(final PropertyDescriptor descriptor, final String oldValue, final String newValue) { if (descriptor.isDynamic()) { final Set<String> newDynamicPropertyNames = new HashSet<>(dynamicPropertyNames); if (newValue == null) { newDynamicPropertyNames.remove(descriptor.getName()); } else if (oldValue == null) { newDynamicPropertyNames.add(descriptor.getName()); } this.dynamicPropertyNames = Collections.unmodifiableSet(newDynamicPropertyNames); } else { if (PROP_ATTRIBUTES_TO_SEND.getName().equalsIgnoreCase(descriptor.getName())) { if (newValue == null || newValue.isEmpty()) { regexAttributesToSend = null; } else { final String trimmedValue = StringUtils.trimToEmpty(newValue); regexAttributesToSend = Pattern.compile(trimmedValue); } } } }
public static Boolean extractGovCloudFlag(Object object) { if (object != null) { if (object instanceof Boolean) { return (Boolean) object; } else if (object instanceof String) { return Boolean.parseBoolean((String) object); } } return Boolean.FALSE; }
@Override public synchronized ManagedScheduledFutureTask<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) { ScheduledTask<?> task = getNewScheduledTaskFor(command, true); ScheduledFuture<?> future = ((ScheduledExecutorService) executor).scheduleAtFixedRate(task.asRunnable(), initialDelay, period, unit); task.submittedScheduledTask(future); return task; }
protected boolean areMulePluginVersionCompatible(List<ArtifactCoordinates> dependencies) { Set<String> majors = dependencies.stream() .map(ArtifactCoordinates::getVersion) .map(VersionUtils::getMajor) .collect(Collectors.toSet()); return majors.size() <= 1; }
Pair<String, String> convertAttachmentKeyIntoContentTypeAndFilename(final String key) { try { final String[] contentTypeAndFile = key.substring(ATTACHMENT_PREFIX.length()).split(ATTACHMENT_SUFFIX); return new Pair<>(contentTypeAndFile[0], contentTypeAndFile[1]); } catch (Exception exp) { LOG.error("Invalid attachment key {} ... attachment is skipped", key); return null; } }
public static JBBPCompiledBlock compile(final String script) throws IOException { return compile(script, null); }
public Collection<Object> create() { Collection<Object> completeTaxonomyTree = new ArrayList<>(); for (String typeName : includedTypeNames) { completeTaxonomyTree.add(createTaxonomyTreeForType(typeName)); } return completeTaxonomyTree; }
@Override public List<ServiceInstance> getInstances(String serviceId) { Assert.notNull(serviceId, "[Assertion failed] - the object argument must not be null"); List<Endpoints> endpointsList = this.properties.isAllNamespaces() ? this.client.endpoints().inAnyNamespace() .withField("metadata.name", serviceId).list().getItems() : Collections .singletonList(this.client.endpoints().withName(serviceId).get()); List<EndpointSubsetNS> subsetsNS = endpointsList.stream() .map(endpoints -> getSubsetsFromEndpoints(endpoints)) .collect(Collectors.toList()); List<ServiceInstance> instances = new ArrayList<>(); if (!subsetsNS.isEmpty()) { for (EndpointSubsetNS es : subsetsNS) { instances.addAll(this.getNamespaceServiceInstances(es, serviceId)); } } return instances; }
@Override public boolean delete(String name) throws RestException { try { client.delete().forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/" + name); } catch (KeeperException.NoNodeException e) { return false; } catch (Exception e) { throw new RestException(e); } return true; }
@RequestMapping(path = "/v1/patching/topnoncompliantexecs", method = RequestMethod.GET) public ResponseEntity<Object> getTopNonCompliantExecs(@RequestParam(name = "ag", required = true) String assetGroup) { ResponseData response = null; try { response = new ResponseData(patchingService.getNonCompliantExecsForAG(assetGroup)); } catch (ServiceException e) { return complianceService.formatException(e); } return ResponseUtils.buildSucessResponse(response); }
protected InputStream getConfigurationStream(final Properties props) { InputStream result = getConfigStreamFromProperties(props); if (result != null) { return result; } result = getConfigStreamFromProperties(System.getProperties()); if (result != null) { return result; } result = resourceClassLoader.getResourceAsStream(CONFIG_FILE_NAME); if (result != null) { return result; } return null; }
public static Session useBestWrapper(final Session session) { if (session instanceof JackrabbitWrapper || session instanceof JcrWrapper) { return session; } else if (session instanceof JackrabbitSession) { return new JackrabbitWrapper((JackrabbitSession) session); } else if (session != null) { return new JcrWrapper(session); } return null; }
@Override public List<Record> list() { ArrayList<Record> list = new ArrayList<>(); iterator.forEachRemaining(e -> list.add(converter.toRecord(e))); return list; }
public static Entry create(String key, String value, EntryMetadata entryMetadata) { Utils.checkArgument(keyIsValid(key), "Invalid entry key name: %s", key); Utils.checkArgument(isValueValid(value), "Invalid entry value: %s", value); return new AutoValue_Entry(key, value, entryMetadata); }
@Override public Node createNode(CharSequence edgeCharacters, Object value, List<Node> childNodes, boolean isRoot) { if (edgeCharacters == null) { throw new IllegalStateException("The edgeCharacters argument was null"); } if (!isRoot && edgeCharacters.length() == 0) { throw new IllegalStateException("Invalid edge characters for non-root node: " + CharSequences.toString(edgeCharacters)); } if (childNodes == null) { throw new IllegalStateException("The childNodes argument was null"); } NodeUtil.ensureNoDuplicateEdges(childNodes); if (childNodes.isEmpty()) { if (value instanceof VoidValue) { return new ByteArrayNodeLeafVoidValue(edgeCharacters); } else if (value != null) { return new ByteArrayNodeLeafWithValue(edgeCharacters, value); } else { return new ByteArrayNodeLeafNullValue(edgeCharacters); } } else { if (value instanceof VoidValue) { return new ByteArrayNodeNonLeafVoidValue(edgeCharacters, childNodes); } else if (value == null) { return new ByteArrayNodeNonLeafNullValue(edgeCharacters, childNodes); } else { return new ByteArrayNodeDefault(edgeCharacters, value, childNodes); } } }
@Factory public static CompareMatcher isIdenticalTo(final Object control) { return new CompareMatcher(control).checkForIdentical(); }
@Override public ToBoolean<T> orElseGet(ToBoolean<T> getter) { return t -> isNull.test(t) ? getter.applyAsBoolean(t) : original.applyAsBoolean(t); }
@OnMayClose public boolean onMayClose() { return !groupEditorWorkflow.isDirty() || Window.confirm(UsersManagementWidgetsConstants.INSTANCE.groupIsDirty()); }
@Override public String toString() { return new StringBuilder("GRPCServerConfigImpl(") .append(String.format("port: %d, ", port)) .append(String.format("publishedRPCHost: %s, ", publishedRPCHost.isPresent() ? publishedRPCHost.get() : "null")) .append(String.format("publishedRPCPort: %s, ", publishedRPCPort.isPresent() ? publishedRPCPort.get() : "null")) .append(String.format("authorizationEnabled: %b, ", authorizationEnabled)) .append(String.format("userPasswordFile is %s, ", Strings.isNullOrEmpty(userPasswordFile) ? "unspecified" : "specified")) .append(String.format("tokenSigningKey is %s, ", Strings.isNullOrEmpty(tokenSigningKey) ? "unspecified" : "specified")) .append(String.format("accessTokenTTLInSeconds: %s, ", accessTokenTTLInSeconds)) .append(String.format("tlsEnabled: %b, ", tlsEnabled)) .append(String.format("tlsCertFile is %s, ", Strings.isNullOrEmpty(tlsCertFile) ? "unspecified" : "specified")) .append(String.format("tlsKeyFile is %s, ", Strings.isNullOrEmpty(tlsKeyFile) ? "unspecified" : "specified")) .append(String.format("tlsTrustStore is %s, ", Strings.isNullOrEmpty(tlsTrustStore) ? "unspecified" : "specified")) .append(String.format("replyWithStackTraceOnError: %b, ", replyWithStackTraceOnError)) .append(String.format("requestTracingEnabled: %b", requestTracingEnabled)) .append(")") .toString(); }
public static String normaliseName(final String name) { if (Objects.isNull(name)) { return ""; } String value = name; if (StringUtils.nonEmpty(value)) { value = value.trim(); value = value.replaceAll(NORMALIZE_TO_SINGLE_WHITE_SPACE, WHITESPACE_STRING); } return value; }
public static TaskFuture start(Config config, Class<? extends Sequencable> sequenceClass, Object... arguments) { Check.notNull(config); Check.notNull(sequenceClass); Check.notNull(arguments); final Runnable runnable = () -> handle(config, sequenceClass, arguments); final Thread thread = new Thread(runnable, Constant.ENGINE_NAME); final AtomicReference<Throwable> reference = new AtomicReference<>(); thread.setUncaughtExceptionHandler((t, e) -> { reference.set(e); Verbose.exception(e); Engine.terminate(); }); thread.start(); return () -> check(thread, reference); }
public static Promise<QueryResponse, ResourceException> perform(QueryResourceHandler handler, QueryRequest request, List<ResourceResponse> resources) { if (isSortingRequested(request)) { resources = sortItems(request, resources); } if (isPagingRequested(request)) { handler = createPagingHandler(handler, request); } int handledCount = handleResources(handler, resources); QueryResponse response = generateQueryResponse(request, resources.size(), handledCount); return Promises.newResultPromise(response); }
public void ensureBoundConsistency() throws ContradictionException { update.onUpdate(start, IntEventType.REMOVE); }
public MonetaryAmount querySumOf(CurrencyUnit targetCurrency, MonetaryAmount... amounts) { throw new UnsupportedOperationException(); }
static Set<DataSegment> annotateShardSpec(Set<DataSegment> segments) { final Map<Interval, List<DataSegment>> intervalToSegments = new HashMap<>(); segments.forEach( segment -> intervalToSegments.computeIfAbsent(segment.getInterval(), k -> new ArrayList<>()).add(segment) ); for (Entry<Interval, List<DataSegment>> entry : intervalToSegments.entrySet()) { final Interval interval = entry.getKey(); final List<DataSegment> segmentsPerInterval = entry.getValue(); final ShardSpec firstShardSpec = segmentsPerInterval.get(0).getShardSpec(); final boolean anyMismatch = segmentsPerInterval.stream().anyMatch( segment -> segment.getShardSpec().getClass() != firstShardSpec.getClass() ); if (anyMismatch) { throw new ISE( "Mismatched shardSpecs in interval[%s] for segments[%s]", interval, segmentsPerInterval ); } final Function<DataSegment, DataSegment> annotateFn; if (firstShardSpec instanceof OverwriteShardSpec) { annotateFn = annotateAtomicUpdateGroupFn(segmentsPerInterval.size()); } else if (firstShardSpec instanceof BuildingShardSpec) { annotateFn = annotateCorePartitionSetSizeFn(segmentsPerInterval.size()); } else if (firstShardSpec instanceof BucketNumberedShardSpec) { throw new ISE("Cannot publish segments with shardSpec[%s]", firstShardSpec); } else { annotateFn = null; } if (annotateFn != null) { intervalToSegments.put(interval, segmentsPerInterval.stream().map(annotateFn).collect(Collectors.toList())); } } return intervalToSegments.values().stream().flatMap(Collection::stream).collect(Collectors.toSet()); }
public String getTotalFails() { return totalFails; }
public void perform(Rnr requisition, ProgramRnrTemplate template) { requisition.setFullSupplyItemsSubmittedCost(new Money("0")); requisition.setNonFullSupplyItemsSubmittedCost(new Money("0")); calculateForFullSupply(requisition, template); calculateForNonFullSupply(requisition); }
@NonNull @Override public String getThemesPath() { return "themes/"; }
public synchronized byte[] getActiveData() throws ActiveNotFoundException, KeeperException, InterruptedException, IOException { try { if (zkClient == null) { createConnection(); } Stat stat = new Stat(); return getDataWithRetries(zkLockFilePath, false, stat); } catch(KeeperException e) { Code code = e.code(); if (isNodeDoesNotExist(code)) { throw new ActiveNotFoundException(); } else { throw e; } } }
@Override public boolean accept(Corc corc) throws IOException { TruthValue[] truthValues = new TruthValue[evaluators.size()]; for (int i = 0; i < evaluators.size(); i++) { truthValues[i] = evaluators.get(i).evaluate(corc); } TruthValue truthValue = searchArgument.evaluate(truthValues); switch (truthValue) { case YES: return true; default: return false; } }
public static boolean isUnclosedQuote(final String line) { int quoteStart = -1; for (int i = 0; i < line.length(); ++i) { if (quoteStart < 0 && isQuoteChar(line, i)) { quoteStart = i; } else if (quoteStart >= 0 && isTwoQuoteStart(line, i) && !isEscaped(line, i)) { i++; } else if (quoteStart >= 0 && isQuoteChar(line, i) && !isEscaped(line, i)) { quoteStart = -1; } } final int commentInd = line.indexOf(COMMENT); if (commentInd < 0) { return quoteStart >= 0; } else if (quoteStart < 0) { return false; } else { return commentInd > quoteStart; } }
@Override public void validate(Object target, Errors errors) { Visit visit = (Visit) target; ValidationUtils.rejectIfEmpty(errors, "patient", "Visit.error.patient.required"); ValidationUtils.rejectIfEmpty(errors, "visitType", "Visit.error.visitType.required"); ValidationUtils.rejectIfEmpty(errors, "startDatetime", "Visit.error.startDate.required"); if (visit.getStartDatetime() != null && OpenmrsUtil.compareWithNullAsLatest(visit.getStartDatetime(), visit.getStopDatetime()) > 0) { errors.rejectValue("stopDatetime", "Visit.error.endDateBeforeStartDate"); } if (visit.getId() != null) { Date startDateTime = visit.getStartDatetime(); Date stopDateTime = visit.getStopDatetime(); List<Encounter> encounters = Context.getEncounterService().getEncountersByVisit(visit, false); for (Encounter encounter : encounters) { if (encounter.getEncounterDatetime().before(startDateTime)) { errors.rejectValue("startDatetime", "Visit.encountersCannotBeBeforeStartDate", "This visit has encounters whose dates cannot be before the start date of the visit."); break; } else if (stopDateTime != null && encounter.getEncounterDatetime().after(stopDateTime)) { errors.rejectValue("stopDatetime", "Visit.encountersCannotBeAfterStopDate", "This visit has encounters whose dates cannot be after the stop date of the visit."); break; } } } ValidateUtil.validateFieldLengths(errors, target.getClass(), "voidReason"); super.validateAttributes(visit, errors, Context.getVisitService().getAllVisitAttributeTypes()); if (disallowOverlappingVisits()) { List<Visit> otherVisitList = Context.getVisitService().getVisitsByPatient(visit.getPatient()); for (Visit otherVisit : otherVisitList) { validateStartDatetime(visit, otherVisit, errors); validateStopDatetime(visit, otherVisit, errors); } } }
public static Unmarshaller createUnmarshaller() { try { return CONTEXT.createUnmarshaller(); } catch (JAXBException e) { LOGGER.error("Could not instantiate unmarshaller", e); throw new IllegalStateException(e); } }
public static double value(int n, int k) { BinomialCoefficient.checkBinomial(n, k); if (n == k || k == 0) { return 1; } if (k == 1 || k == n - 1) { return n; } if (k > n / 2) { return value(n, n - k); } if (n < 67) { return BinomialCoefficient.value(n, k); } double result = 1; for (int i = 1; i <= k; i++) { result *= n - k + i; result /= i; } return Math.floor(result + 0.5); }
@Override MessageProcessorBase createRequestProcessor(String target, HttpServletRequest request, HttpServletResponse response, OpMonitoringData opMonitoringData) { log.trace("createRequestProcessor({})", target); if (!isGetRequest(request)) { return null; } if (target == null) { throw new CodedException(X_INVALID_REQUEST, "Target must not be null"); } MetadataClientRequestProcessor processor = new MetadataClientRequestProcessor(target, request, response); if (processor.canProcess()) { log.trace("Processing with MetadataClientRequestProcessor"); return processor; } return null; }
@Override public void onClassNameSelectChanged() { checkClassNameValidationErrors(); }
public static <T> Optional<T> min(Iterator<T> iter, Comparator<T> comparator) { T x = null; while(iter.hasNext()) { T elt = iter.next(); if ( x == null ) x = elt; else { int cmp = comparator.compare(x, elt); if ( cmp > 0 ) x = elt; } } return Optional.ofNullable(x); }
@Override public DateHolder convert(Object obj) { if (obj instanceof Date) { return new DateHolder((Date) obj); } if (obj instanceof Calendar) { Calendar cal = (Calendar) obj; return new DateHolder(cal.getTime()); } if (obj == null) { return new DateHolder(null); } if (obj instanceof String) { return decode((String) obj); } throw new IllegalArgumentException("conversion not supported for: " + obj.getClass()); }
public RValueExpression getRValue() { return rvalue; }
public static Optional<ApiMetadata> getApi(String id) { id = DeserializingJcloudsRenamesProvider.INSTANCE.applyJcloudsRenames(id); if (LazyServiceLoader.INSTANCE.apis.containsKey(id)) { return Optional.of(LazyServiceLoader.INSTANCE.apis.get(id)); } return Iterables.tryFind(ApiRegistry.fromRegistry(), ApiPredicates.id(id)); }
public static Properties loadProperties(String name) { return getProperties(getClassLoader(), getName(name)); }
public List<Synset> getSenses() { if (null == synsets) { synsets = new SynsetList(); } return synsets; }
@Override protected Map<String, Object> getParameters(final DepartmentSpecialty entity, final Map<String, Object> parameters) { addParameter(entity.getDepartment(), departmentDao, "department", parameters); addParameter(entity.getSpecialty(), specialtyDao, "specialty", parameters); return parameters; }
public Collection<Alarm> getAllAlarms() { return seyrenRepository.getAllAlarms().getValues(); }
@Override public boolean equals(Object o) { if (!(o instanceof RegimenOrder)) { return false; } RegimenOrder order = (RegimenOrder) o; return drugOrders.equals(order.getDrugOrders()); }
@Override public void exceptionCaught(final ChannelHandlerContext ctx, final ExceptionEvent event) { final Throwable cause = event.getCause(); LOGGER.debug("Caught exception", cause); final Channel channel = event.getChannel(); if (cause instanceof ClosedChannelException) { LOGGER.debug("Channel closed", cause); } else if (cause instanceof QueryException) { handleException(channel, ((QueryException) cause).getMessages(), ((QueryException) cause).getCompletionInfo()); } else if (cause instanceof TimeoutException) { handleException(channel, Collections.singletonList(QueryMessages.timeout()), QueryCompletionInfo.EXCEPTION); } else if (cause instanceof TooLongFrameException) { handleException(channel, Collections.singletonList(QueryMessages.inputTooLong()), QueryCompletionInfo.EXCEPTION); } else if (cause instanceof IOException) { handleException(channel, Collections.<Message>emptyList(), QueryCompletionInfo.EXCEPTION); } else if (cause instanceof DataAccessException) { LOGGER.error("Caught exception on channel id = {}, from = {} for query = {}\n{}", channel.getId(), ChannelUtil.getRemoteAddress(channel), query, cause.toString()); handleException(channel, Collections.singletonList(QueryMessages.internalErroroccurred()), QueryCompletionInfo.EXCEPTION); } else { LOGGER.error("Caught exception on channel id = {}, from = {} for query = {}", channel.getId(), ChannelUtil.getRemoteAddress(channel), query, cause); handleException(channel, Collections.singletonList(QueryMessages.internalErroroccurred()), QueryCompletionInfo.EXCEPTION); } }
public void load(MyMap<Long, IdTreeNode> threadLogs, MyMap<Long, Boolean> threadOfftrack, BiMap<String,Integer> dico) { this.threadLogs = threadLogs; this.threadOfftrack = threadOfftrack; this.dictionary = dico; }
public boolean hasField(final Object target, final String fieldName) { final String cacheKey = "ClassHasField-" + target.getClass().getName() + '-' + fieldName; return CACHE_MANAGER.getFromCache(cacheKey, Boolean.class).orElseGet(() -> { boolean hasField = false; try { target.getClass().getDeclaredField(fieldName); hasField = true; } catch (final NoSuchFieldException e) { final Class<?> superclass = target.getClass().getSuperclass(); if (hasSuperclass(superclass)) { hasField = hasField(superclass, fieldName); } } CACHE_MANAGER.cacheObject(cacheKey, hasField); return hasField; }); }
public static Map<String, Object> convert(Object object) { return jsonToMap(object); }
@Override @FederationEnabled public Object getFullObjectForType(final String objectAbsolutePath) throws FileNotFoundException, JargonException { if (objectAbsolutePath == null || objectAbsolutePath.isEmpty()) { throw new IllegalArgumentException("null or empty object absolute path"); } log.info("getFullObjectForType for path:{}", objectAbsolutePath); final ObjStat objStat = retrieveObjectStatForPath(objectAbsolutePath); final String effectiveAbsolutePath = MiscIRODSUtils.determineAbsolutePathBasedOnCollTypeInObjectStat(objStat); log.info("determined effectiveAbsolutePathToBe:{}", effectiveAbsolutePath); MiscIRODSUtils.evaluateSpecCollSupport(objStat); Object returnObject = null; if (objStat.isSomeTypeOfCollection()) { final CollectionAO collectionAO = new CollectionAOImpl(getIRODSSession(), getIRODSAccount()); returnObject = collectionAO.findGivenObjStat(objStat); } else { if (objStat.getSpecColType() == SpecColType.STRUCT_FILE_COLL) { returnObject = buildDataObjectFromObjStatIfStructuredCollection(objStat); } else { returnObject = buildDataObjectFromICAT(objStat); } } return returnObject; }
public R execute() { try { return queue().get(); } catch (Exception e) { throw Exceptions.sneakyThrow(decomposeException(e)); } }
@Override public void emit(final Event event) { requireNonNull(event, "Cannot emit a null event!"); try { final Message message = session.createTextMessage(serializer.serialize(event)); message.setStringProperty("Content-Type", "application/ld+json"); producer.send(message); } catch (final JMSException ex) { LOGGER.error("Error writing to broker: {}", ex.getMessage()); } }
@Override public Multimap<String,String> flatten(JsonObject object) throws IllegalStateException { Multimap<String,String> map = HashMultimap.create(); flatten(object, map); return map; }
public List<INT16> readAINT16() throws IOException { return AINT16.read(in); }
@Override public Query filterQuery(Query query) { return new EscapeLikeParametersQuery(query); }
public void setScopeNote(String scopeNote) { this.scopeNote = scopeNote; }
public static String ebcdicToAscii(byte[] e) { return EBCDIC.decode(ByteBuffer.wrap(e)).toString(); }
@Override @Transactional public ServiceResult<SaveMonitoringOfficerResult> saveMonitoringOfficer(final Long projectId, final LegacyMonitoringOfficerResource monitoringOfficerResource) { return validateMonitoringOfficer(projectId, monitoringOfficerResource). andOnSuccess(() -> validateInMonitoringOfficerAssignableState(projectId)). andOnSuccess(() -> saveMonitoringOfficer(monitoringOfficerResource)); }
public HelmList pending() { return withFlags(Argument.of("--pending")); }
@Override public void addColumn(TableColumn column) { swingThreadSource.getReadWriteLock().writeLock().lock(); try { swingThreadSource.add((T) column); } finally { swingThreadSource.getReadWriteLock().writeLock().unlock(); } }
protected static Duration getRequestTimeout(HttpRequest request, Duration defaultTimeout) { if ( ! request.hasProperty("timeout")) { return defaultTimeout; } try { return Duration.ofMillis((long) (Double.parseDouble(request.getProperty("timeout")) * 1000)); } catch (Exception e) { return defaultTimeout; } }
@Override public Configuration loadResourceConfiguration() throws Exception { Properties properties = new Properties(); properties.load(new FileInputStream(jvmOptsFile)); Configuration config = new Configuration(); String heapDumpOnOOMError = properties.getProperty("heap_dump_on_OOMError"); String heapDumpDir = properties.getProperty("heap_dump_dir"); config.put(new PropertySimple("minHeapSize", getHeapMinProp(properties))); config.put(new PropertySimple("maxHeapSize", getHeapMaxProp(properties))); config.put(new PropertySimple("heapNewSize", getHeapNewProp(properties))); config.put(new PropertySimple("threadStackSize", getStackSizeProp(properties))); if (!StringUtil.isEmpty(heapDumpOnOOMError)) { config.put(new PropertySimple("heapDumpOnOOMError", true)); } else { config.put(new PropertySimple("heapDumpOnOOMError", false)); } if (!StringUtil.isEmpty(heapDumpDir)) { config.put(new PropertySimple("heapDumpDir", heapDumpDir)); } else { File basedir = jvmOptsFile.getParentFile().getParentFile(); config.put(new PropertySimple("heapDumpDir", new File(basedir, "bin").getAbsolutePath())); } ConfigEditor yamlEditor = new ConfigEditor(cassandraYamlFile); yamlEditor.load(); config.put(new PropertySimple("cqlPort", yamlEditor.getNativeTransportPort())); config.put(new PropertySimple("gossipPort", yamlEditor.getStoragePort())); config.put(new PropertySimple("CommitLogLocation", yamlEditor.getCommitLogDirectory())); config.put(new PropertySimple("SavedCachesLocation", yamlEditor.getSavedCachesDirectory())); PropertyList dataFileLocations = new PropertyList("AllDataFileLocations"); for (String s : yamlEditor.getDataFileDirectories()) { dataFileLocations.add(new PropertySimple("directory", s)); } config.put(dataFileLocations); return config; }
@Override public int hashCode() { int result; long temp; temp = Double.doubleToLongBits(latitude); result = (int) (temp ^ (temp >>> 32)); temp = Double.doubleToLongBits(longitude); result = 31 * result + (int) (temp ^ (temp >>> 32)); return result; }
@Override protected DnsQueryResult query(DnsMessage.Builder queryBuilder) throws IOException { DnsMessage q = queryBuilder.build(); ResolutionState resolutionState = new ResolutionState(this); DnsQueryResult result = queryRecursive(resolutionState, q); return result; }
@Override public List<Metric> transform(QueryContext queryContext, List<Metric>... listOfList) { List<Metric> result = new ArrayList<>(); for (List<Metric> list : listOfList) { for (Metric metric : list) { result.add(metric); } } return result; }
@Override public Map<String, String> get() { return Collections.EMPTY_MAP; }
public static List<WeightedHostAddress> prioritize(WeightedHostAddress[] records) { final List<WeightedHostAddress> result = new LinkedList<>(); SortedMap<Integer, Set<WeightedHostAddress>> byPriority = new TreeMap<>(); for(final WeightedHostAddress record : records) { if (byPriority.containsKey(record.getPriority())) { byPriority.get(record.getPriority()).add(record); } else { final Set<WeightedHostAddress> set = new HashSet<>(); set.add(record); byPriority.put(record.getPriority(), set); } } for(Map.Entry<Integer, Set<WeightedHostAddress>> weights : byPriority.entrySet()) { List<WeightedHostAddress> zeroWeights = new LinkedList<>(); int totalWeight = 0; final Iterator<WeightedHostAddress> i = weights.getValue().iterator(); while (i.hasNext()) { final WeightedHostAddress next = i.next(); if (next.weight == 0) { zeroWeights.add(next); i.remove(); continue; } totalWeight += next.getWeight(); } int iterationWeight = totalWeight; Iterator<WeightedHostAddress> iter = weights.getValue().iterator(); while (iter.hasNext()) { int needle = new Random().nextInt(iterationWeight); while (true) { final WeightedHostAddress record = iter.next(); needle -= record.getWeight(); if (needle <= 0) { result.add(record); iter.remove(); iterationWeight -= record.getWeight(); break; } } iter = weights.getValue().iterator(); } Collections.shuffle(zeroWeights); for(WeightedHostAddress zero : zeroWeights) { result.add(zero); } } return result; }
public void setAdHocOrdering(org.kie.workbench.common.stunner.bpmn.definition.property.task.AdHocOrdering value) { process.setOrdering(AdHocOrdering.getByName(value.getValue())); }
public static double[] buildRleWeights(List<Number> weightList, int limit) { double[] weights = new double[weightList.size() + (weightList.size() / (limit * 2))]; double latestValue = Double.POSITIVE_INFINITY; int counter = 0; int i = 0; for (Number value : weightList) { if (value.doubleValue() == latestValue || (Double.isNaN(latestValue) && Double.isNaN(value.doubleValue()))) { counter++; } else { if (counter > limit) { weights[i++] = Double.POSITIVE_INFINITY; weights[i++] = counter; weights[i++] = latestValue; counter = 1; } else { if (counter > 0) { for (int j = 0; j < counter; j++) { weights[i++] = latestValue; } } counter = 1; } latestValue = value.doubleValue(); } } if (counter > limit) { weights[i++] = Double.POSITIVE_INFINITY; weights[i++] = counter; weights[i++] = latestValue; } else { for (int j = 0; j < counter; j++) { weights[i++] = latestValue; } } return Arrays.copyOf(weights, i); }
@Override protected ReadableByteChannel open(LocalResourceId resourceId) throws IOException { LOG.debug("opening file {}", resourceId); @SuppressWarnings("resource") FileInputStream inputStream = new FileInputStream(resourceId.getPath().toFile()); return inputStream.getChannel(); }
@Override protected BaseQueryBuilder build(final SpecOfferWave context, final BaseQueryBuilder builder) { return builder .where() .openBracket() .addAndCondition(SPECOFFER_CONDITION, context.getSpecOffer()) .addAndCondition(WAVETYPE_CONDITION, context.getWaveType()) .addAndCondition(LICCOUNT_CONDITION, context.getLicCount()) .addAndCondition(STATECOUNT_CONDITION, context.getStateCount()) .addAndCondition(BENEFITCOUNT_CONDITION, context.getBenefitCount()) .addAndCondition(TARGETCOUNT_CONDITION, context.getTargetCount()) .addAndCondition(BEGINDATE_CONDITION, context.getBeginDate()) .addAndCondition(ENDDATE_CONDITION, context.getEndDate()) .closeBracket(); }
@Override public void setExceptionType(String exceptionType) { throw new UnsupportedOperationException("Exception type can not be changed"); }
@Override public void writeNull() throws IOException { out.write(NULL); }
public static @Nullable String convertRawBytesToString( @NotNull Charset contentCharset, @Nullable byte[] rawBytes ) { if (contentCharset == null) { throw new IllegalArgumentException("contentCharset cannot be null"); } if (rawBytes == null) { return null; } if (rawBytes.length == 0) { return ""; } String rawString = new String(rawBytes, contentCharset); rawString = rawString.replace("\uFEFF", ""); return rawString; }
@Override @Transactional(rollbackFor = Throwable.class) public void delete(AssignmentConfig assignmentConfig) { getSession().delete(assignmentConfig); }
@Override public String convertToDatabaseColumn(VariableValue<?> variableValue) { try { return objectMapper.writeValueAsString(variableValue); } catch (JsonProcessingException e) { throw new QueryException("Unable to serialize variable.", e); } }
public ValidationResult validate(@NotNull UpdateAuthorisationRequest updateRequest, @NotNull ScaStatus scaStatus, @NotNull AuthorisationServiceType authType) { if (scaStatus == RECEIVED && updateRequest.getPsuData().isEmpty()) { return ValidationResult.invalid(resolveErrorType(authType), SERVICE_INVALID_400); } if (scaStatus == PSUIDENTIFIED && updateRequest.getPassword() == null) { return ValidationResult.invalid(resolveErrorType(authType), SERVICE_INVALID_400); } if (scaStatus == PSUAUTHENTICATED && updateRequest.getAuthenticationMethodId() == null) { return ValidationResult.invalid(resolveErrorType(authType), SERVICE_INVALID_400); } if (scaStatus == SCAMETHODSELECTED && updateRequest.getScaAuthenticationData() == null) { return ValidationResult.invalid(resolveErrorType(authType), SERVICE_INVALID_400); } return ValidationResult.valid(); }
public static String join(Collection<?> items, String property, String separator) { if (items == null) { return ""; } return StringUtils.join(substract(items, property), separator); }
@Override public T execute(Transaction transaction) throws E { try { return delegate.execute(transaction); } catch (Exception ex) { if (shouldRethrowWithoutLockValidation(ex) || immutableTsLockIsValid()) { throw ex; } throw new TransactionLockTimeoutException( "The following immutable timestamp lock is no longer valid: " + immutableTsLock); } }
@GetMapping("greet") public Mono<Map> greet() { return Mono.just(Map.of("greet", "Hi everybody")); }
ProcessBuilder get() { if (StepRunner.STANDALONE.name().equals(config.processRunner)) { return buildDirect(); } if (StepRunner.DISTRIBUTED.name().equals(config.processRunner)) { return buildSpark(); } throw new IllegalArgumentException("Wrong runner type - " + config.processRunner); }
protected static String format(String pattern, Date currentTime) { return new SimpleDateFormat(pattern,Locale.GERMAN).format(currentTime); }
public static Builder withOrigin(final String origin) { if ("*".equals(origin)) { return new Builder(); } return new Builder(origin); }
public void consume(Map<String, String> result) throws IOException { if (httpResponse.getEntity() != null) { if (responseCharacterSet == null || responseCharacterSet.isEmpty()) { Header contentType = httpResponse.getEntity().getContentType(); if (contentType != null) { String value = contentType.getValue(); NameValuePair[] nameValuePairs = BasicHeaderValueParser.parseParameters(value, BasicHeaderValueParser.INSTANCE); for (NameValuePair nameValuePair : nameValuePairs) { if (nameValuePair.getName().equalsIgnoreCase("charset")) { responseCharacterSet = nameValuePair.getValue(); break; } } } if (responseCharacterSet == null || responseCharacterSet.isEmpty()) { responseCharacterSet = Consts.ISO_8859_1.name(); } } consumeResponseContent(result); } }
public static TransmitStatusPacket createPacket(byte[] payload) { if (payload == null) throw new NullPointerException("Transmit Status packet payload cannot be null."); if (payload.length < MIN_API_PAYLOAD_LENGTH) throw new IllegalArgumentException("Incomplete Transmit Status packet."); if ((payload[0] & 0xFF) != APIFrameType.TRANSMIT_STATUS.getValue()) throw new IllegalArgumentException("Payload is not a Transmit Status packet."); int index = 1; int frameID = payload[index] & 0xFF; index = index + 1; XBee16BitAddress address = new XBee16BitAddress(payload[index] & 0xFF, payload[index + 1] & 0xFF); index = index + 2; int retryCount = payload[index] & 0xFF; index = index + 1; int deliveryStatus = payload[index] & 0xFF; index = index + 1; int discoveryStatus = payload[index] & 0xFF; return new TransmitStatusPacket(frameID, address, retryCount, XBeeTransmitStatus.get(deliveryStatus), XBeeDiscoveryStatus.get(discoveryStatus)); }
public void changeDueDateBy(IncreaseOrDecrease increaseOrDecrease, TimeUnit timeUnit, int quantity) { DayOverflow overflow = DayOverflow.LastDay; int dys = 0, hrs = 0, mts = 0; switch (timeUnit) { case DAYS: dys += quantity; break; case MINUTES: mts += quantity; break; case HOURS: hrs += quantity; } if (_dueDateTime == null) { _dueDateTime = _coreDateUtils.now(); } if (increaseOrDecrease == MINUS) { _dueDateTime = _dueDateTime.minus(0, 0, dys, hrs, mts, 0, 0, overflow); } else { _dueDateTime = _dueDateTime.plus(0, 0, dys, hrs, mts, 0, 0, overflow); } _talkToTaskCreate.updateDueDateDisplay( _taskCreatePresenter.getDueDateText(_dueDateTime), _taskCreatePresenter.getDueDateDiffText(_dueDateTime)); }
@Nullable Variation getWhitelistedVariation(@Nonnull Experiment experiment, @Nonnull String userId) { Map<String, String> userIdToVariationKeyMap = experiment.getUserIdToVariationKeyMap(); if (userIdToVariationKeyMap.containsKey(userId)) { String forcedVariationKey = userIdToVariationKeyMap.get(userId); Variation forcedVariation = experiment.getVariationKeyToVariationMap().get(forcedVariationKey); if (forcedVariation != null) { logger.info("User \"{}\" is forced in variation \"{}\".", userId, forcedVariationKey); } else { logger.error("Variation \"{}\" is not in the datafile. Not activating user \"{}\".", forcedVariationKey, userId); } return forcedVariation; } return null; }
@PublicAPI(usage = ACCESS) public JavaClasses importClasses(Class<?>... classes) { return importClasses(Arrays.asList(classes)); }
public String areaAddress() { return areaAddress; }
@Override @GET @Path("/{id}") @RequiresAuthentication @RequiresPermissions("nexus:roles:read") public RoleXOResponse getRole(@DefaultValue(DEFAULT_SOURCE) @QueryParam("source") final String source, @PathParam("id") @NotEmpty final String id) { try { return RoleXOResponse.fromRole(securitySystem.getAuthorizationManager(source).getRole(id)); } catch (NoSuchAuthorizationManagerException e) { throw buildBadSourceException(source); } catch (NoSuchRoleException e) { throw buildRoleNotFoundException(id); } }
@Override public List<JSONObject> parse(byte[] msg) { JSONObject payload = null; List<JSONObject> messages = new ArrayList<>(); try { String raw_message = new String(msg, getReadCharset()); payload = (JSONObject) JSONValue.parse(raw_message); String message = payload.get("message").toString(); String[] parts = message.split(" "); payload.put("ip_src_addr", parts[6]); payload.put("ip_dst_addr", parts[7]); String fixed_date = parts[5].replace('T', ' '); fixed_date = fixed_date.replace('Z', ' ').trim(); SimpleDateFormat formatter = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss"); Date date; date = formatter.parse(fixed_date); long timestamp = date.getTime(); payload.put("timestamp", timestamp); payload.remove("@timestamp"); payload.remove("message"); payload.put("original_string", message); messages.add(payload); return messages; } catch (Exception e) { _LOG.error("Unable to parse message: {}", payload.toJSONString()); return null; } }
static String separateVariables(String s) { StringBuffer sb = new StringBuffer(); char c = ' '; boolean isVar = false; boolean escaped = false; boolean doubleQuoted = false; boolean quoted = false; int len = s.length(); int bracket = 0; int square = 0; for (int i = 0; i < len; i++) { c = s.charAt(i); if (c == '\\') { escaped = !escaped; } else if (c == '"') { if (!(escaped || quoted)) { doubleQuoted = !doubleQuoted; } } else if (c == '\'') { if (!(escaped || doubleQuoted)) { quoted = !quoted; } } else if (c == '$' && !isVar && !escaped && !quoted && !doubleQuoted && i + 1 < len && Character.isJavaIdentifierStart(s.charAt(i + 1))) { isVar = true; bracket = 0; square = 0; sb.append("\"+s_v("); } else if (isVar && !escaped && !(Character.isJavaIdentifierPart(c) || c == '.')) { boolean append = false; if (!escaped && !quoted && !doubleQuoted) { if (c == '(') { bracket++; } else if (c == ')') { bracket--; if (bracket < 0) { append = true; } } else if (c == '[') { square++; } else if (c == ']') { square--; if (square < 0) { append = true; } } else { if (bracket > 0 && (c == ',' || Character.isWhitespace(c) || c == '/')) { append = false; } else { append = true; } } } if (append) { sb.append(")+\""); isVar = false; } } if (!isVar && (c == '\\' || c == '"')) { sb.append('\\'); } sb.append(c); if (c != '\\') { escaped = false; } } if (isVar) { sb.append(")+\""); isVar = false; } return sb.toString(); }
@CheckForNull public static ExpressionTree retrievedPropertyDefaultValue(ExpressionTree expression) { if (expression.is(Tree.Kind.IDENTIFIER)) { return retrievedPropertyDefaultValue((IdentifierTree) expression); } else if (expression.is(Tree.Kind.METHOD_INVOCATION)) { return retrievedPropertyDefaultValue((MethodInvocationTree) expression); } return null; }
@Override public void configure(ContainerSpecification container) throws IOException { if(hadoopConfDir == null) { return; } File coreSitePath = new File(hadoopConfDir, "core-site.xml"); File hdfsSitePath = new File(hadoopConfDir, "hdfs-site.xml"); container.getEnvironmentVariables().put("HADOOP_CONF_DIR", TARGET_CONF_DIR.toString()); container.getDynamicConfiguration().setString(ConfigConstants.PATH_HADOOP_CONFIG, TARGET_CONF_DIR.toString()); container.getArtifacts().add(ContainerSpecification.Artifact .newBuilder() .setSource(new Path(coreSitePath.toURI())) .setDest(new Path(TARGET_CONF_DIR, coreSitePath.getName())) .setCachable(true) .build()); container.getArtifacts().add(ContainerSpecification.Artifact .newBuilder() .setSource(new Path(hdfsSitePath.toURI())) .setDest(new Path(TARGET_CONF_DIR, hdfsSitePath.getName())) .setCachable(true) .build()); }
@Override public AttributedList<Path> list(final Path directory, final ListProgressListener listener) throws BackgroundException { try { final CloudBlobContainer container = session.getClient().getContainerReference(containerService.getContainer(directory).getName()); final AttributedList<Path> children = new AttributedList<Path>(); ResultContinuation token = null; ResultSegment<ListBlobItem> result; String prefix = StringUtils.EMPTY; if(!containerService.isContainer(directory)) { prefix = containerService.getKey(directory); if(!prefix.endsWith(String.valueOf(Path.DELIMITER))) { prefix += Path.DELIMITER; } } boolean hasDirectoryPlaceholder = containerService.isContainer(directory); do { final BlobRequestOptions options = new BlobRequestOptions(); result = container.listBlobsSegmented( prefix, false, EnumSet.noneOf(BlobListingDetails.class), PreferencesFactory.get().getInteger("azure.listing.chunksize"), token, options, context); for(ListBlobItem object : result.getResults()) { if(new Path(object.getUri().getPath(), EnumSet.of(Path.Type.directory)).equals(directory)) { hasDirectoryPlaceholder = true; continue; } final PathAttributes attributes = new PathAttributes(); if(object instanceof CloudBlob) { final CloudBlob blob = (CloudBlob) object; attributes.setSize(blob.getProperties().getLength()); attributes.setModificationDate(blob.getProperties().getLastModified().getTime()); attributes.setETag(blob.getProperties().getEtag()); if(StringUtils.isNotBlank(blob.getProperties().getContentMD5())) { attributes.setChecksum(Checksum.parse(Hex.encodeHexString(Base64.decodeBase64(blob.getProperties().getContentMD5())))); } } final EnumSet<Path.Type> types = object instanceof CloudBlobDirectory ? EnumSet.of(Path.Type.directory, Path.Type.placeholder) : EnumSet.of(Path.Type.file); final Path child = new Path(directory, PathNormalizer.name(object.getUri().getPath()), types, attributes); children.add(child); } listener.chunk(directory, children); token = result.getContinuationToken(); } while(result.getHasMoreResults()); if(!hasDirectoryPlaceholder && children.isEmpty()) { throw new NotfoundException(directory.getAbsolute()); } return children; } catch(StorageException e) { throw new AzureExceptionMappingService().map("Listing directory {0} failed", e, directory); } catch(URISyntaxException e) { throw new NotfoundException(e.getMessage(), e); } }
@Override public Object2IntMap<String> getLaneLimits(int totalLimit) { Object2IntMap<String> onlyLow = new Object2IntArrayMap<>(1); onlyLow.put(LOW, computeLimitFromPercent(totalLimit, maxLowPercent)); return onlyLow; }
@Override public List<String> getValuesFromArgs(String name, String[] args) { final String prefix = name + ":"; final int prefixLength = prefix.length(); final List<String> values = new ArrayList<String>(); for (String arg : args) { if (arg.startsWith(prefix)) { final String value = arg.substring(prefixLength).trim(); values.add(value); } } return Collections.unmodifiableList(values); }
public ValidationResult validate(final OperationChain<?> operationChain, final User user, final Store store) { final ValidationResult validationResult = new ValidationResult(); if (operationChain.getOperations().isEmpty()) { validationResult.addError("Operation chain contains no operations"); } else { Class<? extends Output> output = null; for (final Operation op : operationChain.getOperations()) { output = validate(op, user, store, validationResult, output); } } return validationResult; }
@Override public Optional<Document> findByIdentifier(String identifier) throws DatabaseException { ParametersChecker.checkParameter(ALL_PARAMS_REQUIRED); String index = indexName; try { return handleSearch(index, termQuery(IDENTIFIER, identifier)); } catch (IOException e) { throw new DatabaseException("Search by identifier exception", e); } }
public void put(long index) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.add(getPageOffset(index)); numProperties += page.getSize() - n; }
@Override public void validate(Object obj, Errors errors) { super.validate(obj, errors); DrugOrder order = (DrugOrder) obj; if (order == null) { errors.reject("error.general"); } else { ValidationUtils.rejectIfEmpty(errors, "asNeeded", "error.null"); if (order.getAction() != Order.Action.DISCONTINUE) { ValidationUtils.rejectIfEmpty(errors, "dosingType", "error.null"); } if (order.getDrug() == null || order.getDrug().getConcept() == null) { ValidationUtils.rejectIfEmpty(errors, "concept", "error.null"); } if (order.getConcept() != null && order.getDrug() != null && order.getDrug().getConcept() != null && !order.getDrug().getConcept().equals(order.getConcept())) { errors.rejectValue("drug", "error.general"); errors.rejectValue("concept", "error.concept"); } if (order.getAction() != Order.Action.DISCONTINUE && order.getDosingType() != null) { DosingInstructions dosingInstructions = order.getDosingInstructionsInstance(); dosingInstructions.validate(order, errors); } validateFieldsForOutpatientCareSettingType(order, errors); validatePairedFields(order, errors); validateUnitsAreAmongAllowedConcepts(errors, order); validateForRequireDrug(errors, order); ValidateUtil.validateFieldLengths(errors, obj.getClass(), "asNeededCondition", "brandName"); } }
public boolean applyTo(DomainObject obj) { Program program = (Program)obj; Listing listing = program.getListing(); if (dataType instanceof FactoryDataType) { msg = "Array not allowed on a Factory data-type: " + dataType.getName(); return false; } if (dataType instanceof Dynamic && !((Dynamic)dataType).canSpecifyLength()) { msg = "Array not allowed on a non-sizable Dynamic data-type: " + dataType.getName(); return false; } if (numElements <= 0) { msg = "Number of elements must be positive, not "+numElements; return false; } Data data = listing.getDataContaining(addr); Data compData = data.getComponent(compPath); int elementLength; if (dataType instanceof Dynamic) { elementLength = compData.getLength(); } else { elementLength = dataType.getLength(); } if (elementLength <=0) { msg = "DataType must have fixed size > 0, not "+elementLength; return false; } int length = numElements*elementLength; int index = compData.getComponentIndex(); int offset = compData.getParentOffset(); DataType parentDataType = compData.getParent().getBaseDataType(); if (!(parentDataType instanceof Structure)) { msg = "Data not in a structure"; return false; } Structure struct = (Structure)parentDataType; if (offset+length > struct.getLength()) { msg = "Array too big for structure"; return false; } try { ArrayDataType adt = new ArrayDataType(dataType, numElements, dataType.getLength()); clearStruct(struct, compData.getParentOffset(), length); if (struct.isInternallyAligned()) { struct.insert(index, adt, adt.getLength()); } else { struct.replace(index, adt, adt.getLength()); } } catch(Exception e) { msg = e.getMessage(); return false; } return true; }
public static String substring(String tail, int startIndex, int endIndex) { if (tail == null) { return ""; } if (tail.length() <= startIndex) { return ""; } else { if (endIndex > tail.length() - 1) { return tail.substring(startIndex, tail.length()); } else { return tail.substring(startIndex, endIndex); } } }
public static void removeMBeanRegistrationListener(MBeanServerConnection pServer,NotificationListener pListener) { try { pServer.removeNotificationListener(JmxUtil.getMBeanServerDelegateName(), pListener); } catch (ListenerNotFoundException e) { } catch (InstanceNotFoundException e) { throw new IllegalStateException("Cannot find " + getMBeanServerDelegateName() + " in server " + pServer,e); } catch (IOException e) { throw new IllegalStateException("IOException while registering notification listener for " + getMBeanServerDelegateName(),e); } }
@Nullable protected AbstractTreeNode<?> createChildNode(ItemReference item) { if ("file".equals(item.getType())) { return getTreeStructure().newFileNode(this, item); } else if ("folder".equals(item.getType()) || "project".equals(item.getType())) { return getTreeStructure().newFolderNode(this, item); } return null; }
public static String notEmpty(String s, String paramName) { notNull(s, paramName); if (s.trim().isEmpty()) { throw new IllegalArgumentException(paramName + " cannot be empty"); } return s; }
public static void readRowRanges() { String projectId = "my-project-id"; String instanceId = "my-instance-id"; String tableId = "mobile-time-series"; readRowRanges(projectId, instanceId, tableId); }
public static ApplicationLoadResult loadApplication( File projectDirectory ) { ApplicationLoadResult result = new ApplicationLoadResult(); ApplicationTemplate app = new ApplicationTemplate(); result.applicationTemplate = app; ApplicationTemplateDescriptor appDescriptor = null; File descDirectory = new File( projectDirectory, Constants.PROJECT_DIR_DESC ); DESC: if( ! descDirectory.exists()) { RoboconfError error = new RoboconfError( ErrorCode.PROJ_NO_DESC_DIR, directory( projectDirectory )); result.loadErrors.add( error ); } else { File descriptorFile = new File( descDirectory, Constants.PROJECT_FILE_DESCRIPTOR ); if( ! descriptorFile.exists()) { result.loadErrors.add( new RoboconfError( ErrorCode.PROJ_NO_DESC_FILE )); break DESC; } try { appDescriptor = ApplicationTemplateDescriptor.load( descriptorFile ); app.setName( appDescriptor.getName()); app.setDescription( appDescriptor.getDescription()); app.setVersion( appDescriptor.getVersion()); app.setDslId( appDescriptor.getDslId()); app.setExternalExportsPrefix( appDescriptor.getExternalExportsPrefix()); app.setTags( appDescriptor.tags ); for( Map.Entry<String,String> entry : appDescriptor.externalExports.entrySet()) app.externalExports.put( entry.getKey(), app.getExternalExportsPrefix() + "." + entry.getValue()); result.objectToSource.put( appDescriptor, new SourceReference( appDescriptor, descriptorFile, 1 )); for( Map.Entry<String,Integer> entry : appDescriptor.propertyToLine.entrySet()) { result.objectToSource.put( entry.getKey(), new SourceReference( entry.getKey(), descriptorFile, entry.getValue())); } Collection<ModelError> errors = RuntimeModelValidator.validate( appDescriptor ); result.loadErrors.addAll( errors ); } catch( IOException e ) { RoboconfError error = new RoboconfError( ErrorCode.PROJ_READ_DESC_FILE, exception( e )); result.loadErrors.add( error ); } } return loadApplication( projectDirectory, appDescriptor, result ); }
@Override public void serialize(BinaryWriter writer) throws IOException { writer.write(this.scriptHash); }
@Override public Writer serializeRpc(final SchemaNode schemaNode, final NormalizedNode<?, ?> normalizedNode) throws SerializationException { Writer writer = new StringWriter(); XMLStreamWriter xmlStreamWriter = createXmlStreamWriter(writer); URI namespace = schemaNode.getQName().getNamespace(); String localName = schemaNode.getQName().getLocalName(); try (NormalizedNodeWriter normalizedNodeWriter = createNormalizedNodeWriter(schemaContext, xmlStreamWriter, schemaNode.getPath())) { xmlStreamWriter.writeStartElement(XMLConstants.DEFAULT_NS_PREFIX, localName, namespace.toString()); xmlStreamWriter.writeDefaultNamespace(namespace.toString()); for (NormalizedNode<?, ?> child : ((ContainerNode) normalizedNode).getValue()) { normalizedNodeWriter.write(child); } normalizedNodeWriter.flush(); xmlStreamWriter.writeEndElement(); xmlStreamWriter.flush(); } catch (IOException | XMLStreamException ioe) { throw new SerializationException(ioe); } return writer; }
@Override public PartitionStatus combine(IntArray curPar, IntArray newPar) { int[] arr1 = curPar.get(); int size1 = curPar.size(); int[] arr2 = newPar.get(); int size2 = newPar.size(); if (size1 != size2) { return PartitionStatus.COMBINE_FAILED; } switch (operation) { case SUM: for (int i = 0; i < size2; i++) { arr1[i] += arr2[i]; } break; case MINUS: for (int i = 0; i < size2; i++) { arr1[i] -= arr2[i]; } break; case MAX: for (int i = 0; i < size2; i++) { if (arr1[i] < arr2[i]) { arr1[i] = arr2[i]; } } break; case MIN: for (int i = 0; i < size2; i++) { if (arr1[i] > arr2[i]) { arr1[i] = arr2[i]; } } break; case MULTIPLY: for (int i = 0; i < size2; i++) { arr1[i] *= arr2[i]; } break; } return PartitionStatus.COMBINED; }
public static ButtonElementBuilder button() { return new ButtonElementBuilder(); }
public void followupOnFPMethod(FormSubmission submission) { EligibleCouple couple = allEligibleCouples.findByCaseId(submission.entityId()); if (couple == null) { logger.warn("Tried to report FP follow up of a non-existing EC, with submission: " + submission); return; } couple = updateECWithFPFollowUp(couple, submission, submission.getField(FP_FOLLOWUP_DATE_FIELD_NAME)); allEligibleCouples.update(couple); FPProductInformation fpProductInformation = new FPProductInformation( submission.entityId(), submission.anmId(), submission.getField(CURRENT_FP_METHOD_FIELD_NAME), null, null, null, null, null, submission.getField(SUBMISSION_DATE_FIELD_NAME), null, submission.getField(FP_FOLLOWUP_DATE_FIELD_NAME), submission.getField(NEEDS_FOLLOWUP_FIELD_NAME), submission.getField(NEEDS_REFERRAL_FOLLOWUP_FIELD_NAME)); schedulingService.fpFollowup(fpProductInformation); }
public static <T> PTransform<PCollection<T>, PCollection<T>> exceptAll( PCollection<T> rightCollection) { checkNotNull(rightCollection, "rightCollection argument is null"); return new SetImpl<>(rightCollection, exceptAll()); }
@Override public ContentValues value() { ContentValues values = mDelegate.value(); values.put(TaskContract.Instances.TASK_ID, mTaskId); return values; }
@Override public org.modeshape.jcr.api.query.Query createQuery( String statement, String language ) throws InvalidQueryException, RepositoryException { CheckArg.isNotNull(statement, "statement"); CheckArg.isNotNull(language, "language"); return createQuery(statement, language, null, null); }
public boolean responseMessageAppliesTo(String streetName) { return this.response.messageAppliesTo(streetName); }
public static String insignificantSpacesStringAny( char[] origin ) { if ( origin == null ) { return " "; } int pos = 0; char[] target = new char[origin.length * 2 + 1]; int newPos = 0; NormStateEnum normState = NormStateEnum.START; while ( normState != NormStateEnum.END ) { switch ( normState ) { case START : if ( pos == origin.length ) { return " "; } char c = origin[pos]; if ( c == ' ' ) { pos++; normState = NormStateEnum.INITIAL_SPACES; } else { target[newPos++] = c; pos++; normState = NormStateEnum.INITIAL_CHAR; } break; case INITIAL_CHAR : if ( pos == origin.length ) { normState = NormStateEnum.END; break; } c = origin[pos]; if ( c == ' ' ) { target[newPos++] = ' '; pos++; normState = NormStateEnum.SPACES; } else { target[newPos++] = c; pos++; normState = NormStateEnum.CHARS; } break; case INITIAL_SPACES : if ( pos == origin.length ) { return " "; } c = origin[pos]; if ( c == ' ' ) { pos++; } else { target[newPos++] = ' '; target[newPos++] = c; pos++; normState = NormStateEnum.INITIAL_CHAR; } break; case CHARS : if ( pos == origin.length ) { normState = NormStateEnum.END; break; } c = origin[pos]; if ( c == ' ' ) { target[newPos++] = ' '; pos++; normState = NormStateEnum.SPACES; } else { target[newPos++] = c; pos++; } break; case SPACES : if ( pos == origin.length ) { normState = NormStateEnum.END; break; } c = origin[pos]; if ( c == ' ' ) { pos++; } else { target[newPos++] = ' '; target[newPos++] = c; pos++; normState = NormStateEnum.SPACE_CHAR; } break; case SPACE_CHAR : if ( pos == origin.length ) { normState = NormStateEnum.END; break; } c = origin[pos]; if ( c == ' ' ) { pos++; target[newPos++] = ' '; normState = NormStateEnum.SPACES; } else { target[newPos++] = c; pos++; normState = NormStateEnum.CHARS; } break; default : break; } } return new String( target, 0, newPos ); }
@Override public void setupActiveSearchFilters() { final Optional<String> processDefinitionSearch = getSearchParameter(SEARCH_PARAMETER_PROCESS_DEFINITION_ID); if (processDefinitionSearch.isPresent()) { final String processDefinitionId = processDefinitionSearch.get(); addActiveFilter(equalsTo(COLUMN_PROCESS_ID, processDefinitionId), constants.Process_Definition_Id(), processDefinitionId, processDefinitionId, v -> removeActiveFilter(equalsTo(COLUMN_PROCESS_ID, v)) ); } final Optional<String> processInstanceSearch = getSearchParameter(SEARCH_PARAMETER_PROCESS_INSTANCE_ID); if (processInstanceSearch.isPresent()) { final String processInstanceId = processInstanceSearch.get(); addActiveFilter(equalsTo(COLUMN_PROCESS_INSTANCE_ID, Integer.valueOf(processInstanceId)), constants.Id(), processInstanceId, Integer.valueOf(processInstanceId), v -> removeActiveFilter(equalsTo(COLUMN_PROCESS_INSTANCE_ID, v)) ); } }
public final long getCacheExpirationTime() { return expirationTime; }
protected ContentType retrieveContentType(File file) throws ResourceConfigException { String fileEnding = FilenameUtils.getExtension(file.getName()); switch (fileEnding) { case "json": return ContentType.JSON; case "yml": return ContentType.YAML; default: throw new ResourceConfigException(COMMONS_MESSAGE_BUNDLE.getMessage("DEPLOYER_COMMONS_ERROR_UNKNOWN_CONTENT_TYPE", file.getName())); } }
@Override public void prepare() throws ServiceNotProvidedException, ModuleStartException { try { List<Address> addressList = ConnectUtils.parse(config.getHostPort()); List<HostAndPort> hostAndPorts = new ArrayList<>(); for (Address address : addressList) { hostAndPorts.add(HostAndPort.fromParts(address.getHost(), address.getPort())); } Consul.Builder consulBuilder = Consul.builder() .withConnectTimeoutMillis(3000); if (StringUtils.isNotEmpty(config.getAclToken())) { consulBuilder.withAclToken(config.getAclToken()); } if (hostAndPorts.size() > 1) { client = consulBuilder.withMultipleHostAndPort(hostAndPorts, 5000).build(); } else { client = consulBuilder.withHostAndPort(hostAndPorts.get(0)).build(); } } catch (ConnectStringParseException | ConsulException e) { throw new ModuleStartException(e.getMessage(), e); } ConsulCoordinator coordinator = new ConsulCoordinator(config, client); this.registerServiceImplementation(ClusterRegister.class, coordinator); this.registerServiceImplementation(ClusterNodesQuery.class, coordinator); }
@Override public void initialize(@Nonnull AnalysisContext analysis) { if (this.analysis != null) { try { flushReports(); } catch (IOException e) { throw new IllegalStateException("Failed to output previous analysis report."); } } this.analysis = analysis; String minLevel = analysis.getConfiguration().get("minSeverity").asString(); String output = analysis.getConfiguration().get("output").asString(); output = "undefined".equals(output) ? "out" : output; boolean append = analysis.getConfiguration().get("append").asBoolean(false); this.minLevel = "undefined".equals(minLevel) ? DifferenceSeverity.POTENTIALLY_BREAKING : DifferenceSeverity.valueOf(minLevel); OutputStream out; switch (output) { case "out": out = System.out; break; case "err": out = System.err; break; default: File f = new File(output); if (f.exists()) { if (!f.isFile()) { LOG.warn( "The configured file, '" + f.getAbsolutePath() + "' is not a file." + " Defaulting the output to standard output."); out = System.out; break; } else if (!f.canWrite()) { LOG.warn( "The configured file, '" + f.getAbsolutePath() + "' is not a writable." + " Defaulting the output to standard output."); out = System.out; break; } } else { File parent = f.getParentFile(); if (parent != null && !parent.exists()) { if (!parent.mkdirs()) { LOG.warn("Failed to create directory structure to write to the configured output file '" + f.getAbsolutePath() + "'. Defaulting the output to standard output."); out = System.out; break; } } } try { out = new FileOutputStream(output, append); } catch (FileNotFoundException e) { LOG.warn("Failed to create the configured output file '" + f.getAbsolutePath() + "'." + " Defaulting the output to standard output.", e); out = System.out; } } shouldClose = out != System.out && out != System.err; this.output = createOutputWriter(out, analysis); }
public static FetchAtomsRequestAction newRequest(RadixAddress address) { return new FetchAtomsRequestAction(UUID.randomUUID().toString(), address); }
public static String extractFileNameFromFilePath(@NonNull String filePath) { checkPreconditionsOnFilePath(filePath); int lastOccurrenceOfFileSeparatorIndex = filePath.lastIndexOf(File.separator); if (lastOccurrenceOfFileSeparatorIndex == -1) return filePath; return filePath.substring(lastOccurrenceOfFileSeparatorIndex + 1); }
public void step(Program aprogram) { steps(aprogram,1); }
@SafeVarargs public static <T> Expression[] literals(T... objects) { Preconditions.checkNotNull(objects); Expression[] result = new Expression[objects.length]; for (int i = 0; i < objects.length; i++) { result[i] = literal(objects[i]); } return result; }
public void processAllVars(CmsCI ci,CmsCI env , CmsCI cloud, CmsCI plat) { processAllVars(ci, getCloudVars(cloud), getGlobalVars(env), getLocalVars(plat)); }
@RolesAllowed( "Environment-Management|Update" ) @Override public void startContainer( final ContainerId containerId ) throws PeerException { Preconditions.checkNotNull( containerId, "Cannot operate on null container id" ); ContainerHostEntity containerHost = ( ContainerHostEntity ) getContainerHostById( containerId.getId() ); ResourceHost resourceHost = containerHost.getParent(); try { resourceHost.startContainerHost( containerHost ); } catch ( Exception e ) { String errMsg = String.format( "Could not start container %s: %s", containerHost.getContainerName(), e.getMessage() ); LOG.error( errMsg, e ); throw new PeerException( errMsg, e ); } }
@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { if (msg instanceof HttpRequest) { for (ProcessingStateClassAndKeyPair<? extends ProcessingState> stateClassAndKeyPair : PROCESSING_STATE_ATTRIBUTE_KEYS) { @SuppressWarnings("unchecked") AttributeKey<ProcessingState> attrKey = (AttributeKey<ProcessingState>) stateClassAndKeyPair.getRight(); Attribute<ProcessingState> processingStateAttr = ctx.channel().attr(attrKey); ProcessingState processingState = processingStateAttr.get(); if (processingState == null) { processingState = stateClassAndKeyPair.getLeft().newInstance(); processingStateAttr.set(processingState); } processingState.cleanStateForNewRequest(); } HttpProcessingState httpProcessingState = ChannelAttributes.getHttpProcessingStateForChannel(ctx).get(); httpProcessingState.setDistributedTracingConfig(distributedTracingConfig); if (metricsListener != null) { metricsListener.onEvent(ServerMetricsEvent.REQUEST_RECEIVED, httpProcessingState); } ChannelPipeline pipeline = ctx.pipeline(); ChannelHandler idleChannelTimeoutHandler = pipeline.get(HttpChannelInitializer.IDLE_CHANNEL_TIMEOUT_HANDLER_NAME); if (idleChannelTimeoutHandler != null) pipeline.remove(idleChannelTimeoutHandler); if (incompleteHttpCallTimeoutMillis > 0 && !(msg instanceof LastHttpContent)) { IncompleteHttpCallTimeoutHandler newHandler = new IncompleteHttpCallTimeoutHandler( incompleteHttpCallTimeoutMillis ); ChannelHandler existingHandler = pipeline.get(INCOMPLETE_HTTP_CALL_TIMEOUT_HANDLER_NAME); if (existingHandler == null) { pipeline.addFirst(INCOMPLETE_HTTP_CALL_TIMEOUT_HANDLER_NAME, newHandler); } else { logger.error("Handling HttpRequest for new request and found an IncompleteHttpCallTimeoutHandler " + "already in the pipeline. This should not be possible. A new " + "IncompleteHttpCallTimeoutHandler will replace the old one. worker_channel_id={}", ctx.channel().toString()); pipeline.replace(existingHandler, INCOMPLETE_HTTP_CALL_TIMEOUT_HANDLER_NAME, newHandler); } } ProxyRouterProcessingState proxyRouterProcessingState = ChannelAttributes.getProxyRouterProcessingStateForChannel(ctx).get(); proxyRouterProcessingState.setDistributedTracingConfig(distributedTracingConfig); } else if (msg instanceof LastHttpContent) { ChannelPipeline pipeline = ctx.pipeline(); ChannelHandler existingHandler = pipeline.get(INCOMPLETE_HTTP_CALL_TIMEOUT_HANDLER_NAME); if (existingHandler != null) pipeline.remove(INCOMPLETE_HTTP_CALL_TIMEOUT_HANDLER_NAME); } super.channelRead(ctx, msg); }
public static String toRoman(long toConvert) { if (toConvert <= 0) { throw new IllegalArgumentException(); } long n = toConvert; StringBuilder buf = new StringBuilder(); final Numeral[] values = Numeral.values(); for (int i = values.length - 1; i >= 0; i--) { while (n >= values[i].weight) { buf.append(values[i]); n -= values[i].weight; } } return buf.toString(); }
@Override public Result execute() { FormattingResultLog resultLog = new FormattingResultLog(); if(jobManager != null) { Iterable<Queue> queues = jobManager.getQueues(); if(queues != null) { for (Queue queue : queues) { String name = queue.getName(); String info = queue.getStateInfo(); resultLog.info("The queue {} is currently {}", name, info); } } else { resultLog.info("There are currently no queues available."); } Statistics statistics = jobManager.getStatistics(); long totalJobs = statistics.getNumberOfJobs(); if (totalJobs > 0) resultLog.info("Found {} total jobs.", totalJobs); else resultLog.debug("Found no jobs in the Job Manager."); long queuedJobs = statistics.getNumberOfQueuedJobs(); if(queuedJobs > 0) resultLog.info("Found {} queued jobs.", queuedJobs); else resultLog.debug("Found no queued jobs."); long activeJobs = statistics.getNumberOfActiveJobs(); if(activeJobs > 0) resultLog.info("Found {} active jobs.", activeJobs); else resultLog.debug("Found no active jobs."); long cancelledJobs = statistics.getNumberOfCancelledJobs(); if(cancelledJobs > 0) resultLog.info("Found {} cancelled jobs.", cancelledJobs); else resultLog.debug("Found no cancelled jobs."); long failedJobs = statistics.getNumberOfFailedJobs(); if(failedJobs > 0) resultLog.info("Found {} failed jobs.", failedJobs); else resultLog.debug("Found no failed jobs."); long averageProcessingTime = statistics.getAverageProcessingTime(); if(averageProcessingTime > 0) resultLog.debug("The average processing time is {}.", averageProcessingTime); long averageWaitingTime = statistics.getAverageWaitingTime(); if(averageWaitingTime > 0) resultLog.debug("The average waiting time is [{}.", averageWaitingTime); if(queuedJobs > MAX_JOBS_QUEUED) { resultLog.warn("Found more than {} jobs queued: {}", MAX_JOBS_QUEUED, queuedJobs); } } else { resultLog.info("No Job Manager available"); } return new Result(resultLog); }
public ParameterComponent createListParameter( final ListParameter listParameter, final ParameterContext parameterContext, final ParameterUpdateContext updateContext ) { final String type = listParameter.getParameterAttribute( ParameterAttributeNames.Core.NAMESPACE, ParameterAttributeNames.Core.TYPE, parameterContext ); if ( type == null || "textbox".equals( type ) ) { return createTextComponent( listParameter, parameterContext, updateContext ); } if ( "dropdown".equals( type ) ) { return new DropDownParameterComponent( listParameter, updateContext, parameterContext ); } if ( "list".equals( type ) ) { return new ListParameterComponent( listParameter, updateContext, parameterContext ); } if ( "checkbox".equals( type ) ) { return new CheckBoxParameterComponent( listParameter, updateContext, parameterContext ); } if ( "radio".equals( type ) ) { return new RadioButtonParameterComponent( listParameter, updateContext, parameterContext ); } if ( "togglebutton".equals( type ) ) { return new ButtonParameterComponent( listParameter, updateContext, parameterContext ); } return createTextComponent( listParameter, parameterContext, updateContext ); }
@Override public InviteeSession onJoinAction(Transaction txn, InviteeSession s) throws DbException { switch (s.getState()) { case START: case ACCEPTED: case JOINED: case LEFT: case DISSOLVED: case ERROR: throw new ProtocolStateException(); case INVITED: return onLocalAccept(txn, s); default: throw new AssertionError(); } }
public Instant getStartTime() { return startTime; }
public Result<T> filter(Function<T, Boolean> p) { return flatMap(x -> p.apply(x) ? this : failure("Condition not matched")); }
public Resource getIncrementAllocation() { Long memory = null; Integer vCores = null; Map<String, Long> others = new HashMap<>(); ResourceInformation[] resourceTypes = ResourceUtils.getResourceTypesArray(); for (int i=0; i < resourceTypes.length; ++i) { String name = resourceTypes[i].getName(); String propertyKey = getAllocationIncrementPropKey(name); String propValue = get(propertyKey); if (propValue != null) { Matcher matcher = RESOURCE_REQUEST_VALUE_PATTERN.matcher(propValue); if (matcher.matches()) { long value = Long.parseLong(matcher.group(1)); String unit = matcher.group(2); long valueInDefaultUnits = getValueInDefaultUnits(value, unit, name); others.put(name, valueInDefaultUnits); } else { throw new IllegalArgumentException("Property " + propertyKey + " is not in \"value [unit]\" format: " + propValue); } } } if (others.containsKey(ResourceInformation.MEMORY_MB.getName())) { memory = others.get(ResourceInformation.MEMORY_MB.getName()); if (get(RM_SCHEDULER_INCREMENT_ALLOCATION_MB) != null) { String overridingKey = getAllocationIncrementPropKey( ResourceInformation.MEMORY_MB.getName()); LOG.warn("Configuration " + overridingKey + "=" + get(overridingKey) + " is overriding the " + RM_SCHEDULER_INCREMENT_ALLOCATION_MB + "=" + get(RM_SCHEDULER_INCREMENT_ALLOCATION_MB) + " property"); } others.remove(ResourceInformation.MEMORY_MB.getName()); } else { memory = getLong( RM_SCHEDULER_INCREMENT_ALLOCATION_MB, DEFAULT_RM_SCHEDULER_INCREMENT_ALLOCATION_MB); } if (others.containsKey(ResourceInformation.VCORES.getName())) { vCores = others.get(ResourceInformation.VCORES.getName()).intValue(); if (get(RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES) != null) { String overridingKey = getAllocationIncrementPropKey( ResourceInformation.VCORES.getName()); LOG.warn("Configuration " + overridingKey + "=" + get(overridingKey) + " is overriding the " + RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES + "=" + get(RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES) + " property"); } others.remove(ResourceInformation.VCORES.getName()); } else { vCores = getInt( RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES, DEFAULT_RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES); } return Resource.newInstance(memory, vCores, others); }
public List<Confirmation> getConfirmationsByUsername(@NonNull final String username) { List<Confirmation> confirmations = repository.findAllByUsername(username); log.info("Query for user {} confirmations returned {} confirmations", username, confirmations.size()); return confirmations; }
public void charactersRemoved(org.apache.pivot.wtk.TextPane arg0, int arg1, int arg2) { if (charactersRemoved != null) { charactersRemoved.call(arg0, arg1, arg2); } }
@Override public @Nullable MplVariable<?> findVariable(String identifier) { MplVariable<?> result = super.findVariable(identifier); if (result != null) { return result; } if (parent != null) { return parent.findVariable(identifier); } return null; }
@Override public void validate(String name, String value) throws ParameterException { try { Region.fromValue(value); } catch (IllegalArgumentException e) { throw new ParameterException("Parameter " + name + " is not a valid AWS region (found " + value + ")", e); } }
@Override public Printer resolve(String name) { Printer printer = printers.get(name); return nonNull(printer) ? printer : printers.get(aliases.get(name)); }
public String getStorageAttributeValueByName(String attributeName, Storage storage, Boolean required) { String attributeValue = null; for (Attribute attribute : storage.getAttributes()) { if (attribute.getName().equalsIgnoreCase(attributeName)) { attributeValue = attribute.getValue(); break; } } if (required && StringUtils.isBlank(attributeValue)) { throw new IllegalStateException(String.format("Attribute \"%s\" for \"%s\" storage must be configured.", attributeName, storage.getName())); } return attributeValue; }
@CheckForNull @Override public Set<Path> branchChangedFiles(String targetBranchName, Path rootBaseDir) { try (Repository repo = buildRepo(rootBaseDir)) { Ref targetRef = resolveTargetRef(targetBranchName, repo); if (targetRef == null) { analysisWarnings.addUnique(String.format("Could not find ref '%s' in refs/heads, refs/remotes/upstream or refs/remotes/origin. " + "You may see unexpected issues and changes. " + "Please make sure to fetch this ref before pull request analysis.", targetBranchName)); return null; } if (isDiffAlgoInvalid(repo.getConfig())) { LOG.warn("The diff algorithm configured in git is not supported. " + "No information regarding changes in the branch will be collected, which can lead to unexpected results."); return null; } Optional<RevCommit> mergeBaseCommit = findMergeBase(repo, targetRef); if (!mergeBaseCommit.isPresent()) { LOG.warn("No merge base found between HEAD and " + targetRef.getName()); return null; } AbstractTreeIterator mergeBaseTree = prepareTreeParser(repo, mergeBaseCommit.get()); try (Git git = newGit(repo)) { List<DiffEntry> diffEntries = git.diff() .setShowNameAndStatusOnly(true) .setOldTree(mergeBaseTree) .setNewTree(prepareNewTree(repo)) .call(); return diffEntries.stream() .filter(diffEntry -> diffEntry.getChangeType() == DiffEntry.ChangeType.ADD || diffEntry.getChangeType() == DiffEntry.ChangeType.MODIFY) .map(diffEntry -> repo.getWorkTree().toPath().resolve(diffEntry.getNewPath())) .collect(Collectors.toSet()); } } catch (IOException | GitAPIException e) { LOG.warn(e.getMessage(), e); } return null; }
@Override public int lastIndexOf(KType e1) { for (int i = elementsCount - 1; i >= 0; i--) { if (Intrinsics.equals(this, e1, buffer[i])) { return i; } } return -1; }
@Override public DiscoveredResourceDetails discoverResource(Configuration pluginConfiguration, ResourceDiscoveryContext context) throws InvalidPluginConfigurationException { PortNetServiceComponentConfiguration componentConfiguration = PortNetServiceComponent .createComponentConfiguration(pluginConfiguration); String resourceKey = createResourceKey(componentConfiguration); return new DiscoveredResourceDetails(context.getResourceType(), resourceKey, resourceKey, null, null, pluginConfiguration, null); }
AxiomDescriptor createForEntityLoading(LoadingParameters<?> loadingParams, EntityType<?> et) { final AxiomDescriptor descriptor = new AxiomDescriptor(NamedResource.create(loadingParams.getIdentifier())); descriptor.setSubjectContext(loadingParams.getDescriptor().getContext()); descriptor.addAssertion(Assertion.createClassAssertion(false)); addForTypes(loadingParams, et, descriptor); addForProperties(loadingParams, et, descriptor); for (Attribute<?, ?> att : et.getAttributes()) { if (!shouldLoad(att.getFetchType(), loadingParams.isForceEager())) { continue; } final Assertion a = createAssertion(att, loadingParams.getDescriptor().getAttributeDescriptor(att)); addAssertionToDescriptor(loadingParams.getDescriptor(), att, descriptor, a); } return descriptor; }
public KGroupedStreamHolder build( final KStreamHolder<Struct> stream, final StreamGroupByKey step ) { final LogicalSchema sourceSchema = stream.getSchema(); final QueryContext queryContext = step.getProperties().getQueryContext(); final Formats formats = step.getInternalFormats(); final Grouped<Struct, GenericRow> grouped = buildGrouped( formats, sourceSchema, queryContext, queryBuilder, groupedFactory ); return KGroupedStreamHolder.of(stream.getStream().groupByKey(grouped), stream.getSchema()); }
public static <T extends ClassLoader> ElementMatcher.Junction<T> isBootstrapClassLoader() { return new NullMatcher<T>(); }
@Override public Result apply(PathData item, int depth) throws IOException { String name = getPath(item).getName(); if (!caseSensitive) { name = StringUtils.toLowerCase(name); } if (globPattern.matches(name)) { return Result.PASS; } else { return Result.FAIL; } }
@Override public InputStream getContent() throws IOException { if( replayBuffer == null ) { return wrappedEntity.getContent(); } else if( finalStream != null ) { throw new IOException( "Existing stream already past replay buffer capacity." ); } else { if( wrappedStream == null ) { wrappedStream = wrappedEntity.getContent(); } return new ReplayStream(); } }
@Override public double[] paramForPoint(IDirectPosition p) { double minDistance = Double.POSITIVE_INFINITY; double minParam = -1; double d = 0; for (int i = 0; i < this.sizeControlPoint() - 1; i++) { IDirectPosition p1 = this.getControlPoint(i); IDirectPosition p2 = this.getControlPoint(i + 1); double param = Operateurs.paramForPoint(p, p1, p2); IDirectPosition point = Operateurs.param(param, p1, p2); double distance = p.distance(point); if (distance < minDistance) { minDistance = distance; minParam = d + param; } d += p1.distance(p2); } return new double[] { minParam }; }
public static TableDef covertToTableDef(String sql) { CreateTable stmt; try { sql = reviseSql(sql); stmt = (CreateTable) CCJSqlParserUtil.parse(sql); checkNotNull(stmt, "CreateTable statement should not be null"); TableDef tableDef = new TableDef(); tableDef.setName(stmt.getTable().getName()); tableDef.setFullyQualifiedName(stmt.getTable().getFullyQualifiedName()); handleCharset(stmt, tableDef); handleCollation(stmt, tableDef); handleColumns(stmt, tableDef); handleIndex(stmt, tableDef); if (log.isDebugEnabled()) { log.debug("origin sql:" + sql); log.debug("parsed sql:" + stmt); } return tableDef; } catch (Exception e) { throw new SqlParseException("Parse create table sql failed " + sql, e); } }
public Credential retrieve() throws IOException, CredentialHelperUnhandledServerUrlException, CredentialHelperNotFoundException { boolean isWindows = systemProperties.getProperty("os.name").toLowerCase(Locale.ENGLISH).contains("windows"); String lowerCaseHelper = credentialHelper.toString().toLowerCase(Locale.ENGLISH); if (!isWindows || lowerCaseHelper.endsWith(".cmd") || lowerCaseHelper.endsWith(".exe")) { return retrieve(Arrays.asList(credentialHelper.toString(), "get")); } for (String suffix : Arrays.asList(".cmd", ".exe")) { try { return retrieve(Arrays.asList(credentialHelper.toString() + suffix, "get")); } catch (CredentialHelperNotFoundException ignored) { } } return retrieve(Arrays.asList(credentialHelper.toString(), "get")); }
public CommandResult execute( RequestBuilder requestBuilder, Host host ) throws CommandException { Preconditions.checkNotNull( requestBuilder ); Preconditions.checkNotNull( host ); CommandResult result = host.execute( requestBuilder ); if ( !result.hasSucceeded() ) { throw new CommandException( String.format( "Error executing command on host %s: %s", host.getHostname(), result.hasCompleted() ? result.getStdErr() : "Command timed out" ) ); } return result; }
public static String toHexFromByte(final byte b) { byte leftSymbol = (byte) ((b >>> BITS_PER_HEX_DIGIT) & 0x0f); byte rightSymbol = (byte) (b & 0x0f); return (hexSymbols[leftSymbol] + hexSymbols[rightSymbol]); }
protected void checkNetwork(long id) throws ApplicationException { if (id >= 0) { throw new ApplicationException("not a valid id for a user network: " + id); } if (networkIds.containsId(id)) { throw new ApplicationException("a network with the id " + id + " already exists in the users data set"); } }
@Override public byte[] md5(String toHash) { try { MessageDigest messageDigest = MessageDigest.getInstance(Hash.MD5.toString()); messageDigest.reset(); messageDigest.update(toHash.getBytes(UTF_8)); return messageDigest.digest(); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } }
@Override boolean isAcceptable(TrustedServiceWrapper service) { Date startDate = service.getStartDate(); Date endDate = service.getEndDate(); if (date == null) { return false; } boolean afterStartRange = (startDate != null && (date.compareTo(startDate) >= 0)); boolean beforeEndRange = (endDate == null || (date.compareTo(endDate) <= 0)); return afterStartRange && beforeEndRange; }
public boolean allocateAdjacencyLabel(Link link) { long applyNum = 1; DeviceId srcDeviceId = link.src().deviceId(); Collection<LabelResource> labelList; checkNotNull(link, LINK_NULL); checkNotNull(labelRsrcService, LABEL_RESOURCE_SERVICE_NULL); checkNotNull(pceStore, PCE_STORE_NULL); LabelResourceId labelId = pceStore.getAdjLabel(link); if (labelId != null) { log.debug("Adjacency label {} was already allocated for a link {}.", labelId.toString(), link.toString()); return false; } labelList = labelRsrcService.applyFromDevicePool(srcDeviceId, applyNum); if (labelList.size() <= 0) { log.error("Unable to allocate label to a device id {}.", srcDeviceId.toString()); return false; } Iterator<LabelResource> iterator = labelList.iterator(); DefaultLabelResource defaultLabelResource = (DefaultLabelResource) iterator.next(); labelId = defaultLabelResource.labelResourceId(); if (labelId == null) { log.error("Unable to allocate label to a device id {}.", srcDeviceId.toString()); return false; } log.debug("Allocated adjacency label {} to a link {}.", labelId.toString(), link.toString()); installAdjLabelRule(srcDeviceId, labelId, link.src().port(), link.dst().port(), Objective.Operation.ADD); pceStore.addAdjLabel(link, labelId); return true; }
public static FailureCallback failureCallbackWithTracing(FailureCallback failureCallback) { return new FailureCallbackWithTracing(failureCallback); }
@Override public Mac wrap(final PrimitiveSet<Mac> primitives) throws GeneralSecurityException { return new WrappedMac(primitives); }
protected Widget getWidgetInstance(HttpServletRequest request, HttpServletResponse response) { Widget widget = newWidgetInstance(request); widget.setRequest(request); widget.setResponse(response); setWidgetParameters(request, widget); return widget; }
@Override public void append(Event event) throws EventDeliveryException { throwIfClosed(); boolean eventSent = false; Iterator<HostInfo> it = selector.createHostIterator(); while (it.hasNext()) { HostInfo host = it.next(); try { RpcClient client = getClient(host); client.append(event); eventSent = true; break; } catch (Exception ex) { selector.informFailure(host); LOGGER.warn("Failed to send event to host " + host, ex); } } if (!eventSent) { throw new EventDeliveryException("Unable to send event to any host"); } }
public SampleGenotype getSampleGenotype(String sampleId) { return sampleGenotypes.getOrDefault(sampleId, SampleGenotype.empty()); }
public UserProfile fetchUserProfile(Facebook facebook) { User profile = facebook.userOperations().getUserProfile(); return new UserProfileBuilder().setId(profile.getId()).setName(profile.getName()).setFirstName(profile.getFirstName()).setLastName(profile.getLastName()). setEmail(profile.getEmail()).build(); }
public static Date joinDateAndTime(final Date date, final Date time) { Calendar dateCal = Calendar.getInstance(); dateCal.setTime(date); Calendar timeCal = Calendar.getInstance(); timeCal.setTime(time); dateCal.set(Calendar.HOUR_OF_DAY, timeCal.get(Calendar.HOUR_OF_DAY)); dateCal.set(Calendar.MINUTE, timeCal.get(Calendar.MINUTE)); dateCal.set(Calendar.SECOND, timeCal.get(Calendar.SECOND)); dateCal.set(Calendar.MILLISECOND, timeCal.get(Calendar.MILLISECOND)); return dateCal.getTime(); }
public static double similarity(String s1, String s2) { if (s1.equals(s2)) return 1.0; if (s1.length() > s2.length()) { String tmp = s2; s2 = s1; s1 = tmp; } boolean[] isCommonCharInS2 = new boolean[s2.length()]; int maxdist = s2.length() / 2; int c = 0; int t = 0; int prevpos = -1; for (int ix = 0; ix < s1.length(); ix++) { char ch = s1.charAt(ix); for (int ix2 = Math.max(0, ix - maxdist); ix2 < Math.min(s2.length(), ix + maxdist); ix2++) { if (ch == s2.charAt(ix2) && !isCommonCharInS2[ix2]) { c++; isCommonCharInS2[ix2] = true; if (prevpos != -1 && ix2 < prevpos) t++; prevpos = ix2; break; } } } if (c == 0) return 0.0; double score = ((c / (double) s1.length()) + (c / (double) s2.length()) + ((c - t) / (double) c)) / 3.0; int p = 0; int last = Math.min(4, s1.length()); for (; p < last && s1.charAt(p) == s2.charAt(p); p++) ; score = score + ((p * (1 - score)) / 10); return score; }
@JsonCreator public static AlarmSubExpression of(String expression) { AlarmExpressionParser parser = new AlarmExpressionParser(new CommonTokenStream( new AlarmExpressionLexer(new ANTLRInputStream(expression)))); parser.removeErrorListeners(); parser.addErrorListener(new AlarmExpressionErrorListener()); parser.setBuildParseTree(true); ParserRuleContext tree = parser.start(); AlarmSubExpressionListener listener = new AlarmSubExpressionListener(true); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return (AlarmSubExpression) listener.getElements().get(0); }
public static @Nonnull MacAddress of(long longVal) { checkArgument( longVal == (longVal & 0xFFFFFFFFFFFFL), "Cannot create MAC address from invalid long value: %s", longVal); return new MacAddress(longVal); }
@Override public <T extends DataObject> void put(final InstanceIdentifier<T> path, final T data) { final WriteTransaction writeTx = contextBindingBrokerDependency.newWriteOnlyTransaction(); writeTx.mergeParentStructurePut(LogicalDatastoreType.OPERATIONAL, path, data); try { writeTx.commit().get(); } catch (InterruptedException | ExecutionException e) { throw new IllegalStateException("Unable to perform put of " + path, e); } }
@PutMapping("/id/{userId}/update-profile-skills") public RestResult<Void> updateProfileSkills(@PathVariable("userId") long id, @Valid @RequestBody ProfileSkillsEditResource profileSkills) { return profileService.updateProfileSkills(id, profileSkills).toPutResponse(); }
@NotNull @Override public Scope getScope() { String value = scope.getValue(scope.getSelectedIndex()); return Scope.detect(value); }
public SerializableFunction<Row, T> getFromRowFunction() { return fromRowFunction; }
public void setHeaders(final Message message, final Map<String, String> msgMap, final DataType dataType, final String address, final @NonNull PersonRecord contact, final Date sentDate, final int status) throws MessagingException { message.setHeader(Headers.REFERENCES, String.format(REFERENCE_UID_TEMPLATE, reference, contact.getId())); message.setHeader(Headers.MESSAGE_ID, createMessageId(sentDate, address, status)); message.setHeader(Headers.ADDRESS, sanitize(address)); message.setHeader(Headers.DATATYPE, dataType.toString()); message.setHeader(Headers.BACKUP_TIME, toGMTString(new Date())); message.setHeader(Headers.VERSION, version); message.setSentDate(sentDate, false); message.setInternalDate(sentDate); switch (dataType) { case SMS: setSmsHeaders(message, msgMap); break; case MMS: setMmsHeaders(message, msgMap); break; case CALLLOG: setCallLogHeaders(message, msgMap); break; } }
public int generate( final MasterReport report, final int acceptedPage, final OutputStream outputStream, final int yieldRate ) throws ReportProcessingException, IOException { final FlowReportProcessor reportProcessor = createProcessor( report, yieldRate ); final IAsyncReportListener listener = ReportListenerThreadHolder.getListener(); if ( listener != null ) { reportProcessor.addReportProgressListener( listener ); } try { proxyOutputStream.setParent( outputStream ); if ( templateData != null ) { final FlowExcelOutputProcessor target = (FlowExcelOutputProcessor) reportProcessor.getOutputProcessor(); target.setTemplateInputStream( new ByteArrayInputStream( templateData ) ); } reportProcessor.processReport(); if ( listener != null ) { listener.setIsQueryLimitReached( reportProcessor.isQueryLimitReached() ); } outputStream.flush(); return 0; } finally { if ( listener != null ) { reportProcessor.removeReportProgressListener( listener ); } reportProcessor.close(); proxyOutputStream.setParent( null ); final FlowExcelOutputProcessor target = (FlowExcelOutputProcessor) reportProcessor.getOutputProcessor(); target.setTemplateInputStream( null ); } }
public int solution(int A, int B, int K) { long countOfNumbers = ((long) B) - A + 1; long count = (int) (countOfNumbers / K); if (count < K) { if (A % K == 0) { ++count; } if (A != B && B % K == 0) { ++count; } } return (int) count; }
@Override public <K, V> Map<K, V> toMap(DataTable dataTable, Type keyType, Type valueType) { requireNonNull(dataTable, "dataTable may not be null"); requireNonNull(keyType, "keyType may not be null"); requireNonNull(valueType, "valueType may not be null"); if (dataTable.isEmpty()) { return emptyMap(); } DataTable keyColumn = dataTable.columns(0, 1); DataTable valueColumns = dataTable.columns(1); String firstHeaderCell = keyColumn.cell(0, 0); boolean firstHeaderCellIsBlank = firstHeaderCell == null || firstHeaderCell.isEmpty(); List<K> keys = convertEntryKeys(keyType, keyColumn, valueType, firstHeaderCellIsBlank); if (valueColumns.isEmpty()) { return createMap(keyType, keys, valueType, nCopies(keys.size(), null)); } boolean keysImplyTableRowTransformer = keys.size() == dataTable.height() - 1; List<V> values = convertEntryValues(valueColumns, keyType, valueType, keysImplyTableRowTransformer); if (keys.size() != values.size()) { throw keyValueMismatchException(firstHeaderCellIsBlank, keys.size(), keyType, values.size(), valueType); } return createMap(keyType, keys, valueType, values); }
public static boolean valid(String num) { return PHONENUM_PATTERN.matcher(num).matches(); }
public static String trim(String str) { return StringUtils.trim(str); }
static ExistsQueryBuilder existsQuery( String name ) { return new ExistsQueryBuilder( name ); }
public void setInstanceCapacityMap(Map<String, Integer> capacityDataMap) throws IllegalArgumentException { if (capacityDataMap == null) { throw new IllegalArgumentException("Capacity Data is null"); } Map<String, String> capacityData = new HashMap<>(); capacityDataMap.entrySet().stream().forEach(entry -> { if (entry.getValue() < 0) { throw new IllegalArgumentException(String .format("Capacity Data contains a negative value: %s = %d", entry.getKey(), entry.getValue())); } capacityData.put(entry.getKey(), Integer.toString(entry.getValue())); }); _record.setMapField(InstanceConfigProperty.INSTANCE_CAPACITY_MAP.name(), capacityData); }
@Override public ConfigPropertyAuditTrail listAllConfigPropertyAudits(String timestamp) throws Exception { if (StringUtils.isEmpty(timestamp)) { LocalDateTime now = LocalDateTime.now(); timestamp = now.minusMonths(1).format(DateTimeFormatter.ofPattern(DATE_FORMAT)); } List<ConfigPropertyAudit> allStoredAudits = configPropertyAuditRepository .findAllByOrderByModifiedDateDescModifiedByAsc(); Comparator<ConfigPropertyAudit> comp = ((m2, m1) -> LocalDateTime .parse(m1.getModifiedDate(), DateTimeFormatter.ofPattern(DATE_FORMAT)).compareTo( LocalDateTime.parse(m2.getModifiedDate(), DateTimeFormatter.ofPattern(DATE_FORMAT)))); Collections.sort(allStoredAudits, comp); ConfigPropertyAuditItem previousAuditItem = new ConfigPropertyAuditItem(); ConfigPropertyAuditItem currentAuditItem = new ConfigPropertyAuditItem(); List<ConfigPropertyDataChange> dataChangeList = new ArrayList<ConfigPropertyDataChange>(); List<ConfigPropertyAuditItem> auditItemList = new ArrayList<>(); for (ConfigPropertyAudit storedAudit : allStoredAudits) { if (LocalDateTime.parse(storedAudit.getModifiedDate(), DateTimeFormatter.ofPattern(DATE_FORMAT)) .isBefore(LocalDateTime.parse(timestamp, DateTimeFormatter.ofPattern(DATE_FORMAT)))) { break; } if (!(storedAudit.getModifiedDate().equals(previousAuditItem.getAuditTimeStamp()) && storedAudit.getModifiedBy().equals(previousAuditItem.getModifiedBy()))) { if (currentAuditItem.getAuditTimeStamp() != null) { auditItemList.add(currentAuditItem); currentAuditItem = new ConfigPropertyAuditItem(); dataChangeList = new ArrayList<ConfigPropertyDataChange>(); } } currentAuditItem.setConfigPropertyChangeList(dataChangeList); currentAuditItem.setAuditTimeStamp(storedAudit.getModifiedDate()); currentAuditItem.setModifiedBy(storedAudit.getModifiedBy()); currentAuditItem.setUserMessage(storedAudit.getUserMessage()); currentAuditItem.setSystemMessage(storedAudit.getSystemMessage()); ConfigPropertyDataChange dataChange = new ConfigPropertyDataChange(); dataChange.setConfigKey(storedAudit.getCfkey()); dataChange.setApplication(storedAudit.getApplication()); dataChange.setOldConfigValue(storedAudit.getOldvalue()); dataChange.setNewConfigValue(storedAudit.getNewvalue()); dataChangeList.add(dataChange); previousAuditItem = currentAuditItem; } if (currentAuditItem.getAuditTimeStamp() != null) { auditItemList.add(currentAuditItem); } ConfigPropertyAuditTrail trail = new ConfigPropertyAuditTrail(); trail.setConfigPropertyAudit(auditItemList); return trail; }
public EcPoint hashToCurve(final String input) { return this.hashToCurve(input.getBytes(StandardCharsets.UTF_8), null); }
public void writeError(HttpServletResponse response, TppErrorMessage tppErrorMessage) throws IOException { MessageErrorCode messageErrorCode = tppErrorMessage.getCode(); MessageError messageError = new MessageError(getErrorType(messageErrorCode.getCode()), TppMessageInformation.of(tppErrorMessage.getCategory(), messageErrorCode, tppErrorMessage.getTextParams())); writeMessageError(response, messageError); }
@Override public void seek(int recordIndex) throws IOException { if (this.shxReader != null) { this.shxReader.seek(recordIndex); final ShapeFileIndexRecord shxRecord = this.shxReader.read(); if (shxRecord != null) { assert shxRecord.getRecordIndex() == recordIndex; readHeader(); setReadingPosition( recordIndex, shxRecord.getOffsetInContent()); return; } } throw new SeekOperationDisabledException("Unspecified Shape File Index"); }
@Override public boolean startsWith(Path other) { if (isAbsolute() != other.isAbsolute()) { return false; } if (other.getNameCount() > getNameCount()) { return false; } for (int i = 0; i < other.getNameCount(); i++) { if (!getName(i).toString().equals(other.getName(i).toString())) { return false; } } return true; }
boolean isMatchWithRegExp(final File file) { return file.getName().matches(FILE_NAME_EXP); }
@Override public void execute() { int address = z80.get16BitRegisterValue(Register.HL); byte memoryValue = mmu.readByte(address); z80.set8BitRegisterValue(Register.A, memoryValue); int newHLRegisterValue = z80.get16BitRegisterValue(Register.HL) - 1; z80.set16BitRegisterValue(Register.HL, newHLRegisterValue); z80.setLastInstructionExecutionTime(2); }
protected boolean isMatchingRelationName(AbstractResourceRelationEntity relation, String relationName) { if (relation.getIdentifier() != null && relation.getIdentifier().equals(relationName)) { return true; } return relation.getIdentifier() == null && relation.getSlaveResource().getName().equals(relationName); }
@Override public Observable<MosaicGlobalRestriction> getMosaicGlobalRestriction(MosaicId mosaicId) { return exceptionHandling( call(() -> getClient().getMosaicGlobalRestriction(mosaicId.getIdAsHex())) .map(this::toMosaicGlobalRestriction)); }
@VisibleForTesting static List<ParallelIndexIngestionSpec> createIngestionSchema( final TaskToolbox toolbox, final LockGranularity lockGranularityInUse, final SegmentProvider segmentProvider, final PartitionConfigurationManager partitionConfigurationManager, @Nullable final DimensionsSpec dimensionsSpec, @Nullable final AggregatorFactory[] metricsSpec, @Nullable final Granularity segmentGranularity, final ObjectMapper jsonMapper, final CoordinatorClient coordinatorClient, final SegmentLoaderFactory segmentLoaderFactory, final RetryPolicyFactory retryPolicyFactory ) throws IOException, SegmentLoadingException { NonnullPair<Map<DataSegment, File>, List<TimelineObjectHolder<String, DataSegment>>> pair = prepareSegments( toolbox, segmentProvider, lockGranularityInUse ); final Map<DataSegment, File> segmentFileMap = pair.lhs; final List<TimelineObjectHolder<String, DataSegment>> timelineSegments = pair.rhs; if (timelineSegments.size() == 0) { return Collections.emptyList(); } final List<NonnullPair<QueryableIndex, DataSegment>> queryableIndexAndSegments = loadSegments( timelineSegments, segmentFileMap, toolbox.getIndexIO() ); final ParallelIndexTuningConfig compactionTuningConfig = partitionConfigurationManager.computeTuningConfig(); if (segmentGranularity == null) { final Map<Interval, List<NonnullPair<QueryableIndex, DataSegment>>> intervalToSegments = new TreeMap<>( Comparators.intervalsByStartThenEnd() ); queryableIndexAndSegments.forEach( p -> intervalToSegments.computeIfAbsent(p.rhs.getInterval(), k -> new ArrayList<>()) .add(p) ); List<NonnullPair<Interval, List<NonnullPair<QueryableIndex, DataSegment>>>> intervalToSegmentsUnified = new ArrayList<>(); Interval union = null; List<NonnullPair<QueryableIndex, DataSegment>> segments = new ArrayList<>(); for (Entry<Interval, List<NonnullPair<QueryableIndex, DataSegment>>> entry : intervalToSegments.entrySet()) { Interval cur = entry.getKey(); if (union == null) { union = cur; segments.addAll(entry.getValue()); } else if (union.overlaps(cur)) { union = Intervals.utc(union.getStartMillis(), Math.max(union.getEndMillis(), cur.getEndMillis())); segments.addAll(entry.getValue()); } else { intervalToSegmentsUnified.add(new NonnullPair<>(union, segments)); union = cur; segments = new ArrayList<>(entry.getValue()); } } intervalToSegmentsUnified.add(new NonnullPair<>(union, segments)); final List<ParallelIndexIngestionSpec> specs = new ArrayList<>(intervalToSegmentsUnified.size()); for (NonnullPair<Interval, List<NonnullPair<QueryableIndex, DataSegment>>> entry : intervalToSegmentsUnified) { final Interval interval = entry.lhs; final List<NonnullPair<QueryableIndex, DataSegment>> segmentsToCompact = entry.rhs; final DataSchema dataSchema = createDataSchema( segmentProvider.dataSource, segmentsToCompact, dimensionsSpec, metricsSpec, GranularityType.fromPeriod(interval.toPeriod()).getDefaultGranularity() ); specs.add( new ParallelIndexIngestionSpec( dataSchema, createIoConfig( toolbox, dataSchema, interval, coordinatorClient, segmentLoaderFactory, retryPolicyFactory ), compactionTuningConfig ) ); } return specs; } else { final DataSchema dataSchema = createDataSchema( segmentProvider.dataSource, queryableIndexAndSegments, dimensionsSpec, metricsSpec, segmentGranularity ); return Collections.singletonList( new ParallelIndexIngestionSpec( dataSchema, createIoConfig( toolbox, dataSchema, segmentProvider.interval, coordinatorClient, segmentLoaderFactory, retryPolicyFactory ), compactionTuningConfig ) ); } }
@IntRange(from = MIN_WRAPPED_VIEW_TYPE, to = MAX_WRAPPED_VIEW_TYPE) public static int extractWrappedViewTypePart(int composedViewType) { return (composedViewType << (32 - BIT_WIDTH_WRAPPED_VIEW_TYPE - BIT_OFFSET_WRAPPED_VIEW_TYPE)) >> (32 - BIT_WIDTH_WRAPPED_VIEW_TYPE); }
public static double similarity(String s1, String s2) { if (s1.equals(s2)) return 1.0; if (s1.length() > s2.length()) { String tmp = s2; s2 = s1; s1 = tmp; } boolean[] isCommonCharInS2 = new boolean[s2.length()]; int maxdist = s2.length() / 2; int c = 0; int t = 0; int prevpos = -1; for (int ix = 0; ix < s1.length(); ix++) { char ch = s1.charAt(ix); for (int ix2 = Math.max(0, ix - maxdist); ix2 < Math.min(s2.length(), ix + maxdist); ix2++) { if (ch == s2.charAt(ix2) && !isCommonCharInS2[ix2]) { c++; isCommonCharInS2[ix2] = true; if (prevpos != -1 && ix2 < prevpos) t++; prevpos = ix2; break; } } } if (c == 0) return 0.0; double score = ((c / (double) s1.length()) + (c / (double) s2.length()) + ((c - t) / (double) c)) / 3.0; int p = 0; int last = Math.min(4, s1.length()); for (; p < last && s1.charAt(p) == s2.charAt(p); p++) ; score = score + ((p * (1 - score)) / 10); return score; }
public Optional<RefDataValue> get(final Txn<ByteBuffer> txn, final ByteBuffer keyBuffer, final int typeId) { return getAsBytes(txn, keyBuffer) .map(valueBuffer -> valueSerde.deserialize(valueBuffer, typeId)); }
public Invite getInvite(String domainId, String instanceId, String email) throws NotFoundException, ServerException { requireNonNull(domainId, "Required non-null domain id"); requireNonNull(instanceId, "Required non-null instance id"); requireNonNull(email, "Required non-null email"); return inviteDao.getInvite(domainId, instanceId, email); }
public double getPercentile(int requestedPercentile) { return getPercentile(requestedPercentile, new ArrayList<Double>(cslm.values())); }
@Override public String getType() { return "v0-8 to v1-0"; }
@Override public void apply(MergeParametersBuilder builder, Consumer<String> onError) { try { table().getItems().stream().filter(s -> !Objects.equals("0", trim(s.pageSelection.get()))) .map(i -> new PdfMergeInput(i.descriptor().toPdfFileSource(), i.toPageRangeSet())) .forEach(builder::addInput); if (!builder.hasInput()) { onError.accept(DefaultI18nContext.getInstance().i18n("No PDF document has been selected")); } } catch (ConversionException e) { LOG.error(e.getMessage()); onError.accept(e.getMessage()); } }
public static Expression exp(String expressionString, Object... parameters) { Expression e = fromString(expressionString); if (parameters != null && parameters.length > 0) { e.inPlaceParamsArray(parameters); } return e; }
protected double covariance(Dataset<E> dataset) { Matrix m = dataset.asMatrix(); Matrix cov = new SymmetricMatrixDiag(m.columnsCount()); DenseVector mean = new DenseVector(dataset.attributeCount()); for (int i = 0; i < mean.size(); i++) { mean.set(i, dataset.getAttribute(i).statistics(StatsNum.MEAN)); } Vector v; double res, sum = 0.0; for (int i = 0; i < m.rowsCount(); i++) { v = m.getRowVector(i).minus(mean); res = v.dot(v); sum += res; } return sum / (m.rowsCount() - 1); }
public static UUID createUUID(int uuid) { final String base = "-0000-1000-8000-00805F9B34FB"; return UUID.fromString(String.format("%08X", uuid & 0xFFFF) + base); }
public Geometry postProcess(MathTransform mt, Geometry geometry) { return geometry; }
public InterceptorMetadata with(Class<?> mockingClass, Method method, Object[] args) { Annotation[] annotations = mockingClass.getAnnotations(); List<InterceptorMetadata> interceptorsMetadata = new ArrayList<>(); for (Annotation annotation : annotations) { Interceptor interceptorAnnotation = annotation.annotationType() .getAnnotation(Interceptor.class); if (interceptorAnnotation == null) continue; Metadata metadata = new Metadata(mockingClass, method, args, annotation, method.getGenericReturnType()); Interceptor.Behaviour interceptor = instantiateInterface .from(interceptorAnnotation.value()); interceptorsMetadata.add(new InterceptorMetadata(metadata, interceptor)); } if (interceptorsMetadata.size() > 1) { String message = Messages.multipleInterceptorsFoundOnClass(mockingClass); throw new RuntimeException(message); } if (interceptorsMetadata.isEmpty()) { String message = Messages.noInterceptorsFoundOnClass(mockingClass); throw new RuntimeException(message); } return interceptorsMetadata.get(0); }
public static PathQuery getConversionQuery(List<ApiTemplate> conversionTemplates, Class<? extends InterMineObject> typeA, Class<? extends InterMineObject> typeB, Object bagOrIds) { PathQuery pq = getConversionMapQuery(conversionTemplates, typeA, typeB, bagOrIds); if (pq == null) { return null; } try { List<String> view = pq.getView(); for (String viewElement : view) { Path path = pq.makePath(viewElement); if (path.getLastClassDescriptor().getType().equals(typeA)) { pq.removeView(viewElement); for (OrderElement orderBy : pq.getOrderBy()) { if (orderBy.getOrderPath().equals(viewElement)) { pq.removeOrderBy(viewElement); } } } } return pq; } catch (PathException e) { throw new RuntimeException("Conversion query was invalid: ", e); } }
@Override public final void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { CalendarDayViewHolder viewHolder = (CalendarDayViewHolder) holder; DayState state = new DayState(); fillViewState(position, selectedPosition, data, state); viewHolder.bind(data.getAt(position), state); addCustomData(viewHolder, data.getAt(position)); }
@Override public void log(String formattedMessage, org.sonarsource.scanner.api.LogOutput.Level level) { stdOut.println(level.name() + ": " + formattedMessage); }
@Override public List<CaseDefinitionSummary> getCaseDefinitions() { final List<CaseDefinition> caseDefinitions = client.getCaseDefinitions(0, PAGE_SIZE_UNLIMITED, CaseServicesClient.SORT_BY_CASE_DEFINITION_NAME, true); return caseDefinitions.stream().map(new CaseDefinitionMapper()).collect(toList()); }
public void updateBusinessObjectDataStatusIgnoreException(BusinessObjectDataKey businessObjectDataKey, String businessObjectDataStatus) { try { updateBusinessObjectDataStatus(businessObjectDataKey, businessObjectDataStatus); } catch (Exception e) { LOGGER.warn(e.getMessage(), e); } }
public void printHelp(String cmdLineSyntax, Options options) { printHelp(getWidth(), cmdLineSyntax, null, options, null, false); }
public Optional<JobEventRdbConfiguration> getJobEventRdbConfiguration() { String driver = getValue(EnvironmentArgument.EVENT_TRACE_RDB_DRIVER); String url = getValue(EnvironmentArgument.EVENT_TRACE_RDB_URL); String username = getValue(EnvironmentArgument.EVENT_TRACE_RDB_USERNAME); String password = getValue(EnvironmentArgument.EVENT_TRACE_RDB_PASSWORD); if (!Strings.isNullOrEmpty(driver) && !Strings.isNullOrEmpty(url) && !Strings.isNullOrEmpty(username)) { BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return Optional.of(new JobEventRdbConfiguration(dataSource)); } return Optional.absent(); }
@Override public void write(int b) throws IOException { if (finished) { throw new IOException("Stream has been finished. Can not write any more data."); } if (count == 0) { os.write(b); return; } if (buffer.hasRemaining()) { buffer.put((byte) b); } else { outputBuffer(); os.write(b); } }
public ArrayList<Integer> nextGreater(ArrayList<Integer> a) { int[] res = new int[a.size()]; Arrays.fill(res, -1); Stack<Integer> stack = new Stack<>(); for (int i = 0; i < a.size(); i++) { int height = a.get(i); while (!stack.isEmpty() && height > a.get(stack.peek())) { res[stack.pop()] = height; } stack.push(i); } ArrayList<Integer> result = new ArrayList<>(); for (int num : res) { result.add(num); } return result; }
@Override public CleanupContext processStep(CleanupContext context) { log.entry(context); TranscodeFinishedEvent result = context.getTranscodeFinishedEvent(); if (isFailed(result)) return log.exit(context); Path source = result.getTemporaryPath(); Path target = cleanupConfig.base_output_dir().resolve(source.getFileName()); context.setOutputPath(moveAndReplaceExisting(source, target, cleanupConfig.overwrite_files())); return log.exit(context); }
public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception { Status currentStatus = monitoredService.getServiceStatus().getStatus(); setResponseCode(currentStatus, resp); setAppropriateWarningHeaders(resp, currentStatus); setCachingHeaders(resp); writeOutCurrentStatusInResponseBody(resp, currentStatus); return null; }
@Override public List<ProjectDependenceData> findProjectDependences(Integer projectId, boolean includeStd) { List<ProjectDependence> dependences; if(includeStd) { dependences = this.findAllByProjectId(projectId); } else { dependences = projectDependenceDao.findAllByProjectId(projectId); } return convert(dependences); }
public FEELFnResult<Object> invoke(@ParameterName("list") List list) { if ( list == null || list.isEmpty() ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "list", "cannot be null or empty")); } else { try { return FEELFnResult.ofResult(Collections.max(list, new InterceptNotComparableComparator())); } catch (ClassCastException e) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "list", "contains items that are not comparable")); } } }
public static boolean isNameCoveredByPattern( String name, String pattern ) { if ( name == null || name.isEmpty() || pattern == null || pattern.isEmpty() ) { throw new IllegalArgumentException( "Arguments cannot be null or empty." ); } final String needle = name.toLowerCase(); final String hayStack = pattern.toLowerCase(); if ( needle.equals( hayStack )) { return true; } if ( hayStack.startsWith( "*." ) ) { return needle.endsWith( hayStack.substring( 2 ) ); } return false; }
public void markReportAsSent(MCTSReport report) { mctsReportRepository.markReportAsSent(report); }
@Override public void deployApplicationResourcesToGroupHosts(String groupName, Application app, ResourceGroup resourceGroup) { List<String> appResourcesNames = groupPersistenceService.getGroupAppsResourceTemplateNames(groupName); final List<Jvm> jvms = jvmPersistenceService.getJvmsByGroupName(groupName); if (null != appResourcesNames && !appResourcesNames.isEmpty()) { for (String resourceTemplateName : appResourcesNames) { String metaDataStr = groupPersistenceService.getGroupAppResourceTemplateMetaData(groupName, resourceTemplateName, app.getName()); try { ResourceTemplateMetaData metaData = resourceService.getTokenizedMetaData(resourceTemplateName, app, metaDataStr); if (jvms != null && !jvms.isEmpty() && !metaData.getEntity().getDeployToJvms()) { Set<String> hostNames = new HashSet<>(); for (Jvm jvm : jvms) { final String host = jvm.getHostName().toLowerCase(Locale.US); if (!hostNames.contains(host)) { hostNames.add(host); executeDeployGroupAppTemplate(groupName, resourceTemplateName, app, jvm.getHostName()); } } } } catch (IOException e) { LOGGER.error("Failed to map meta data for template {} in group {}", resourceTemplateName, groupName, e); throw new InternalErrorException(FaultType.BAD_STREAM, "Failed to read meta data for template " + resourceTemplateName + " in group " + groupName, e); } } } }
public static ModelField[] getAvailableFieldCompletions(final ModelField[] fieldCompletions, final ActionFieldList afl) { if (fieldCompletions == null || fieldCompletions.length == 0) { return fieldCompletions; } if (afl == null || afl.getFieldValues().length == 0) { return fieldCompletions; } final List<ModelField> availableModelFields = new ArrayList<>(); availableModelFields.addAll(Arrays.asList(fieldCompletions)); for (ActionFieldValue afv : afl.getFieldValues()) { final List<ModelField> usedModelFields = availableModelFields.stream().filter(m -> m.getName().equals(afv.getField())).collect(Collectors.toList()); availableModelFields.removeAll(usedModelFields); } return availableModelFields.toArray(new ModelField[availableModelFields.size()]); }
@Override public String getId() { return hostId; }
@VisibleForTesting static byte[] prefixWithTimestampMillis(byte[] input, long timestampMillis) { String dateAsString = Long.toString(timestampMillis); byte[] newSpanBytes = new byte[TIMESTAMP_MILLIS_PREFIX.length + dateAsString.length() + input.length]; int pos = 0; System.arraycopy(TIMESTAMP_MILLIS_PREFIX, 0, newSpanBytes, pos, TIMESTAMP_MILLIS_PREFIX.length); pos += TIMESTAMP_MILLIS_PREFIX.length; for (int i = 0, length = dateAsString.length(); i < length; i++) { newSpanBytes[pos++] = (byte) dateAsString.charAt(i); } newSpanBytes[pos++] = ','; System.arraycopy(input, 1, newSpanBytes, pos, input.length - 1); return newSpanBytes; }
@Override public String getRestMethodName() { return this.restMethodName; }
public static boolean noneOf(Object collection, Object value) { if (collection == null) { throw new IllegalArgumentException("collection cannot be null"); } if (value == null) { throw new IllegalArgumentException("value cannot be null"); } Collection targetCollection = getTargetCollection(collection, value); if (DMNParseUtil.isParseableCollection(value)) { Collection valueCollection = DMNParseUtil.parseCollection(value, targetCollection); return !CollectionUtils.containsAny(targetCollection, valueCollection); } else if (DMNParseUtil.isJavaCollection(value)) { return !CollectionUtils.containsAny(targetCollection, (Collection) value); } else if (DMNParseUtil.isArrayNode(value)) { Collection valueCollection = DMNParseUtil.getCollectionFromArrayNode((ArrayNode) value); return !CollectionUtils.containsAny(targetCollection, valueCollection); } else { Object formattedValue = DMNParseUtil.getFormattedValue(value, targetCollection); return !targetCollection.contains(formattedValue); } }
@Override public void contextDestroyed(ServletContextEvent event) { super.contextDestroyed(event); try { this.destroySubsystems(); } catch (Exception e) { throw new RuntimeException(e); } }
public int minimumScore() { if (surveyType != null & scoreRules.containsKey(surveyType)){ return scoreRules.get(surveyType).get(surveyTypeScale).get("min"); } else { return scoreRules.get("NPS").get(surveyTypeScale).get("min"); } }
public ParsedServiceElements modelServices(BundleManifest manifest, IDirectory bundle) throws ModellerException { logger.debug("modelServices", new Object[] {manifest, bundle}); ParsedEJBServices ejbServices = new ParsedEJBServices(); String header = manifest.getRawAttributes().getValue("Export-EJB"); logger.debug("Export-EJB header is " + header); if(header == null) return ejbServices; Collection<String> allowedNames = getNames(header.trim()); if(allowedNames.contains("NONE")) return ejbServices; ejbServices.setAllowedNames(allowedNames); locator.findEJBs(manifest, bundle, ejbServices); logger.debug("ejbServices", ejbServices); return ejbServices; }
@Override public Num calculate(BarSeries series, TradingRecord tradingRecord) { long numberOfLosingTrades = tradingRecord.getTrades().stream().filter(Trade::isClosed) .filter(trade -> isLosingTrade(series, trade)).count(); return series.numOf(numberOfLosingTrades); }
@Override public void application( Application application, EventType eventType ) { if( eventType == EventType.DELETED ) { this.logger.fine( "Application " + application + " was deleted. Associated jobs are about to be deleted." ); try { Set<TriggerKey> tks = this.scheduler.scheduler.getTriggerKeys( GroupMatcher.triggerGroupEquals( application.getName())); for( TriggerKey tk : tks ) { try { this.scheduler.deleteJob( tk.getName()); } catch( Exception e ) { this.logger.warning( "An error occurred while unscheduling job " + tk.getName() + ". " + e.getMessage()); Utils.logException( this.logger, e ); } } } catch( Exception e ) { this.logger.warning( "An error occurred while listing jobs for application " + application + ". " + e.getMessage()); Utils.logException( this.logger, e ); } } }
@Override public String getBucketVersions() { return bucketVersions(); }
public static boolean containsAny(String str, Iterable<String> pieces) { if (str == null) { return false; } for (String piece : pieces) { if (piece != null && str.contains(piece)) { return true; } } return false; }
public List<List<Integer>> palindromePairs(String[] words) { List<List<Integer>> ret = new ArrayList<>(); for(int i=0;i<words.length;i++) { for(int j=0;j<words.length;j++) { if(i!=j) { if(words[i].length()==0 || words[j].length()==0 || words[i].charAt(0)==words[j].charAt(words[j].length()-1) ) { if(isPalindrome(words[i],words[j])) { addOne(ret, i, j); } } } } } return ret; }
public static Ordering parse(String ordering) { if (ordering == null) { return Ordering.empty(); } final StringTokenizer tokenizer = new StringTokenizer(ordering, ","); final Map<Field, Direction> fields = Maps.newLinkedHashMap(); while (tokenizer.hasMoreTokens()) { final String token = tokenizer.nextToken(); final int index = token.indexOf('-'); final Direction direction = index > -1 ? Direction.DESCENDING : Direction.ASCENDING; final Field field = Field.fromName(token.substring(index + 1)); Preconditions.checkArgument( field != null, "Unsupported ordering field: %s", token ); fields.put(field, direction); } return new Ordering(fields); }
@PostConstruct public void validate() { boolean valid = true; log.info("Validating exchange..."); for (Entry<String, ExchangeConfig> entry : exchanges.entrySet()) { valid = validate(entry.getKey(), entry.getValue(), valid); } log.info("Validating queue..."); for (Entry<String, QueueConfig> entry : queues.entrySet()) { valid = validate(entry.getKey(), entry.getValue(), valid); } log.info("Validating binding..."); for (Entry<String, BindingConfig> entry : bindings.entrySet()) { valid = validate(entry.getKey(), entry.getValue(), valid); } if (isDeadLetterEnabled()) { log.info("Validating DeadLetterConfig..."); if (deadLetterConfig == null || deadLetterConfig.getDeadLetterExchange() == null) { log.error("Validating failed. DeadLetterConfig must provided if any queue enable dead letter queue."); valid = false; } else { valid = validate("DeadLetterConfig", deadLetterConfig, valid); } } if (reQueueConfig != null) { log.info("Validating ReQueueConfig..."); valid = validate("ReQueueConfig", reQueueConfig, valid); } if (valid) { log.info("RabbitConfig Validation done successfully. RabbitConfig = {{}}", this.toString()); } else { throw new RabbitmqConfigurationException("Invalid RabbitConfig Configuration"); } }
@Override public float getFloat(int columnIndex) throws OntoDriverException { return resultSet.getFloat(columnIndex); }
@Override @SuppressWarnings("unchecked") public <T> T convert(final Object source, Type type) { if (source == null) { return (T) nullValue(type); } if (source.getClass() == type) { return (T) source; } if (Generics.isSuperType(type, source.getClass())) { return (T) source; } if ("".equals(source) && type != String.class && isEmptyStringNull()) { return null; } Type sourceType = source.getClass(); Class<?> sourceClass = Generics.erase(sourceType); if (sourceClass.isArray() && Generics.isSuperType(Collection.class, type)) { return (T) Arrays.asList(source); } Class<?> targetClass = Generics.erase(type); if (Collection.class.isAssignableFrom(sourceClass) && targetClass.isArray()) { throw new UnsupportedOperationException("Not implemented yet"); } if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) { type = Primitives.wrap((Class<?>) type); } Object result = null; do { SourceAndTarget key = new SourceAndTarget(sourceType, type); Collection<Converter<?, ?>> forwards = convertersBySourceAndTarget.get(key); for (Converter<?, ?> forward : forwards) if ((result = typeSafeTo(forward, source)) != null) break; if (result == null) { Collection<Converter<?,?>> reverses = convertersBySourceAndTarget.get(key.reverse()); for (Converter<?, ?> reverse : reverses) if ((result = typeSafeFrom(reverse, source)) != null) break; } if (sourceType == Object.class) break; Class<?> superClass = erase(sourceType).getSuperclass(); sourceType = getExactSuperType(sourceType, superClass); } while (result == null); if (result == null) throw new IllegalStateException("Cannot convert " + source.getClass() + " to " + type); return (T) result; }
@Override public boolean createReservation(ReservationId reservationId, String user, Plan plan, ReservationDefinition contract) throws PlanningException { return computeAllocation(reservationId, user, plan, contract, null); }
@Override public Object get() { return value; }
@Override public ListenableFuture<?> submit(Runnable task) { return (ListenableFuture<?>) super.submit(task); }
public static void checkReadDeleteOnlyMode(String method, List<PathSegment> pathSegment) { if (!ReadDeleteModeLockManager.isReadDeleteOnlyMode()) { return; } if (isAuthPath(pathSegment)) { return; } if (isBatchPath(pathSegment)) { return; } if (ACCEPT_METHODS.contains(method)) { return; } throw DcCoreException.Server.READ_DELETE_ONLY; }
public int size() { return mTiles.size(); }
public void updateDaemonStatus(final TaskContext taskContext, final boolean isIdle) { runningService.updateIdle(taskContext, isIdle); }
@Override public void setPaymentInfoModel(final PaymentTransactionModel paymentTransactionModel, final AbstractOrderModel orderModel, final OrderNotificationMessage orderNotificationMessage) throws WorldpayConfigurationException { final PaymentInfoModel paymentInfo = getPaymentInfoModel(paymentTransactionModel, orderNotificationMessage); attachPaymentInfoModel(paymentTransactionModel, orderModel, paymentInfo); updateStoredCredentialsOnPaymentInfo(paymentInfo,orderNotificationMessage); removePaymentInfoWhenCreatingNewOneFromNotification(orderModel); }
@Override public Boolean exemptAndUpdateIssueDetails(IssueResponse issueException) throws DataException { try { List<Map<String, Object>> issueDetails = getOpenIssueDetails(issueException.getIssueId()); if (!issueDetails.isEmpty()) { Map<String, Object> issueDetail = issueDetails.get(0); Map<String, Object> issueExceptionDetails = issueException.getIssueExceptionDetails(); issueExceptionDetails.put(TARGET_TYPE, String.valueOf(issueDetail.get(TARGET_TYPE))); issueExceptionDetails.put("source", "issueException"); issueExceptionDetails.put("resourceId", String.valueOf(issueDetail.get(RESOURCEID))); String dataSource = issueDetail.get(PAC_DS) + "_" + issueDetail.get(TARGET_TYPE); String targetType = issueDetail.get(TYPE) + "_" + issueDetail.get(TARGET_TYPE); String id = String.valueOf(issueDetail.get(ES_DOC_ID_KEY)); String routing = String.valueOf(issueDetail.get(ES_DOC_ROUTING_KEY)); String parent = String.valueOf(issueDetail.get(ES_DOC_PARENT_KEY)); Map<String, Object> partialDocument = Maps.newHashMap(); partialDocument.put(ISSUE_STATUS, EXEMPTED); SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT, Locale.US); sdf.setTimeZone(TimeZone.getTimeZone("UTC")); partialDocument.put(MODIFIED_DATE, sdf.format(new Date())); partialDocument.put(STATUS, "enforced"); Boolean isUpdated = elasticSearchRepository.updatePartialDataToES(dataSource, targetType, id, routing, parent, partialDocument); if (isUpdated) { return elasticSearchRepository.saveExceptionDataToES(dataSource, routing, issueExceptionDetails); } } return false; } catch (Exception e) { throw new DataException(e); } }
@Override public void adjustTlsContextAfterSerialize(FinishedMessage message) { if (tlsContext.getChooser().getSelectedProtocolVersion().isTLS13()) { if (tlsContext.getChooser().getConnectionEndType() == ConnectionEndType.CLIENT) { setClientRecordCipher(Tls13KeySetType.APPLICATION_TRAFFIC_SECRETS); } else { adjustApplicationTrafficSecrets(); setServerRecordCipher(Tls13KeySetType.APPLICATION_TRAFFIC_SECRETS); } } }
public byte[] perform(byte[] blob) throws TokenStrategyFailedException { Reject.ifTrue(blob == null); if (!isTokenValidForCompression(blob)) { return blob; } return performUpdate(blob, replacement); }
public boolean isCurrent(int page) { return current == page; }
public PointRecCalcResult cancelPoint(PointRecPo rec, BigDecimal delta) { BigDecimal deltaCost; if (DecimalUtils.lt(rec.getAvailable(), delta)) { log.warn("no enough available point. rec = {}, delta = {}", rec, delta); throw new HyenaNoPointException("no enough available point", Level.WARN); } else if (DecimalUtils.gt(rec.getAvailable(), delta)) { BigDecimal available = rec.getAvailable().subtract(delta); BigDecimal canceled = rec.getCancelled().add(delta); deltaCost = this.costCalculator.accountCost(rec, delta); rec.setAvailable(available).setCancelled(canceled) .setUsedCost(rec.getUsedCost().add(deltaCost)); } else { BigDecimal canceled = rec.getCancelled().add(rec.getAvailable()); deltaCost = this.costCalculator.accountCost(rec, delta); rec.setAvailable(DecimalUtils.ZERO).setCancelled(canceled) .setUsedCost(rec.getUsedCost().add(deltaCost)); if (DecimalUtils.lte(rec.getFrozen(), DecimalUtils.ZERO)) { rec.setEnable(false); } } PointRecPo rec4Update = new PointRecPo(); rec4Update.setAvailable(rec.getAvailable()) .setCancelled(rec.getCancelled()) .setUsedCost(rec.getUsedCost()) .setEnable(rec.getEnable()) .setId(rec.getId()); return new PointRecCalcResult(rec4Update, deltaCost); }
public Hasher putByte(byte b) { hasher.putByte(b); return this; }
@Override public String getTitle() { return newTemplatePresenter.getView().getNewServerTemplateWizardTitle(); }
@NonNull public Task<FirebaseRemoteConfigInfo> ensureInitialized() { Task<ConfigContainer> activatedConfigsTask = activatedConfigsCache.get(); Task<ConfigContainer> defaultsConfigsTask = defaultConfigsCache.get(); Task<ConfigContainer> fetchedConfigsTask = fetchedConfigsCache.get(); Task<FirebaseRemoteConfigInfo> metadataTask = Tasks.call(executor, this::getInfo); Task<String> installationIdTask = firebaseInstallations.getId(); Task<InstallationTokenResult> installationTokenTask = firebaseInstallations.getToken(false); return Tasks.whenAllComplete( activatedConfigsTask, defaultsConfigsTask, fetchedConfigsTask, metadataTask, installationIdTask, installationTokenTask) .continueWith(executor, (unusedListOfCompletedTasks) -> metadataTask.getResult()); }
public boolean overlaps(KeyExtent otherExtent) { boolean result = this.extent.overlaps(otherExtent); if (!result && needsToBeChopped(otherExtent)) return true; return result; }
@Override public MessageKey getArgumentsMismatchMessage() { return MessageKey.USAGE_CHANGE_PASSWORD; }
@Override public boolean equals(Object object) { if (this == object) { return true; } if (!(object instanceof SerializableObjectWrapper)) { return false; } SerializableObjectWrapper serializableWrapper = (SerializableObjectWrapper)object; return _serializable.equals(serializableWrapper._serializable); }
@SuppressWarnings("unchecked") public String doProcessSiteLocation(ServiceDecomposition serviceDecomposition, String uuiRequest) { if (!isNeedProcessSite(uuiRequest)) { return uuiRequest; } Map<String, Object> uuiObject = getJsonObject(uuiRequest, Map.class); if (uuiObject == null) { return uuiRequest; } Map<String, Object> serviceObject = (Map<String, Object>) uuiObject.getOrDefault("service", Collections.emptyMap()); Map<String, Object> serviceParametersObject = (Map<String, Object>) serviceObject.getOrDefault("parameters", Collections.emptyMap()); Map<String, Object> serviceRequestInputs = (Map<String, Object>) serviceParametersObject.getOrDefault("requestInputs", Collections.emptyMap()); List<Object> resources = (List<Object>) serviceParametersObject.getOrDefault("resources", Collections.emptyList()); if (isSiteLocationLocal(serviceRequestInputs, resources)) { return getJsonString(uuiObject); } List<Resource> addResourceList = new ArrayList<>(); addResourceList.addAll(serviceDecomposition.getServiceResources()); serviceDecomposition.setVnfResources(null); serviceDecomposition.setAllottedResources(null); serviceDecomposition.setNetworkResources(null); serviceDecomposition.setConfigResources(null); for (Resource resource : addResourceList) { String resourcemodelName = resource.getModelInfo().getModelName(); if (StringUtils.containsIgnoreCase(resourcemodelName, "sppartner")) { serviceDecomposition.addResource(resource); break; } } return uuiRequest; }
@Override public void selectMenuItem(final String id) { workbenchMenuCompactNavBarView.selectMenuItem(id); workbenchMenuStandardNavBarView.selectMenuItem(id); }
@Deprecated String getParameters() { return mParameters; }
@Override public Response getOrderById(String orderId, HttpHeaders headers) { Order order = orderOtherRepository.findById(UUID.fromString(orderId)); if (order == null) { return new Response<>(0, orderNotFound, null); } else { return new Response<>(1, success, order); } }
@Override public boolean runningOrPaused(TargetInstance aTargetInstance) { String state = aTargetInstance.getState(); return state.equals(TargetInstance.STATE_RUNNING) || aTargetInstance.getState().equals(TargetInstance.STATE_PAUSED); }
public static PointShiftsBuilder builder(ShiftType shiftType) { return new PointShiftsBuilder(shiftType); }
@Override protected void execute() throws ApiFeException, InterruptedException, RpcException { String vmId = (String) step.getTransientResource(ResourceReserveStepCmd.VM_ID); checkNotNull(vmId, "VM id is not available"); Map<String, VmService.NetworkInfo> networkInfoMap = getNetworkInfo(vmId); for (VmService.NetworkInfo networkInfo : networkInfoMap.values()) { releasePrivateIp(networkInfo.id, vmId, networkInfo.privateIpAddress); if (networkHelper.isSdnEnabled()) { releaseFloatingIp(networkInfo.id, vmId, networkInfo.floatingIpAddress); } } logger.info("Released IP for VM {}", vmId); }
public String getImpl() { return clazz; }
public List<V> getAll(final K parent) { final List<V> all = this.getMultiples(parent); this.getSingle(parent).peek(all::add); return all; }
public T remove(String id) { return remove (new RestModelMetadata(id)); }
@Nullable public static MimeType parseMimeType (@Nullable final String sMimeType) { return parseMimeType (sMimeType, CMimeType.DEFAULT_QUOTING); }
@Override public void onBindViewHolder(@NonNull EmptyViewHolder emptyViewHolder, int position) { Item item = items.get(position); Witch.bind(getBinder(item).take(item), emptyViewHolder.itemView); }
String reverseJsonArray(String src) { Gson gson = new Gson(); List list = gson.fromJson(src, List.class); if (CollectionUtils.isEmpty(list)) { return StringUtils.EMPTY; } else { Collections.reverse(list); return gson.toJson(list); } }
public Predicate<I> getPredicate() { return predicate; }
public StorageUnitStatusEntity getStorageUnitStatusEntity(String code) throws ObjectNotFoundException { StorageUnitStatusEntity storageUnitStatusEntity = storageUnitStatusDao.getStorageUnitStatusByCode(code); if (storageUnitStatusEntity == null) { throw new ObjectNotFoundException(String.format("Storage unit status \"%s\" doesn't exist.", code)); } return storageUnitStatusEntity; }
public static <K, OLD, NEW> DataSet<Edge<K, NEW>> translateEdgeValues(DataSet<Edge<K, OLD>> edges, TranslateFunction<OLD, NEW> translator) { return translateEdgeValues(edges, translator, PARALLELISM_DEFAULT); }
public boolean accepts(DataElement element) { MetaDataProvider metaDataProvider = element.getMetaData(); if (myEvaluator == null || !metaDataProvider.hasKey(myField)) { return false; } Object value = metaDataProvider.getValue(myField); if (value instanceof DynamicEnumerationKey) { value = myDynamicEnumRegistry.getEnumerationValue((DynamicEnumerationKey)value); } else if (value == null && element.getDataTypeInfo().getMetaDataInfo().getSpecialTypeForKey(myField) == TimeKey.DEFAULT) { value = element.getTimeSpan(); } if (myFieldFunction != null) { value = applyFunction(value); } return myEvaluator.evaluate(value); }
@Override public void addJob(AgentMngrAPIRequest request) { logger.debug("adding job for job id " + request.getJobId()); JobRequestData data = new JobRequestData(request); elements.put(request.getJobId(), data); }
@Override public void negativeDeliveryAck(Delivery delivery) { try { channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false); log.debug("Send negative Ack (deliveryTag={})", delivery.getEnvelope().getDeliveryTag()); publishEventToFailedQueue(delivery); } catch (IOException e) { log.error("Could not publish message.created event on eddi.failed queue! \n" + e.getLocalizedMessage(), e); } }
public int getCollectionDisplayDepthForSearch(String field) { HierarchicalConfiguration collection = getCollectionConfiguration(field); if (collection == null) { return -1; } return collection.getInt("displayDepthForSearch", -1); }
@Post public Representation registerPermissionRequest(JsonRepresentation entity) throws UmaException, NotFoundException, ServerException { JsonValue permissionRequest = json(toMap(entity)); String resourceSetId = getResourceSetId(permissionRequest); OAuth2Request oAuth2Request = requestFactory.create(getRequest()); String clientId = getClientId(oAuth2Request); OAuth2ProviderSettings providerSettings = providerSettingsFactory.get(oAuth2Request); String resourceOwnerId = getResourceOwnerId(oAuth2Request); ResourceSetDescription resourceSetDescription = getResourceSet(resourceSetId, resourceOwnerId, providerSettings); Set<String> scopes = validateScopes(permissionRequest, resourceSetDescription); for (PermissionRequestFilter filter : extensionFilterManager.getFilters(PermissionRequestFilter.class)) { filter.onPermissionRequest(resourceSetDescription, scopes, clientId); } String ticket = umaProviderSettingsFactory.get(getRequest()).getUmaTokenStore() .createPermissionTicket(resourceSetId, scopes, clientId).getId(); return setResponse(201, Collections.<String, Object>singletonMap("ticket", ticket)); }
@Override public Object getValue(final IFieldName name) throws ReadValueException, InvalidArgumentException { if (null == name) { throw new InvalidArgumentException("Name parameter should not be null."); } return body.get(name); }
@Override public CompletableFuture<MembersIdsResponse> getRoomMembersIds( final String roomId, final String start) { return toFuture(retrofitImpl.getMembersIds(ORG_TYPE_ROOM, roomId, start)); }
public static LineString fromLngLats(@NonNull MultiPoint multiPoint) { return new LineString(TYPE, null, multiPoint.coordinates()); }
@Override public Request.Name requestHandled() { return METHOD_NAME; }
public List<List<DependencyNode>> getPaths() { return paths; }
public static Builder builder(final Version version, final String creator) { return new Builder(version, creator); }
public static List<String> parseMethodDescriptor(String descriptor) { if (descriptor.startsWith("()")) { return new ArrayList<>(); } descriptor = descriptor.substring(descriptor.indexOf("(") + 1, descriptor.indexOf(")")); List<Character> base = Arrays.asList('V', 'Z', 'B', 'C', 'S', 'I', 'J', 'F', 'D'); List<String> rets = new ArrayList<>(); for (int i = 0; i < descriptor.length(); i++) { if (base.contains(descriptor.charAt(i))) { rets.add(String.valueOf(descriptor.charAt(i))); continue; } if (descriptor.charAt(i) == '[') { int temp = i; i++; while (descriptor.charAt(i) == '[') { i++; } if (base.contains(descriptor.charAt(i))) { rets.add(descriptor.substring(temp, i + 1)); continue; } int idx = descriptor.indexOf(';', i); rets.add(descriptor.substring(temp, idx)); i = idx; continue; } if (descriptor.charAt(i) == 'L') { int idx = descriptor.indexOf(';', i); rets.add(descriptor.substring(i, idx)); i = idx; continue; } } return rets; }
public DeepExperimentBuilder experiment(Experiment_ImplBase experiment) { if (experiment == null) { throw new NullPointerException("The experiment is null"); } this.experiment = experiment; return this; }
public Function<T, T17> get17() { return getAndCast(17); }
public static String areaAddres(byte[] bytes) { String areaAddres = ""; for (Byte byt : bytes) { String hexa = Integer.toHexString(Byte.toUnsignedInt(byt)); if (hexa.length() % 2 != 0) { hexa = "0" + hexa; } areaAddres = areaAddres + hexa; } return areaAddres; }
@SuppressWarnings({"PMD.NcssCount", "PMD.AvoidReassigningLoopVariables"}) static String expandEscapedChars(String str) { StringBuilder builder = new StringBuilder(); for (int i = 0; i < str.length(); ++i) { char c = str.charAt(i); if (c == '\\') { ++i; if (i >= str.length()) { throw error("dangling escape", str, i); } c = str.charAt(i); switch (c) { case 't': builder.append('\t'); break; case 'n': builder.append('\n'); break; case 'r': builder.append('\r'); break; case 'f': builder.append('\f'); break; case 'a': builder.append('\u0007'); break; case 'e': builder.append('\u001B'); break; case '0': int numDigits = 0; for (int j = i + 1; j < Math.min(i + 4, str.length()); ++j) { c = str.charAt(j); if (c >= '0' && c <= '7') { ++numDigits; } else { break; } } if (numDigits < 1 || numDigits > 3) { throw error("invalid octal escape sequence", str, i); } c = parse(str.substring(i + 1, i + numDigits + 1), 8, "octal", str, i); builder.append(c); i += numDigits; break; case 'x': if (i + 3 > str.length()) { throw error("invalid hexadecimal escape sequence", str, i); } c = parse(str.substring(i + 1, i + 3), 16, "hexadecimal", str, i); builder.append(c); i += 2; break; case 'u': if (i + 5 > str.length()) { throw error("invalid unicode escape sequence", str, i); } c = parse(str.substring(i + 1, i + 5), 16, "unicode", str, i); builder.append(c); i += 4; break; default: builder.append('\\').append(c); break; } } else { builder.append(c); } } return builder.toString(); }
public boolean isOn() { return localhostRequestProcessor.isEnabled(); }
@Override public List<String> apply(String from) { DatabagItem bootstrapConfig = bootstrapConfigForGroup.apply(from); Map<String, JsonBall> config = json.fromJson(bootstrapConfig.toString(), BootstrapConfigForGroup.BOOTSTRAP_CONFIG_TYPE); JsonBall runlist = config.get("run_list"); return json.fromJson(runlist.toString(), RUN_LIST_TYPE); }
public static BigDecimal valueOf(int number) { return 0 <= number && number < NUMBERS.length ? NUMBERS[number] : BigDecimal.valueOf(number); }
public Optional<GatekeeperRDSInstance> getOneInstance(AWSEnvironment environment, String dbInstanceIdentifier, String instanceName) { logger.info(dbInstanceIdentifier); Long startTime = System.currentTimeMillis(); List<String> securityGroupIds = sgLookupService.fetchSgsForAccountRegion(environment); AmazonRDSClient amazonRDSClient = awsSessionService.getRDSSession(environment); List<GatekeeperRDSInstance> gatekeeperRDSInstances; if(dbInstanceIdentifier.startsWith("cluster")){ DescribeDBClustersResult result = amazonRDSClient.describeDBClusters( new DescribeDBClustersRequest().withDBClusterIdentifier(instanceName)); gatekeeperRDSInstances = loadToGatekeeperRDSInstanceAurora(environment, amazonRDSClient, result.getDBClusters(), securityGroupIds, DatabaseType.AURORA_REGIONAL); }else { DescribeDBInstancesResult result = amazonRDSClient.describeDBInstances(new DescribeDBInstancesRequest().withDBInstanceIdentifier(instanceName)); gatekeeperRDSInstances = loadToGatekeeperRDSInstance(environment, amazonRDSClient, result.getDBInstances(), securityGroupIds); } logger.info("Fetched Instance in " + ((double)(System.currentTimeMillis() - startTime) / 1000) + " Seconds"); Optional<GatekeeperRDSInstance> gatekeeperRDSInstance = Optional.of(gatekeeperRDSInstances.get(0)); return gatekeeperRDSInstance; }
void setPage(int page) { int safePage = max(0, page); this.page = min(safePage, getPages() - 1); }
public void dismiss() { if (whatToShow != null) { whatToShow = null; if (!hasView()) return; Popup<D, R> popUp = getView(); if (popUp.isShowing()) popUp.dismiss(WITH_FLOURISH); } }
public ImmutableList<String> coexpressedGenesFor(String experiment, String identifier) { try { String result = jdbcTemplate.queryForObject(CE_GENES_SQL_QUERY_TEMPLATE, String.class, experiment, identifier); return ImmutableList.copyOf( Stream.of(result.split(",")) .filter(geneId -> !geneId.equalsIgnoreCase(identifier)) .collect(toList())); } catch (IncorrectResultSizeDataAccessException e) { return ImmutableList.of(); } }
@Override public void execute(JsonApiDocument jsonApiDocument, PersistentResource resource, Optional<MultivaluedMap<String, String>> queryParams) { if (isPresent(queryParams, INCLUDE)) { addIncludedResources(jsonApiDocument, resource, queryParams.get().get(INCLUDE)); } }
public Map<Location, Integer> countLeafEntitiesByLocatedLocations() { Map<Location, Integer> result = new LinkedHashMap<Location, Integer>(); for (Entity e: context.getApplications()) { countLeafEntitiesByLocatedLocations(e, null, result); } return result; }
@Override public Set<? extends Image> get() { memoizedImageSupplier.get(); return ImmutableSet.copyOf(imageCache.asMap().values()); }
public Integer getStorageAttributeIntegerValueByName(String attributeName, StorageEntity storageEntity, Integer defaultValue) { Integer value = getStorageAttributeIntegerValueByName(attributeName, storageEntity, false, false); if (value == null) { value = defaultValue; } return value; }
public RectangleArea move(double deltaX, double deltaY) { return new RectangleArea(x + deltaX, y + deltaY, width, height); }
@Override public boolean isSigned(final int column) throws SQLException { Preconditions.checkArgument(column == 1); return true; }
@Override public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException { return delegate.invokeAny(wrapTracerCallableCollection(tasks)); }
public DefinitionGraph transform(Map<String, List<ModuleContext>> moduleMap) { definition(null, RootDefinition.builder(), builder -> moduleMap.keySet().forEach( moduleName -> builder.withModule(transformModules(moduleName, moduleMap.get(moduleName))))); return createGraph(definitions).build(); }
@Override protected void startUp() throws Exception { LOG.info("Starting RunRecordCorrectorService"); localDatasetDeleterService = Executors .newSingleThreadScheduledExecutor(r -> new Thread(r, "local dataset deleter")); long interval = cConf.getLong(Constants.AppFabric.LOCAL_DATASET_DELETER_INTERVAL_SECONDS); if (interval <= 0) { LOG.warn("Invalid interval specified for the local dataset deleter {}. Setting it to 3600 seconds.", interval); interval = 3600L; } long initialDelay = cConf.getLong(Constants.AppFabric.LOCAL_DATASET_DELETER_INITIAL_DELAY_SECONDS); if (initialDelay <= 0) { LOG.warn("Invalid initial delay specified for the local dataset deleter {}. Setting it to 300 seconds.", initialDelay); initialDelay = 300L; } Runnable runnable = new LocalDatasetDeleterRunnable(namespaceAdmin, store, datasetFramework); localDatasetDeleterService.scheduleWithFixedDelay(runnable, initialDelay, interval, TimeUnit.SECONDS); }
@Override public void unexpectedEvent(final String message) { safeSendMail("UNEXPECTED TRADE EVENT", message); }
@Override public ApiTracer newTracer(ApiTracer parent, SpanName spanName, OperationType operationType) { Span parentSpan = internalTracer.getCurrentSpan(); if (parent instanceof OpencensusTracer) { parentSpan = ((OpencensusTracer) parent).getSpan(); } Span span = internalTracer .spanBuilderWithExplicitParent(spanName.toString(), parentSpan) .setRecordEvents(true) .startSpan(); span.putAttributes(spanAttributes); return new OpencensusTracer(internalTracer, span, operationType); }
public FederatedServiceMethodInvocationHandler getHandlerForMethod( Method method) { FederatedByAgencyIdMethod byAgency = method.getAnnotation(FederatedByAgencyIdMethod.class); if (byAgency != null) return new FederatedByAgencyIdMethodInvocationHandlerImpl(method, byAgency.argument(), byAgency.propertyExpression()); FederatedByAnyEntityIdMethod byAnyEntityId = method.getAnnotation(FederatedByAnyEntityIdMethod.class); if (byAnyEntityId != null) return new FederatedByAnyEntityIdMethodInvocationHandlerImpl(method, byAnyEntityId.argument(), byAnyEntityId.properties(), byAnyEntityId.agencyIdProperties()); FederatedByEntityIdMethod ann0 = method.getAnnotation(FederatedByEntityIdMethod.class); if (ann0 != null) return new FederatedByEntityIdMethodInvocationHandlerImpl(method, ann0.argument(), ann0.propertyExpression()); FederatedByEntityIdsMethod ann1 = method.getAnnotation(FederatedByEntityIdsMethod.class); if (ann1 != null) return new FederatedByEntityIdsMethodInvocationHandlerImpl( ann1.argument()); FederatedByBoundsMethod ann2 = method.getAnnotation(FederatedByBoundsMethod.class); if (ann2 != null) return new FederatedByBoundsMethodInvocationHandlerImpl( ann2.lat1Argument(), ann2.lon1Argument(), ann2.lat2Argument(), ann2.lon2Argument()); FederatedByLocationMethod ann3 = method.getAnnotation(FederatedByLocationMethod.class); if (ann3 != null) return new FederatedByLocationMethodInvocationHandlerImpl( ann3.latArgument(), ann3.lonArgument()); FederatedByAggregateMethod ann4 = method.getAnnotation(FederatedByAggregateMethod.class); if (ann4 != null) { EMethodAggregationType aggregationType = getAggregationTypeForMethod(method); return new FederatedByAggregateMethodInvocationHandlerImpl( aggregationType); } FederatedByCoordinateBoundsMethod ann5 = method.getAnnotation(FederatedByCoordinateBoundsMethod.class); if (ann5 != null) return new FederatedByCoordinateBoundsMethodInvocationHandlerImpl(method, ann5.argument(), ann5.propertyExpression()); FederatedByCoordinatePointsMethod ann6 = method.getAnnotation(FederatedByCoordinatePointsMethod.class); if (ann6 != null) { int[] argumentIndices = ann6.arguments(); String[] expressions = ann6.propertyExpressions(); if (expressions.length == 0) expressions = new String[argumentIndices.length]; return new FederatedByCoordinatePointsMethodInvocationHandlerImpl(method, argumentIndices, expressions); } FederatedByCustomMethod ann7 = method.getAnnotation(FederatedByCustomMethod.class); if (ann7 != null) { Class<? extends FederatedServiceMethodInvocationHandler> handlerClass = ann7.handler(); try { return handlerClass.newInstance(); } catch (Exception ex) { throw new ServiceException( "error creating FederatedServiceMethodInvocationHandler of type " + handlerClass, ex); } } throw new IllegalArgumentException( "No FederatedService method annotation for method: " + method); }
@Override public void detachSecurityGroup(String instanceId, String securityGroup) { if (instanceId.isEmpty() || instanceId == null) { throw new InvalidInputDataException("Empty/Null instanceId provided in request"); } else if (securityGroup.isEmpty() || securityGroup == null) { throw new InvalidInputDataException("Empty/Null securityGroup provided in request"); } List<String> securityGroups = this.getSecurityGroups(instanceId); if (securityGroups != null && securityGroups.contains(securityGroup)) { securityGroups.remove(securityGroup); ec2Delegator.getEc2().modifyInstanceAttribute(new ModifyInstanceAttributeRequest().withInstanceId(instanceId).withGroups(securityGroups)); } else { throw new InvalidInputDataException("Invalid SecurityGroup: " + securityGroup + " provided in request"); } }
public static double rho( double spot, double strike, double timeToExpiry, double lognormalVol, double interestRate, double costOfCarry, boolean isCall) { ArgChecker.isTrue(spot >= 0d, "negative/NaN spot; have {}", spot); ArgChecker.isTrue(strike >= 0d, "negative/NaN strike; have {}", strike); ArgChecker.isTrue(timeToExpiry >= 0d, "negative/NaN timeToExpiry; have {}", timeToExpiry); ArgChecker.isTrue(lognormalVol >= 0d, "negative/NaN lognormalVol; have {}", lognormalVol); ArgChecker.isFalse(Double.isNaN(interestRate), "interestRate is NaN"); ArgChecker.isFalse(Double.isNaN(costOfCarry), "costOfCarry is NaN"); double discount = 0d; if (-interestRate > LARGE) { return isCall ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; } if (interestRate > LARGE) { return 0d; } discount = (Math.abs(interestRate) < SMALL && timeToExpiry > LARGE) ? 1d : Math.exp(-interestRate * timeToExpiry); if (LARGE * spot < strike || timeToExpiry > LARGE) { double res = isCall ? 0d : -discount * strike * timeToExpiry; return Double.isNaN(res) ? -discount : res; } if (spot > LARGE * strike || timeToExpiry < SMALL) { double res = isCall ? discount * strike * timeToExpiry : 0d; return Double.isNaN(res) ? discount : res; } int sign = isCall ? 1 : -1; double rootT = Math.sqrt(timeToExpiry); double sigmaRootT = lognormalVol * rootT; double factor = Math.exp(costOfCarry * timeToExpiry); double rescaledSpot = spot * factor; double d2 = 0d; if (Math.abs(spot - strike) < SMALL || sigmaRootT > LARGE || (spot > LARGE && strike > LARGE)) { double coefD1 = (costOfCarry / lognormalVol - 0.5 * lognormalVol); double tmp = coefD1 * rootT; d2 = Double.isNaN(tmp) ? 0d : tmp; } else { if (sigmaRootT < SMALL) { return isCall ? (rescaledSpot > strike ? discount * strike * timeToExpiry : 0d) : (rescaledSpot < strike ? -discount * strike * timeToExpiry : 0d); } double tmp = costOfCarry * rootT / lognormalVol; double sig = (costOfCarry >= 0d) ? 1d : -1d; double scnd = Double.isNaN(tmp) ? ((lognormalVol < LARGE && lognormalVol > SMALL) ? sig / lognormalVol : sig * rootT) : tmp; d2 = Math.log(spot / strike) / sigmaRootT + scnd - 0.5 * sigmaRootT; } double norm = NORMAL.getCDF(sign * d2); double result = norm < SMALL ? 0d : sign * discount * strike * timeToExpiry * norm; return Double.isNaN(result) ? sign * discount : result; }
public String response(long serverStartTime) { var currentTime = System.nanoTime(); if ((currentTime - serverStartTime) * 1.0 / (1000 * 1000 * 1000) < delay) { return "Delayed service is down"; } else { return "Delayed service is working"; } }
@Override public List<StoredDocument> getDocs(String idField, Set<String> ids, Set<String> whiteListFields, Set<String> blackListFields) throws IOException, SearchClientException { StringBuilder sb = new StringBuilder(); int i = 0; sb.append(idField + ":("); for (String id : ids) { if (i++ > 0) { sb.append(" OR "); } sb.append("\"" + id + "\""); } sb.append(")"); Map<String, String> qRequest = new HashMap<>(); qRequest.put("query", sb.toString()); qRequest.put("limit", Integer.toString(i + 10)); if (whiteListFields.size() > 0) { String fields = StringUtils.join(whiteListFields, ","); qRequest.put("fields", fields); } String json = GSON.toJson(qRequest); JsonResponse fullResponse = postJson(url + "/select", json); if (fullResponse.getStatus() != 200) { LOG.warn("problem with " + url + " and " + json); return Collections.EMPTY_LIST; } List<StoredDocument> documents = new ArrayList<>(); JsonElement root = fullResponse.getJson(); JsonObject response = (JsonObject) ((JsonObject) root).get("response"); long totalHits = response.get("numFound").getAsLong(); if (response.has("docs")) { JsonArray docs = (JsonArray) response.get("docs"); for (JsonElement docElement : docs) { StoredDocument document = new StoredDocument(); JsonObject docObj = (JsonObject) docElement; for (String key : docObj.keySet()) { if (!blackListFields.contains(key)) { JsonElement value = docObj.get(key); if (value.isJsonArray()) { for (int j = 0; j < ((JsonArray) value).size(); j++) { document.addNonBlankField(key, ((JsonArray) value).get(j).getAsString()); } } else { document.addNonBlankField(key, value.getAsString()); } } } documents.add(document); } } return documents; }
@Override public double calculate(Vector2D<?, ?> orientation, double angularSpeed, double maxAngularSpeed, Vector2D<?, ?> target) { final double angle = orientation.signedAngle(target); if (Math.abs(angle) <= this.stopAngle) { return 0; } return MathUtil.clamp(angle, -maxAngularSpeed, maxAngularSpeed); }
@Override public AttributedList<Path> list(final Path directory, final ListProgressListener listener) throws BackgroundException { try { final AttributedList<Path> buckets = new AttributedList<Path>(); Buckets response; String page = null; do { response = session.getClient().buckets().list(session.getHost().getCredentials().getUsername()) .setMaxResults(preferences.getLong("googlestorage.listing.chunksize")) .setPageToken(page) .execute(); if(null != response.getItems()) { for(Bucket item : response.getItems()) { final Path bucket = new Path(PathNormalizer.normalize(item.getName()), EnumSet.of(Path.Type.volume, Path.Type.directory), attributes.toAttributes(item) ); buckets.add(bucket); listener.chunk(directory, buckets); } } page = response.getNextPageToken(); } while(page != null); return buckets; } catch(IOException e) { throw new GoogleStorageExceptionMappingService().map("Listing directory {0} failed", e, directory); } }
@Override public void blockquote() { blockquote( null ); }
@Override public boolean matchAnyCommunity(Environment environment, Set<Community> communityCandidates) { return resolve(environment).matchAnyCommunity(environment, communityCandidates); }
@Override public ExecutionState execute(IConversationMemory memory, List<BehaviorRule> trace) { List<IData<Context>> contextData = memory.getCurrentStep().getAllData(CONTEXT); ExecutionState state; boolean success = false; for (IData<Context> contextDatum : contextData) { Context context = contextDatum.getResult(); if (contextDatum.getKey().equals(CONTEXT + ":" + contextKey)) { switch (context.getType()) { case expressions: Expressions contextExpressions = expressionProvider. parseExpressions(context.getValue().toString()); success = Collections.indexOfSubList(contextExpressions, expressions) != -1; break; case object: try { if (object.getObjectKeyPath() != null) { final String contextObjectAsJson = jsonSerialization.serialize(context.getValue()); Object foundObjectValue = findObjectValue(contextObjectAsJson); if (foundObjectValue != null) { success = object.getObjectValue() == null || object.getObjectValue().equals(foundObjectValue.toString()); } } } catch (IOException e) { log.error(e.getLocalizedMessage(), e); success = false; } break; default: case string: success = string.equals(context.getValue().toString()); break; } } } state = success ? ExecutionState.SUCCESS : ExecutionState.FAIL; return state; }
public void plus(int x) { for (int i = 0; i < SIZE; i++) { ELEMENTS[i] += x; } }
@Override public void subscribe(MultiSubscriber<? super T> downstream) { BaseMultiEmitter<T> emitter; switch (backpressure) { case DROP: emitter = new DropItemOnOverflowMultiEmitter<>(downstream); break; case ERROR: emitter = new ErrorOnOverflowMultiEmitter<>(downstream); break; case IGNORE: emitter = new IgnoreBackPressureMultiEmitter<>(downstream); break; case LATEST: emitter = new DropLatestOnOverflowMultiEmitter<>(downstream); break; default: emitter = new BufferItemMultiEmitter<>(downstream, 16); break; } downstream.onSubscribe(emitter); try { consumer.accept(emitter.serialize()); } catch (Throwable ex) { emitter.fail(ex); } }
public static Map<String, Long> fillMap(Map<String, Long> defaultMap, Map<String, Long> mapToFill) { notNull(defaultMap, "defaultMap should not be null"); notNull(mapToFill, "mapToFill should not be null"); isTrue(defaultMap.size() >= mapToFill.size(), "default map should not have less element than mapToFill, so that the result should contain all the elements of both maps"); final Map<String, Long> resultMap = new LinkedHashMap<>(); defaultMap.forEach((k, v) -> resultMap.merge(k, v, Long::max)); mapToFill.forEach((k, v) -> resultMap.merge(k, v, Long::max)); return resultMap; }
@Override public ReleaseResult execute( ReleaseDescriptor releaseDescriptor, ReleaseEnvironment releaseEnvironment, List<MavenProject> reactorProjects ) throws ReleaseExecutionException { ReleaseResult result = new ReleaseResult(); resourceBundle = getResourceBundle( releaseEnvironment.getLocale() ); MavenProject rootProject = ReleaseUtil.getRootProject( reactorProjects ); if ( releaseDescriptor.isAutoVersionSubmodules() && ArtifactUtils.isSnapshot( rootProject.getVersion() ) ) { MavenProject project = rootProject; String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() ); String nextVersion = resolveNextVersion( project, projectId, releaseDescriptor, result ); if ( !convertToSnapshot ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else if ( releaseDescriptor.isBranchCreation() && convertToBranch ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else { releaseDescriptor.addDevelopmentVersion( projectId, nextVersion ); } for ( MavenProject subProject : reactorProjects ) { String subProjectId = ArtifactUtils.versionlessKey( subProject.getGroupId(), subProject.getArtifactId() ); if ( convertToSnapshot ) { String v; if ( ArtifactUtils.isSnapshot( subProject.getVersion() ) ) { v = nextVersion; } else { v = subProject.getVersion(); } if ( releaseDescriptor.isBranchCreation() && convertToBranch ) { releaseDescriptor.addReleaseVersion( subProjectId, v ); } else { releaseDescriptor.addDevelopmentVersion( subProjectId, v ); } } else { releaseDescriptor.addReleaseVersion( subProjectId, nextVersion ); } } } else { for ( MavenProject project : reactorProjects ) { String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() ); String nextVersion = resolveNextVersion( project, projectId, releaseDescriptor, result ); if ( !convertToSnapshot ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else if ( releaseDescriptor.isBranchCreation() && convertToBranch ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else { releaseDescriptor.addDevelopmentVersion( projectId, nextVersion ); } } } result.setResultCode( ReleaseResult.SUCCESS ); return result; }
@Override public Response toResponse(final TransactionNotFoundException e) { LOGGER.info(e.getMessage()); return Response.status(Response.Status.NOT_FOUND).entity(e.getMessage()).type(MediaType.TEXT_PLAIN).build(); }
public static void setEnvFromInputString(Map<String, String> env, String envString, String classPathSeparator) { if (envString != null && envString.length() > 0) { Matcher varValMatcher = VARVAL_SPLITTER.matcher(envString); while (varValMatcher.find()) { String envVar = varValMatcher.group(1); String envVal = varValMatcher.group(2).replaceAll("^\"|\"$", ""); Matcher m = VAR_SUBBER.matcher(envVal); StringBuffer sb = new StringBuffer(); while (m.find()) { String var = m.group(1); String replace = env.get(var); if (replace == null) replace = System.getenv(var); if (replace == null) replace = ""; m.appendReplacement(sb, Matcher.quoteReplacement(replace)); } m.appendTail(sb); addToEnvironment(env, envVar, sb.toString(), classPathSeparator); } } }
public void expand(String key, long value, RangeHandler rangeHandler, EdgeHandler edgeHandler) { if (value < lowerBound || value > upperBound) { return; } int maxLevels = value > 0 ? maxPositiveLevels : maxNegativeLevels; int sign = value > 0 ? 1 : -1; StringBuilder builder = new StringBuilder(128); builder.append(key).append('='); long levelSize = arity; long edgeInterval = (value / arity) * arity; edgeHandler.handleEdge(createEdgeFeatureHash(builder, edgeInterval), (int) Math.abs(value - edgeInterval)); for (int i = 0; i < maxLevels; ++i) { long start = (value / levelSize) * levelSize; if (Math.abs(start) + levelSize - 1 < 0) { break; } rangeHandler.handleRange(createRangeFeatureHash(builder, start, start + sign * (levelSize - 1))); levelSize *= arity; if (levelSize <= 0 && levelSize != Long.MIN_VALUE) { break; } } }
public void reset() { start = partial = System.nanoTime(); events = new LinkedHashMap<>(); }
@Override public void execute(DelegateExecution delegateExecution) { if (delegateExecution != null) { final ResponseEntity<Object> serviceResponse = doPost(getURLasString(), new HttpEntity<>(getProcessVariable(delegateExecution, DATA_KEY), createHttpHeaders(delegateExecution)), getProcessVariable(delegateExecution, PARAMS_KEY)); updateDataKeyVariable(delegateExecution, serviceResponse); } }
public boolean checkTicket(IMediaStream stream, IClient client) { if (client == null) { logger.debug("No client, returning ", stream); return false; } return checkTicket(stream.getName(), client.getQueryStr(), client.getIp()); }
public static String renderSpeakPreview(String content) { return KmarkProcessor.process(content); }
public static JmsTracer create(Tracer tracer) { return create(tracer, false); }
public static byte[] encryptHmacSHA1(final byte[] data, final byte[] key) { return hmacTemplate(data, key, "HmacSHA1"); }
@Override public void validate(Object obj, Errors errors) throws APIException { if (obj == null || !(obj instanceof ConceptReferenceTerm)) { throw new IllegalArgumentException("The parameter obj should not be null and must be of type" + ConceptReferenceTerm.class); } ConceptReferenceTerm conceptReferenceTerm = (ConceptReferenceTerm) obj; String code = conceptReferenceTerm.getCode(); boolean hasBlankFields = false; if (!StringUtils.hasText(code)) { errors.rejectValue("code", "ConceptReferenceTerm.error.codeRequired", "The code property is required for a concept reference term"); hasBlankFields = true; } if (conceptReferenceTerm.getConceptSource() == null) { errors.rejectValue("conceptSource", "ConceptReferenceTerm.error.sourceRequired", "The conceptSource property is required for a concept reference term"); hasBlankFields = true; } if (hasBlankFields) { return; } code = code.trim(); ConceptReferenceTerm termWithDuplicateCode = Context.getConceptService().getConceptReferenceTermByCode(code, conceptReferenceTerm.getConceptSource()); if (termWithDuplicateCode != null && !OpenmrsUtil.nullSafeEquals(termWithDuplicateCode.getUuid(), conceptReferenceTerm.getUuid())) { errors.rejectValue("code", "ConceptReferenceTerm.duplicate.code", "Duplicate concept reference term code in its concept source: " + code); } if (CollectionUtils.isNotEmpty(conceptReferenceTerm.getConceptReferenceTermMaps())) { int index = 0; Set<String> mappedTermUuids = null; for (ConceptReferenceTermMap map : conceptReferenceTerm.getConceptReferenceTermMaps()) { if (map == null) { throw new APIException("ConceptReferenceTerm.add.null", (Object[]) null); } if (map.getConceptMapType() == null) { errors.rejectValue("conceptReferenceTermMaps[" + index + "].conceptMapType", "ConceptReferenceTerm.error.mapTypeRequired", "Concept Map Type is required"); } else if (map.getTermB() == null) { errors.rejectValue("conceptReferenceTermMaps[" + index + "].termB", "ConceptReferenceTerm.error.termBRequired", "Mapped Term is required"); } else if (map.getTermB().equals(conceptReferenceTerm)) { errors.rejectValue("conceptReferenceTermMaps[" + index + "].termB", "ConceptReferenceTerm.map.sameTerm", "Cannot map a concept reference term to itself"); } if (errors.hasErrors()) { return; } if (mappedTermUuids == null) { mappedTermUuids = new HashSet<>(); } if (!mappedTermUuids.add(map.getTermB().getUuid())) { errors.rejectValue("conceptReferenceTermMaps[" + index + "].termB", "ConceptReferenceTerm.termToTerm.alreadyMapped", "Cannot map a reference term multiple times to the same concept reference term"); } index++; } } ValidateUtil.validateFieldLengths(errors, obj.getClass(), "name", "code", "version", "description", "retireReason"); }
public void setValues(Iterable<Double> vals) { if(vals==null) throw new IllegalArgumentException("vector is null"); v.clear(); for(Double d : vals) v.add(d); }
public static Expression product(@Size(min = 2) Expression... numbers) { return new Expression("*", numbers); }
@Override public void plus(MapID m) { for (MapID.Entry e : m.entrySet()) { int key = e.getKey(); if (this.containsKey(key)) { this.put(key, this.get(key) + e.getValue()); } else { this.put(key, e.getValue()); } } }
@Override public boolean put(String key, @Nullable V value) { return putAll(key, Arrays.asList(value)); }
@Override public final void dispose() { SubscriptionHelper.cancel(s); }
public static GeneralAdminInp instanceForAddUser(final User user) throws JargonException { if (user == null) { throw new JargonException("null user"); } if (user.getName().isEmpty()) { throw new JargonException("blank user name"); } if (user.getUserType() == UserTypeEnum.RODS_UNKNOWN) { throw new JargonException("unknown user type"); } return new GeneralAdminInp("add", "user", user.getName(), user.getUserType().getTextValue(), "", "", BLANK, BLANK, BLANK, BLANK, GEN_ADMIN_INP_API_NBR); }
@Override protected ListableStackResourceFactory createInstance() { String stackName = this.stackNameProvider.getStackName(); return new StaticStackResourceRegistry(stackName, getResourceMappings("", stackName)); }
public NodeState deserialize(String json){ JsopReader reader = new JsopTokenizer(json); reader.read('{'); NodeState state = deserialize(reader); reader.read(JsopReader.END); return state; }
@Override public byte[] next() throws IOException { checkStop(); try { reader.mark(avgSizeByte); String line = reader.readLine(); if (line == null) { throw new EOFException("reach the end of line reader bucket."); } byte[] data = line.getBytes(); position += data.length; return data; } catch (EOFException eof) { throw eof; } catch (IOException io) { try { reader.reset(); } catch (IOException ignore) { } throw io; } }
@Override public void checkServerTrusted(X509Certificate[] certs, String arg1) throws CertificateException { boolean verified = false; if (certs !=null){ for (X509Certificate cert : certs) { if (cert.equals(controllerCert)) { verified = true; break; } } } if (!verified) throw new CertificateException(); }
@Override public FluentWebElementAssert hasText(String textToFind) { String actualText = actual.text(); if (!actualText.contains(textToFind)) { failWithMessage("The element does not contain the text: " + textToFind + ". Actual text found : " + actualText); } return this; }
String produceLinkLocalIp() { try { Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces(); while (nics.hasMoreElements()) { NetworkInterface nic = nics.nextElement(); Enumeration<InetAddress> addresses = nic.getInetAddresses(); while (addresses.hasMoreElements()) { InetAddress address = addresses.nextElement(); if (address.isSiteLocalAddress()) return address.getHostAddress(); } } } catch (Exception e) { log("error reading nics", e); } return null; }
@Override public void subscribe(Consumer<T> consumer, Consumer<? super Throwable> exceptionConsumer) { throw new UnsupportedOperationException("only available for async implementations"); }
@Override public void initialize(Properties overridingProperties) throws XWikiVelocityException { RuntimeInstance runtime = new RuntimeInstance(); runtime.setApplicationAttribute(ComponentManager.class.getName(), this.componentManager); initializeProperties(runtime, this.velocityConfiguration.getProperties(), overridingProperties); runtime.loadDirective(TryCatchDirective.class.getName()); try { runtime.init(); } catch (Exception e) { throw new XWikiVelocityException("Cannot start the Velocity engine", e); } this.runtimeInstance = runtime; this.globalEntry = new TemplateEntry(""); }
public static LifecycleComponentStack buildBookieServer(BookieConfiguration conf) throws Exception { final ComponentInfoPublisher componentInfoPublisher = new ComponentInfoPublisher(); final Supplier<BookieServiceInfo> bookieServiceInfoProvider = () -> buildBookieServiceInfo(componentInfoPublisher); LifecycleComponentStack.Builder serverBuilder = LifecycleComponentStack .newBuilder() .withComponentInfoPublisher(componentInfoPublisher) .withName("bookie-server"); StatsProviderService statsProviderService = new StatsProviderService(conf); StatsLogger rootStatsLogger = statsProviderService.getStatsProvider().getStatsLogger(""); serverBuilder.addComponent(statsProviderService); log.info("Load lifecycle component : {}", StatsProviderService.class.getName()); BookieService bookieService = new BookieService(conf, rootStatsLogger, bookieServiceInfoProvider); serverBuilder.addComponent(bookieService); log.info("Load lifecycle component : {}", BookieService.class.getName()); if (conf.getServerConf().isLocalScrubEnabled()) { serverBuilder.addComponent( new ScrubberService( rootStatsLogger.scope(ScrubberStats.SCOPE), conf, bookieService.getServer().getBookie().getLedgerStorage())); } if (conf.getServerConf().isAutoRecoveryDaemonEnabled()) { AutoRecoveryService autoRecoveryService = new AutoRecoveryService(conf, rootStatsLogger.scope(REPLICATION_SCOPE)); serverBuilder.addComponent(autoRecoveryService); log.info("Load lifecycle component : {}", AutoRecoveryService.class.getName()); } if (conf.getServerConf().isHttpServerEnabled()) { BKHttpServiceProvider provider = new BKHttpServiceProvider.Builder() .setBookieServer(bookieService.getServer()) .setServerConfiguration(conf.getServerConf()) .setStatsProvider(statsProviderService.getStatsProvider()) .build(); HttpService httpService = new HttpService(provider, conf, rootStatsLogger); serverBuilder.addComponent(httpService); log.info("Load lifecycle component : {}", HttpService.class.getName()); } String[] extraComponents = conf.getServerConf().getExtraServerComponents(); if (null != extraComponents) { try { List<ServerLifecycleComponent> components = loadServerComponents( extraComponents, conf, rootStatsLogger); for (ServerLifecycleComponent component : components) { serverBuilder.addComponent(component); log.info("Load lifecycle component : {}", component.getClass().getName()); } } catch (Exception e) { if (conf.getServerConf().getIgnoreExtraServerComponentsStartupFailures()) { log.info("Failed to load extra components '{}' - {}. Continuing without those components.", StringUtils.join(extraComponents), e.getMessage()); } else { throw e; } } } return serverBuilder.build(); }
public Position getCurrentPosition() { return position; }
public static Topic parse(String topic) { List<Level> levels = new ArrayList<>(); Set<String> labels = new HashSet<>(); for (String level : topic.split("/")) { if (level.contains("#") || level.contains("+")) { throw new TopicSyntaxException(format( "Wildcard levels are not allowed in MQTT topics. Found `%s` in `%s`", level, topic)); } else if (level.startsWith("{") && level.endsWith("}")) { String label = level.substring(1, level.length() - 1); if (!LABEL_PATTERN.matcher(label).matches()) { throw new TopicSyntaxException(format( "Invalid topic label name `%s` found in `%s`", label, topic)); } else if (labels.contains(label)) { throw new TopicSyntaxException(format("Duplicate topic label `%s` found in `%s`", label, topic)); } labels.add(label); levels.add(new Level(label, true)); } else if (level.contains("{") || level.contains("}")) { throw new TopicSyntaxException(format( "Topic labels must span an entire level. Found `%s` in `%s`", level, topic)); } else { levels.add(new Level(level, false)); } } return new Topic(topic, levels); }
public static UnivariatePolynomialZ64 ModularGCD(UnivariatePolynomialZ64 a, UnivariatePolynomialZ64 b) { UnivariatePolynomialZ64 trivialGCD = TrivialGCD(a, b); if (trivialGCD != null) return trivialGCD; if (a.degree < b.degree) return ModularGCD(b, a); long aContent = a.content(), bContent = b.content(); long contentGCD = MachineArithmetic.gcd(aContent, bContent); if (a.isConstant() || b.isConstant()) return UnivariatePolynomialZ64.create(contentGCD); return ModularGCD0(a.clone().divideOrNull(aContent), b.clone().divideOrNull(bContent)).multiply(contentGCD); }
public void setAngle(double angle) throws IOException { if (angle < mMinAngle || angle > mMaxAngle) { throw new IllegalArgumentException("angle (" + angle + ") not in range [" + mMinAngle + ", " + mMaxAngle + "]"); } mAngle = angle; updateDutyCycle(); }
public static BitSet of(int... bits) { final BitSet bitSet = new BitSet(); for (int bit : bits) { bitSet.set(bit); } return bitSet; }
@Override public void process() { if (snapshotMode == CassandraConnectorConfig.SnapshotMode.ALWAYS) { snapshot(); } else if (snapshotMode == CassandraConnectorConfig.SnapshotMode.INITIAL && initial) { snapshot(); initial = false; } else { LOGGER.debug("Skipping snapshot [mode: {}]", snapshotMode); } }
@Override public Task performStartOperation(String vmId) throws IOException { String path = String.format("%s/%s/start", getBasePath(), vmId); HttpResponse httpResponse = this.restClient.perform( RestClient.Method.POST, path, null); this.restClient.checkResponse(httpResponse, HttpStatus.SC_CREATED); return parseTaskFromHttpResponse(httpResponse); }
static <T extends Type> String encodeDynamicArray(DynamicArray<T> value) { int size = value.getValue().size(); String encodedLength = encode(new Uint(BigInteger.valueOf(size))); String encodedValues = encodeArrayValues(value); StringBuilder result = new StringBuilder(); result.append(encodedLength); result.append(encodedValues); return result.toString(); }
public List<U> get() { if (this.loaded == null) { if (this.parent.isNew() || UnitTesting.isEnabled()) { this.loaded = new ArrayList<U>(); } else { if (!UoW.isOpen()) { throw new DisconnectedException(); } if (!EagerLoading.isEnabled()) { Select<U> q = Select.from(this.childAlias); q.where(this.childForeignKeyToParentColumn.eq(this.parent)); q.orderBy(this.childAlias.getIdColumn().asc()); q.limit(UoW.getIdentityMap().getCurrentSizeLimit()); this.loaded = q.list(); } else { MapToList<Long, U> byParentId = UoW.getEagerCache().get(this.childForeignKeyToParentColumn); if (!byParentId.containsKey(this.parent.getId())) { Collection<Long> idsToLoad = UoW.getEagerCache().getIdsToLoad(this.parent, this.childForeignKeyToParentColumn); if (!idsToLoad.contains(this.parent.getId())) { throw new IllegalStateException("Instance has been disconnected from the UoW: " + this.parent); } this.eagerlyLoad(byParentId, idsToLoad); } this.loaded = new ArrayList<U>(); this.loaded.addAll(byParentId.get(this.parent.getId())); } } if (this.addedBeforeLoaded.size() > 0 || this.removedBeforeLoaded.size() > 0) { this.loaded.addAll(this.addedBeforeLoaded); this.loaded.removeAll(this.removedBeforeLoaded); this.loaded = Copy.unique(this.loaded); } this.proxy = new ListProxy<U>(this.loaded, this.listDelegate); } return this.proxy; }
@SuppressWarnings("deprecation") @Override public int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws IOException, AccumuloException, AccumuloSecurityException, TableNotFoundException { final String tableName = OptUtil.getTableOpt(cl, shellState); String[] args = cl.getArgs(); boolean setTime; String dir = args.length > 0 ? args[0] : ""; int status = 0; switch (args.length) { case 2: { setTime = Boolean.parseBoolean(cl.getArgs()[1]); shellState.getAccumuloClient().tableOperations().importDirectory(dir).to(tableName) .tableTime(setTime).load(); break; } case 3: { Shell.log.warn( "Deprecated since 2.0.0. New bulk import technique does not take a failure directory " + "as an argument."); String failureDir = args[1]; setTime = Boolean.parseBoolean(cl.getArgs()[2]); shellState.getAccumuloClient().tableOperations().importDirectory(tableName, dir, failureDir, setTime); break; } default: { shellState.printException( new IllegalArgumentException(String.format("Expected 2 or 3 arguments. There %s %d.", args.length == 1 ? "was" : "were", args.length))); printHelp(shellState); status = 1; break; } } return status; }
public static boolean send(String receiverName, String receiverAccount, String subject, String content) { Properties props = System.getProperties(); props.setProperty("mail.transport.protocol", "smtp"); props.setProperty("mail.smtp.host", SENDER_SMTP_HOST); props.setProperty("mail.smtp.auth", "true"); Session session = Session.getDefaultInstance(props); session.setDebug(DEBUG); Transport transport = null; try { MimeMessage message = createMimeMessage(session, receiverName, receiverAccount, subject, content); transport = session.getTransport(); transport.connect(SENDER_ACCOUNT, SENDER_PASSWORD); transport.sendMessage(message, message.getAllRecipients()); } catch (UnsupportedEncodingException | MessagingException e) { logger.error(EMAIL_SEND_ERROR, e); return false; } finally { try { if (transport != null) { transport.close(); } } catch (MessagingException e) { logger.error(EMAIL_SEND_ERROR, e); } } return true; }
public static LeaseRequestResult leaseGranted(long leaseLength) { if (leaseLength <= 0) { throw new IllegalArgumentException("Granting a non-positive length lease is not allowed: " + leaseLength); } return new LeaseRequestResult(true, true, leaseLength); }
public String getValue() { return value; }
@Override public void syncMarkets() { if (splashPreference.isMarketSynced()) { getView().onSyncMarketSuccess(); } else { syncMarket.execute(new SyncMarketResult()); } }
public String getSelectedProtocol(SSLSocket socket) { return platform.getSelectedProtocol(socket); }
@Override public SelectorQuery assembleQueryPlan(SemanticSelector semanticSelector) { return buildQueryPlan(semanticSelector); }
public static Integer modulus(Number dividend, Number divisor) { if (dividend == null || divisor == null) { throw new IllegalArgumentException(); } return dividend.intValue() % divisor.intValue(); }
void validate(T entity) { validator.validate(entity, false); }
public DetectorResult detect(@NonNull MappedMetricData mappedMetricData) { try { MDC.put("DetectorUuid", mappedMetricData.getDetectorUuid().toString()); checkMappedMetricData(mappedMetricData); Optional<DetectorContainer> container = getDetector(mappedMetricData); if (container.isPresent()) { Optional<DetectorResult> optionalDetectorResult = doDetection(container.get(), mappedMetricData.getMetricData()); return optionalDetectorResult.orElse(null); } else { return null; } } finally { MDC.remove("DetectorUuid"); } }
@Override public <T> T getRouteState(VehicleRoute route, StateId stateId, Class<T> type) { if (route == null) return null; T state = null; if(isIndexedBased){ try { state = type.cast(routeStatesArr[route.getVehicle().getIndex()][stateId.getIndex()]); } catch (ClassCastException e) { throw getClassCastException(e,stateId,type.toString(),routeStatesArr[route.getVehicle().getIndex()][stateId.getIndex()].getClass().toString()); } } else { try { if (routeStateMap.containsKey(route)) { state = type.cast(routeStateMap.get(route)[stateId.getIndex()]); } } catch (ClassCastException e) { throw getClassCastException(e, stateId, type.toString(), routeStateMap.get(route)[stateId.getIndex()].getClass().toString()); } } return state; }
public static <T extends JsonValue> JsonValueFieldDefinition<T> newInstance(final CharSequence pointer, final Class<T> valueType, final Function<JsonValue, Boolean> checkJavaTypeFunction, final Function<JsonValue, T> mappingFunction, final JsonFieldMarker ... markers) { requireNonNull(mappingFunction, "The mapping function must not be null!"); return new JsonValueFieldDefinition<>(pointer, valueType, checkJavaTypeFunction, mappingFunction, markers); }
@Override public long transfer( final FileChannel dst, final long position, final long count) throws IOException { if (dst == null) { return 0; } if (isCompleted()) { return 0; } long bytesRead; if (this.buffer.hasData()) { final int maxLen = this.buffer.length(); dst.position(position); bytesRead = this.buffer.read(dst, count < maxLen ? (int)count : maxLen); } else { if (this.channel.isOpen()) { if (position > dst.size()) { throw new IOException("Position past end of file [" + position + " > " + dst.size() + "]"); } bytesRead = dst.transferFrom(this.channel, position, count); if (count > 0 && bytesRead == 0) { bytesRead = this.buffer.fill(this.channel); } } else { bytesRead = -1; } if (bytesRead > 0) { this.metrics.incrementBytesTransferred(bytesRead); } } if (bytesRead == -1) { setCompleted(); } return bytesRead; }
@Override public boolean equals(Object objectToCompare) { if (this == objectToCompare) { return true; } if (!(objectToCompare instanceof DigitalService)) { return false; } DigitalService asset = (DigitalService) objectToCompare; return getTypeVersion() == asset.getTypeVersion() && Objects.equals(getURL(), asset.getURL()) && Objects.equals(getGUID(), asset.getGUID()) && Objects.equals(getTypeId(), asset.getTypeId()) && Objects.equals(getTypeName(), asset.getTypeName()) && Objects.equals(getTypeDescription(), asset.getTypeDescription()) && Objects.equals(getQualifiedName(), asset.getQualifiedName()) && Objects.equals(getDisplayName(), asset.getDisplayName()) && Objects.equals(getDescription(), asset.getDescription()) && Objects.equals(getAdditionalProperties(), asset.getAdditionalProperties()) && Objects.equals(getClassifications(), asset.getClassifications()); }
protected static void checkString(String string, int max) throws WrongLengthOfStringException { checkString(string, 0, max); }
@Override public Collection<ACITuple> filter( AciContext aciContext, OperationScope scope, Entry userEntry ) throws LdapException { if ( aciContext.getAciTuples().isEmpty() ) { return aciContext.getAciTuples(); } for ( Iterator<ACITuple> ii = aciContext.getAciTuples().iterator(); ii.hasNext(); ) { ACITuple tuple = ii.next(); if ( tuple.isGrant() ) { if ( !isRelated( aciContext.getUserGroupNames(), aciContext.getUserDn(), userEntry, aciContext.getEntryDn(), tuple.getUserClasses() ) || aciContext.getAuthenticationLevel().compareTo( tuple.getAuthenticationLevel() ) < 0 ) { ii.remove(); } } else { if ( !isRelated( aciContext.getUserGroupNames(), aciContext.getUserDn(), userEntry, aciContext.getEntryDn(), tuple.getUserClasses() ) && aciContext.getAuthenticationLevel().compareTo( tuple.getAuthenticationLevel() ) >= 0 ) { ii.remove(); } } } return aciContext.getAciTuples(); }
public int solution(int A, int B, int K) { long countOfNumbers = ((long) B) - A + 1; long count = (int) (countOfNumbers / K); if (count < K) { if (A % K == 0) { ++count; } if (A != B && B % K == 0) { ++count; } } return (int) count; }
@Override public CommandResult<CanvasViolation> allow(final AbstractCanvasHandler context) { ControlPointValidations.checkDeleteControlPoint(getViewControlPoints(context, candidate), index); return CanvasCommandResultBuilder.SUCCESS; }
public void connectCustomerToVpnBinding(String globalSubscriberId, String vpnId) { AAIResourceUri customerURI = AAIUriFactory.createResourceUri(AAIObjectType.CUSTOMER, globalSubscriberId); AAIResourceUri vpnBindingURI = AAIUriFactory.createResourceUri(AAIObjectType.VPN_BINDING, vpnId); injectionHelper.getAaiClient().connect(customerURI, vpnBindingURI); }
@Override public boolean equals(Object obj) { if (obj instanceof Tuple) { Tuple other = (Tuple) obj; return Arrays.equals(getValues(), other.getValues()); } return false; }
@Override public boolean equals(Object o) { if (o == null || this.getClass() != o.getClass()) { return false; } Location that = (Location) o; return this.latitude == that.latitude && this.longitude == that.longitude; }
@Override public boolean isValid(File value, ConstraintValidatorContext context) { if (value != null && value.isFile()) { String extension = FilenameUtils.getExtension(value.getName()); return equalsIgnoreCase(expectedExtension, extension) && indexOfExtension(value.getName()) > 0; } return true; }
public DrawContext fillText(String text, double x, double y) throws IOException { if (text == null || text.trim().isEmpty()) { return this; } FontSetting fontSetting = null; if (state.font != null) { fontSetting = state.font; } else { fontSetting = new FontSetting(1d, FontSet.get(FontName.SimSun)); } int readDirection = state.font.getReadDirection(); int charDirection = state.font.getCharDirection(); Font font = fontSetting.getFont(); Double fontSize = state.font.getFontSize(); ST_ID id = resManager.addFont(font); TextObject txtObj = new CT_Text() .setBoundary(this.boundary.clone()) .setFont(id.ref()) .setSize(fontSize) .toObj(new ST_ID(maxUnitID.incrementAndGet())); if (state.font.getFontWeight() != null && state.font.getFontWeight() != 400) { txtObj.setWeight(Weight.getInstance(state.font.getFontWeight())); } if (state.font.isItalic()) { txtObj.setItalic(true); } if (state.fillColor != null) { txtObj.setFillColor(CT_Color.rgb(state.fillColor)); } if (state.ctm != null) { txtObj.setCTM(state.ctm.clone()); } if (state.globalAlpha != null && state.globalAlpha != 1) { txtObj.setAlpha((int) (255 * this.state.globalAlpha)); } if (readDirection != 0) { txtObj.setReadDirection(Direction.getInstance(readDirection)); } if (charDirection != 0) { txtObj.setCharDirection(Direction.getInstance(charDirection)); } MeasureBody measureBody = TextMeasureTool.measureWithWith(text, fontSetting); double xx = x + measureBody.firstCharOffsetX; double yy = y + measureBody.firstCharOffsetY; switch (readDirection) { case 0: case 180: xx += textFloatFactor(state.font.getTextAlign(), measureBody.width, readDirection); break; case 90: case 270: yy += textFloatFactor(state.font.getTextAlign(), measureBody.width, readDirection); break; } TextCode tcSTTxt = new TextCode() .setContent(text) .setX(xx) .setY(yy); if (readDirection == 90 || readDirection == 270) { tcSTTxt.setDeltaY(measureBody.offset); } else { tcSTTxt.setDeltaX(measureBody.offset); } txtObj.addTextCode(tcSTTxt); container.addPageBlock(txtObj); return this; }
@Override public boolean isValid(Block block) { return isValid(block.getHeader()); }
@Override public InputStream stream(InputStream value) { return value; }
@Override public boolean validate(String signedData, String signature) { if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(signature)) { Log.e(TAG, "Purchase verification failed: missing data."); return false; } else if (!verify(signedData, signature)) { Log.w(TAG, "signature does not match data."); return false; } else { return true; } }
@Override public void ensureValid(String config, Object value) { if (value instanceof String) { validate(config, (String) value); } else if (value instanceof List) { List<String> values = (List<String>) value; for (String v : values) { validate(config, v); } } else { throw new ConfigException(config, value, "Must be a string or list."); } }
public static Graph open(final Configuration configuration) { if (null == configuration) throw Graph.Exceptions.argumentCanNotBeNull("configuration"); final String clazz = configuration.getString(Graph.GRAPH, null); if (null == clazz) throw new RuntimeException(String.format("Configuration must contain a valid '%s' setting", Graph.GRAPH)); final Class<?> graphClass; try { graphClass = Class.forName(clazz); } catch (final ClassNotFoundException e) { throw new RuntimeException(String.format("GraphFactory could not find [%s] - Ensure that the jar is in the classpath", clazz)); } final GraphFactoryClass factoryAnnotation = graphClass.getAnnotation(GraphFactoryClass.class); final Class<?> factoryClass = factoryAnnotation != null ? factoryAnnotation.value() : graphClass; return open(configuration, factoryClass); }
public boolean setUpdateTime(double time) { return attribute.setUpdateTime(time); }
public double getPriceInterval () { return priceInterval; }
public static int argmax(double[] x) { if (x == null || x.length == 0) { throw new IllegalArgumentException("Vector x is null or empty"); } int maxIdx = 0; for (int i = 1; i < x.length; i++) { if (x[maxIdx] < x[i]) maxIdx = i; } return maxIdx; }
@Override public int compareTo(final DeliveryBucket bucket) { int compare = supplier.compareTo(bucket.getSupplier()); if (compare == 0) { compare = group.compareTo(bucket.getGroup()); if (compare == 0) { compare = qualifier.compareTo(bucket.getQualifier()); } } return compare; }
@SuppressWarnings("rawtypes") public static <T> Class[] resolveParameterizedClass(Class<T> genericClass, Class<? extends T> descendantClass) throws IllegalArgumentException, IllegalStateException { if (genericClass == null) { throw new IllegalArgumentException("Argument 'genericsClass' (" + Class.class.getName() + ") is null"); } if (descendantClass == null) { throw new IllegalArgumentException("Argument 'descendantClass'(" + Class.class.getName() + ") is null"); } List<ParameterizedType> ancestorTypeList = getAncestorTypeList( genericClass, descendantClass); ParameterizedType parameterizedType = ancestorTypeList.get( ancestorTypeList.size() - 1); Type[] actualTypes = parameterizedType.getActualTypeArguments(); Class[] actualClasses = new Class[actualTypes.length]; for (int i = 0; i < actualTypes.length; i++) { actualClasses[i] = resolveTypeVariable(actualTypes[i], ancestorTypeList); } return actualClasses; }
@Override public void execute() { generator.generate(sourceSdlResource, targetIntrospectionFile); }
@PostConstruct public void init() { view.init(this); }
@Override @Transactional public CmsResponse<Boolean> findAndTerminateOldConsentsByNewConsentId(String encryptedNewConsentId) { Optional<String> decryptIdOptional = securityDataService.decryptId(encryptedNewConsentId); if (decryptIdOptional.isEmpty()) { log.info("Encrypted Consent ID: [{}]. Terminate consent by id failed, couldn't decrypt consent id", encryptedNewConsentId); return CmsResponse.<Boolean>builder() .error(TECHNICAL_ERROR) .build(); } return consentService.findAndTerminateOldConsentsByNewConsentId(decryptIdOptional.get()); }
@Override @Pure public boolean equals(Object obj) { if (obj instanceof ShapeFileIndexRecord) { final ShapeFileIndexRecord r = (ShapeFileIndexRecord) obj; return r.offset == this.offset && r.length == this.length; } return false; }
synchronized <T extends PipelineOptions> T as(Class<T> iface) { checkNotNull(iface); checkArgument(iface.isInterface(), "Not an interface: %s", iface); if (!interfaceToProxyCache.containsKey(iface)) { Registration<T> registration = PipelineOptionsFactory.CACHE.get().validateWellFormed(iface, knownInterfaces); List<PropertyDescriptor> propertyDescriptors = registration.getPropertyDescriptors(); Class<T> proxyClass = registration.getProxyClass(); gettersToPropertyNames.putAll(generateGettersToPropertyNames(propertyDescriptors)); settersToPropertyNames.putAll(generateSettersToPropertyNames(propertyDescriptors)); knownInterfaces.add(iface); interfaceToProxyCache.putInstance( iface, InstanceBuilder.ofType(proxyClass) .fromClass(proxyClass) .withArg(InvocationHandler.class, this) .build()); } return interfaceToProxyCache.getInstance(iface); }
@Override public void filterAbstractHttpRequest(SubmitContext context, AbstractHttpRequest<?> wsdlRequest) { String username = PropertyExpander.expandProperties(context, wsdlRequest.getUsername()); if (username == null || username.length() == 0) { return; } Settings settings = wsdlRequest.getSettings(); String password = PropertyExpander.expandProperties(context, wsdlRequest.getPassword()); String domain = PropertyExpander.expandProperties(context, wsdlRequest.getDomain()); Enum authType = Enum.forString(wsdlRequest.getAuthType()); String wssPasswordType = null; if (wsdlRequest instanceof WsdlRequest) { wssPasswordType = PropertyExpander.expandProperties(context, ((WsdlRequest) wsdlRequest).getWssPasswordType()); } if (StringUtils.isNullOrEmpty(wssPasswordType)) { initRequestCredentials(context, username, settings, password, domain, authType); } }
private List<String> parse(String uri) { String[] values = Strings.split(uri, ','); List<String> uris = new ArrayList<>(values.length); for (String value : values) { String result = value.strip(); if (result.indexOf(':') == -1) { uris.add(result + ":9092"); } else { uris.add(result); } } return uris; }
@Override public void serialize(final TreeMap treeMap, JsonGenerator jgen, SerializerProvider provider) throws IOException { TreeMapNode root = treeMap.getRoot(); process(root, node -> setUserObject(treeMap, node)); jgen.writeStartObject(); int numberOfNodes = TreeMapNodeCounter.countAllNodes(root); jgen.writeObjectField(TOTAL_NUMBER_OF_POINTS, numberOfNodes); boolean tooManyRows = numberOfNodes > ROWS_LIMIT; jgen.writeBooleanField(TOO_MANY_ROWS, tooManyRows); if (tooManyRows) { root = treeMapReducer.limitTreeMap(root); jgen.writeObjectField(ROWS_LIMIT_ITEMS, ROWS_LIMIT); jgen.writeObjectField(NUMBER_OF_POINTS_TO_DISPLAY, TreeMapNodeCounter.countReducedLeaves(root) + LEAVES); } serialize(treeMap, jgen); if (root != null) jgen.writeObjectField(GRAPHICS_LIST, root); if (treeMap.getMode() != null) jgen.writeObjectField(MODE, treeMap.getMode().getJsName()); if (treeMap.getSticky() != null) jgen.writeObjectField(STICKY, treeMap.getSticky()); if (treeMap.getRatio() != null) jgen.writeObjectField(RATIO, treeMap.getRatio()); if (treeMap.getRound() != null) jgen.writeObjectField(ROUND, treeMap.getRound()); jgen.writeObjectField(VALUE_ACCESSOR, treeMap.getValueAccessor()); jgen.writeEndObject(); }
public void reportJSException(String instanceId, String function, String exception) { if (WXEnvironment.isApkDebugable()) { WXLogUtils.e("reportJSException >>>> instanceId:" + instanceId + ", exception function:" + function + ", exception:" + exception); } WXSDKInstance instance; if (instanceId != null && (instance = WXSDKManager.getInstance().getSDKInstance(instanceId)) != null) { instance.onJSException(null, function, exception); String err="function:"+function+"#exception:"+exception; commitJSBridgeAlarmMonitor(instanceId,WXErrorCode.WX_ERR_JS_EXECUTE,err); } }
public void populate(final StockMovementViewModel model, StockCard stockCard) { removeTextChangeListeners(model, stockCard.calculateSOHFromLots()); disableLine(); hideUnderline(); txMovementDate.setText(model.getMovementDate()); etDocumentNo.setText(model.getDocumentNo()); etReceived.setText(model.getReceived()); etNegativeAdjustment.setText(model.getNegativeAdjustment()); etPositiveAdjustment.setText(model.getPositiveAdjustment()); etIssued.setText(model.getIssued()); etRequested.setText(model.getRequested()); txStockExistence.setText(model.getStockExistence()); txSignature.setText(model.getSignature()); if (model.getReason() != null) { txReason.setText(model.getReason().getDescription()); } else { txReason.setText(StringUtils.EMPTY); } setItemViewTextColor(model); if (model.isDraft()) { setInitialDraftStyle(model); } else { itemView.setBackgroundColor(Color.TRANSPARENT); } addClickListeners(model, getPreviousMovementDate(stockCard)); addTextChangedListeners(model, stockCard.calculateSOHFromLots()); }
public void afterPropertiesSet() throws Exception { this.connectSupport = new ConnectSupport(sessionStrategy); this.connectSupport.setUseAuthenticateUrl(true); if (this.applicationUrl != null) { this.connectSupport.setApplicationUrl(applicationUrl); } }
public void increase(int step) { value += step; }
public static boolean isReservedParameter(Class<?> type) { return type == UIContext.class || type == UIPrompt.class || type == UIOutput.class || type == UIProgressMonitor.class || type == UIProvider.class || type == UIExecutionContext.class || type == UIDesktop.class; }
@Override public ByteArrayOutputStream compress(final InputStream inputStream) { InputStream source = inputStream; ByteArrayOutputStream baos = outputStreamFactory.createByteArrayOutputStream(); try { GZIPOutputStream gout = gzipOutputStreamFactory.createOutputStream(baos); IOUtils.copy(source, gout); gout.finish(); gout.close(); } catch (IOException e) { throw new SystemException("Could not gzip message body!", e); } return baos; }
public static Ticker adaptTicker(BithumbTicker bithumbTicker, CurrencyPair currencyPair) { return new Ticker.Builder() .currencyPair(currencyPair) .ask(bithumbTicker.getSellPrice()) .bid(bithumbTicker.getBuyPrice()) .high(bithumbTicker.getMaxPrice()) .low(bithumbTicker.getMinPrice()) .last(bithumbTicker.getClosingPrice()) .open(bithumbTicker.getOpeningPrice()) .vwap(bithumbTicker.getAveragePrice()) .volume(bithumbTicker.getUnitsTraded()) .timestamp(new Date(bithumbTicker.getDate())) .build(); }
@NonNull public MenuItem getCurrentMenuItem() { return navigationView.getMenu().getItem(getCurrentNavigationMenu().ordinal()); }
@Override public String getLatestVersion() { try { if (jsonSource instanceof URL) { return JSON.std.mapFrom(urlToStream((URL) jsonSource)).getOrDefault(CURRENT_VERSION_KEY, "").toString(); } return JSON.std.mapFrom(jsonSource).getOrDefault(CURRENT_VERSION_KEY, "").toString(); } catch (IOException e) { LOG.warn(DefaultI18nContext.getInstance().i18n("Unable to find the latest available version."), e); } return EMPTY; }
@Override public <T> T get(String path, Class<T> wantedReturnType, Params paramsOrNull) { Optional<RequestConfig> requestConfig = getRequestConfigOverride(paramsOrNull); return tryAllConfigServers(configServer -> { HttpGet get = new HttpGet(configServer.resolve(path)); requestConfig.ifPresent(get::setConfig); return get; }, wantedReturnType); }
@Override public boolean isEmpty() { return store.isEmpty(); }
public Dispatcher dispatcherFor(final InjectionPoint injectionPoint) { return createDispatcherIfAbsent(new DispatcherKey( componentNameExtractor.componentFrom(injectionPoint), componentLocationFrom(injectionPoint))); }
void flatten(OpenAPI openapi) { this.openapi = openapi; if (openapi.getComponents() == null) { openapi.setComponents(new Components()); } if (openapi.getComponents().getSchemas() == null) { openapi.getComponents().setSchemas(new HashMap<String, Schema>()); } flattenPaths(openapi); flattenComponents(openapi); }
public static OdePosition3D odePosition3D(DsrcPosition3D dsrcPos) { return odePosition3D(dsrcPos.getLatitude(), dsrcPos.getLongitude(), dsrcPos.getElevation()); }
@JsonProperty("routerId") public void setRouterId(Ip4Address routerId) { this.routerId = routerId; }
public static <T> T checkNotNull(T reference, @Nullable Object message) { checkArgument(reference != null, message); return reference; }
@Override public void process(final String record) { assert !isClosed(); buffer = StringUtil.copyToBuffer(record, buffer); recordLen = record.length(); if (isRecordEmpty()) { return; } String id = extractRecordId(); if (id == null) { if (!ignoreMissingIdn) { throw new MissingIdException("Record has no id"); } id = ""; } getReceiver().startRecord(id); PicaParserState state = PicaParserState.FIELD_NAME; for (int i = 0; i < recordLen; ++i) { state = state.parseChar(buffer[i], parserContext, isNormalized); } state.endOfInput(parserContext); getReceiver().endRecord(); }
@Override public void onConstruct(EnhancedInstance objInst, Object[] allArguments) { final GaugeImpl toolkitGauge = (GaugeImpl) objInst; final ToolkitGaugeAdapter gaugeAdapter = new ToolkitGaugeAdapter(toolkitGauge); final GaugeTransformer gaugeTransformer = new GaugeTransformer(gaugeAdapter); if (METER_SERVICE == null) { METER_SERVICE = ServiceManager.INSTANCE.findService(MeterService.class); } METER_SERVICE.register(gaugeTransformer); }
boolean match(SamplingRequest req) { Map<String, String> requestAttributes = req.getAttributes(); for (Map.Entry<String, String> a : attributes.entrySet()) { if (!requestAttributes.containsKey(a.getKey())) { return false; } if (!SearchPattern.wildcardMatch(a.getValue(), requestAttributes.get(a.getKey()))) { return false; } } return SearchPattern.wildcardMatch(url, req.getUrl().orElse("")) && SearchPattern.wildcardMatch(service, req.getService().orElse("")) && SearchPattern.wildcardMatch(method, req.getMethod().orElse("")) && SearchPattern.wildcardMatch(host, req.getHost().orElse("")) && SearchPattern.wildcardMatch(serviceType, req.getServiceType().orElse("")); }
public void apply(String idProcess, ParameterTransformation parameterTransformation, ObjectNode jsonValue) { String valueToFormat = at(parameterTransformation.getKeyField(), jsonValue).asText(); if (StringUtils.isNotBlank(valueToFormat)) { put(jsonValue, parameterTransformation.getKeyField() + "_double", Double.valueOf(valueToFormat)); remove(jsonValue,parameterTransformation.getKeyField()); } }
boolean matchDelegatedTrustAssertion(Assertion assertion, String roleName, String roleMember, List<Role> roles) { if (!ZMSUtils.assumeRoleResourceMatch(roleName, assertion)) { return false; } String rolePattern = StringUtils.patternFromGlob(assertion.getRole()); for (Role role : roles) { String name = role.getName(); if (!name.matches(rolePattern)) { continue; } if (isMemberOfRole(role, roleMember)) { return true; } } return false; }
@Override public void updateTable(String dbName, TableInput tableInput) { super.updateTable(dbName, tableInput); if(tableCacheEnabled) { purgeTableFromCache(dbName, tableInput.getName()); } }
@Override public void serialize(MatchEntry entry, ByteBuf outBuffer) { super.serialize(entry, outBuffer); MplsLabelCase entryValue = (MplsLabelCase) entry.getMatchEntryValue(); outBuffer.writeInt(entryValue.getMplsLabel().getMplsLabel().intValue()); }
public static int[] boundsForPow(IntVar x, IntVar y) { return bound(0, 1, MathUtils.pow(x.getLB(), y.getUB()), MathUtils.pow(x.getUB(), y.getUB()), MathUtils.pow(x.getLB() + 1, y.getUB()), MathUtils.pow(x.getUB() - 1, y.getUB()), MathUtils.pow(x.getLB(), Math.max(0, y.getUB() - 1)), MathUtils.pow(x.getUB(), Math.max(0, y.getUB() - 1)), MathUtils.pow(x.getLB() + 1, Math.max(0, y.getUB() - 1)), MathUtils.pow(x.getUB() - 1, Math.max(0, y.getUB() - 1)) ); }
public String interpret(String input) { switch (this.interpreter) { case STRING: return getFormattedString(input); case STATIC: return this.format; default: return getFormattedTime(input); } }
@Override public boolean equals(Object o) { if (this == o) return true; else if (!(o instanceof NullableExpression)) return false; final NullableExpression<?, ?> that = (NullableExpression<?, ?>) o; return Objects.equals(original, that.inner()) && Objects.equals(isNull, that.isNullPredicate()); }
@SuppressWarnings( { "unchecked", "rawtypes" } ) public static ObjectMapper createObjectMapper() { ObjectMapper mapper = new ObjectMapper(); mapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false ); SimpleModule module = new SimpleModule( "RoboconfModule", new Version( 1, 0, 0, null, null, null )); for( Map.Entry<Class<?>,? super JsonSerializer<?>> entry : SERIALIZERS.entrySet()) module.addSerializer((Class) entry.getKey(), (JsonSerializer) entry.getValue()); for( Map.Entry<Class<?>,? super JsonDeserializer<?>> entry : DESERIALIZERS.entrySet()) module.addDeserializer((Class) entry.getKey(), (JsonDeserializer) entry.getValue()); mapper.registerModule( module ); return mapper; }
@Override public void addObserver(@NonNull LifecycleObserver observer) { State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) { return; } LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) { return; } boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); mAddingObserverCounter++; while ((statefulObserver.mState.compareTo(targetState) < 0 && mObserverMap.contains(observer))) { pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); targetState = calculateTargetState(observer); } if (!isReentrance) { sync(); } mAddingObserverCounter--; }
public static Supplier<MutableTuple0> constructor() { return () -> MutableTuple0Impl.EMPTY_TUPLE; }
@PublicAPI(usage = ACCESS) public Set<Dependency> getDirectDependenciesToSelf() { return javaClassDependencies.getDirectDependenciesToClass(); }
private static void inlineIncludes(NodeList signatureNodes, Collection<Attachment> attachments) throws IOException { for (int i = 0; i < signatureNodes.getLength(); ++i) { Element sigElement = (Element) signatureNodes.item(i); Object child = sigElement.getFirstChild(); if (child instanceof Element && isIncludeElement((Element) child)) { String refId = ((Element) child).getAttribute(HREF_ATTRIBUTE).replaceFirst(CONTENT_ID_PREFIX, ""); Optional<Attachment> attachment = getAttachment(attachments, refId); if (attachment.isPresent()) { String attachmentValue = convertToBase64Data(attachment.get().getDataHandler()); sigElement.setTextContent(attachmentValue); } else { LOG.warn( "Failed to inline signature/digest element to the header. Cannot find reference id: {}", refId); } } } }
public ResultSentence disambiguate(String sentence) { List<WordAnalysis> ambiguous = analyzer.analyzeSentence(sentence); ResultSentence s = new ResultSentence(sentence, ambiguous); s.makeDecisions(rules); return s; }
public URI getMetadataFileUri(Process process) { URI workPathUri = ServiceManager.getFileService().getProcessBaseUriForExistingProcess(process); String workDirectoryPath = workPathUri.getPath(); try { return new URI(workPathUri.getScheme(), workPathUri.getUserInfo(), workPathUri.getHost(), workPathUri.getPort(), workDirectoryPath.endsWith("/") ? workDirectoryPath.concat(METADATA_FILE_NAME) : workDirectoryPath + '/' + METADATA_FILE_NAME, workPathUri.getQuery(), null); } catch (URISyntaxException e) { throw new IllegalArgumentException(e.getMessage(), e); } }
public static Object getProperty(JmsMessage message, String name) throws JMSException { Object value = null; checkPropertyNameIsValid(name, message.isValidatePropertyNames()); PropertyIntercepter jmsPropertyExpression = PROPERTY_INTERCEPTERS.get(name); if (jmsPropertyExpression != null) { value = jmsPropertyExpression.getProperty(message); } else { value = message.getFacade().getProperty(name); } return value; }
@Override public FluentWebElement contextClick() { mouse().contextClick(); return this; }
@Override public <T> T read(Class<T> clazz, Object value) { if (LocalTime.class.isInstance(value)) { return (T) value; } if (Calendar.class.isInstance(value)) { return (T) ((Calendar) value).toInstant().atZone(ZoneId.systemDefault()).toLocalTime(); } if (Date.class.isInstance(value)) { return (T) ((Date) value).toInstant().atZone(ZoneId.systemDefault()).toLocalTime(); } if (Number.class.isInstance(value)) { return (T) new Date(((Number) value).longValue()).toInstant().atZone(ZoneId.systemDefault()).toLocalTime(); } return (T) LocalTime.parse(value.toString()); }
@Override public void handle(CloudRuntimeEvent<?, ?> event) { CloudProcessStartedEvent startedEvent = (CloudProcessStartedEvent) event; String processInstanceId = startedEvent.getEntity().getId(); LOGGER.debug("Handling start of process Instance " + processInstanceId); Optional<ProcessInstanceEntity> findResult = processInstanceRepository.findById(processInstanceId); ProcessInstanceEntity processInstanceEntity = findResult.orElseThrow( () -> new QueryException("Unable to find process instance with the given id: " + processInstanceId)); if (ProcessInstance.ProcessInstanceStatus.CREATED.equals(processInstanceEntity.getStatus())) { processInstanceEntity.setStatus(ProcessInstance.ProcessInstanceStatus.RUNNING); processInstanceEntity.setName(startedEvent.getEntity().getName()); processInstanceEntity.setLastModified(new Date(startedEvent.getTimestamp())); processInstanceRepository.save(processInstanceEntity); } }
public static int decodeLength(ByteBuffer buf) { if (buf == null || buf.remaining() == 0) { throw new IllegalArgumentException("Null or empty buffer"); } int len = 0; byte first = buf.get(); if (first >> 7 == 0) { len = first & 0x7f; } else { int numOctets = first & 0x7f; if (buf.remaining() < numOctets) { throw new IllegalArgumentException("Insufficient data to decode long-form DER length"); } for (int i = 0; i < numOctets; i++) { len = (len << 8) + (0xff & buf.get()); } } return len; }
public AudioMapType guessAudioMap() throws InvalidAudioChannelAssignmentException { if (contextProvider.getSequenceContext().getSequenceCount(SequenceType.AUDIO) == 0) { return null; } logger.debug("Trying to generate an audiomap.xml based on the EssenceDescriptor..."); prepareContext(); AudioMapType audioMap = createAudioMap(); logger.info("Generated an audiomap.xml based on the EssenceDescriptor: OK"); return audioMap; }
@Override public void applySecret(KubernetesEnvironment env, RuntimeIdentity runtimeIdentity, Secret secret) throws InfrastructureException { boolean secretAutomount = Boolean.parseBoolean(secret.getMetadata().getAnnotations().get(ANNOTATION_AUTOMOUNT)); for (PodData podData : env.getPodsData().values()) { if (!podData.getRole().equals(PodRole.DEPLOYMENT)) { continue; } for (Container container : podData.getSpec().getContainers()) { Optional<ComponentImpl> component = getComponent(env, container.getName()); if (component.isPresent() && isComponentAutomountFalse(component.get())) { continue; } if (!secretAutomount && (!component.isPresent() || !isComponentAutomountTrue(component.get()))) { continue; } for (Entry<String, String> secretDataEntry : secret.getData().entrySet()) { final String mountEnvName = envName(secret, secretDataEntry.getKey(), runtimeIdentity); container .getEnv() .add( new EnvVarBuilder() .withName(mountEnvName) .withValueFrom( new EnvVarSourceBuilder() .withSecretKeyRef( new SecretKeySelectorBuilder() .withName(secret.getMetadata().getName()) .withKey(secretDataEntry.getKey()) .build()) .build()) .build()); } } } }
@Override public final int nextChar() { ensureBuffer(); return ch = readBuf[index++]; }
public String getId() { return id; }
public DppType getDpp() { return dpp; }
@Override public LoginContext createLoginContext(TypedCallbackHandlerMap additionalCallbacks) throws LoginException { try { final DefaultLoginResult loginResult = new DefaultLoginResult(); DispatchCallbackHandler handler = createDefaultCallbackHandler(loginResult, additionalCallbacks); defineAuthenticationTokenScheme(additionalCallbacks); return createLoginContext(handler, loginResult); } catch (Exception e) { final String msg = String.format("%s", ERROR_MSG); if (logEnabled()) { LOG.trace(msg, e); } throw (LoginException) new LoginException(msg).initCause(e); } }
public static Number findMinimumRangeValue(CategoryDataset dataset) { ParamChecks.nullNotPermitted(dataset, "dataset"); if (dataset instanceof RangeInfo) { RangeInfo info = (RangeInfo) dataset; return new Double(info.getRangeLowerBound(true)); } else { double minimum = Double.POSITIVE_INFINITY; int seriesCount = dataset.getRowCount(); int itemCount = dataset.getColumnCount(); for (int series = 0; series < seriesCount; series++) { for (int item = 0; item < itemCount; item++) { Number value; if (dataset instanceof IntervalCategoryDataset) { IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset; value = icd.getStartValue(series, item); } else { value = dataset.getValue(series, item); } if (value != null) { minimum = Math.min(minimum, value.doubleValue()); } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return minimum; } } }
public Response options(Request request) { String origin = request.header("Origin").orElseThrow(() -> new ForbiddenException("access denied")); checkOrigin(origin); return Response.empty().status(HTTPStatus.OK) .header("Access-Control-Allow-Origin", origin) .header("Access-Control-Allow-Methods", "POST, PUT, OPTIONS") .header("Access-Control-Allow-Headers", "Accept, Content-Type") .header("Access-Control-Allow-Credentials", "true"); }
public static void main(String[] args) { try (Scanner in = new Scanner(System.in)) { String text = in.nextLine(); int minLength = (int) Math.floor(Math.sqrt(text.length())); int rows = minLength; int columns = minLength; if (!(rows * columns >= text.length())) { ++columns; } if (!(rows * columns >= text.length())) { ++rows; } char[][] array = new char[rows][columns]; for (int i = 0; i < rows; ++i) { for (int j = 0; j < columns; ++j) { if (columns * i + j < text.length()) { array[i][j] = text.charAt(columns * i + j); } else { array[i][j] = '\0'; } } } StringBuilder encrypted = new StringBuilder(); for (int j = 0; j < columns; ++j) { for (int i = 0; i < rows; ++i) { if (array[i][j] != '\0') { encrypted.append(array[i][j]); } } if (j < columns - 1) { encrypted.append(' '); } } System.out.println(encrypted.toString()); } }
@Override public boolean equals(@Nullable Object obj) { if (this == obj) { return true; } if (!(obj instanceof Endpoint)) { return false; } final Endpoint that = (Endpoint) obj; return host().equals(that.host()) && Objects.equals(ipAddr, that.ipAddr) && port == that.port; }
Set<NodeEndpoint> listEndpointOfMajorExceptSelf() { Set<NodeEndpoint> endpoints = new HashSet<>(); for (GroupMember member : memberMap.values()) { if (member.isMajor() && !member.idEquals(selfId)) { endpoints.add(member.getEndpoint()); } } return endpoints; }
public ImmutableList<Replacement> format( SnippetKind kind, String source, List<Range<Integer>> ranges, int initialIndent, boolean includeComments) throws FormatterException { RangeSet<Integer> rangeSet = TreeRangeSet.create(); for (Range<Integer> range : ranges) { rangeSet.add(range); } if (includeComments) { if (kind != SnippetKind.COMPILATION_UNIT) { throw new IllegalArgumentException( "comment formatting is only supported for compilation units"); } return formatter.getFormatReplacements(source, ranges); } SnippetWrapper wrapper = snippetWrapper(kind, source, initialIndent); ranges = offsetRanges(ranges, wrapper.offset); String replacement = formatter.formatSource(wrapper.contents.toString(), ranges); replacement = replacement.substring( wrapper.offset, replacement.length() - (wrapper.contents.length() - wrapper.offset - source.length())); return toReplacements(source, replacement).stream() .filter(r -> rangeSet.encloses(r.getReplaceRange())) .collect(toImmutableList()); }
public static String getZooKeeperClusterKey(Configuration conf) { return getZooKeeperClusterKey(conf, null); }
public ListOp setDataStore(DataStore dataStore) { this.dataStore = dataStore; return this; }
public synchronized SecurityFilterChain buildSecurityChain(MotechURLSecurityRule securityRule, HTTPMethod method) { LOGGER.info("Building security chain for rule: {} and method: {}", securityRule.getPattern(), method); List<Filter> filters = new ArrayList<>(); RequestMatcher matcher; validateRule(securityRule); String pattern = securityRule.getPattern(); if (pattern.equals(SecurityConfigConstants.ANY_PATTERN) || "/**".equals(pattern) || "**".equals(pattern)) { matcher = AnyRequestMatcher.INSTANCE; } else if (ANY == method) { matcher = new AntPathRequestMatcher(pattern); } else { matcher = new AntPathRequestMatcher(pattern, method.name()); } if (!noSecurity(securityRule)) { try { filters = addFilters(securityRule); } catch (ServletException e) { LOGGER.error("Cannot create {} in {} security rule.", SecurityContextHolderAwareRequestFilter.class, securityRule.getPattern(), e); } } LOGGER.info("Built security chain for rule: {} and method: {}", securityRule.getPattern(), method); return new MotechSecurityFilterChain(securityRule, matcher, filters); }
@Override public PageModelDto addPageModel(PageModelRequest pageModelRequest) { try { BeanPropertyBindingResult validationResult = this.validateAdd(pageModelRequest); if (validationResult.hasErrors()) { throw new ValidationGenericException(validationResult); } PageModel pageModel = this.createPageModel(pageModelRequest); this.pageModelManager.addPageModel(pageModel); return this.dtoBuilder.convert(pageModel); } catch (ValidationGenericException | ValidationConflictException e) { throw e; } catch (Exception e) { logger.error("Error in add pageModel", e); throw new RestServerError("error in add pageModel", e); } }
public static String retrieveInputSource(Parameters parameters) throws FHIROperationException { if (parameters != null) { for (Parameters.Parameter parameter : parameters.getParameter()) { if (BulkDataConstants.PARAM_INPUT_SOURCE.equals(parameter.getName().getValue()) && parameter.getValue() != null && parameter.getValue().is(com.ibm.fhir.model.type.Uri.class)) { return parameter.getValue().as(com.ibm.fhir.model.type.Uri.class).getValue(); } } } throw buildExceptionWithIssue("$import requires 'inputSource' is not found", IssueType.INVALID); }
@Override @NotNull public PackageNodeModel.SelectedState getCurrentState() { return getState(UpdaterTreeNode::getCurrentState); }
public static boolean isEmpty(final String value) { if (value == null) { return true; } return (value.trim().isEmpty()); }
public boolean isValidFormat( final Transaction transaction, final AcceptedTransactionTypes acceptedTransactionTypes) { if (transaction == null) { return false; } switch (acceptedTransactionTypes) { case FRONTIER_TRANSACTIONS: return transaction.isFrontierTransaction(); case FEE_MARKET_TRANSITIONAL_TRANSACTIONS: return transaction.isFrontierTransaction() || transaction.isEIP1559Transaction(); case FEE_MARKET_TRANSACTIONS: return transaction.isEIP1559Transaction(); default: return false; } }
String readKeyFromFile(URL url, int majorVersion) throws IOException { String majorVersionStr = String.valueOf(majorVersion); List<String> lines = IOUtils.readLines(url.openStream()); String defaultKey = null; for (String line : lines) { String[] parts = line.split("\\s*=\\s*"); if (parts.length < 2) { defaultKey = parts[0].trim(); } if (parts[0].equals(majorVersionStr)) { return parts[1].trim(); } } return defaultKey; }
public static String toXml(XmlMessageHeader xmlMessage) { try { return XmlObjectMapper.defaultMapper().toXml(xmlMessage); } catch (JsonProcessingException e) { logger.error("message to xml failed", e); throw new WxRuntimeException(999, "message to xml failed," + e.getMessage()); } }
public Map<String, Object> build(ScanReportResult scanResult) { String trafficLight = scanResult.getTrafficLight(); String styleRed = HIDE_LIGHT; String styleYellow = HIDE_LIGHT; String styleGreen = HIDE_LIGHT; switch (trafficLight) { case "RED": styleRed = SHOW_LIGHT; break; case "YELLOW": styleYellow = SHOW_LIGHT; break; case "GREEN": styleGreen = SHOW_LIGHT; break; default: } HtmlCodeScanDescriptionSupport codeScanSupport = new HtmlCodeScanDescriptionSupport(); SecHubResult result = scanResult.getResult(); Map<Integer,List<HTMLScanResultCodeScanEntry>> codeScanEntries = new HashMap<>(); for (SecHubFinding finding: result.getFindings()) { codeScanEntries.put(finding.id, codeScanSupport.buildEntries(finding)); } Map<String, Object> model = new HashMap<>(); model.put("result", scanResult.getResult()); model.put("redList", trafficLightCalculator.filterFindingsFor(result, TrafficLight.RED)); model.put("yellowList", trafficLightCalculator.filterFindingsFor(result, TrafficLight.YELLOW)); model.put("greenList", trafficLightCalculator.filterFindingsFor(result, TrafficLight.GREEN)); model.put("trafficlight", trafficLight); model.put("styleRed", styleRed); model.put("styleYellow", styleYellow); model.put("styleGreen", styleGreen); model.put("isWebDesignMode", webDesignMode); model.put("embeddedCSS", getEmbeddedCSS()); model.put("codeScanEntries", codeScanEntries); model.put("codeScanSupport", codeScanSupport); if (webDesignMode) { File file; try { if (cssResource==null) { LOG.error("CSS resource not set:{}",cssResource); }else { file = cssResource.getFile(); String absolutePathToCSSFile = file.getAbsolutePath(); LOG.info("Web design mode activate, using not embedded css but ref to:{}",absolutePathToCSSFile); model.put("includedCSSRef", absolutePathToCSSFile); } } catch (Exception e) { LOG.error("Was not able get file from resource:{}",cssResource,e); } } UUID jobUUID = scanResult.getJobUUID(); if (jobUUID!=null) { model.put("jobuuid", jobUUID.toString()); }else { model.put("jobuuid", "none"); } model.put("info", scanResult.getInfo()); return model; }
@Override public RoleToken getRoleToken(ResourceContext ctx, String domainName, String roleNames, Integer minExpiryTime, Integer maxExpiryTime, String proxyForPrincipal) { final String caller = "getroletoken"; final String callerTiming = "getroletoken_timing"; metric.increment(HTTP_GET); final String principalDomain = logPrincipalAndGetDomain(ctx); validateRequest(ctx.request(), principalDomain, caller); validate(domainName, TYPE_DOMAIN_NAME, principalDomain, caller); if (roleNames != null && !roleNames.isEmpty()) { validate(roleNames, TYPE_ENTITY_LIST, principalDomain, caller); } if (proxyForPrincipal != null && !proxyForPrincipal.isEmpty()) { validate(proxyForPrincipal, TYPE_ENTITY_NAME, principalDomain, caller); } domainName = domainName.toLowerCase(); if (roleNames != null) { roleNames = roleNames.toLowerCase(); } if (proxyForPrincipal != null) { proxyForPrincipal = normalizeDomainAliasUser(proxyForPrincipal.toLowerCase()); } Object timerMetric = metric.startTiming(callerTiming, domainName, principalDomain); final Principal principal = ((RsrcCtxWrapper) ctx).principal(); String principalName = principal.getFullName(); if (LOGGER.isDebugEnabled()) { LOGGER.debug("getRoleToken(domain: {}, principal: {}, role-name: {}, proxy-for: {})", domainName, principalName, roleNames, proxyForPrincipal); } roleNames = convertEmptyStringToNull(roleNames); proxyForPrincipal = convertEmptyStringToNull(proxyForPrincipal); if (leastPrivilegePrincipal && roleNames == null) { throw requestError("getRoleToken: Client must specify a roleName to request a token for", caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); } if (proxyForPrincipal != null && !isAuthorizedProxyUser(authorizedProxyUsers, principalName)) { LOGGER.error("getRoleToken: Principal {} not authorized for proxy role token request", principalName); throw forbiddenError("getRoleToken: Principal: " + principalName + " not authorized for proxy role token request", caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); } DataCache data = dataStore.getDataCache(domainName); if (data == null) { metric.increment(HTTP_REQUEST, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); metric.increment(caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); throw notFoundError("getRoleToken: No such domain: " + domainName, caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); } metric.increment(HTTP_REQUEST, domainName, principalDomain); metric.increment(caller, domainName, principalDomain); checkRoleTokenAuthorizedServiceRequest(principal, domainName, caller); String[] requestedRoleList = null; if (roleNames != null) { requestedRoleList = roleNames.split(","); } Set<String> roles = new HashSet<>(); dataStore.getAccessibleRoles(data, domainName, principalName, requestedRoleList, roles, false); if (roles.isEmpty()) { throw forbiddenError("getRoleToken: No access to any roles in domain: " + domainName, caller, domainName, principalDomain); } String proxyUser = null; if (proxyForPrincipal != null) { Set<String> rolesForProxy = new HashSet<>(); dataStore.getAccessibleRoles(data, domainName, proxyForPrincipal, requestedRoleList, rolesForProxy, false); roles.retainAll(rolesForProxy); if (roles.isEmpty()) { throw forbiddenError("getRoleToken: No access to any roles by User and Proxy Principals", caller, domainName, principalDomain); } proxyUser = principalName; principalName = proxyForPrincipal; } if (!isPrincipalRoleCertificateAccessValid(principal, domainName, roles)) { throw forbiddenError("getRoleToken: Role based Principal does not include all roles", caller, domainName, principalDomain); } long tokenTimeout = determineTokenTimeout(data, roles, minExpiryTime, maxExpiryTime); List<String> roleList = new ArrayList<>(roles); boolean domainCompleteRoleSet = (includeRoleCompleteFlag && roleNames == null); com.yahoo.athenz.auth.token.RoleToken token = new com.yahoo.athenz.auth.token.RoleToken.Builder(ZTS_ROLE_TOKEN_VERSION, domainName, roleList) .expirationWindow(tokenTimeout).host(serverHostName).keyId(privateKey.getId()) .principal(principalName).ip(ServletRequestUtil.getRemoteAddress(ctx.request())) .proxyUser(proxyUser).domainCompleteRoleSet(domainCompleteRoleSet).build(); token.sign(privateKey.getKey()); RoleToken roleToken = new RoleToken(); roleToken.setToken(token.getSignedToken()); roleToken.setExpiryTime(token.getExpiryTime()); metric.stopTiming(timerMetric, domainName, principalDomain); return roleToken; }
public BashScriptModel build(String bashScript) throws BashScriptModelException { BashScriptModel model = new BashScriptModel(); TokenParser parser = new TokenParser(); List<ParseToken> tokens; try { tokens = parser.parse(bashScript); } catch (TokenParserException e) { throw new BashScriptModelException("Was not able to build bashscript", e); } buildScriptVariablesByTokens(model,false,true, tokens); buildFunctionsByTokens(model, tokens); List<ValidationResult> results = new ArrayList<>(); for (BashScriptValidator<List<ParseToken>> validator : createParseTokenValidators()) { results.addAll(validator.validate(tokens)); } for (ValidationResult result : results) { if (result instanceof BashError) { model.errors.add((BashError) result); } } if (debugMode) { appendDebugTokens(model, tokens); } return model; }
public static String getHostAddress() { if (hostAddress == null) { doGetHostNameAndHostAddress(); } return hostAddress; }
@SuppressWarnings( "rawtypes" ) public PathRepresentation findSinglePath( long startId, long endId, Map<String,Object> map ) { FindParams findParams = new FindParams( startId, endId, map ).invoke(); PathFinder finder = findParams.getFinder(); Node startNode = findParams.getStartNode(); Node endNode = findParams.getEndNode(); Path path = finder.findSinglePath( startNode, endNode ); if ( path == null ) { throw new NotFoundException(); } return findParams.pathRepresentationOf( path ); }
@Override public long getSerialIndex() { return this.serialDate.toSerial(); }
public static boolean isArchive(String path) { File f = new File(path); int fileSignature = 0; RandomAccessFile raf = null; try { raf = new RandomAccessFile(f, "r"); fileSignature = raf.readInt(); } catch (IOException e) { } finally { IOUtils.closeQuietly(raf); } return fileSignature == 0x504B0304 || fileSignature == 0x504B0506 || fileSignature == 0x504B0708 || fileSignature == 0x74657374 || fileSignature == 0x75737461 || (fileSignature & 0xFFFF0000) == 0x1F8B0000; }
@Override public Map<String, String[]> unmarshal(ClientReportParametersMapWrapper v) throws Exception { Map<String, String[]> result = null; if (v != null) { final HashMap<String, String[]> parameterValues = v.getParameterValues(); if (parameterValues != null && !parameterValues.isEmpty()) { result = new HashMap<String, String[]>(); for (String currentKey : parameterValues.keySet()) { String[] currentValue = parameterValues.get(currentKey); result.put(currentKey, currentValue); } } } return result; }
static void generatePassword(String[] argv) throws Exception { if (argv == null || argv.length < 2) { System.out.println("Usage :"); System.err.println(" java " + Password.class.getCanonicalName() + " <style> <password>"); System.err.println(" where style is one of (trailing colon is required):"); for (String s : STYLES) { System.err.println(" " + s); } return; } PasswordCodec ph = create(argv[0]); String plainText = argv[1]; System.err.println("Cut and paste the following value where passwords are supported"); System.err.println("(should be a single line, with no spaces)"); System.err.println(ph.encode(plainText)); }
@Override public int compareTo(final Object o) { if (o == null || getClass() != o.getClass()) { return 1; } final DecisionNavigatorItem that = (DecisionNavigatorItem) o; if (this.equals(that)) { return 0; } else { return getOrderingName().compareTo(that.getOrderingName()); } }
@Override public int undoTaskAssignment(List<DocumentDTO> taskList, Long userID) { if (taskList != null && !taskList.isEmpty()) { try { int deleteCount = 0; for (Iterator<DocumentDTO> it = taskList.iterator(); it.hasNext();){ DocumentDTO tb = (DocumentDTO) it.next(); TaskAssignment taskAssignment = (TaskAssignment) getTaskAssignment(tb.getDocumentID(), userID); delete(taskAssignment); em.flush(); ++deleteCount; } return deleteCount; } catch (Exception e) { logger.error("Error in undo operation!"); } } return 0; }
@Override public void apply( TransactionToApply first, TransactionToApply last ) throws Exception { if ( batchSizeExceedsSafeZone( first, last ) ) { kernelTransactions.blockNewTransactions(); try { markUnsafeTransactionsForTermination( first, last ); commit( first ); } finally { kernelTransactions.unblockNewTransactions(); } } else { markUnsafeTransactionsForTermination( first, last ); commit( first ); } }
public StartEventBuilder startEvent() { return startEvent(null); }
@Override public OperationType operationType() { return operationType; }
@Override public List<ATCKlassifikaator> findATCKlassifikaatoridDetailandmed(List<String> items) throws XRoadServiceConsumptionException { ATCKlassifikaatoridByIDArray request = ATCKlassifikaatoridByIDArray.Factory.newInstance(); request.setKeha(createDetailsRequest(items)); return ravimiregisterXRoadDatabase.atcKlassifikaatoridByIDArrayV1(request).getKeha().getItemList(); }
@Override public TextRange rangeToHighlight() { if (name != null) { return name.metaData().textRange(); } TextRange bodyRange = body.metaData().textRange(); List<TextRange> tokenRangesBeforeBody = metaData().tokens().stream() .map(Token::textRange) .filter(t -> t.start().compareTo(bodyRange.start()) < 0) .collect(Collectors.toList()); if (tokenRangesBeforeBody.isEmpty()) { return bodyRange; } return TextRanges.merge(tokenRangesBeforeBody); }
@Override public final Event read() throws IOException { if (events.hasNext()) { return events.next(); } else { T sample; while (!events.hasNext() && (sample = samples.read()) != null) { events = createEvents(sample); } if (events.hasNext()) { return read(); } } return null; }
public String prettyprint(ASTExpression node) { getPrinter().clearBuffer(); node.accept(getRealThis()); return getPrinter().getContent(); }
public static String[] splitWithCommaOrSemicolon(String src) { if (isEmpty(src)) { return StringUtils.EMPTY_STRING_ARRAY; } String[] ss = split(src.replace(',', ';'), ";"); List<String> list = new ArrayList<String>(); for (String s : ss) { if (!isBlank(s)) { list.add(s.trim()); } } return list.toArray(new String[list.size()]); }
@Override public Node operate(final AtomicValue mOperand1, final AtomicValue mOperand2) throws SirixXPathException { final Type returnType = getReturnType(mOperand1.getTypeKey(), mOperand2.getTypeKey()); final int typeKey = asXdmNodeReadTrx().keyForName(returnType.getStringRepr()); final byte[] value; switch (returnType) { case DOUBLE: case FLOAT: case DECIMAL: case INTEGER: final double dOp1 = Double.parseDouble(new String(mOperand1.getRawValue())); final double dOp2 = Double.parseDouble(new String(mOperand2.getRawValue())); value = TypedValue.getBytes(dOp1 * dOp2); break; case YEAR_MONTH_DURATION: case DAY_TIME_DURATION: throw new IllegalStateException( "Add operator is not implemented for the type " + returnType.getStringRepr() + " yet."); default: throw new XPathError(ErrorType.XPTY0004); } return new AtomicValue(value, typeKey); }
public static Builder newBuilder() { return new AutoValue_DLPInspectText.Builder(); }
public static List<Integer> getDaysInMonth(Integer month, Integer year) { if (month == null) { return new ArrayList<>(); } Calendar calendar = new GregorianCalendar(); if (year == null) { calendar.set(Calendar.YEAR, 2020); } else { calendar.set(Calendar.YEAR, year); } calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, 1); Integer daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH); List<Integer> x = new ArrayList<Integer>(); for (int i = 1; i <= daysInMonth; i++) { x.add(i); } return x; }
public Mono<MessageFullView> fromMetaDataWithContent(MetaDataWithContent message) { return Mono.fromCallable(() -> Helpers.parse(message.getContent())) .flatMap(Throwing.function(mimeMessage -> fromMetaDataWithContent(message, mimeMessage))); }
@Override public WatchListMessageData extract(DocumentReference subscriberReference, XWikiDocument document, BaseObject userObject) { WatchListMessageData result = null; try { if (skipContextUser && subscriberReference.equals(getXWikiContext().getUserReference())) { return null; } List<WatchListEvent> matchingEvents = eventMatcher.getMatchingVisibleEvents(source.getEvents(), document.getPrefixedFullName()); if (matchingEvents.size() == 0) { return null; } String firstName = userObject.getStringValue("first_name"); String lastName = userObject.getStringValue("last_name"); Address address = addressExtractor.extract(subscriberReference, document, userObject); if (address == null || processedAddresses.contains(address)) { return null; } processedAddresses.add(address); DocumentReference templateReference = getTemplateReference(subscriberReference); result = new WatchListMessageData(subscriberReference, templateReference, firstName, lastName, address, matchingEvents); } catch (Exception e) { LOGGER.error("Failed to retrieve information for user [{}]", subscriberReference, e); } return result; }
public NumberDataValue minus(NumberDataValue left, NumberDataValue right, NumberDataValue result) throws StandardException { if (result == null) { result = new SQLLongint(); } if (left.isNull() || right.isNull()) { result.setToNull(); return result; } long diff = left.getLong() - right.getLong(); if ((left.getLong() < 0) != (right.getLong() < 0)) { if ((left.getLong() < 0) != (diff < 0)) { throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "BIGINT"); } } result.setValue(diff); return result; }
public Properties getOptionProperties(String opt) { Properties props = new Properties(); for (Option option : options) { if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) { List<String> values = option.getValuesList(); if (values.size() >= 2) { props.put(values.get(0), values.get(1)); } else if (values.size() == 1) { props.put(values.get(0), "true"); } } } return props; }
public static boolean createDirectory(File dir) { if (!dir.exists() && !dir.mkdirs()) { ConsoleLogger.warning("Could not create directory '" + dir + "'"); return false; } return dir.isDirectory(); }
@Override public Expression<Long> toLong(final Expression<? extends Number> number) { throw new UnsupportedOperationException(); }
public static GlobeCoordinatesValue makeGlobeCoordinatesValue( double latitude, double longitude, double precision, String globeIri) { return factory.getGlobeCoordinatesValue(latitude, longitude, precision, globeIri); }
public static <T, K> void reconcileObjectCollections(Collection<T> existingCollection, Collection<T> updatedCollection, CollectionReconciliationHelper<T, K> reconciliationHelper, boolean removeMissingObjects) { Validate.noNullElements(existingCollection); Validate.noNullElements(updatedCollection); HashMap<K, T> existingObjects = new HashMap<K, T>(existingCollection.size()); HashMap<K, T> updatedObjects = new HashMap<K, T>(updatedCollection.size()); for (T updatedObject : updatedCollection) { updatedObjects.put(reconciliationHelper.extractKey(updatedObject), updatedObject); } for (Iterator<T> iterator = existingCollection.iterator(); iterator.hasNext();) { T existingObject = iterator.next(); T updatedObject = updatedObjects.get(reconciliationHelper.extractKey(existingObject)); if (updatedObject == null) { if (removeMissingObjects) { iterator.remove(); } } else { reconciliationHelper.reconcileValues(existingObject, updatedObject); existingObjects.put(reconciliationHelper.extractKey(existingObject), existingObject); } } for (Map.Entry<K, T> updatedObjectEntry : updatedObjects.entrySet()) { if (!existingObjects.containsKey(updatedObjectEntry.getKey())) { existingCollection.add(updatedObjectEntry.getValue()); } } }
public void run() { Performable performable = null; final Optional<String> command = this.arguments.getCommand(); if (!command.isPresent()) { throw new IllegalStateException("Command missing trying to execute OFT mode."); } switch (command.get()) { case ConvertCommand.COMMAND_NAME: performable = new ConvertCommand(this.arguments); break; case TraceCommand.COMMAND_NAME: performable = new TraceCommand(this.arguments); break; default: throw new IllegalStateException( "Unknown command '" + command.get() + "' trying to execute OFT mode."); } if (performable.run()) { exit(ExitStatus.OK); } else { exit(ExitStatus.FAILURE); } }
public void changePasswordAsAdmin(CommandSender sender, final String playerName, String newPassword) { final String lowerCaseName = playerName.toLowerCase(); if (!(playerCache.isAuthenticated(lowerCaseName) || dataSource.isAuthAvailable(lowerCaseName))) { if (sender == null) { ConsoleLogger.warning("Tried to change password for user " + lowerCaseName + " but it doesn't exist!"); } else { commonService.send(sender, MessageKey.UNKNOWN_USER); } return; } HashedPassword hashedPassword = passwordSecurity.computeHash(newPassword, lowerCaseName); if (dataSource.updatePassword(lowerCaseName, hashedPassword)) { bungeeSender.sendAuthMeBungeecordMessage(MessageType.REFRESH_PASSWORD, lowerCaseName); if (sender != null) { commonService.send(sender, MessageKey.PASSWORD_CHANGED_SUCCESS); ConsoleLogger.info(sender.getName() + " changed password of " + lowerCaseName); } else { ConsoleLogger.info("Changed password of " + lowerCaseName); } } else { if (sender != null) { commonService.send(sender, MessageKey.ERROR); } ConsoleLogger.warning("An error occurred while changing password for user " + lowerCaseName + "!"); } }
@Override public Geometry apply(Geometry geometry, Context context) { if (geometry == null || geometry.isEmpty()) { return geometry; } return geometryPrecisionReducer.reduce(geometry); }
@Override public String sanitizeString(String string, String info) { if (policy == null) { log.error("Cannot sanitize, no policy registered"); return string; } return policy.sanitize(string); }
@Override public Interval getDataInterval() { return baseSegment.getDataInterval(); }
public Optional<TransactionSimulatorResult> process( final CallParameter callParams, final Hash blockHeaderHash) { final BlockHeader header = blockchain.getBlockHeader(blockHeaderHash).orElse(null); return process(callParams, OperationTracer.NO_TRACING, header); }
@Override public Future<Void> start() { final Promise<Void> startPromise = Promise.promise(); if (running.compareAndSet(false, true)) { if (!getConfig().isModificationEnabled()) { LOG.info("modification of credentials has been disabled"); } if (getConfig().getFilename() == null) { LOG.debug("credentials filename is not set, no credentials will be loaded"); startPromise.complete(); } else { checkFileExists(getConfig().isSaveToFile()) .compose(ok -> loadCredentials()) .onSuccess(ok -> { if (getConfig().isSaveToFile()) { LOG.info("saving credentials to file every 3 seconds"); vertx.setPeriodic(3000, saveIdentities -> saveToFile()); } else { LOG.info("persistence is disabled, will not save credentials to file"); } }) .onFailure(t -> { LOG.error("failed to start up service", t); running.set(false); }) .onComplete(startPromise); } } else { startPromise.complete(); } return startPromise.future(); }
@Pure public static UUID getAttributeUUID(Node document, boolean caseSensitive, String... path) { assert document != null : AssertMessages.notNullParameter(0); return getAttributeUUIDWithDefault(document, caseSensitive, null, path); }
static UnknownTopicPathException fromTopicAndPath( @Nullable final TopicPath topicPath, @Nullable final MessagePath path, @Nonnull final DittoHeaders dittoHeaders) { final String theTopicPath = null != topicPath ? topicPath.getPath() : ""; final String message = MessageFormat.format(MESSAGE_TEMPLATE_WITH_PATH, theTopicPath, path); return new Builder() .dittoHeaders(dittoHeaders) .message(message) .build(); }
public void remove(int index) { list.remove(index); }
@Override public String getZoneSea(String zoneId) { synchronized (lock) { Map<String, SliEntityLocator> seaMap = zoneMapProvider.getZoneToSliIdMap(); SliEntityLocator locator = seaMap.get(zoneId); Entity seaEntity = fetchSliEntity(locator); if (seaEntity == null) { return null; } return seaEntity.getId(); } }
public static String handleShortSyntax(String line, List<String> options) { final String prepend = "concourse."; if(line.equalsIgnoreCase("time") || line.equalsIgnoreCase("date")) { return line + " \"now\""; } else if(!line.contains("(")) { if(line.startsWith(prepend)) { boolean hasArgs = line.split("\\s+").length > 1; if(!hasArgs) { line += "()"; } return line; } else { String[] query = line.split("\\s+"); String cmd = query[0]; if(cmd.contains("_")) { String replacement = CaseFormat.LOWER_UNDERSCORE .to(CaseFormat.LOWER_CAMEL, cmd); line = line.replaceFirst(cmd, replacement); } String expanded = prepend + line.trim(); Pattern pattern = Pattern.compile(expanded.split("\\s|\\(")[0]); for (String option : options) { if(pattern.matcher(option).matches()) { boolean hasArgs = expanded.split("\\s+").length > 1; if(!hasArgs) { expanded += "()"; } return expanded; } } } } else { Set<String> shortInvokedMethods = parseShortInvokedMethods(line); for (String method : shortInvokedMethods) { if(options.contains(prepend + method)) { line = line.replaceAll("(?<!\\_)" + method + "\\(", prepend + method + "\\("); } } } return line; }
public List<Pointer> getPointers() { return pointers; }
@Override public void preInit(SpringProcessEngineConfiguration configuration) { String historyLevel = camundaBpmProperties.getHistoryLevel(); if (historyLevel != null) { configuration.setHistory(historyLevel); } if (historyEventHandler != null) { logger.debug("registered history event handler: {}", historyEventHandler.getClass()); configuration.getCustomHistoryEventHandlers().add(historyEventHandler); } }
public void deleteReportByIdAndTenant(String processId, int tenantId) { DeleteResult deleteResult = collection.deleteMany(and(eq(PROCESS_ID, processId), eq(TENANT, tenantId))); LOGGER.info("Deleted document count: " + deleteResult.getDeletedCount() + " for process " + processId); }
public Expression extract(Session session, PlanNode node, TypeProvider types, TypeAnalyzer typeAnalyzer) { return node.accept(new Visitor(domainTranslator, metadata, session, types, typeAnalyzer, useTableProperties), null); }
@Override public int rename(String oldPath, String newPath) { return AlluxioFuseUtils.call(LOG, () -> renameInternal(oldPath, newPath), "rename", "oldPath=%s,newPath=%s,", oldPath, newPath); }
@SafeVarargs public final Stream<N> breadthFirstFrom(N... startNodes) { return breadthFirstFrom(nonNullList(startNodes)); }
@Override public int hashCode() { int hash = 37; if ( description != null ) { hash = hash * 17 + description.hashCode(); } hash = hash * 17 + Long.valueOf( revision ).hashCode(); return hash; }
public int getCount() { return buckets.length + 1; }
@Override public ProducerResponseMapper createResponseMapper(ResponseMapperFactorys<ProducerResponseMapper> factorys, Type producerType) { Type realProducerType = ((ParameterizedType) producerType).getActualTypeArguments()[0]; ProducerResponseMapper realMapper = factorys.createResponseMapper(realProducerType); return new SpringmvcProducerResponseMapper(realMapper); }
public static String replace( String originalString, String partToMatch, String replacement ) { StringBuilder buffer = new StringBuilder( originalString.length() ); buffer.append( originalString ); int indexOf = buffer.indexOf( partToMatch ); while (indexOf != -1) { buffer = buffer.replace(indexOf, indexOf + partToMatch.length(), replacement); indexOf = buffer.indexOf(partToMatch, indexOf + replacement.length()); } return buffer.toString(); }
@Override public DataPolicy convert(String policyValue) { Policy policy = Policy.getValue(policyValue); return (policy == null ? null : policy.toDataPolicy()); }
public com.silanis.esl.api.model.External toAPIExternal(){ if(sdkExternal == null){ return apiExternal; } apiExternal = new com.silanis.esl.api.model.External(); apiExternal.setProvider(sdkExternal.getProvider()); apiExternal.setId(sdkExternal.getId()); apiExternal.setProviderName(sdkExternal.getProviderName()); return apiExternal; }
@Override public void record(long value, Labels labels) { BoundInstrument boundInstrument = bind(labels); boundInstrument.record(value); boundInstrument.unbind(); }
@Override public List<WorkflowInstance> getAllChildWorkflows() { return queryChildWorkflows(new QueryWorkflowInstances.Builder().build()); }
public void setup(final Map<String,Object> config) { Preconditions.checkArgument(config != null, "Credential configuration cannot be null"); Preconditions.checkState(config.containsKey(CONFIG_HMAC_SECRET), String.format("Credential configuration missing the %s key", CONFIG_HMAC_SECRET)); if (config.containsKey(CONFIG_HMAC_ALGO)) { hmacAlgo = config.get(CONFIG_HMAC_ALGO).toString(); } else { hmacAlgo = DEFAULT_HMAC_ALGO; } if (config.containsKey(CONFIG_TOKEN_TIMEOUT)) { timeout = ((Number) config.get(CONFIG_TOKEN_TIMEOUT)).longValue(); } else { timeout = DEFAULT_HMAC_TOKEN_TIMEOUT; } super.setup(config); secret = config.containsKey(CONFIG_HMAC_SECRET) ? config.get(CONFIG_HMAC_SECRET).toString().toCharArray() : DEFAULT_HMAC_SECRET; }
public Object getModelPropertyValueByName( String name ) throws Exception { List<Field> fields = findAllFields( new ArrayList<Field>(), this.getClass() ); for ( Field f : fields ) { if ( f.isAnnotationPresent( ModelProperty.class ) ) { ModelProperty mp = f.getAnnotation( ModelProperty.class ); if ( StringUtils.equals( mp.name(), name ) ) { return PropertyUtils.getProperty( this, f.getName() ); } } } return null; }
@Override @CheckReturnValue @Nonnull public WebDriver getAndCheckWebDriver() { WebDriver webDriver = threadWebDriver.get(currentThread().getId()); if (webDriver != null && reopenBrowserOnFail && !browserHealthChecker.isBrowserStillOpen(webDriver)) { log.info("Webdriver has been closed meanwhile. Let's re-create it."); closeWebDriver(); webDriver = createDriver(); } else if (webDriver == null) { log.info("No webdriver is bound to current thread: {} - let's create a new webdriver", currentThread().getId()); webDriver = createDriver(); } return webDriver; }
public Map<String, Object> loadConfiguration(File file) throws IOException { Map<String, Object> config = new HashMap<>(defaultConfig); Map<String, Object> tmpConfig; try (InputStream input = new FileInputStream(file)) { Yaml yaml = new Yaml(); tmpConfig = yaml.load(input); if (tmpConfig == null) { return config; } for (Map.Entry element : tmpConfig.entrySet()) { String key = (String) element.getKey(); if (!variableNames.contains(key)) { throw new InvalidVariableException("unknown variable: " + key); } else { config.put(key, element.getValue()); } } } return config; }
public List<Double> getCurrentAllocatedMips() { return currentAllocatedMips; }
@Override public CloseableIterable<KeyStatistics<A>> getStatisticsForDistinctKeys(QueryOptions queryOptions) { return backingIndex().getStatisticsForDistinctKeys(queryOptions); }
public JpaWidgetComment convert(WidgetComment source, String widgetId) { return source instanceof JpaWidgetComment ? (JpaWidgetComment) source : createEntity(source, widgetId); }
public boolean isBackupKey( @Nonnull final String key ) { return key.startsWith( BACKUP_PREFIX ); }
String describeNewGroup(@NonNull DecryptedGroup group) { Optional<DecryptedPendingMember> selfPending = DecryptedGroupUtil.findPendingByUuid(group.getPendingMembersList(), selfUuid); if (selfPending.isPresent()) { return context.getString(R.string.MessageRecord_s_invited_you_to_the_group, describe(selfPending.get().getAddedByUuid())); } if (group.getRevision() == 0) { Optional<DecryptedMember> foundingMember = DecryptedGroupUtil.firstMember(group.getMembersList()); if (foundingMember.isPresent()) { ByteString foundingMemberUuid = foundingMember.get().getUuid(); if (selfUuidBytes.equals(foundingMemberUuid)) { return context.getString(R.string.MessageRecord_you_created_the_group); } else { return context.getString(R.string.MessageRecord_s_added_you, describe(foundingMemberUuid)); } } } if (DecryptedGroupUtil.findMemberByUuid(group.getMembersList(), selfUuid).isPresent()) { return context.getString(R.string.MessageRecord_you_joined_the_group); } else { return context.getString(R.string.MessageRecord_group_updated); } }
public String getRequestMethod(Class<?> httpServletRequestClass, Object httpServletRequest) { Method m = retrieveMethod(HttpMethods.SERVLET_GET_METHOD, httpServletRequestClass); if (null == m) { return HttpInfo.UNDEFINED; } try { String requestMethod = (String) m.invoke(httpServletRequest, (Object[]) null); if (null != requestMethod) { return requestMethod; } else { return HttpInfo.UNDEFINED; } } catch (Exception e) { LOG.error("Invocation on given object failed.", e); return HttpInfo.UNDEFINED; } }
public static <R extends JmxRequest> R createGetRequest(String pPathInfo, ProcessingParameters pProcessingParameters) { RequestType type = null; try { String pathInfo = extractPathInfo(pPathInfo, pProcessingParameters); Stack<String> elements = EscapeUtil.extractElementsFromPath(pathInfo); type = elements.size() != 0 ? RequestType.getTypeByName(elements.pop()) : RequestType.VERSION; return (R) getCreator(type).create(elements, pProcessingParameters); } catch (MalformedObjectNameException e) { throw new IllegalArgumentException("Invalid object name. " + e.getMessage(),e); } catch (EmptyStackException exp) { throw new IllegalArgumentException("Invalid arguments in pathinfo " + pPathInfo + (type != null ? " for command " + type : ""),exp); } }
@Override public List<WorldpayOrderModificationModel> findProcessedOrderModificationsBeforeDate(final Date date) { validateParameterNotNull(date, "Date must not be null"); final FlexibleSearchQuery query = new FlexibleSearchQuery(ORDER_MODIFICATION_CLEAN_UP_QUERY); query.addQueryParameter(BEFORE_DATE, date); query.addQueryParameter(PROCESSED, true); query.addQueryParameter(DEFECTIVE, false); final SearchResult<WorldpayOrderModificationModel> result = search(query); return result.getResult(); }
@Override protected void doPost(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); }
static int calculateSceneRasterHeight(DSD dsdGeoLocationAds, int numMDSR) { final int linesFromADS = (dsdGeoLocationAds.getNumRecords() - 1) * EnvisatConstants.AATSR_LOC_TIE_POINT_SUBSAMPLING_Y; if (numMDSR > linesFromADS) { return numMDSR; } return linesFromADS; }
@Override public Constraint<Boolean> isClosedLoopAllowed(Constraint<Boolean> value) { String mode = SP.getString(R.string.key_aps_mode, "open"); if (!mode.equals("closed")) value.set(false, MainApp.gs(R.string.closedmodedisabledinpreferences), this); if (!MainApp.isEngineeringModeOrRelease()) { if (value.value()) { Notification n = new Notification(Notification.TOAST_ALARM, MainApp.gs(R.string.closed_loop_disabled_on_dev_branch), Notification.NORMAL); RxBus.INSTANCE.send(new EventNewNotification(n)); } value.set(false, MainApp.gs(R.string.closed_loop_disabled_on_dev_branch), this); } PumpInterface pump = ConfigBuilderPlugin.getPlugin().getActivePump(); if (pump != null && !pump.isFakingTempsByExtendedBoluses() && TreatmentsPlugin.getPlugin().isInHistoryExtendedBoluslInProgress()) { value.set(false, MainApp.gs(R.string.closed_loop_disabled_with_eb), this); } return value; }
@Override public int hashCode() { return Objects.hash(getContext(), getLanguage()); }
public void deactivate() { active = false; }
@Override public @NonNull String mergeTemplateIntoString(final @NonNull String templateReference, final @NonNull Map<String, Object> model) throws IOException, TemplateException { final String trimmedTemplateReference = templateReference.trim(); checkArgument(!isNullOrEmpty(trimmedTemplateReference), "The given templateName is null, empty or blank"); if (trimmedTemplateReference.contains(".")) checkArgument(Objects.equals(getFileExtension(trimmedTemplateReference), expectedTemplateExtension()), "Expected a Mustache template file with extension '%s', while '%s' was given. To check " + "the default extension look at 'spring.mustache.suffix' in your application.properties file", expectedTemplateExtension(), getFileExtension(trimmedTemplateReference)); try { final Reader template = mustacheAutoConfiguration.mustacheTemplateLoader() .getTemplate(normalizeTemplateReference(trimmedTemplateReference)); return mustacheAutoConfiguration.mustacheCompiler(mustacheAutoConfiguration.mustacheTemplateLoader()) .compile(template) .execute(model); } catch (Exception e) { throw new TemplateException(e); } }
public static void throwAuthorizationFailure(Set<String> challenges) { throwAuthorizationFailure(challenges, null); }
static Multimap<SystemStream, String> getStreamToConsumerTasks(JobModel jobModel) { Multimap<SystemStream, String> streamToConsumerTasks = HashMultimap.create(); jobModel.getContainers().values().forEach(containerModel -> { containerModel.getTasks().values().forEach(taskModel -> { taskModel.getSystemStreamPartitions().forEach(ssp -> { streamToConsumerTasks.put(ssp.getSystemStream(), taskModel.getTaskName().getTaskName()); }); }); }); return streamToConsumerTasks; }
public static Integer getQueueExpireAfter(MultiMap headers) { try { final Integer ans = getExpireValue(headers.get(QUEUE_EXPIRE_AFTER_HEADER)); return (ans != null && ans == -1) ? null : ans; } catch (NumberFormatException e) { return null; } }
public void suspendServices() throws ConflictException { if (!statusRef.compareAndSet(RUNNING, PREPARING_TO_SHUTDOWN)) { throw new ConflictException( "System shutdown has been already called, system status: " + statusRef.get()); } ExecutorService exec = Executors.newSingleThreadExecutor( new ThreadFactoryBuilder() .setDaemon(false) .setNameFormat("SuspendSystemServicesPool") .setUncaughtExceptionHandler(LoggingUncaughtExceptionHandler.getInstance()) .build()); exec.execute(ThreadLocalPropagateContext.wrap(this::doSuspendServices)); exec.shutdown(); }
@Override public int getNumChildren() { return getNumArgs(); }
public LHSGeneratorContext newGeneratorContext() { final LHSGeneratorContext gc = new LHSGeneratorContext(); contexts.add(gc); return gc; }
@Override public SpringCache getCache(final String name) { final RemoteCache<Object, Object> nativeCache = this.nativeCacheManager.getCache(name); if (nativeCache == null) { springCaches.remove(name); return null; } return springCaches.computeIfAbsent(name, n -> new SpringCache(nativeCache, readTimeout, writeTimeout)); }
protected boolean eventCanBeIgnored(Operation operation) { return operation.isLoad(); }
@Override public void add(int location, E object) { if (location < 0 || location > itemCount) { throw new ProgrammerError("Index out of bounds; index: {}, size: {}", location, itemCount); } if (location == 0) { if (firstIndex == 0) { growAtFront(1); } array[--firstIndex] = object; } else if (location == itemCount) { if (firstIndex + itemCount == array.length) { growAtEnd(1); } array[firstIndex + itemCount] = object; } else { if (itemCount == array.length) { growForInsert(location, 1); } else if (firstIndex + itemCount == array.length || (firstIndex > 0 && location < itemCount / 2)) { SystemUtils.arraycopy(array, firstIndex, array, --firstIndex, location); } else { int index = location + firstIndex; SystemUtils.arraycopy(array, index, array, index + 1, itemCount - location); } array[location + firstIndex] = object; } itemCount++; modCount++; }
public KubernetesPod getPodById(String uid, String namespace, String name) throws VmidcException { if (uid == null) { throw new IllegalArgumentException("Uid should not be null"); } if (name == null) { throw new IllegalArgumentException("Name should not be null"); } if (namespace == null) { throw new IllegalArgumentException("Namespace should not be null"); } KubernetesPod pod = getPodsByName(namespace, name); return (pod == null || !pod.getUid().equals(uid)) ? null : pod; }
@Override public HttpClient getCommonHttpClient() { initialize(); logger.debug("shared http client requested"); return commonHttpClient; }
@Override public String status() { Map<String, JsonNode> txProps = new HashMap<>(); txProps.put(PENDING, jsonNodeFactory.numberNode(transactionPool.getPendingTransactions().size())); txProps.put(QUEUED, jsonNodeFactory.numberNode(transactionPool.getQueuedTransactions().size())); JsonNode node = jsonNodeFactory.objectNode().setAll(txProps); return node.toString(); }
public void oneWayReceived(OspfMessage ospfHello, Channel channel) { log.debug("OSPFNbr::oneWayReceived...!!!"); stopInactivityTimeCheck(); startInactivityTimeCheck(); if (state == OspfNeighborState.ATTEMPT) { state = OspfNeighborState.INIT; } else if (state == OspfNeighborState.DOWN) { state = OspfNeighborState.INIT; } if (state.getValue() >= OspfNeighborState.TWOWAY.getValue()) { state = OspfNeighborState.INIT; failedTxList.clear(); ddSummaryList.clear(); lsReqList.clear(); } }
public void set(int position) { if (position < 0 || position >= this.size) { throw new IndexOutOfBoundsException(String.format("Index: %s, Size: %s", position, this.size)); } int offset = position / 8; int bitoffset = position % 8; this.bytes[offset] |= 1 << bitoffset; }
@Override protected boolean isPermitted(Authentication authentication, ObjectPermission objectPermission, Object object) { User user = (User)authentication.getPrincipal(); boolean res = true; if (objectPermission.getPermissionRecipient() instanceof User){ User recipient = (User)objectPermission.getPermissionRecipient(); res = !((recipient.getUsername() == user.getUsername() || recipient.getUsername().equals(user.getUsername())) && (recipient.getTenantId() == user.getTenantId() || recipient.getTenantId().equals(user.getTenantId()))); } return res; }
@Override public Set<ContainerModel> group(Set<TaskModel> tasks) { validateTasks(tasks); List<TaskModel> sortedTasks = new ArrayList<>(tasks); Collections.sort(sortedTasks); Map<TaskName, TaskModel>[] taskGroups = new Map[containerCount]; for (int i = 0; i < containerCount; i++) { taskGroups[i] = new HashMap<>(); } for (int i = 0; i < sortedTasks.size(); i++) { TaskModel tm = sortedTasks.get(i); taskGroups[i % containerCount].put(tm.getTaskName(), tm); } Set<ContainerModel> containerModels = new HashSet<>(); for (int i = 0; i < containerCount; i++) { containerModels.add(new ContainerModel(String.valueOf(i), taskGroups[i])); } return Collections.unmodifiableSet(containerModels); }
@Override public <T> T createInstance(Class<T> type, RandomizerContext context) { if (context.getParameters().isScanClasspathForConcreteTypes() && isAbstract(type)) { Class<?> randomConcreteSubType = randomElementOf(getPublicConcreteSubTypesOf((type))); if (randomConcreteSubType == null) { throw new InstantiationError("Unable to find a matching concrete subtype of type: " + type + " in the classpath"); } else { return (T) createNewInstance(randomConcreteSubType); } } else { try { return createNewInstance(type); } catch (Error e) { throw new ObjectCreationException("Unable to create an instance of type: " + type, e); } } }
@SuppressWarnings("unchecked") @Override public void start(Workflow workflow, Task task, WorkflowExecutor provider) { Map<String, Object> input = task.getInputData(); String name = input.get("subWorkflowName").toString(); int version = (int) input.get("subWorkflowVersion"); WorkflowDef workflowDefinition = null; if (input.get("subWorkflowDefinition") != null) { workflowDefinition = objectMapperSupplier.get().convertValue(input.get("subWorkflowDefinition"), WorkflowDef.class); } Map taskToDomain = workflow.getTaskToDomain(); if (input.get("subWorkflowTaskToDomain") instanceof Map) { taskToDomain = (Map) input.get("subWorkflowTaskToDomain"); } Map<String, Object> wfInput = (Map<String, Object>) input.get("workflowInput"); if (wfInput == null || wfInput.isEmpty()) { wfInput = input; } String correlationId = workflow.getCorrelationId(); try { String subWorkflowId = null; if (workflowDefinition != null) { subWorkflowId = provider.startWorkflow( workflowDefinition, wfInput, null, correlationId, 0, workflow.getWorkflowId(), task.getTaskId(), null, taskToDomain); } else { subWorkflowId = provider.startWorkflow( name, version, wfInput, null, correlationId, workflow.getWorkflowId(), task.getTaskId(), null, taskToDomain); } task.setSubWorkflowId(subWorkflowId); task.getOutputData().put(SUB_WORKFLOW_ID, subWorkflowId); Workflow subWorkflow = provider.getWorkflow(subWorkflowId, false); updateTaskStatus(subWorkflow.getStatus(), task); } catch (Exception e) { task.setStatus(Status.FAILED); task.setReasonForIncompletion(e.getMessage()); logger.error("Error starting sub workflow: {} from workflow: {}", name, workflow.getWorkflowId(), e); } }
public String getHostOrDefault(String defaultHost) { if (this.getHost() == null) { return defaultHost; } return this.getHost(); }
CardWithdrawn withdraw(WithdrawalCommand command) { BigDecimal amount = command.getAmount(); if (thereIsMoneyToWithdraw(amount)) { return new CardWithdrawn(cardId, amount); } else { throw new NotEnoughMoneyException(cardId, command.getAmount(), availableBalance()); } }
@SuppressWarnings("unchecked") public static <Term extends AMonomial<Term>, Poly extends AMultivariatePolynomial<Term, Poly>> Poly[] divideAndRemainder(Poly dividend, Poly... dividers) { Poly[] quotients = dividend.createArray(dividers.length + 1); int i = 0; int constDivider = -1; for (; i < dividers.length; i++) { if (dividers[i].isZero()) throw new ArithmeticException("divide by zero"); if (dividers[i].isConstant()) constDivider = i; quotients[i] = dividend.createZero(); } quotients[i] = dividend.createZero(); if (constDivider != -1) { if (dividers[constDivider].isOne()) { quotients[constDivider] = dividend.clone(); return quotients; } Poly dd = dividend.clone().divideByLC(dividers[constDivider]); if (dd != null) { quotients[constDivider] = dd; return quotients; } } IMonomialAlgebra<Term> mAlgebra = dividend.monomialAlgebra; Term[] dividersLTs = Arrays.stream(dividers).map(Poly::lt).toArray(mAlgebra::createArray); dividend = dividend.clone(); Poly remainder = quotients[quotients.length - 1]; while (!dividend.isZero()) { Term ltDiv = null; Term lt = dividend.lt(); for (i = 0; i < dividers.length; i++) { ltDiv = mAlgebra.divideOrNull(lt, dividersLTs[i]); if (ltDiv != null) break; } if (ltDiv != null) { quotients[i] = quotients[i].add(ltDiv); dividend = dividend.subtract(ltDiv, dividers[i]); } else { remainder = remainder.add(lt); dividend = dividend.subtractLt(); } } return quotients; }
@CrossOrigin @DeleteMapping(value = "/tim") public ResponseEntity<String> deleteTim(@RequestBody String jsonString, @RequestParam(value = "index", required = true) Integer index) { if (null == jsonString) { logger.error("Empty request"); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(JsonUtils.jsonKeyValue(ERRSTR, "Empty request")); } RSU queryTarget = (RSU) JsonUtils.fromJson(jsonString, RSU.class); TimTransmogrifier.updateRsuCreds(queryTarget, odeProperties); logger.info("TIM delete call, RSU info {}", queryTarget); SnmpSession ss = null; try { ss = new SnmpSession(queryTarget); } catch (IOException e) { logger.error("Error creating TIM delete SNMP session", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(JsonUtils.jsonKeyValue(ERRSTR, e.getMessage())); } catch (NullPointerException e) { logger.error("TIM query error, malformed JSON", e); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(JsonUtils.jsonKeyValue(ERRSTR, "Malformed JSON")); } PDU pdu = new ScopedPDU(); pdu.add(new VariableBinding(new OID("1.0.15628.4.1.4.1.11.".concat(Integer.toString(index))), new Integer32(6))); pdu.setType(PDU.SET); ResponseEvent rsuResponse = null; try { rsuResponse = ss.set(pdu, ss.getSnmp(), ss.getTarget(), false); } catch (IOException e) { logger.error("Error sending TIM query PDU to RSU", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(JsonUtils.jsonKeyValue(ERRSTR, e.getMessage())); } HttpStatus returnCode = null; String bodyMsg = ""; if (null == rsuResponse || null == rsuResponse.getResponse()) { returnCode = HttpStatus.REQUEST_TIMEOUT; bodyMsg = JsonUtils.jsonKeyValue(ERRSTR, "Timeout."); } else if (rsuResponse.getResponse().getErrorStatus() == 0) { returnCode = HttpStatus.OK; bodyMsg = JsonUtils.jsonKeyValue("deleted_msg", Integer.toString(index)); } else if (rsuResponse.getResponse().getErrorStatus() == 12) { returnCode = HttpStatus.BAD_REQUEST; bodyMsg = JsonUtils.jsonKeyValue(ERRSTR, "No message at index ".concat(Integer.toString(index))); } else if (rsuResponse.getResponse().getErrorStatus() == 10) { returnCode = HttpStatus.BAD_REQUEST; bodyMsg = JsonUtils.jsonKeyValue(ERRSTR, "Invalid index ".concat(Integer.toString(index))); } else { returnCode = HttpStatus.BAD_REQUEST; bodyMsg = JsonUtils.jsonKeyValue(ERRSTR, rsuResponse.getResponse().getErrorStatusText()); } logger.info("Delete call response code: {}, message: {}", returnCode, bodyMsg); return ResponseEntity.status(returnCode).body(bodyMsg); }
public void mstart() { createThread(); }
@Nullable static Type getType(ExpressionTree leftOperand, ExpressionTree rightOperand, Tree.Kind operationKind) { if (COMPARATIVE_OPERATORS.contains(operationKind)) { return PrimitiveType.BOOLEAN; } else if (ARITHMETIC_OPERATORS.contains(operationKind)) { return PrimitiveType.INTEGER; } else { return getType(leftOperand.types().getUniqueKnownType(), rightOperand.types().getUniqueKnownType(), operationKind); } }
@Override public String getString(final String parameter) { return (String) getValue(parameter); }
@Override public ObjectNode encode(Intent intent, CodecContext context) { checkNotNull(intent, "Intent cannot be null"); final ObjectNode result = context.mapper().createObjectNode() .put(TYPE, intent.getClass().getSimpleName()) .put(ID, intent.id().toString()) .put(APP_ID, UrlEscapers.urlPathSegmentEscaper() .escape(intent.appId().name())); final ArrayNode jsonResources = result.putArray(RESOURCES); for (final NetworkResource resource : intent.resources()) { jsonResources.add(resource.toString()); } IntentService service = context.getService(IntentService.class); IntentState state = service.getIntentState(intent.key()); if (state != null) { result.put(STATE, state.toString()); } return result; }
@Override public IngestionResult ingestFromFile(FileSourceInfo fileSourceInfo, IngestionProperties ingestionProperties) throws IngestionClientException, IngestionServiceException { Ensure.argIsNotNull(fileSourceInfo, "fileSourceInfo"); Ensure.argIsNotNull(ingestionProperties, "ingestionProperties"); fileSourceInfo.validate(); ingestionProperties.validate(); try { String filePath = fileSourceInfo.getFilePath(); File file = new File(filePath); if (file.length() == 0) { String message = "Empty file."; log.error(message); throw new IngestionClientException(message); } InputStream stream = new FileInputStream(filePath); StreamSourceInfo streamSourceInfo = new StreamSourceInfo(stream, false, fileSourceInfo.getSourceId()); streamSourceInfo.setCompressionType(AzureStorageClient.getCompression(filePath)); return ingestFromStream(streamSourceInfo, ingestionProperties); } catch (FileNotFoundException e) { log.error("File not found when ingesting a file.", e); throw new IngestionClientException("IO exception - check file path.", e); } }
public static List<Definition> toDefinition(String definition) { List<Definition> list = new ArrayList<Definition>(); HashSet<String> check = new HashSet<String>(); String[] defs = splitDefinitions(definition); for (String line : defs) { int mark = line.indexOf("="); if (mark != -1) { String name = line.substring(0, mark).trim(); String expressionDefinition = line.substring(mark + 1).trim(); if (check.contains(name)) { throw new IllegalArgumentException( "Attribute " + name + " defined more than once"); } Expression expression; try { expression = ECQL.toExpression(expressionDefinition); } catch (CQLException e) { throw new IllegalArgumentException( "Unable to parse expression " + name + "=" + expressionDefinition + " " + e, e); } Definition def = new Definition(); def.name = name; def.expression = expression; list.add(def); check.add(name); } } return list; }
public TilesDefinition findAnnotation(Object action, String tileName) { Class<?> clazz = action.getClass(); TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class); TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class); if (tilesDefinition == null && tilesDefinitions != null) { if (!StringUtils.isEmpty(tileName)) { for (TilesDefinition i : tilesDefinitions.value()) { if (i.name().equals(tileName)) { tilesDefinition = i; break; } } } else { if (tilesDefinitions.value().length > 0) { tilesDefinition = tilesDefinitions.value()[0]; } } } return tilesDefinition; }
@VisibleForTesting @Nullable static Map<String, Map<?, ?>> portSetToMap(@Nullable Set<Port> exposedPorts) { return setToMap(exposedPorts, port -> port.getPort() + "/" + port.getProtocol()); }
@Override public String buildSQL(String template) throws IOException, SQLException { template = replaceTemplate(template); template = reword(template); template = _removeNull(template); template = StringUtil.replace(template, "\\'", "''"); template = StringUtil.replace(template, "\\n", "'||CHR(10)||'"); return template; }
public static AsyncApiBaseBuilder builder() { return new Builder(); }
public static boolean isValidExtension(String extension) { if (StringUtils.isBlank(extension)) { return false; } Pattern pattern = Pattern.compile(REGEXP_FILE_EXTENSION); Matcher matcher = pattern.matcher(extension); return matcher.matches(); }
public void deleteNode(String path, String name) throws ApiException { deleteNodeWithHttpInfo(path, name); }
@Override public int read() throws IOException { if (bb.remaining() == 0) { return -1; } return bb.get() & 0xff; }
@Override public void debug(String msg) { logger.debug(msg); }
public Object execute(Handler handler) throws Exception { int parallelism = Runtime.getRuntime().availableProcessors(); System.out.println("parallelism = " + parallelism); JAI.getDefaultInstance().getTileScheduler().setParallelism(parallelism); Dimension frameSize = getFrameSize(); int numXFrames = 1 + (product.getSceneRasterWidth() - 1) / frameSize.width; int numYFrames = 1 + (product.getSceneRasterHeight() - 1) / frameSize.height; Rectangle sceneRegion = new Rectangle(product.getSceneRasterWidth(), product.getSceneRasterHeight()); for (int frameY = 0; frameY < numYFrames; frameY++) { for (int frameX = 0; frameX < numXFrames; frameX++) { Rectangle frameRegion = new Rectangle(frameX * frameSize.width, frameY * frameSize.height, frameSize.width, frameSize.height).intersection(sceneRegion); int numBands = product.getNumBands(); Band[] bandArray = new Band[numBands]; ProductData[] dataArray = new ProductData[numBands]; for (int b = 0; b < numBands; b++) { Band band = product.getBandAt(b); PlanarImage planarImage = band.getSourceImage(); Point[] indices = planarImage.getTileIndices(null); System.out.println("indices = " + indices.length); TileRequest tileRequest = planarImage.queueTiles(indices); Raster raster = planarImage.getData(); System.out.println("raster = " + raster); ProductData data = band.createCompatibleRasterData(frameRegion.width, frameRegion.height); band.readRasterData(frameRegion.x, frameRegion.y, frameRegion.width, frameRegion.height, data); bandArray[b] = band; dataArray[b] = data; } MyFrame frame = new MyFrame(frameRegion, bandArray, dataArray); handler.frameComputed(frame); } } return new Object(); }
public String substitute(List<String> values) throws IllegalArgumentException { if (values == null) { throw new IllegalArgumentException("values is null"); } Iterator<String> iter = values.iterator(); StringBuilder sb = new StringBuilder(); for (UriChunk chunk : uriChunks) { if (chunk instanceof Variable) { Variable var = (Variable)chunk; if (iter.hasNext()) { String value = iter.next(); if (!var.matches(value)) { throw new IllegalArgumentException("Value '" + value + "' does not match variable " + var.getName() + " with pattern " + var.getPattern()); } sb.append(value); } else { sb.append(var); } } else { sb.append(chunk); } } return sb.toString(); }
@Override public void reply(Ethernet eth, ConnectPoint inPort) { checkPermission(PACKET_WRITE); checkNotNull(eth, REQUEST_NULL); MessageContext context = createContext(eth, inPort); if (context != null) { replyInternal(context); } }
public static RemoteCallable<Void> stopAllocRecording() { return new RemoteCallableStaticMethod<>(CONTROLLER_CLASS, "stopAllocRecording"); }
public static <T> T getInternalState(Object object, String fieldName) { return WhiteboxImpl.getInternalState(object, fieldName); }
@Override public boolean[] filter( final IFilter filter , final boolean[] filterArray ) throws IOException{ switch( filter.getFilterType() ){ case STRING: IStringFilter stringFilter = (IStringFilter)filter; String targetStr = stringFilter.getSearchString(); switch( stringFilter.getStringFilterType() ){ case PERFECT: return toColumnList( perfectMatch( targetStr ) , filterArray ); case PARTIAL: return toColumnList( partialMatch( targetStr ) , filterArray ); case FORWARD: return toColumnList( forwardMatch( targetStr ) , filterArray ); case BACKWARD: return toColumnList( backwardMatch( targetStr ) , filterArray ); case REGEXP: return toColumnList( regexpMatch( targetStr ) , filterArray ); default: return null; } case STRING_COMPARE: IStringCompareFilter stringCompareFilter = (IStringCompareFilter)filter; IStringComparator comparator = stringCompareFilter.getStringComparator(); return toColumnList( compareString( comparator ) , filterArray ); case STRING_DICTIONARY: IStringDictionaryFilter stringDictionaryFilter = (IStringDictionaryFilter)filter; Set<String> dictionary = stringDictionaryFilter.getDictionary(); return toColumnList( dictionaryString( dictionary ) , filterArray ); default: return null; } }
public static String formatAlertMessage(TransactionSeenEvent event) { final Coin amount = event.getAmount(); final Coin modulusAmount; if (amount.compareTo(Coin.ZERO) >= 0) { modulusAmount = amount; } else { modulusAmount = amount.negate(); } final String messageAmount = Formats.formatCoinAsSymbolicText( modulusAmount, Configurations.currentConfiguration.getLanguage(), Configurations.currentConfiguration.getBitcoin() ); if (amount.compareTo(Coin.ZERO) >= 0) { return Languages.safeText(MessageKey.PAYMENT_RECEIVED_ALERT, messageAmount); } else { return Languages.safeText(MessageKey.PAYMENT_SENT_ALERT, messageAmount); } }
public static <InputT> Builder<InputT> withoutHold(PTransformNode transform) { return new Builder(transform, BoundedWindow.TIMESTAMP_MAX_VALUE); }
public void setChannel(int channel) { if (channel < 0) throw new IllegalArgumentException(ERROR_CHANNEL); this.channel = channel; }
@Override @TimerJ protected void insert(TableMetadata targetStream, Row row, boolean isNotExists, Connection<IStratioStreamingAPI> connection) throws ExecutionException, UnsupportedException { if (isNotExists){ throw new UnsupportedException("if not exist is not supporting in Decision connector"); } String streamName = StreamUtil.createStreamName(targetStream.getName()); try { List<ColumnNameValue> streamData = new ArrayList<ColumnNameValue>(); Map<String, Cell> cells = row.getCells(); for (Map.Entry<String, Cell> cellName : cells.entrySet()) { streamData.add(new ColumnNameValue(cellName.getKey(), cellName.getValue().getValue())); } connection.getNativeConnection().insertData(streamName, streamData); } catch (StratioStreamingException e) { String msg = "Inserting data error in Decision [" + streamName + "]. " + e.getMessage(); logger.error(msg); throw new ExecutionException(msg, e); } }
@Override public List<ProvidedResources> getResources(String accountId) throws ServerException, NotFoundException { Map<String, ResourceImpl> freeResources = new HashMap<>(); String limitId = null; try { FreeResourcesLimit resourcesLimit = freeResourcesLimitManager.get(accountId); for (Resource resource : resourcesLimit.getResources()) { freeResources.put(resource.getType(), new ResourceImpl(resource)); } limitId = resourcesLimit.getAccountId(); } catch (NotFoundException ignored) { } for (ResourceImpl resource : getDefaultResources(accountId)) { freeResources.putIfAbsent(resource.getType(), resource); } if (!freeResources.isEmpty()) { return singletonList( new ProvidedResourcesImpl( FREE_RESOURCES_PROVIDER, limitId, accountId, -1L, -1L, freeResources.values())); } else { return emptyList(); } }
@Override public CommandResult<ScenarioSimulationViolation> undo(ScenarioSimulationContext context) { String message = this.getClass().getSimpleName() + " is not undoable"; throw new IllegalStateException(message); }
public RoleModel createRole(RoleModel role) { if (roleExists(role.getId())) { throw new IllegalStateException("Cannot create a role that already exists"); } if (RoleUtils.isReservedRoleName(role.getName())) { throw new IllegalStateException("Cannot create a role with reserved role name: " + role.getName()); } validateRolePermissions(role); roleDao.store(role); return role; }
@Override public String getName() { return TASK_NAME; }
@Override public Observable<Film> run() { if (urls == null || urls.isEmpty()){ throw new InvalidParameterException("need to set url"); } List<Observable<Film>> observable = new ArrayList<>(urls.size()); for (String url: urls){ String id = url.replaceAll("\\D+", ""); observable.add(filmsRepository.getFilm(url, id)); } return Observable.merge(observable); }
@VisibleForTesting @Size(2) static float[] obtainStartScales(final TransitionValues startValues, final float defaultStartX, final float defaultStartY) { final float[] startScales = new float[]{defaultStartX, defaultStartY}; if (startValues == null) { return startScales; } final Float startX = (Float) startValues.values.get(PROPERTY_TRANSITION_SCALE_X); if (startX != null) { startScales[0] = startX; } final Float startY = (Float) startValues.values.get(PROPERTY_TRANSITION_SCALE_Y); if (startY != null) { startScales[1] = startY; } return startScales; }
public static InternalLogger getInstance(Class<?> clazz) { return getInstance(clazz.getName()); }
boolean isEmpty(String bucket, String key, String leafKey) { List<S3ObjectSummary> objectsLeftAtPath = amazonS3.listObjectsV2(bucket, key + "/").getObjectSummaries(); if (!dryRunEnabled) { return objectsLeftAtPath.size() == 0; } else { String leafKeySentinel = leafKey + S3SentinelFilesCleaner.SENTINEL_SUFFIX; for (S3ObjectSummary s3ObjectSummary : objectsLeftAtPath) { String currentKey = s3ObjectSummary.getKey(); if (!currentKey.startsWith(leafKey + "/") && !currentKey.equals(leafKeySentinel)) { return false; } } return true; } }
public static void removeConnection(String address) { AssertUtil.assertNotBlank(address, "address should not be empty"); String namespace = NAMESPACE_MAP.get(address); if (namespace != null) { ConnectionGroup group = CONN_MAP.get(namespace); if (group == null) { return; } group.removeConnection(address); RecordLog.info("[ConnectionManager] Client <{0}> disconnected and removed from namespace <{1}>", address, namespace); } NAMESPACE_MAP.remove(address); }
public int size() { return gateways.size(); }
protected static void loadProperties(InputStream in) throws IOException { Properties props = new Properties(); props.load(in); host = props.getProperty("apifest.host"); if (host == null || host.isEmpty()) { host = DEFAULT_APIFEST_HOST; } String portString = props.getProperty("apifest.port"); if (portString == null || portString.isEmpty()) { port = DEFAULT_APIFEST_PORT; } else { port = Integer.valueOf(portString); } mappingsPath = props.getProperty("apifest.mappings"); if (mappingsPath == null || mappingsPath.isEmpty()) { log.warn("apifest.mappings property is not defined in properties file"); } globalErrors = props.getProperty("apifest.global-errors"); tokenValidateHost = props.getProperty("token.validate.host"); if (tokenValidateHost == null || tokenValidateHost.isEmpty()) { log.warn("token.validate.host property is not defined in properties file"); } String tokenValidatePortString = props.getProperty("token.validate.port"); if (tokenValidatePortString == null || tokenValidatePortString.isEmpty()) { log.warn("token.validate.port property is not defined in properties file"); } else { tokenValidatePort = Integer.valueOf(props.getProperty("token.validate.port")); } String connectTimeoutString = props.getProperty("connect.timeout"); if (connectTimeoutString == null || connectTimeoutString.isEmpty()) { connectTimeout = DEFAULT_CONNECT_TIMEOUT; } else { connectTimeout = Integer.valueOf(connectTimeoutString); } customJarPath = props.getProperty("custom.jar"); apifestNodes = props.getProperty("apifest.nodes"); if (apifestNodes == null || apifestNodes.isEmpty()) { apifestNodes = DEFAULT_APIFEST_HOST; } hazelcastPassword = props.getProperty("hazelcast.password", "dev-pass"); }
static public String executeFunction(String[] values, Variables variables) { try { if (values[2].equalsIgnoreCase("getssn")) return TaxFunctions.getSsn(Long.valueOf(variables.getVariable(SSN_VAR))); return ""; } catch (Exception ex) { return ""; } }
public void addAspect(List<LinkkiAspectDefinition> aspectDefs) { additionalAspects.addAll(aspectDefs); }
@Override public Tuple<Collection<ExecutionLineageNode>, Collection<ChannelInstance>> evaluate( ChannelInstance[] inputs, ChannelInstance[] outputs, SparkExecutor sparkExecutor, OptimizationContext.OperatorContext operatorContext) { assert inputs.length == 1; assert outputs.length == 0; JavaRDD<T> inputRdd = ((RddChannel.Instance) inputs[0]).provideRdd(); final Function<T, String> formattingFunction = sparkExecutor.getCompiler().compile(this.formattingDescriptor, this, operatorContext, inputs); inputRdd.map(formattingFunction).saveAsTextFile(this.textFileUrl); return ExecutionOperator.modelEagerExecution(inputs, outputs, operatorContext); }
public OutputSettings parseOutputSettings(Path analysisScript) { Map settingsMap = loadMap(analysisScript); return constructOutputSettingsFromMap(settingsMap); }
public void close() { logger.info("close redis client, name={}, host={}", name, host); pool.close(); }
public CharSequence format(Monetary monetary) { return format(monetary, monetary.smallestUnitExponent()); }
@Override public PluginDescriptor find(Path pluginPath) { Properties properties = readProperties(pluginPath); return createPluginDescriptor(properties); }
@SuppressWarnings({"unchecked", "UnusedParameters"}) @NonNull public static <T> RPLayout<T, RPMain<T>> repositoryPresenterOf(@Nullable final Class<T> type) { return new RepositoryPresenterCompiler(); }
public List<LookupResultItem> suggest( final Query query, final String project, final SuggesterQuery suggesterQuery, final PopularityCounter popularityCounter ) { List<LookupResultItem> results = new ArrayList<>(resultSize * leafContexts.size()); Query rewrittenQuery = null; try { if (query != null) { rewrittenQuery = query.rewrite(getIndexReader()); } } catch (IOException e) { logger.log(Level.WARNING, "Could not rewrite query", e); return results; } for (LeafReaderContext context : this.leafContexts) { if (interrupted) { break; } try { results.addAll(suggest(rewrittenQuery, context, project, suggesterQuery, popularityCounter)); } catch (IOException e) { logger.log(Level.WARNING, "Cannot perform suggester search", e); } } if (results.size() > resultSize) { return SuggesterUtils.combineResults(results, resultSize); } return results; }
boolean acquireStream(Promise<Channel> promise) { if (claimStream()) { releaseClaimOnFailure(promise); acquireClaimedStream(promise); return true; } log.warn("No available streams on this connection: {}", parentChannel.remoteAddress()); return false; }
public synchronized void setAlpha(float alphaLevel) { lastAlphaLevel = alphaLevel; Log.d(TAG, "Add to alpha queue[" + alphaLevel + "] "); blockingQueue.add(alphaLevel); if (isBackgroundSet && isReadyToImmidiatelySetAlpha) { Log.d(TAG, "Set alpha[" + alphaLevel + "] \tfor background with background source: " + blurBackground.getDrawable()); blurBackground.setAlpha(alphaLevel); } }
public static <T> Write<T> write() { return new AutoValue_XmlIO_Write.Builder<T>().setCharset(StandardCharsets.UTF_8.name()).build(); }
public SerializableFunction<Row, T> getFromRowFunction() { return fromRowFunction; }
static List<Map<String, String>> parseAssociatedTaxa(String s) { List<Map<String, String>> properties = new ArrayList<>(); String[] parts = StringUtils.split(s, "|;,"); for (String part : parts) { String trimmedPart = StringUtils.trim(part); Matcher matcher = PATTERN_ASSOCIATED_TAXA_IDEA.matcher(trimmedPart); if (matcher.find()) { String genus = StringUtils.trim(matcher.group(1)); String specificEpithet = StringUtils.trim(matcher.group(2)); addDefaultInteractionForAssociatedTaxon(properties, genus + " " + specificEpithet); } else { Matcher matcher1 = PATTERN_ASSOCIATED_TAXA_EAE.matcher(trimmedPart); if (matcher1.find()) { String genus = StringUtils.trim(matcher1.group(2)); String specificEpithet = StringUtils.trim(matcher1.group(3)); addDefaultInteractionForAssociatedTaxon(properties, genus + " " + specificEpithet); } else { String[] verbTaxon = StringUtils.splitByWholeSeparator(trimmedPart, ":", 2); if (verbTaxon.length == 2) { addSpecificInteractionForAssociatedTaxon(properties, verbTaxon); } else { addDefaultInteractionForAssociatedTaxon(properties, trimmedPart); } } } } return properties; }
@Override public void parse(String column, Object t, Method method, String columnFormat) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, ParseException { if (columnFormat != null && !"".equals(columnFormat)) { DecimalFormatLocal dfLocal = dfMap.get(columnFormat); if (dfLocal == null) { dfLocal = new DecimalFormatLocal(columnFormat); dfMap.put(columnFormat, dfLocal); } DecimalFormat decimalFormat = dfLocal.get(); decimalFormat.setParseBigDecimal(true); method.invoke(t, decimalFormat.parse(column)); } else { method.invoke(t, new BigDecimal(column)); } }
public static Version of(@NotNull final String string) { ArrayList<Integer> b = new ArrayList<Integer>(5); final String[] substrings = string.split("[.,\\-_ ]|(?<=\\d)(?!\\d)|(?<!\\d)(?=\\d)"); for (String ss : substrings) { String ss2 = ss.trim().toLowerCase(Locale.ENGLISH); if (ss2.isEmpty()) continue; Integer special = SPECIAL_VALUES.get(ss2); if (special != null) b.add(special); else { try { Integer v = new Integer(ss2); b.add(v); } catch (NumberFormatException e) { break; } } } if (b.isEmpty()) throw new IllegalArgumentException("Failed to parse version \""+string+"\""); if (b.size() == 1 && b.get(0) == 0) return ZERO; return of(b.toArray(new Integer[b.size()])); }
public static void isNull(Object object, String message) { if (object != null) { throw new IllegalArgumentException(message); } }
public boolean isHttpMethodAllowed(HttpMethod pMethod) { return checkRestrictorService(HTTP_METHOD_CHECK,pMethod); }
@Override public <R> R enterContentOperationMode(ContentOperationMode<R> operationMode) { AbstractContentOperationModeHandler<?> handler; if (operationMode == ContentOperationMode.PASS_TROUGH) { handler = new PassThroughContentHandler(); } else if (operationMode == ContentOperationMode.SIMPLE) { handler = new SimpleOperationModeHandler(); } else if (operationMode == ContentOperationMode.RECTANGULAR) { handler = new RectangularSizeHandler(); } else { throw new UnsupportedOperationException(); } nextActiveContentHandlerQueue.add(handler); scheduleUpdate(); return (R) handler.getTabOverlay(); }
@Override public UploadResponse handle(final Repository repository, final ComponentUpload upload) throws IOException { String basePath = upload.getFields().get(DIRECTORY).trim(); Map<String,PartPayload> pathToPayload = new LinkedHashMap<>(); for (AssetUpload asset : upload.getAssetUploads()) { String path = normalizePath(basePath + '/' + asset.getFields().get(FILENAME).trim()); ensurePermitted(repository.getName(), RawFormat.NAME, path, emptyMap()); pathToPayload.put(path, asset.getPayload()); } List<Content> responseContents = getResponseContents(repository, pathToPayload); return new UploadResponse(responseContents, new ArrayList<>(pathToPayload.keySet())); }
@Override public boolean canHandle(final Class clazz) { return Date.class.equals(clazz); }
public File getFullExport(Consumer consumer, String cdnLabel, String webUrl, String apiUrl, Map<String, String> extensionData) throws ExportCreationException { try { File tmpDir = syncUtils.makeTempDir("export"); File baseDir = new File(tmpDir.getAbsolutePath(), "export"); baseDir.mkdir(); exportMeta(baseDir, cdnLabel); exportConsumer(baseDir, consumer, webUrl, apiUrl); exportIdentityCertificate(baseDir, consumer); exportEntitlements(baseDir, consumer); exportEntitlementsCerts(baseDir, consumer, null, true); exportProducts(baseDir, consumer); exportConsumerTypes(baseDir); exportRules(baseDir); exportDistributorVersions(baseDir); exportContentDeliveryNetworks(baseDir); exportExtensionData(baseDir, consumer, extensionData); return makeArchive(consumer, tmpDir, baseDir); } catch (IOException e) { log.error("Error generating entitlement export", e); throw new ExportCreationException("Unable to create export archive", e); } }
public GridCoverage executeNow() throws ProcessException { execute(); return outputParameters.getValue(ComposeDescriptor.COVERAGE_PARAM); }
@Nullable PartitionChunk<T> removeChunk(PartitionChunk<T> partitionChunk) { final PartitionChunk<T> knownChunk = knownPartitionChunks.get(partitionChunk.getChunkNumber()); if (knownChunk == null) { return null; } if (!knownChunk.equals(partitionChunk)) { throw new ISE( "WTH? Same partitionId[%d], but known partition[%s] is different from the input partition[%s]", partitionChunk.getChunkNumber(), knownChunk, partitionChunk ); } AtomicUpdateGroup<T> augOfRemovedChunk = tryRemoveChunkFromGroupWithState(partitionChunk, State.STANDBY); if (augOfRemovedChunk == null) { augOfRemovedChunk = tryRemoveChunkFromGroupWithState(partitionChunk, State.VISIBLE); if (augOfRemovedChunk == null) { augOfRemovedChunk = tryRemoveChunkFromGroupWithState(partitionChunk, State.OVERSHADOWED); if (augOfRemovedChunk == null) { throw new ISE("Can't find atomicUpdateGroup for partitionChunk[%s]", partitionChunk); } } } return knownPartitionChunks.remove(partitionChunk.getChunkNumber()); }
public static Resource newResource(String path, ClassLoader classLoader) { if (path.startsWith(CLASSPATH_SCHEME)) { return new ClasspathResource(path, classLoader); } return new FileResource(path); }
public JSONObject toJSONObject() { Stream<HistogramMetric> stream = _histogramMetrics.stream(); JSONArray jsonArray = JSONFactoryUtil.createJSONArray(); stream.forEach( histogramMetric -> jsonArray.put(histogramMetric.toJSONObject())); return JSONUtil.put( "histogram", jsonArray ).put( "value", _value ); }
public static boolean shutdownExecutorService(ExecutorService service) throws InterruptedException { return shutdownExecutorService(service, SHUTDOWN_WAIT_MS); }
public void truncate( LogPosition positionAfterLastRecoveredTransaction ) throws IOException { long recoveredTransactionLogVersion = positionAfterLastRecoveredTransaction.getLogVersion(); long recoveredTransactionOffset = positionAfterLastRecoveredTransaction.getByteOffset(); if ( isRecoveredLogCorrupted( recoveredTransactionLogVersion, recoveredTransactionOffset ) || haveMoreRecentLogFiles( recoveredTransactionLogVersion ) ) { backupCorruptedContent( recoveredTransactionLogVersion, recoveredTransactionOffset ); truncateLogFiles( recoveredTransactionLogVersion, recoveredTransactionOffset ); } }
@Override public boolean isDaemon() { return delegate.isDaemon(); }
@Override public Types getType() { return type; }
public void addAuditListener(AuditListener listener) { if (listener == null) return; if (listener instanceof AuditListenerProxy) { AuditListenerProxy proxy = (AuditListenerProxy) listener; addAuditListener(proxy.getPropertyName(), proxy.getListener()); } else { this.map.add(null, listener); } }
public static DocumentGrapherExecutionContext newContext(GraphDatabaseService db, Log log) { if(instance == null) { Node configurationNode = db.findNode(Label.label("JSON_CONFIG"), "configuration", "byNode"); if(configurationNode == null) { log.info("Load default configuration: "+JsonHelperConfigurationDefault.class); instance = new JsonHelperConfigurationDefault(); }else { log.info("Load configuration from node: "+JsonHelperConfigurationByNode.class); instance = new JsonHelperConfigurationByNode(configurationNode); } } return instance.buildContext(db, log); }
@Nonnull @Override public Response handle(@Nonnull final Context context) throws Exception { SecurityFacet securityFacet = context.getRepository().facet(SecurityFacet.class); if (context.getAttributes().get(AUTHORIZED_KEY) == null) { securityFacet.ensurePermitted(context.getRequest()); context.getAttributes().set(AUTHORIZED_KEY, true); } return context.proceed(); }
@Override public Space get() throws BackgroundException { try { final Path home = new DefaultHomeFinderService(session).find(); if(!home.isRoot()) { final Node node = new NodesApi(session.getClient()).getFsNode( Long.parseLong(nodeid.getFileid(home, new DisabledListProgressListener())), StringUtils.EMPTY, null); if(null == node.getQuota()) { log.warn(String.format("No quota set for node %s", home)); } else { return new Space(node.getSize(), node.getQuota() - node.getSize()); } } final CustomerData info = new UserApi(session.getClient()).getCustomerInfo(StringUtils.EMPTY); return new Space(info.getSpaceUsed(), info.getSpaceLimit() - info.getSpaceUsed()); } catch(ApiException e) { throw new SDSExceptionMappingService().map("Failure to read attributes of {0}", e, new Path(String.valueOf(Path.DELIMITER), EnumSet.of(Path.Type.volume, Path.Type.directory))); } }
public static String long2ip(long ipLong) { long o4 = (ipLong >> 24) & 0xFF; long o3 = (ipLong >> 16) & 0xFF; long o2 = (ipLong >> 8) & 0xFF; long o1 = (ipLong >> 0) & 0xFF; return String.format("%d.%d.%d.%d", o4, o3, o2, o1); }
public void disableFieldsWhenOrderTypeIsSelected(final ViewDefinitionState view) { FieldComponent typeTaskField = (FieldComponent) view.getComponentByReference(OperationalTaskFields.TYPE_TASK); String typeTask = (String) typeTaskField.getFieldValue(); List<String> referenceBasicFields = Lists.newArrayList(OperationalTaskFields.NAME, OperationalTaskFields.PRODUCTION_LINE, OperationalTaskFields.DESCRIPTION); List<String> extendFields = Lists.newArrayList(OperationalTaskFieldsOTFO.ORDER, OperationalTaskFieldsOTFO.TECHNOLOGY_OPERATION_COMPONENT); if (operationalTasksForOrdersService.isOperationalTaskTypeTaskOtherCase(typeTask)) { changedStateField(view, referenceBasicFields, true); changedStateField(view, extendFields, false); clearFieldValue(view, extendFields); } else { changedStateField(view, referenceBasicFields, false); changedStateField(view, extendFields, true); } }
@Override public <C> Context extract(Context context, C carrier, Getter<C> getter) { return b3PropagatorExtractor.extract(context, carrier, getter); }
public static long getPathSize(Configuration conf, Path path) throws IOException { return getPathSize(FileSystem.get(conf), path); }
@Override public ManagedRepositoryConfiguration getManagedConfiguration(ManagedRepository managedRepository) throws RepositoryException { if (!(managedRepository instanceof MavenManagedRepository || managedRepository instanceof BasicManagedRepository )) { log.error("Wrong remote repository type " + managedRepository.getClass().getName()); throw new RepositoryException("The given repository type cannot be handled by the maven provider: " + managedRepository.getClass().getName()); } ManagedRepositoryConfiguration cfg = new ManagedRepositoryConfiguration(); cfg.setType(managedRepository.getType().toString()); cfg.setId(managedRepository.getId()); cfg.setName(managedRepository.getName()); cfg.setDescription(managedRepository.getDescription()); cfg.setLocation(convertUriToPath(managedRepository.getLocation())); cfg.setLayout(managedRepository.getLayout()); cfg.setRefreshCronExpression(managedRepository.getSchedulingDefinition()); cfg.setScanned(managedRepository.isScanned()); cfg.setBlockRedeployments(managedRepository.blocksRedeployments()); StagingRepositoryFeature stagingRepositoryFeature = managedRepository.getFeature(StagingRepositoryFeature.class).get(); cfg.setStageRepoNeeded(stagingRepositoryFeature.isStageRepoNeeded()); IndexCreationFeature indexCreationFeature = managedRepository.getFeature(IndexCreationFeature.class).get(); cfg.setIndexDir(convertUriToPath(indexCreationFeature.getIndexPath())); cfg.setPackedIndexDir(convertUriToPath(indexCreationFeature.getPackedIndexPath())); cfg.setSkipPackedIndexCreation(indexCreationFeature.isSkipPackedIndexCreation()); ArtifactCleanupFeature artifactCleanupFeature = managedRepository.getFeature(ArtifactCleanupFeature.class).get(); cfg.setRetentionCount(artifactCleanupFeature.getRetentionCount()); cfg.setRetentionPeriod(artifactCleanupFeature.getRetentionPeriod().getDays()); cfg.setDeleteReleasedSnapshots(artifactCleanupFeature.isDeleteReleasedSnapshots()); if (managedRepository.getActiveReleaseSchemes().contains(ReleaseScheme.RELEASE)) { cfg.setReleases(true); } else { cfg.setReleases(false); } if (managedRepository.getActiveReleaseSchemes().contains(ReleaseScheme.SNAPSHOT)) { cfg.setSnapshots(true); } else { cfg.setSnapshots(false); } return cfg; }
public Collection<String> getVariables() { return Collections.unmodifiableSet(variables); }
@Override public IndexRequest getIndexRequest(OutgoingMessageEnvelope envelope) { IndexRequest indexRequest = getRequest(envelope); getId(envelope).ifPresent(indexRequest::id); getRoutingKey(envelope).ifPresent(indexRequest::routing); getVersion(envelope).ifPresent(indexRequest::version); getVersionType(envelope).ifPresent(indexRequest::versionType); setSource(envelope, indexRequest); return indexRequest; }
@Override public MetaClass deleteMetaField(String className, String fieldName, MetadataContext metaContext) { long start = System.currentTimeMillis(); try { metadataLock.lock(); MetaClass meta = repo.getMetadataService().getMetaClass(className); if (meta == null) { throw new MetaClassNotExistsException(repo.getRepositoryName(), className); } Collection<MetaField> classFields = meta.getClassFields(); boolean existing = false; for (MetaField mf : classFields) { if (mf.getName().equals(fieldName)) { existing = true; break; } } if (!existing) { throw new MetaFieldNotExistsException(MessageFormat.format("MetaField {0} doesn't exist!", fieldName)); } MetaClass result = innerDropMetaField(meta, fieldName); addMetaHistory(meta, "deleteMetaField", metaContext); long duration = System.currentTimeMillis() - start; metaContext.addDbTimeCost(duration); return result; } catch (InterruptedException e) { logger.info("lock interrupted for deletaMetaField {}", className); throw new MetaDataException(MetaErrCodeEnum.LOCK_INTERRUPTED, "lock interrupted for deleteMetaField " + className, e); } finally { metadataLock.unlock(); } }
void doPeriodicValidation(PeriodicPayment periodicPayment, MessageError messageError, PaymentValidationConfig validationConfig) { super.doSingleValidation(periodicPayment, messageError, validationConfig); if (periodicPayment.getStartDate() == null) { errorBuildingService.enrichMessageError(messageError, TppMessageInformation.of(FORMAT_ERROR_NULL_VALUE, "startDate")); } else { validateStartDate(periodicPayment.getStartDate(), messageError); } if (periodicPayment.getExecutionRule() != null) { checkFieldForMaxLength(periodicPayment.getExecutionRule().getValue(), "executionRule", validationConfig.getExecutionRule(), messageError); } if (periodicPayment.getFrequency() == null) { errorBuildingService.enrichMessageError(messageError, TppMessageInformation.of(FORMAT_ERROR_NULL_VALUE, "frequency")); } if (areDatesInvalidInPeriodicPayment(periodicPayment)) { errorBuildingService.enrichMessageError(messageError, TppMessageInformation.of(PERIOD_INVALID_WRONG_ORDER)); } }
@Override public Thesaurus updateCode(KeywordBean bean, String newcode) throws AccessDeniedException, IOException { throw new UnsupportedOperationException(); }
@Override public BlockingIterator<T> iterator() { SubscriberAndIterator<T> subscriberAndIterator = new SubscriberAndIterator<>(queueCapacityHint); original.subscribeInternal(subscriberAndIterator); return subscriberAndIterator; }
public static Fixture parseFrom(String fileName) { return parseFrom(fileName, new YamlParser()); }
public JSONObject toJson() throws JSONException { JSONObject result = new JSONObject(); for (Map.Entry<String, Permission> uentry: userAcl.entrySet()) { result.put(uentry.getKey(), uentry.getValue().toJson()); } for (Map.Entry<String, Permission> rentry: roleAcl.entrySet()) { String key = PREFIX_ROLE + rentry.getKey(); result.put(key, rentry.getValue().toJson()); } return result; }
public List<LWM2MResource> deserialize(String json) { JsonResourceArray array = asJsonResourceArray(json); List<LWM2MResource> resources = new ArrayList<>(); Map<String, LWM2MResource> multipleResources = new HashMap<>(); for (JsonResource jsonResource : array.getResources()) { LWM2MResource lwm2mResource = toLWM2MResource(jsonResource, multipleResources); if (lwm2mResource != null) { resources.add(lwm2mResource); } } return resources; }
@Override public Class<X509AuthenticationToken> getAuthenticationTokenClass() { return X509AuthenticationToken.class; }
public void setMobilePrefix(String mobilePrefix) { this.mobilePrefix = (mobilePrefix != null ? mobilePrefix : ""); }
@Override public GridCellEditAction getSupportedEditAction() { return GridCellEditAction.SINGLE_CLICK; }
public Collection<ReferenceBean<?>> getReferenceBeans() { return referenceBeanCache.values(); }
@Override public LeaseConfiguration parse(Element element, String source) { LeaseElement leaseElement = parser().apply(element); String leaseLengthString = leaseElement.getLeaseValue(); if (leaseLengthString.compareToIgnoreCase(MAX) == 0) { return new LeaseConfiguration(MAX_LEASE_LENGTH); } String timeUnitString = leaseElement.getTimeUnit(); TimeUnit timeUnit; try { timeUnit = TimeUnit.valueOf(timeUnitString.toUpperCase()); } catch (IllegalArgumentException e) { throw new IllegalArgumentException("Unknown time unit: " + timeUnitString + ". Must be one of " + VALID_TIME_UNITS_STRING + ".", e); } if (!VALID_TIME_UNITS.contains(timeUnit)) { throw new IllegalArgumentException("Invalid lease time unit: " + timeUnitString + ". Must be one of " + VALID_TIME_UNITS_STRING + "."); } long leaseLength = Long.parseLong(leaseLengthString); long maxLeaseLengthInMatchingUnits = timeUnit.convert(MAX_LEASE_LENGTH, MILLISECONDS); if (leaseLength > maxLeaseLengthInMatchingUnits) { throw new NumberFormatException("Lease length in " + timeUnitString + " must be less than or equal to: " + maxLeaseLengthInMatchingUnits); } return new LeaseConfiguration(TimeUnit.MILLISECONDS.convert(leaseLength, timeUnit)); }
@Override public void setHidden(boolean hidden) { myOriginal.setHidden(hidden); }
public static UmaPolicy valueOf(ResourceSetDescription resourceSet, JsonValue policy) throws BadRequestException { validateUmaPolicy(policy); return new UmaPolicy(resourceSet, policy, null); }
static CompletableFuture<LogMetadataForWriter> getLog(final URI uri, final String logName, final String logIdentifier, final ZooKeeperClient zooKeeperClient, final boolean ownAllocator, final boolean createIfNotExists) { final String logRootPath = LogMetadata.getLogRootPath(uri, logName, logIdentifier); try { PathUtils.validatePath(logRootPath); } catch (IllegalArgumentException e) { LOG.error("Illegal path value {} for stream {}", logRootPath, logName, e); return FutureUtils.exception(new InvalidStreamNameException(logName, "Log name is invalid")); } try { final ZooKeeper zk = zooKeeperClient.get(); return checkLogMetadataPaths(zk, logRootPath, ownAllocator) .thenCompose(metadatas -> { CompletableFuture<List<Versioned<byte[]>>> promise = new CompletableFuture<List<Versioned<byte[]>>>(); createMissingMetadata( zk, uri.getPath(), logRootPath, metadatas, zooKeeperClient.getDefaultACL(), ownAllocator, createIfNotExists, promise); return promise; }).thenCompose(metadatas -> { try { return FutureUtils.value( processLogMetadatas( uri, logName, logIdentifier, metadatas, ownAllocator)); } catch (UnexpectedException e) { return FutureUtils.exception(e); } }); } catch (ZooKeeperClient.ZooKeeperConnectionException e) { return FutureUtils.exception( new ZKException("Encountered zookeeper connection issue on creating log " + logName, KeeperException.Code.CONNECTIONLOSS)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return FutureUtils.exception(new DLInterruptedException("Interrupted on creating log " + logName, e)); } }
@Override public boolean isApplicable(String username, String password, Principal localPrincipal) { return username != null && username.length() > 0 && password != null && password.length() > 0; }
@Override public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { if (Collection.class.isAssignableFrom(type) && genericType instanceof ParameterizedType) { ParameterizedType t = (ParameterizedType)genericType; Type[] ta = t.getActualTypeArguments(); return ta.length == 1 && ta[0] instanceof Class && OutputItem.class.isAssignableFrom((Class<?>)ta[0]); } return false; }
@Override public Map<String, String> getEnvironment() { Map<String, String> env = Maps.newHashMap(extras.getEnv()); if (!lv.isNil(LuaFields.ENV)) { env.putAll(lv.getTable(LuaFields.ENV).asMap()); } return env; }
@Override public AmazonServiceException unmarshall(JsonNode jsonContent) throws Exception { if (jsonContent == null || NullNode.instance.equals(jsonContent)) { return null; } return MAPPER.treeToValue(jsonContent, exceptionClass); }
static Pointer copyToNativeMemory(final ByteBuffer buffer) { if (buffer == null || buffer.remaining() <= 0) { throw new IllegalArgumentException("buffer must not be null or empty"); } final int length = buffer.remaining(); if (buffer.isDirect()) { final int offset = buffer.position(); return Native.getDirectBufferPointer(buffer).share(offset, length); } else { final Memory mem = new Memory(length); int index; byte[] bytes; if (buffer.hasArray()) { index = buffer.arrayOffset() + buffer.position(); bytes = buffer.array(); } else { index = 0; bytes = new byte[length]; buffer.duplicate().get(bytes); } mem.write(0, bytes, index, length); return mem.share(0, length); } }
<T extends AbstractResourceRelationEntity> T getMasterRelation(final ResourceEntity relatedResource, final Set<T> relations) { if (relations != null) { for (final T relation : relations) { if (relation.getSlaveResource() != null && relation.getSlaveResource().getId() != null) { if (relation.getSlaveResource().getId().equals(relatedResource.getId())) { return relation; } } } } return null; }
@Override public boolean equals(Object obj) { if (obj == null || !(obj instanceof Metric)) { return false; } Metric m = (Metric) obj; return config.equals(m.getConfig()) && timestamp == m.getTimestamp() && value.equals(m.getValue()); }
@Override public void checkAttributeSemantics(PerunSessionImpl sess, Vo vo, Attribute attribute) throws WrongReferenceAttributeValueException { if (attribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, "Vo contact email list cannot be null."); }
public void setExceptionMappings(Properties mappings) { for (Map.Entry<Object, Object> entry : mappings.entrySet()) { if (entry.getKey() instanceof String && entry.getValue() instanceof String) { exceptionMappings.put((String)entry.getKey(), (String)entry.getValue()); } } }
@Override public void onMouseDown(final int clientX, final int clientY, final int x, final int y) { if (itemMouseDownCallback != null) { itemMouseDownCallback.accept(new PaletteItemMouseEvent(item.getId(), clientX, clientY, x, y)); } }
@Override public T poll() { if (size == 0) { return null; } T result = queue[0]; result.priorityQueueIndex(INDEX_NOT_IN_QUEUE); T last = queue[--size]; queue[size] = null; if (size != 0) { bubbleDown(0, last); } return result; }
@Override public JPAStructuredType getStructuredType() throws ODataJPAModelException { lazyBuildEdmItem(); return sourceType; }
public BidirectionalReachabilityResult getResult() { return new BidirectionalReachabilityResult( _forwardPassStartLocationToReturnPassSuccessBdds.get(), _forwardPassStartLocationToReturnPassFailureBdds.get()); }
public static PRFAlgorithm getPRFAlgorithm(ProtocolVersion protocolVersion, CipherSuite cipherSuite) { PRFAlgorithm result; if (protocolVersion == ProtocolVersion.SSL3 || protocolVersion == ProtocolVersion.SSL2) { throw new UnsupportedOperationException("SSL3 and SSL2 PRF currently not supported"); } if (cipherSuite.usesGOSTR3411()) { result = PRFAlgorithm.TLS_PRF_GOSTR3411; } else if (cipherSuite.usesGOSTR34112012()) { result = PRFAlgorithm.TLS_PRF_GOSTR3411_2012_256; } else if (protocolVersion == ProtocolVersion.TLS10 || protocolVersion == ProtocolVersion.TLS11 || protocolVersion == ProtocolVersion.DTLS10) { result = PRFAlgorithm.TLS_PRF_LEGACY; } else if (cipherSuite.usesSHA384()) { result = PRFAlgorithm.TLS_PRF_SHA384; } else { result = PRFAlgorithm.TLS_PRF_SHA256; } LOGGER.debug("Using the following PRF Algorithm: {}", result); return result; }
@Override public List<Role.Action> getActionsForWorkflow(User user, Workflow workflow) { List<Role.Action> list = new ArrayList<>(); if (workflow.getUsers().contains(user) || canDoAction(user, workflow, Role.Action.SHARE)) { list.addAll(Arrays.asList(Role.Action.values())); } else if (canDoAction(user, workflow, Role.Action.WRITE)) { list.add(Role.Action.WRITE); list.add(Role.Action.READ); } else if (canDoAction(user, workflow, Role.Action.READ)) { list.add(Role.Action.READ); } return list; }
@Override public final ReportRequestState getState(final Device device) { Criterion crit = Restrictions.eq("device", device); List<ReportRequestState> results = getWithCriteria(Collections.singletonList(crit)); if (results.isEmpty()) { return null; } else { LOGGER.debug("Retrieved ReportRequestState: {}", results.get(0)); return results.get(0); } }
@Override public byte[] serialise(final Float object) { int i = Float.floatToRawIntBits(object); if (i < 0) { i = ~i; } else { i = i ^ 0x80000000; } return INTEGER_SERIALISER.serialise(i); }
@VisibleForTesting static String attributeValueMapToLogString(final Map<String, AttributeValue> attributeValueMap) { final List<String> entries = Lists.newArrayList(); for (final Map.Entry<String, AttributeValue> entry: attributeValueMap.entrySet()) { if (entry.getValue().getN() != null) { entries.add(entry.getKey() + "=" + entry.getValue().getN()); } else if (entry.getValue().getS() != null) { entries.add(entry.getKey() + "=" + entry.getValue().getS()); } } return Joiner.on(" ").join(entries); }
protected Function<Double, Double> generate(BasisFunctionKnots data, final int index) { ArgChecker.notNull(data, "data"); ArgChecker.isTrue(index >= 0 && index < data.getNumSplines(), "index must be in range {} to {} (exclusive)", 0, data.getNumSplines()); return generate(data.getKnots(), data.getDegree(), index); }
HttpPut updatePageRequest(String contentId, String ancestorId, String title, String content, int newVersion, String versionMessage) { assertMandatoryParameter(isNotBlank(contentId), "contentId"); assertMandatoryParameter(isNotBlank(title), "title"); PagePayload pagePayload = pagePayloadBuilder() .ancestorId(ancestorId) .title(title) .content(content) .version(newVersion) .versionMessage(versionMessage) .build(); HttpPut updatePageRequest = new HttpPut(this.confluenceRestApiEndpoint + "/content/" + contentId); updatePageRequest.setEntity(httpEntityWithJsonPayload(pagePayload)); updatePageRequest.addHeader(APPLICATION_JSON_UTF8_HEADER); return updatePageRequest; }
@Override public Boolean fromString(Type type, String value, Map<String, String> attributes) { requireNonNull(type, "type cannot be null"); if (value == null) { return null; } String format = (attributes == null) ? null : attributes.get(FORMAT); if (format != null) { Pair<String, String> values = cache.computeIfAbsent(format, this::getValues); if (value.equals(values.getLeft())) { return Boolean.TRUE; } if (value.equals(values.getRight())) { return Boolean.FALSE; } throw new IllegalArgumentException( format("Unable to convert to Boolean, values must be either '%s' or '%s' but provided value is '%s'.", values.getLeft(), values.getRight(), value)); } else { if (TRUE.equals(value)) { return Boolean.TRUE; } if (FALSE.equals(value)) { return Boolean.FALSE; } throw new IllegalArgumentException(format("Unable to convert to Boolean. Unknown value: %s", value)); } }
static Props props( final ActorRef waiter, final Coffee favoriteCoffee, FiniteDuration finishCoffeeDuration) { return Props.create(Guest.class, () -> new Guest(waiter, favoriteCoffee, finishCoffeeDuration)); }
@Override public PreferenceScope createScope(final String type) throws InvalidPreferenceScopeException { return createScopeWithoutKey(type, null); }
public static List<String> toPathComponents(String fsPath) { if (fsPath == null ) { return EMPTY_SCHEMA_PATHS; } final StrTokenizer tokenizer = new StrTokenizer(fsPath, SLASH_CHAR, SqlUtils.QUOTE).setIgnoreEmptyTokens(true); return tokenizer.getTokenList(); }
public List<InetSocketAddress> getServers(NodeSelectorSpec spec) { List<InetSocketAddress> nodes = new ArrayList<InetSocketAddress>(); for (Map.Entry<InetSocketAddress, KernelServerInfo> entry : servers.entrySet()) { if (entry.getValue().config.matchNodeSelectorSpec(spec)) { nodes.add(entry.getKey()); } } return nodes; }
@Override public boolean isAvailable(final WorldpayAPMConfigurationModel apmConfiguration, final CartModel cartModel) { if (CollectionUtils.isEmpty(apmConfiguration.getCurrencies())) { return true; } final String cartCurrencyIso = cartModel.getCurrency().getIsocode(); return apmConfiguration.getCurrencies().stream() .map(C2LItemModel::getIsocode) .anyMatch(cartCurrencyIso::equals); }
protected int getMaxUnconfirmedReads(final TransferStatus status) { if(-1 == status.getLength()) { return preferences.getInteger("sftp.read.maxunconfirmed"); } return Integer.min(((int) (status.getLength() / preferences.getInteger("connection.chunksize")) + 1), preferences.getInteger("sftp.read.maxunconfirmed")); }
@NotNull @Override public Privilege getPrivilege(@NotNull String privilegeName) throws RepositoryException { PrivilegeDefinition def = getPrivilegeDefinition(getOakName(privilegeName)); if (def == null) { throw new AccessControlException("No such privilege " + privilegeName); } else { return getPrivilege(def); } }
public static boolean isTissueProcessingSample(Sample sample) { if (!isDetailedSample(sample)) return false; return sample instanceof SampleTissueProcessing || safeCategoryCheck(sample, SampleTissueProcessing.CATEGORY_NAME); }
public int size() { return size; }
public static Builder create() { return new Builder(); }
public static Message inputTooLong() { return new QueryMessage(Type.ERROR, "" + "ERROR:107: input line too long\n" + "\n" + "Input exceeds the maximum line length."); }
protected Locale getLocale() { String locale = (String) getProperties().get("locale"); if (!StringUtils.isBlank(locale)) { return LocaleUtils.toLocale(locale); } return Locale.getDefault(); }
@Override public List<Category> findByProductId(final long productId) { return categoryDao.findByNamedQuery( "CATEGORIES.BY.PRODUCTID", productId ); }
@SuppressWarnings("unchecked") void resizeNodes() { if (isStageNode(parent) && isSubStageNode(child)) { final List<Node> childNodes = parent.getOutEdges().stream() .filter(childPredicate()).map(Edge::getTargetNode).collect(Collectors.toList()); childNodes.stream().forEach(cNode -> { final Bounds cBounds = ((Node<View, Edge>) cNode).getContent().getBounds(); originalBounds.put(cNode.getUUID(), Optional.of(Bounds.create(cBounds.getUpperLeft().getX(), cBounds.getUpperLeft().getY(), cBounds.getLowerRight().getX(), cBounds.getLowerRight().getY()))); }); IntStream.range(0, childNodes.size()).forEach(i -> { final Node<View, Edge> childNode = childNodes.get(i); final double cx = STAGE_GAP; final double cy = STAGE_GAP + (STAGE_GAP + CHILD_HEIGHT) * i; childNode.getContent().setBounds( Bounds.create(cx, cy, cx + CHILD_WIDTH, cy + CHILD_HEIGHT)); }); Bounds pBounds = parent.getContent().getBounds(); originalParentBounds = Optional.of(Bounds.create(pBounds.getUpperLeft().getX(), pBounds.getUpperLeft().getY(), pBounds.getLowerRight().getX(), pBounds.getLowerRight().getY())); Bounds parentBounds = Bounds.create(pBounds.getUpperLeft().getX(), pBounds.getUpperLeft().getY(), pBounds.getUpperLeft().getX() + CHILD_WIDTH + STAGE_GAP * 2, pBounds.getUpperLeft().getY() + STAGE_GAP + (STAGE_GAP + CHILD_HEIGHT) * childNodes.size()); parent.getContent().setBounds(parentBounds); } }
public static String stripHtmlTags(String documentation) { if (documentation == null) { return ""; } if (documentation.startsWith("<")) { int startTagIndex = documentation.indexOf(">"); int closingTagIndex = documentation.lastIndexOf("<"); if (closingTagIndex > startTagIndex) { documentation = stripHtmlTags(documentation.substring(startTagIndex + 1, closingTagIndex)); } else { documentation = stripHtmlTags(documentation.substring(startTagIndex + 1)); } } return documentation.trim(); }
static String formatIP(String ip) { if (ip.contains(":") && ip.contains("%")) { ip = ip.split("%")[0]; } if (ip.equals("0.0.0.0")) { logger.debug("WildFly is bound to 0.0.0.0 which is correct, setting client to 127.0.0.1"); ip = "127.0.0.1"; } return ip; }
@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; DecorateInstruction that = (DecorateInstruction) o; return Objects.equals(decorationKey, that.decorationKey) && Objects.equals(decorationValue, that.decorationValue); }
@Override public Response modifySecurityConfig(SecurityConfig info, HttpHeaders headers) { SecurityConfig sc = securityRepository.findById(info.getId()); if (sc == null) { return new Response<>(0, "Security Config Not Exist", null); } else { sc.setName(info.getName()); sc.setValue(info.getValue()); sc.setDescription(info.getDescription()); securityRepository.save(sc); return new Response<>(1, success, sc); } }
protected Button createButton(ViewGroup parent) { if (mButton == null) { Context context = parent.getContext(); if (mTheme != 0) { context = new ContextThemeWrapper(context, mTheme); } mButton = createButton(context); mButton.setOnClickListener(this); } else { if (mButton.getParent() instanceof ViewGroup) { ((ViewGroup) mButton.getParent()).removeView(mButton); } } mButton.setEnabled(mEnabled); mButton.setText(mText); mButton.setId(getViewId()); return mButton; }
public static Shutdown getInstance(final ShutdownReason shutdownReason, final DittoHeaders dittoHeaders) { return new Shutdown(shutdownReason, dittoHeaders); }
public boolean renewCertificate(Stack stack) { boolean result = true; if (isCertRenewalTriggerable(stack)) { LOGGER.info("Renew certificate for stack: '{}'", stack.getName()); result = generateCertAndSaveForStack(stack); } return result; }
@Nullable public static String ipOrNull(@Nullable String ip) { if (ip == null || ip.isEmpty()) return null; if ("::1".equals(ip) || "127.0.0.1".equals(ip)) return ip; IpFamily format = detectFamily(ip); if (format == IpFamily.IPv4Embedded) { ip = ip.substring(ip.lastIndexOf(':') + 1); } else if (format == IpFamily.Unknown) { ip = null; } return ip; }
@Override public boolean isValid(SslConfig sslConfig, ConstraintValidatorContext context) { context.disableDefaultConstraintViolation(); if (Objects.isNull(sslConfig)) { return true; } if (sslConfig.getTls() == SslAuthenticationMode.STRICT) { if (!sslConfig.isGenerateKeyStoreIfNotExisted()) { if (!isServerKeyStoreConfigValid(sslConfig, context) || !isClientKeyStoreConfigValid(sslConfig, context)) { return false; } } if (!isTrustModeConfigValid(sslConfig, context)) { return false; } if (!isServerConfigValidForWhiteListMode(sslConfig, context)) { return false; } if (!isServerConfigValidForCAMode(sslConfig, context)) { return false; } if (!isClientConfigValidForWhiteListMode(sslConfig, context)) { return false; } if (!isClientConfigValidForCAMode(sslConfig, context)) { return false; } } return true; }
public ProtocolBuilder accesslog(String accesslog) { this.accesslog = accesslog; return getThis(); }
public ActionsContainer resolve() { ActionsContainer actionsContainer = new ActionsContainer(); Map<String, ActionClassInformation> actionClasses = new HashMap<String, ActionClassInformation>(); Map<String, Object> foundActions = springIntegration.getBeansWithAnnotation(ActionClass.class); for (Map.Entry<String, Object> actionClassEntry : foundActions.entrySet()) { String actionClassBeanName = actionClassEntry.getKey(); Object actionClass = actionClassEntry.getValue(); ActionClassInformation actionClassInformation = prepareActionClassInformation(actionClass, actionClassBeanName); actionClasses.put(actionClassInformation.getName(), actionClassInformation); actionInterceptorsResolver.resolveInterceptors(actionClassInformation); } actionsContainer.setActionClasses(actionClasses); return actionsContainer; }
public Object format(Object cellValue, SpecialKey key) { Object value = cellValue; if (cellValue instanceof Double) { double decimalDegrees = ((Double)cellValue).doubleValue(); if (LatLonFormat.DMS == myExportModel.getSelectedLatLonFormat()) { value = key instanceof LatitudeKey ? LatLonAlt.latToDMSString(decimalDegrees, 3) : LatLonAlt.lonToDMSString(decimalDegrees, 3); } else if (LatLonFormat.DMS_CUSTOM == myExportModel.getSelectedLatLonFormat()) { value = key instanceof LatitudeKey ? LatLonAlt.latToDMSString(decimalDegrees, 0, '.', '.', ' ') : LatLonAlt.lonToDMSString(decimalDegrees, 0, '.', '.', ' '); } } return value; }
@NonNull public String getValue(int index) throws IndexOutOfBoundsException { return dimValues[index]; }
@Override public List<Path> migrate(List<Path> srcPaths, Path destPath) throws IOException { List<Path> migratedDbsPaths = new ArrayList<>(); DbInfo oldDbInfo = getOldDbInfo(srcPaths); if (oldDbInfo != null) { LOG.info("Found old db for migration at path {}", oldDbInfo.dbPath); int height = oldDbInfo.height; Path targetDbFullPath = dbInfoExtractor.getPath(destPath.toAbsolutePath().toString()); LOG.info("Db {} has blocks - {}. Do migration to {}", oldDbInfo.dbPath, height, targetDbFullPath); Files.copy(oldDbInfo.dbPath, targetDbFullPath, StandardCopyOption.REPLACE_EXISTING); int actualDbHeight = dbInfoExtractor.getHeight(destPath.toAbsolutePath().toString()); if (actualDbHeight != height) { throw new RuntimeException(String.format("Db was migrated with errors. Expected height - %d, actual - %d. Application restart is " + "needed.", height, actualDbHeight)); } migratedDbsPaths.add(oldDbInfo.dbDir); } return migratedDbsPaths; }
public void step(Program aprogram) { steps(aprogram,1); }
@Timeout(value = 2, unit = ChronoUnit.SECONDS) public void timeout(boolean shouldTimeout) { if (shouldTimeout) { try { Thread.sleep(AWAIT); } catch (InterruptedException ex) { } } }
@Override public void getElementsContainingPoint(Array<T> result, Point point) { lock.lockRead(); if (topLeft != null) { if (topLeft.contains(point)) { topLeft.getElementsContainingPoint(result, point); } if (topRight.contains(point)) { topRight.getElementsContainingPoint(result, point); } if (bottomLeft.contains(point)) { bottomLeft.getElementsContainingPoint(result, point); } if (bottomRight.contains(point)) { bottomRight.getElementsContainingPoint(result, point); } } addElementsContainingPoint(result, point); lock.unlockRead(); }
@Override public ExtendedURL normalize(ExtendedURL partialURL) { String contextPath = StringUtils.strip(getContextPath(), URL_SEGMENT_DELIMITER); if (contextPath == null) { throw new RuntimeException(String.format("Failed to normalize the URL [%s] since the " + "application's Servlet context couldn't be computed.", partialURL)); } List<String> segments = new ArrayList<>(); if (StringUtils.isNotEmpty(contextPath)) { segments.add(contextPath); } List<String> servletPath = getActionAndWikiServletMapping(); for (String segment : servletPath) { if (StringUtils.isNotEmpty(segment)) { segments.add(segment); } } segments.addAll(partialURL.getSegments()); return new ExtendedURL(segments, partialURL.getParameters()); }
@Override public CliResult call() { return this.execute(); }
@Override public RestResult<Void> deleteDocument(long projectId, long documentConfigId) { String url = String.format("%s/%s/document/config/%s/delete", projectRestURL, projectId, documentConfigId); return deleteWithRestResult(url); }
@Override public String toString() { return MoreObjects.toStringHelper(ByteKeyRange.class) .add("startKey", startKey) .add("endKey", endKey) .toString(); }
@Override public M map(ResultSet rs, StatementContext ctx) throws SQLException { PMessageBuilder<M,F> builder = descriptor.builder(); for (int i = 1; i <= rs.getMetaData().getColumnCount(); ++i) { if (!tableName.isEmpty() && !tableName.equalsIgnoreCase(rs.getMetaData().getTableName(i))) { continue; } String name = rs.getMetaData().getColumnLabel(i).toUpperCase(Locale.US); F field = fieldNameMapping.get(name); if (field != null) { int columnType = rs.getMetaData().getColumnType(i); switch (field.getType()) { case BOOL: { if (columnType == Types.BOOLEAN || columnType == Types.BIT) { boolean b = rs.getBoolean(i); if (!rs.wasNull()) { builder.set(field, b); } } else { int b = rs.getInt(i); if (!rs.wasNull()) { builder.set(field, b != 0); } } break; } case BYTE: { byte b = rs.getByte(i); if (!rs.wasNull()) { builder.set(field, b); } break; } case I16: { short b = rs.getShort(i); if (!rs.wasNull()) { builder.set(field, b); } break; } case I32: { if (columnType == Types.TIMESTAMP) { Timestamp ts = rs.getTimestamp(i); if (ts != null) { builder.set(field, (int) (ts.getTime() / 1000L)); } } else { int b = rs.getInt(i); if (!rs.wasNull()) { builder.set(field, b); } } break; } case I64: { if (columnType == Types.TIMESTAMP) { Timestamp ts = rs.getTimestamp(i); if (ts != null) { builder.set(field, ts.getTime()); } } else { long b = rs.getLong(i); if (!rs.wasNull()) { builder.set(field, b); } } break; } case DOUBLE: { double b = rs.getDouble(i); if (!rs.wasNull()) { builder.set(field, b); } break; } case STRING: { builder.set(field, rs.getString(i)); break; } case BINARY: { switch (columnType) { case Types.BINARY: case Types.VARBINARY: byte[] ts = rs.getBytes(i); if (ts != null) { builder.set(field, Binary.copy(ts)); } break; case Types.BLOB: Blob blob = rs.getBlob(i); if (blob != null) { try { builder.set(field, Binary.read(blob.getBinaryStream(), (int) blob.length())); } catch (IOException e) { throw new UncheckedIOException(e.getMessage(), e); } } break; case Types.CHAR: case Types.VARCHAR: case Types.NCHAR: case Types.NVARCHAR: { String tmp = rs.getString(i); if (tmp != null) { builder.set(field, Binary.fromBase64(tmp)); } break; } case Types.NULL: break; default: throw new ResultSetException("Unknown column type " + rs.getMetaData().getColumnTypeName(i) + " for " + descriptor.getType().toString() + " field " + name + " in " + descriptor.getQualifiedName(), null, ctx); } break; } case ENUM: { int val = rs.getInt(i); if (!rs.wasNull()) { PEnumDescriptor ed = (PEnumDescriptor) field.getDescriptor(); builder.set(field, ed.findById(val)); } break; } case MESSAGE: { try { PMessageDescriptor<?,?> md = (PMessageDescriptor) field.getDescriptor(); switch (columnType) { case Types.BINARY: case Types.VARBINARY: byte[] data = rs.getBytes(i); if (data != null) { ByteArrayInputStream in = new ByteArrayInputStream(data); builder.set(field, BINARY.deserialize(in, md)); } break; case Types.BLOB: { Blob blob = rs.getBlob(i); if (blob != null) { builder.set(field, BINARY.deserialize(blob.getBinaryStream(), md)); } break; } case Types.CHAR: case Types.VARCHAR: case Types.NCHAR: case Types.NVARCHAR: { String tmp = rs.getString(i); if (tmp != null) { StringReader reader = new StringReader(tmp); builder.set(field, JSON.deserialize(reader, md)); } break; } case Types.CLOB: { Clob clob = rs.getClob(i); if (clob != null) { builder.set(field, JSON.deserialize(clob.getCharacterStream(), md)); } break; } case Types.NULL: break; default: throw new ResultSetException("Unknown column type " + rs.getMetaData().getColumnTypeName(i) + " for " + descriptor.getType().toString() + " field " + name + " in " + descriptor.getQualifiedName(), null, ctx); } } catch (IOException e) { throw new UncheckedIOException(e.getMessage(), e); } break; } case LIST: case SET: case MAP: { } case VOID: default: { throw new ResultSetException("Unhandled column of type " + rs.getMetaData().getColumnTypeName(i) + " for " + descriptor.getType().toString() + " field " + name + " in " + descriptor.getQualifiedName(), null, ctx); } } } } return builder.build(); }
@Override public void getMetrics(MetricsCollector collector, boolean all) { StartupProgressView prog = startupProgress.createView(); MetricsRecordBuilder builder = collector.addRecord( STARTUP_PROGRESS_METRICS_INFO); builder.addCounter(info("ElapsedTime", "overall elapsed time"), prog.getElapsedTime()); builder.addGauge(info("PercentComplete", "overall percent complete"), prog.getPercentComplete()); for (Phase phase: prog.getPhases()) { addCounter(builder, phase, "Count", " count", prog.getCount(phase)); addCounter(builder, phase, "ElapsedTime", " elapsed time", prog.getElapsedTime(phase)); addCounter(builder, phase, "Total", " total", prog.getTotal(phase)); addGauge(builder, phase, "PercentComplete", " percent complete", prog.getPercentComplete(phase)); } }
public static Resource detectResource() { List<Resource> resourceList = new ArrayList<Resource>(); resourceList.add(Resource.createFromEnvironmentVariables()); if (System.getenv("KUBERNETES_SERVICE_HOST") != null) { resourceList.add(ContainerResource.detect()); resourceList.add(K8sResource.detect()); } resourceList.add(HostResource.detect()); resourceList.add(CloudResource.detect()); return firstNonNull(Resource.mergeResources(resourceList), EMPTY_RESOURCE); }
public static double strikeForDelta( double spot, double spotDelta, double timeToExpiry, double lognormalVol, double interestRate, double costOfCarry, boolean isCall) { ArgChecker.isTrue(spot > 0d, "non-positive/NaN spot; have {}", spot); ArgChecker.isTrue(timeToExpiry > 0d, "non-positive/NaN timeToExpiry; have {}", timeToExpiry); ArgChecker.isTrue(lognormalVol > 0d, "non-positive/NaN lognormalVol; have {}", lognormalVol); ArgChecker.isFalse(Double.isNaN(interestRate), "interestRate is NaN"); ArgChecker.isFalse(Double.isNaN(costOfCarry), "costOfCarry is NaN"); ArgChecker.isFalse(Double.isInfinite(spot), "spot is infinite"); ArgChecker.isFalse(Double.isInfinite(spotDelta), "spotDelta is infinite"); ArgChecker.isFalse(Double.isInfinite(timeToExpiry), "timeToExpiry is infinite"); ArgChecker.isFalse(Double.isInfinite(lognormalVol), "lognormalVol is infinite"); ArgChecker.isFalse(Double.isInfinite(interestRate), "interestRate is infinite"); ArgChecker.isFalse(Double.isInfinite(costOfCarry), "costOfCarry is infinite"); double rescaledDelta = spotDelta * Math.exp((-costOfCarry + interestRate) * timeToExpiry); ArgChecker.isTrue((isCall && rescaledDelta > 0d && rescaledDelta < 1.) || (!isCall && spotDelta < 0d && rescaledDelta > -1.), "delta/Math.exp((costOfCarry - interestRate) * timeToExpiry) out of range, ", rescaledDelta); double sigmaRootT = lognormalVol * Math.sqrt(timeToExpiry); double rescaledSpot = spot * Math.exp(costOfCarry * timeToExpiry); int sign = isCall ? 1 : -1; double d1 = sign * NORMAL.getInverseCDF(sign * rescaledDelta); return rescaledSpot * Math.exp(-d1 * sigmaRootT + 0.5 * sigmaRootT * sigmaRootT); }
public String getSummaryData(TestSummary summary) { if (summary.hasFailed()) { StringBuffer sb = new StringBuffer("\n\n"); sb.append("Script: ").append(summary.getScriptName()); sb.append("\nFailures: ").append(summary.getFailures()); sb.append("\nErrors: ").append(summary.getErrors()); return sb.toString(); } return ""; }
public static <T> Result<T> runTask(Task<T> task, Config config) { return new Result<>(new FloRunner<T>(config).run(task), loadTerminationHooks(config)); }
@Override public String getEngineName() { return engineName; }
public CurrencyAmount currentCash(ResolvedFixedCouponBondTrade trade, LocalDate valuationDate) { Payment upfrontPayment = upfrontPayment(trade); Currency currency = upfrontPayment.getCurrency(); CurrencyAmount currentCash = CurrencyAmount.zero(currency); if (upfrontPayment.getDate().equals(valuationDate)) { currentCash = currentCash.plus(upfrontPayment.getValue()); } if (trade.getSettlement().isPresent()) { LocalDate settlementDate = trade.getSettlement().get().getSettlementDate(); ResolvedFixedCouponBond product = trade.getProduct(); if (!settlementDate.isAfter(valuationDate)) { double cashCoupon = product.hasExCouponPeriod() ? 0d : currentCashCouponPayment(product, valuationDate); Payment payment = product.getNominalPayment(); double cashNominal = payment.getDate().isEqual(valuationDate) ? payment.getAmount() : 0d; currentCash = currentCash.plus(CurrencyAmount.of(currency, (cashCoupon + cashNominal) * trade.getQuantity())); } } return currentCash; }
public <T extends ExtensionAuthenticatorOutput> byte[] convert(AuthenticatorData<T> source) { try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] rpIdHash = source.getRpIdHash(); byteArrayOutputStream.write(rpIdHash); byteArrayOutputStream.write(new byte[]{source.getFlags()}); byteArrayOutputStream.write(UnsignedNumberUtil.toBytes(source.getSignCount())); if (source.getAttestedCredentialData() != null) { byteArrayOutputStream.write(attestedCredentialDataConverter.convert(source.getAttestedCredentialData())); } byteArrayOutputStream.write(convert(source.getExtensions())); return byteArrayOutputStream.toByteArray(); } catch (IOException e) { throw new UncheckedIOException(e); } }
@Override public Long create( String value ) { if (value == null) return null; try { return Long.valueOf(value.trim()); } catch (NumberFormatException err) { throw new ValueFormatException(value, getPropertyType(), GraphI18n.errorConvertingType.text(String.class.getSimpleName(), Long.class.getSimpleName(), value), err); } }
public static Matcher<JsonNode> jsonArray() { return new IsJsonArray(is(anything())); }
@RequestMapping(value = "/{widgetId}/properties/{propertyName}", method = RequestMethod.PUT) public List<Property> updateProperty(@PathVariable("widgetId") String widgetId, @PathVariable("propertyName") String propertyName, @RequestBody Property property) throws RepositoryException, NotFoundException, NotAllowedException { checkWidgetIdIsNotAPbWidget(widgetId); return widgetService.updateProperty(widgetId, propertyName, property); }
public Bus createBus() { return createBus((String)null); }
@SuppressWarnings("unused") public void onDecisionTablePinnedEvent(final @Observes DecisionTablePinnedEvent event) { final GuidedDecisionTableModellerView.Presenter modeller = event.getPresenter(); if (modeller == null) { return; } if (!modeller.equals(this.modeller)) { return; } view.enableDrag(!event.isPinned()); }
public static <C> C combine(C origin, C override) { if (origin == null) { return override; } if (override == null) { return origin; } Class<C> originClass = (Class<C>) origin.getClass(); Class<C> overrideClass = (Class<C>) override.getClass(); if (String.class.isAssignableFrom(originClass)) { if (Strings.isNullOrEmpty((String)origin)) { return override; } if (Strings.isNullOrEmpty((String)override)) { return origin; } } if (!overrideClass.equals(originClass)) { throw new IllegalStateException(String.format("Objects types don't match. Found: [%s] and [%s].", overrideClass, originClass)); } if (overrideClass.isPrimitive() || overrideClass.isEnum()) { return override; } if (List.class.isAssignableFrom(originClass)) { return mergeList(origin, override); } if (Set.class.isAssignableFrom(originClass)) { return mergeSet(origin, override); } if (Map.class.isAssignableFrom(originClass)) { return mergeMap(origin, override); } if (originClass.isArray()) { return mergeArray(origin, override); } String fcqn = overrideClass.getCanonicalName(); if (fcqn.startsWith("java") || fcqn.startsWith("com.sun") || fcqn.startsWith("sun.")) { return override; } try { final C result = originClass.newInstance(); for (Field f : getAllFields(originClass)) { try { String name = f.getName(); f.setAccessible(true); Object value = combine(f.get(origin), f.get(override)); f.set(result, value); } catch (Exception e) { throw DekorateException.launderThrowable(e); } } return result; } catch (Exception e) { throw DekorateException.launderThrowable(e); } }
protected Class<?> getContextClass(MediaType mediaType) { Class<?> contextClass = contextsManager.getContextDescriptionClass(getType(mediaType)); if (contextClass == null) { throw new WebApplicationException(Response.Status.UNSUPPORTED_MEDIA_TYPE); } return contextClass; }
@Override public boolean equals(Object o){ if (this == o) { return true; } if (o == null || !getClass().equals(o.getClass())) { return false; } User that = (User) o; return Objects.equals(id, that.id) && Objects.equals(name, that.name) && Objects.equals(email, that.email) && Objects.equals(userId, that.userId); }
public ImageSize getImageSize(long imageID) { ImageSize result = null; lock.readLock().lock(); try { result = sizes.getOrDefault(imageID, null); } finally { lock.readLock().unlock(); } return result; }
public static void applyFiltersToScript(Collection<ScriptFilter> filters, Script script) { ExternalScriptDao externalScriptDao = new ExternalScriptDao(); List<ScriptFilter> internalFilters = new ArrayList<ScriptFilter>(); List<ScriptFilter> externalFilters = new ArrayList<ScriptFilter>(); for (ScriptFilter filter : filters) { if (filter.getFilterType() == ScriptFilterType.EXTERNAL) { externalFilters.add(filter); } else { internalFilters.add(filter); } } for (ScriptFilter filter : internalFilters) { AWSXRay.createSubsegment("Apply.InternalFilter." + filter.getName(), (subsegment) -> { applyFilter(filter, script.getScriptSteps()); }); } if (!externalFilters.isEmpty()) { LoggingOutputLogger outputLogger = new LoggingOutputLogger(); ScriptTO scriptTo = ScriptServiceUtil.scriptToTransferObject(script); ScriptRunner runner = new ScriptRunner(); Map<String, Object> map = new HashMap<String, Object>(); map.put("script", scriptTo); for (ScriptFilter filter : externalFilters) { ExternalScript externalScript = externalScriptDao.findById(filter.getExternalScriptId()); logger.info("Running external Script: " + externalScript); if (externalScript != null) { Subsegment subsegment = AWSXRay.beginSubsegment("Apply.ExternalFilter." + externalScript.getName()); try { runner.runScript(externalScript.getName(), externalScript.getScript(), externalScript.getEngine(), map, outputLogger); } catch (ScriptException e) { logger.error("Error Running Script: " + e); subsegment.addException(e); throw new RuntimeException(e); } finally { AWSXRay.endSubsegment(); } } } script.getScriptSteps().clear(); for (ScriptStepTO stepTo : scriptTo.getSteps()) { script.getScriptSteps().add(ScriptServiceUtil.transferObjectToScriptStep(stepTo)); } } }
@POST @Path("/{contentId}") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Object pushContent(@PathParam("type") String type, @PathParam("contentId") String contentId, Map<String, Object> content) throws PreprocessorInvalidDataException { ProviderContentTypeInfo typeInfo = getTypeInfoWithManagePermissionCheck(type); PushContentImplRet pcir = pushContentImpl(typeInfo, contentId, content); IndexResponse ir = pcir.irb.execute().actionGet(); ContentStoredEvent event = new ContentStoredEvent(pcir.sysContentId, content); log.log(Level.FINE, "Going to fire event {0}", event); eventContentStored.fire(event); Map<String, Object> retJson = new LinkedHashMap<String, Object>(); processIndexResponse(ir, retJson); if (pcir.contentWarnings != null && !pcir.contentWarnings.isEmpty()) retJson.put(RETFIELD_WARNINGS, pcir.contentWarnings); return Response.ok(retJson).build(); }
@Override public boolean isService(Object bean, String beanName) { Class<?> classType = bean.getClass(); Set<Class<?>> interfaceClasses = ReflectionUtil.getInterfaces(classType); for (Class<?> interClass : interfaceClasses) { if (interClass.isAnnotationPresent(LocalTCC.class)) { return true; } } return false; }
@Override public int treeLevels() { if (root != null) { return root.level(); } return 0; }
public String getServiceUrlTls() { return serviceUrlTls; }
public static Tag valueOf(String tagName) { Validate.notNull(tagName); Tag tag = tags.get(tagName); if (tag == null) { tagName = tagName.trim().toLowerCase(); Validate.notEmpty(tagName); tag = tags.get(tagName); if (tag == null) { tag = new Tag(tagName); tag.isBlock = false; tag.canContainBlock = true; } } return tag; }
public int getAdapterVersion() { return adapterVersion; }
@Nullable @Override public String asString() { return null; }
@Override protected OAuth2AccessToken createToken(String accessToken, String tokenType, Integer expiresIn, String refreshToken, String scope, JsonNode response, String rawResponse) { OAuth2AccessToken token = super.createToken(accessToken, tokenType, expiresIn, refreshToken, scope, response, rawResponse); String uid = extractRequiredParameter(response, "uid", rawResponse).asText(); if (uid == null || "".equals(uid)) { throw new OAuthException( "There is no required UID in the response of the AssessToken endpoint."); } return new WeiboToken(token, uid); }
public static HttpResponseStatus parseLine(CharSequence line) { return (line instanceof AsciiString) ? parseLine((AsciiString) line) : parseLine(line.toString()); }
public String getName() { return name; }
@Override public List<StorageLocation> listAvailableStorageLocations(PID pid) { List<PID> ancestors = pathFactory.getAncestorPids(pid); ancestors.add(pid); return new ArrayList<>(ancestors.stream() .limit(COLLECTION_PATH_DEPTH + 1l) .map(pidToStorageLocation::get) .filter(Objects::nonNull) .collect(Collectors.toSet())); }
@Override public CompletableFuture<GetNamespaceResponse> getNamespace(GetNamespaceRequest request) { String nsName = request.getName(); if (!validateNamespaceName(nsName)) { log.error("Failed to get namespace due to invalid namespace name {}", nsName); return FutureUtils.value( GetNamespaceResponse.newBuilder() .setCode(StatusCode.INVALID_NAMESPACE_NAME) .build()); } else { return getNamespace(request.getName()).thenApply(nsMetadata -> { GetNamespaceResponse.Builder nsRespBuilder = GetNamespaceResponse.newBuilder(); if (null == nsMetadata) { nsRespBuilder.setCode(StatusCode.NAMESPACE_NOT_FOUND); } else { nsRespBuilder.setCode(StatusCode.SUCCESS); nsRespBuilder.setNsProps(nsMetadata.getProps()); } return nsRespBuilder.build(); }); } }
public String getLdapName() { return ldapName; }
String shortName(String key) { Matcher matcher = KEY_PATTERN.matcher(key); if (!matcher.matches()) throw new IllegalArgumentException("Unexpected key: " + key); StringBuilder result = new StringBuilder(); String annotationSimpleName = matcher.group(1); if (annotationSimpleName != null) { result.append('@').append(annotationSimpleName).append(' '); } String simpleName = matcher.group(2); result.append(simpleName); String typeParameters = matcher.group(3); if (typeParameters != null) { result.append(typeParameters); } String arrays = matcher.group(4); if (arrays != null) { result.append(arrays); } return result.toString(); }
Iterator<NodeStateEntry> children() { return children(false); }
public static JsonPrimitive validateBoolean(JsonObject inputObject, String value) throws ValidatorException, ParserException { if (value == null) { throw new ValidatorException("Received null input to be validated with : " + inputObject.toString() + ". Expected a boolean but found null"); } Boolean parsedValue = DataTypeConverter.convertToBoolean(value); if (inputObject.has(ValidatorConstants.ENUM)) { JsonArray enumElements = inputObject.getAsJsonArray(ValidatorConstants.ENUM); if (enumElements.size() > 0 && !enumElements.contains(new JsonPrimitive(parsedValue))) { throw new ValidatorException("input \"" + value + "\" not contains any " + "element from the enum : " + enumElements.toString()); } } if (inputObject.has(ValidatorConstants.CONST) && !parsedValue.equals(inputObject.getAsJsonPrimitive (ValidatorConstants.CONST).getAsBoolean())) { throw new ValidatorException("String \"" + value + "\" is not equal to the const" + " value"); } return new JsonPrimitive(parsedValue); }
@Override public void getNext(JCas jCas) throws CollectionException { log.trace("Reading next document."); initializeAnnotationTableNames(jCas); log.trace("Retrieving document data from the database."); byte[][] data = getNextArtifactData(); log.trace("Got document data with {} fields.", null != data ? data.length : 0); if (data != null) populateCas(jCas, data); }
public String createPortImplementation(String userId, PortImplementation portImplementation, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException { return createPort(userId, portImplementation, PortPropertiesMapper.PORT_IMPLEMENTATION_TYPE_NAME, externalSourceName); }
@Override public Map<String, Object> getParameters(final StudyPlanCycle entity, final Map<String, Object> parameters) { addParameter(entity.getAbbrName(), "abbrName", parameters); addParameter(entity.getName(), "name", parameters); return parameters; }
public static Type[] getReturnTypes(Method method) { Class<?> returnType = method.getReturnType(); Type genericReturnType = method.getGenericReturnType(); if (Future.class.isAssignableFrom(returnType)) { if (genericReturnType instanceof ParameterizedType) { Type actualArgType = ((ParameterizedType) genericReturnType).getActualTypeArguments()[0]; if (actualArgType instanceof ParameterizedType) { returnType = (Class<?>) ((ParameterizedType) actualArgType).getRawType(); genericReturnType = actualArgType; } else { returnType = (Class<?>) actualArgType; genericReturnType = returnType; } } else { returnType = null; genericReturnType = null; } } return new Type[]{returnType, genericReturnType}; }
@Override public void forward(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { if (servletRequest.getDispatcherType().equals(ASYNC)) { asyncForward(servletRequest, servletResponse); return; } syncForward(servletRequest, servletResponse); }
public static ParseUser become(String sessionToken) throws ParseException { return ParseTaskUtils.wait(becomeInBackground(sessionToken)); }
public List<Coordinate> computeSideHull(boolean left, Coordinate p1, Coordinate p2) { if(p1.equals(p2)) { return new ArrayList<>(); } Set<LineSegment> freeFieldSegments = new HashSet<>(); GeometryFactory geometryFactory = new GeometryFactory(); List<Coordinate> input = new ArrayList<>(); Coordinate[] coordinates = new Coordinate[0]; int indexp1 = 0; int indexp2 = 0; boolean convexHullIntersects = true; input.add(p1); input.add(p2); Set<Integer> buildingInHull = new HashSet<>(); Plane cutPlane = ComputeZeroRadPlane(p1, p2); IntersectionRayVisitor intersectionRayVisitor = new IntersectionRayVisitor( data.freeFieldFinder.getPolygonWithHeight(), p1, p2, data.freeFieldFinder, input, buildingInHull, cutPlane); data.freeFieldFinder.getBuildingsOnPath(p1, p2, intersectionRayVisitor); int k; while (convexHullIntersects) { ConvexHull convexHull = new ConvexHull(input.toArray(new Coordinate[0]), geometryFactory); Geometry convexhull = convexHull.getConvexHull(); if (convexhull.getLength() / p1.distance(p2) > MAX_RATIO_HULL_DIRECT_PATH) { return new ArrayList<>(); } convexHullIntersects = false; coordinates = convexhull.getCoordinates(); input.clear(); input.addAll(Arrays.asList(coordinates)); indexp1 = -1; for (int i = 0; i < coordinates.length - 1; i++) { if (coordinates[i].equals(p1)) { indexp1 = i; break; } } if (indexp1 == -1) { return new ArrayList<>(); } Coordinate[] coordinatesShifted = new Coordinate[coordinates.length]; int len = (coordinates.length - 1) - indexp1; System.arraycopy(coordinates, indexp1, coordinatesShifted, 0, len); System.arraycopy(coordinates, 0, coordinatesShifted, len, coordinates.length - len - 1); coordinatesShifted[coordinatesShifted.length - 1] = coordinatesShifted[0]; coordinates = coordinatesShifted; indexp1 = 0; indexp2 = -1; for (int i = 1; i < coordinates.length - 1; i++) { if (coordinates[i].equals(p2)) { indexp2 = i; break; } } if (indexp2 == -1) { return new ArrayList<>(); } for (k = 0; k < coordinates.length - 1; k++) { LineSegment freeFieldTestSegment = new LineSegment(coordinates[k], coordinates[k + 1]); if (left && k < indexp2 || !left && k >= indexp2) { if (!freeFieldSegments.contains(freeFieldTestSegment)) { if(!data.freeFieldFinder.getMeshEnvelope().contains(coordinates[k]) || !data.freeFieldFinder.getMeshEnvelope().contains(coordinates[k+1])) { return new ArrayList<>(); } intersectionRayVisitor = new IntersectionRayVisitor(data.freeFieldFinder.getPolygonWithHeight(), coordinates[k], coordinates[k + 1], data.freeFieldFinder, input, buildingInHull, cutPlane); data.freeFieldFinder.getBuildingsOnPath(coordinates[k], coordinates[k + 1], intersectionRayVisitor); if(!intersectionRayVisitor.doContinue()) { convexHullIntersects = true; } if (!convexHullIntersects) { freeFieldSegments.add(freeFieldTestSegment); } else { break; } } } } } for(Coordinate p : coordinates) { if(p.z < 0) { return new ArrayList<>(); } } if(left) { return Arrays.asList(Arrays.copyOfRange(coordinates,indexp1, indexp2 + 1)); } else { ArrayList<Coordinate> inversePath = new ArrayList<>(); inversePath.addAll(Arrays.asList(Arrays.copyOfRange(coordinates,indexp2, coordinates.length))); Collections.reverse(inversePath); return inversePath; } }
@Override public SearchResponse search(SearchRequest searchRequest) throws InvalidSearchException { for(IndexDao dao : indices) { SearchResponse s = dao.search(searchRequest); if(s != null) { return s; } } return null; }
@Override public List<TaskSummary> getCaseTasksAssignedAsBusinessAdmin(String caseId, String userId, List<Status> status, QueryContext queryContext) { Map<String, Object> params = new HashMap<String, Object>(); params.put("caseId", caseId + "%"); params.put("userId", userId); params.put("status", adoptList(status, allActiveStatus)); params.put("groupIds", getAuthenticatedUserRoles(identityProvider)); applyQueryContext(params, queryContext); List<TaskSummary> tasks = commandService.execute(new QueryNameCommand<List<TaskSummary>>("getCaseTasksAsBusinessAdmin", params)); return tasks; }
public static Builder newBuilder() { AutoValue_GoogleAdsClient.Builder clientBuilder = new AutoValue_GoogleAdsClient.Builder(); clientBuilder.setEnableGeneratedCatalog(false); InstantiatingGrpcChannelProvider transportChannelProvider = InstantiatingGrpcChannelProvider.newBuilder() .setInterceptorProvider( () -> ImmutableList.of( new LoggingInterceptor( new RequestLogger(), clientBuilder.getHeaders(), clientBuilder.getEndpoint()))) .setMaxInboundMetadataSize(16 * 1024 * 1024) .setMaxInboundMessageSize(64 * 1024 * 1024) .build(); clientBuilder .setEndpoint(DEFAULT_ENDPOINT) .setTransportChannelProvider(transportChannelProvider); return clientBuilder; }
public static Builder builder() { return new Builder(); }
public static ExtendedBaselineInfo createPaddedBaselineInfo( final int codepoint, final FontMetrics fontMetrics, final BaselineInfo reusableBaselineInfo ) { if ( fontMetrics == null ) { throw new NullPointerException( "FontMetrics cannot be null" ); } final BaselineInfo baselineInfo = fontMetrics.getBaselines( codepoint, reusableBaselineInfo ); final int dominantBaseline = TextUtility.translateBaselines( baselineInfo.getDominantBaseline() ); final long underlinePosition = fontMetrics.getUnderlinePosition(); final long strikeThroughPosition = fontMetrics.getStrikeThroughPosition(); final long fontSize = fontMetrics.getMaxHeight(); final long threshold = (long) ( fontSize * 1.005 ); final long safeFontSize = (long) ( fontSize * 1.3 ); final long totalAscentAndDescent = fontMetrics.getMaxAscent() + fontMetrics.getMaxDescent(); if ( fontSize < totalAscentAndDescent && totalAscentAndDescent < threshold ) { return new DefaultExtendedBaselineInfo( dominantBaseline, baselineInfo, 0, 0, safeFontSize, safeFontSize, underlinePosition, strikeThroughPosition ); } return new DefaultExtendedBaselineInfo( dominantBaseline, baselineInfo, 0, 0, fontSize, fontSize, underlinePosition, strikeThroughPosition ); }
@Override public void updateScaStatusConsentStatusConsentData(String psuId, ConsentWorkflow workflow) { updateCmsAuthorizationScaStatus(workflow, psuId); updateAspspConsentData(workflow); }
@Override public int hashCode() { return Objects.hash(name, type, use, defaultGeometry, srid, dateFormat, useShortName, geometryType, analyzed, stored, nested, order, customName); }
@Override void decode(ByteBufAllocator alloc, ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception { if (headerBlock == null) { throw new NullPointerException("headerBlock"); } if (frame == null) { throw new NullPointerException("frame"); } if (cumulation == null) { decodeHeaderBlock(headerBlock, frame); if (headerBlock.isReadable()) { cumulation = alloc.buffer(headerBlock.readableBytes()); cumulation.writeBytes(headerBlock); } } else { cumulation.writeBytes(headerBlock); decodeHeaderBlock(cumulation, frame); if (cumulation.isReadable()) { cumulation.discardReadBytes(); } else { releaseBuffer(); } } }
String inflateGroups(String input, Set<String> groups) { String result = input; for (String key : groups) { Optional<String> $value = world.get(key); if ($value.isPresent()) { result = result.replaceAll("\\{\\(" + key + "\\)\\}", $value.get()); } } return result; }
@Override public String resolve(ResolveEndpointRequest request) { this.productEndpointMap = request.productEndpointMap; this.productEndpointRegional = request.productEndpointRegional; this.productNetwork = request.productNetwork; this.productSuffix = request.productSuffix; if (this.productEndpointMap == null || this.productEndpointRegional == null) { return null; } return getEndpoint(request.productCode, request.regionId); }
@Override public Map<String, Object> getParameters(final PersonName entity, final Map<String, Object> parameters) { addParameter(entity.getPerson(), personDao, "person", parameters); addParameter(entity.getLanguage(), languageDao, "language", parameters); addParameter(entity.getName(), "name", parameters); addParameter(entity.getFirstName(), "firstName", parameters); addParameter(entity.getFatherName(), "fatherName", parameters); addParameter(entity.getSurname(), "surname", parameters); return parameters; }
@EventListener public void listen(EurekaInstanceRegisteredEvent event) { final InstanceInfo instanceInfo = event.getInstanceInfo(); final Map<String, String> metadata = instanceInfo.getMetadata(); final String serviceId = EurekaUtils.getServiceIdFromInstanceId(instanceInfo.getInstanceId()); metadataTranslationService.translateMetadata(serviceId, metadata); metadataDefaultsService.updateMetadata(serviceId, metadata); if (StringUtils.equalsIgnoreCase(GatewayNotifier.GATEWAY_SERVICE_ID, serviceId)) { gatewayNotifier.distributeInvalidatedCredentials(instanceInfo.getInstanceId()); } gatewayNotifier.serviceUpdated(serviceId, instanceInfo.getInstanceId()); }
public ListIterator<NODE> listIterator() { return vector.listIterator(); }
static void parseCueText(String id, String markup, WebvttCue.Builder builder, List<WebvttCssStyle> styles) { SpannableStringBuilder spannedText = new SpannableStringBuilder(); ArrayDeque<StartTag> startTagStack = new ArrayDeque<>(); List<StyleMatch> scratchStyleMatches = new ArrayList<>(); int pos = 0; while (pos < markup.length()) { char curr = markup.charAt(pos); switch (curr) { case CHAR_LESS_THAN: if (pos + 1 >= markup.length()) { pos++; break; } int ltPos = pos; boolean isClosingTag = markup.charAt(ltPos + 1) == CHAR_SLASH; pos = findEndOfTag(markup, ltPos + 1); boolean isVoidTag = markup.charAt(pos - 2) == CHAR_SLASH; String fullTagExpression = markup.substring(ltPos + (isClosingTag ? 2 : 1), isVoidTag ? pos - 2 : pos - 1); String tagName = getTagName(fullTagExpression); if (tagName == null || !isSupportedTag(tagName)) { continue; } if (isClosingTag) { StartTag startTag; do { if (startTagStack.isEmpty()) { break; } startTag = startTagStack.pop(); applySpansForTag(id, startTag, spannedText, styles, scratchStyleMatches); } while(!startTag.name.equals(tagName)); } else if (!isVoidTag) { startTagStack.push(StartTag.buildStartTag(fullTagExpression, spannedText.length())); } break; case CHAR_AMPERSAND: int semiColonEndIndex = markup.indexOf(CHAR_SEMI_COLON, pos + 1); int spaceEndIndex = markup.indexOf(CHAR_SPACE, pos + 1); int entityEndIndex = semiColonEndIndex == -1 ? spaceEndIndex : (spaceEndIndex == -1 ? semiColonEndIndex : Math.min(semiColonEndIndex, spaceEndIndex)); if (entityEndIndex != -1) { applyEntity(markup.substring(pos + 1, entityEndIndex), spannedText); if (entityEndIndex == spaceEndIndex) { spannedText.append(" "); } pos = entityEndIndex + 1; } else { spannedText.append(curr); pos++; } break; default: spannedText.append(curr); pos++; break; } } while (!startTagStack.isEmpty()) { applySpansForTag(id, startTagStack.pop(), spannedText, styles, scratchStyleMatches); } applySpansForTag(id, StartTag.buildWholeCueVirtualTag(), spannedText, styles, scratchStyleMatches); builder.setText(spannedText); }
@Deprecated public BitmapMarker addMarker(MarkerOptions markerOptions) { final Marker marker = mapController.addMarker(); BitmapMarker bitmapMarker = bitmapMarkerFactory.createMarker(this, marker, styleStringGenerator); configureMarker(bitmapMarker, markerOptions); Collections.synchronizedList(restorableMarkers).add(bitmapMarker); return bitmapMarker; }
public double distanceWithWindow(final double[] a, final double[] b, int w) { int n = a.length; int m = b.length; double[][] matrix = new double[n + 1][m + 1]; w = Math.max(w, Math.abs(n - m)); for (int i = 1; i <= n; i++) { matrix[i][0] = Double.MAX_VALUE; } for (int j = 1; j <= m; j++) { matrix[0][j] = Double.MAX_VALUE; } matrix[0][0] = 0d; for (int i = 1; i <= n; i++) { for (int j = Math.max(1, i - w); j <= Math.min(m, i + w); j++) { double cost = this.delta.distance(a[i - 1], b[j - 1]); double mini = Math.min(matrix[i - 1][j], Math.min(matrix[i][j - 1], matrix[i - 1][j - 1])); matrix[i][j] = cost + mini; } } return matrix[n][m]; }
public boolean record(final Throwable observation) { final long timestamp = clock.time(); DistinctObservation distinctObservation; synchronized (this) { distinctObservation = find(distinctObservations, observation); if (null == distinctObservation) { distinctObservation = newObservation(timestamp, observation); if (INSUFFICIENT_SPACE == distinctObservation) { return false; } } } final int offset = distinctObservation.offset; buffer.getAndAddInt(offset + OBSERVATION_COUNT_OFFSET, 1); buffer.putLongOrdered(offset + LAST_OBSERVATION_TIMESTAMP_OFFSET, timestamp); return true; }
public TelemetryResponse convert(Telemetry telemetry) { TelemetryResponse response = null; if (telemetry != null) { LoggingResponse loggingResponse = createLoggingResponseFromSource(telemetry); WorkloadAnalyticsResponse waResponse = createWorkloadAnalyticsResponseFromSource(telemetry); response = new TelemetryResponse(); response.setLogging(loggingResponse); response.setWorkloadAnalytics(waResponse); response.setFluentAttributes(telemetry.getFluentAttributes()); response.setRules(telemetry.getRules()); createFeaturesResponseFromSource(response, telemetry.getFeatures()); } return response; }
public JMeterProperty getMetricSettings() { return getProperty(DATA_PROPERTY); }
@Override public String[] generateKeys(final Object[] keyObjects) { if (keyObjects == null || keyObjects.length < 1) { throw new InvalidParameterException("The key objects must be defined."); } final String[] results = new String[keyObjects.length]; for (int i = 0; i < keyObjects.length; i++) { results[i] = generateKey(keyObjects[i]); } return results; }
@Override public JPAExpandQueryResult execute() throws ODataApplicationException { final int handle = debugger.startRuntimeMeasurement(this, "execute"); long skip = 0; long top = Long.MAX_VALUE; try { tupleQuery = createTupleQuery(); final int resultHandle = debugger.startRuntimeMeasurement(tupleQuery, "getResultList"); final List<Tuple> intermediateResult = tupleQuery.getResultList(); debugger.stopRuntimeMeasurement(resultHandle); if (uriResource.getTopOption() != null || uriResource.getSkipOption() != null) { if (uriResource.getSkipOption() != null) skip = uriResource.getSkipOption().getValue(); if (uriResource.getTopOption() != null) top = uriResource.getTopOption().getValue(); } final Map<String, List<Tuple>> result = convertResult(intermediateResult, assoziation, skip, top); final Set<JPAPath> requestedSelection = new HashSet<>(); buildSelectionAddNavigationAndSelect(uriResource, requestedSelection, uriResource.getSelectOption()); debugger.stopRuntimeMeasurement(handle); return new JPAExpandQueryResult(result, count(), jpaEntity, requestedSelection); } catch (JPANoSelectionException e) { return new JPAExpandQueryResult(Collections.emptyMap(), Collections.emptyMap(), this.jpaEntity, Collections .emptyList()); } catch (ODataJPAModelException e) { throw new ODataApplicationException(e.getLocalizedMessage(), HttpStatusCode.INTERNAL_SERVER_ERROR .getStatusCode(), ODataJPAModelException.getLocales().nextElement(), e); } }
@SuppressWarnings("unchecked") @Override public <T> CloseableIterator<T> iterate(Query query, FactoryExpression<?> projection) { if (query instanceof NativeQuery) { NativeQuery hQuery = (NativeQuery) query; ScrollableResults results = hQuery.scroll(ScrollMode.FORWARD_ONLY); CloseableIterator<T> iterator = new ScrollableResultsIterator<T>(results); if (projection != null) { iterator = new TransformingIterator<T>(iterator, projection); } return iterator; } else { Iterator<T> iterator = query.getResultList().iterator(); if (projection != null) { return new TransformingIterator<T>(iterator, projection); } else { return new IteratorAdapter<T>(iterator); } } }
@Override public String toString() { StringBuilder sb = new StringBuilder(); if (name != null) { sb.append(name); } sb.append('|'); if (mimetype != null) { sb.append(mimetype); } sb.append('|'); if (filename != null) { sb.append(filename); } sb.append('|'); if (extension != null) { sb.append(extension); } sb.append('|'); if (filesize != null) { sb.append(filesize); } sb.append('|'); if (checksum != null) { sb.append(checksum); } sb.append('|'); if (owner != null) { sb.append(owner); } return sb.toString(); }
public void opLogEvent(String replicaSetName, Document oplogEvent, Document masterEvent, long orderInTx) { Position position = INITIAL_POSITION; String namespace = ""; if (oplogEvent != null) { BsonTimestamp ts = extractEventTimestamp(masterEvent); Long opId = masterEvent.getLong("h"); String sessionTxnId = extractSessionTxnId(masterEvent); position = new Position(ts, opId, orderInTx, sessionTxnId); namespace = oplogEvent.getString("ns"); } positionsByReplicaSetName.put(replicaSetName, position); onEvent(replicaSetName, CollectionId.parse(replicaSetName, namespace), position); }
@Override public boolean add(E item) { checkNotNull(item, "Item to be added cannot be null."); return items.add(serializer.encode(item)); }
@Override public List<NodeBase> getChildren() { if (child == null) { return Arrays.asList(); } return Arrays.asList(child); }
@Nullable @DirectMethod @Timed @ExceptionMetered @RequiresAuthentication @RequiresPermissions("nexus:*") public PagedResponse<ComponentXO> previewCleanup(final StoreLoadParameters parameters) throws IOException { String policy = parameters.getFilter("cleanupPolicy"); String filter = parameters.getFilter("filter"); if(policy == null || parameters.getSort() == null) { return null; } Sort sort = parameters.getSort().get(0); QueryOptions queryOptions = new QueryOptions(filter, sort.getProperty(), sort.getDirection(), parameters.getStart(), parameters.getLimit()); CleanupPolicyPreviewXO previewXO = mapper .readValue(policy, CleanupPolicyPreviewXO.class); Repository repository = repositoryManager.get(previewXO.getRepositoryName()); if(repository == null) { return null; } return cleanupPreviewHelper.get().getSearchResults(previewXO, repository, queryOptions); }
@Override public SchemaAndValue toConnectData(String topic, byte[] value) { JsonNode jsonValue; try { jsonValue = deserializer.deserialize(topic, value); } catch (SerializationException e) { throw new DataException("Converting byte[] to Kafka Connect data failed due to serialization error: ", e); } if (enableSchemas && (jsonValue == null || !jsonValue.isObject() || jsonValue.size() != 2 || !jsonValue.has("schema") || !jsonValue.has("payload"))) throw new DataException("JsonConverter with schemas.enable requires \"schema\" and \"payload\" fields and may not contain additional fields." + " If you are trying to deserialize plain JSON data, set schemas.enable=false in your converter configuration."); if (!enableSchemas) { ObjectNode envelope = JsonNodeFactory.instance.objectNode(); envelope.set("schema", null); envelope.set("payload", jsonValue); jsonValue = envelope; } return jsonToConnect(jsonValue); }
public final E_StrBefore strbefore(Object expr1, Object expr2) { return new E_StrBefore(asExpr(expr1), asExpr(expr2)); }
public static ParseRESTUserCommand getCurrentUserCommand(String sessionToken) { return new ParseRESTUserCommand("users/me", ParseHttpRequest.Method.GET, null, sessionToken); }
@Override public List<RoleAssignment> getPatronAccess(PID pid) { if (isMarkedForDeletion(pid)) { return Collections.emptyList(); } boolean isEmbargoed = isEmbargoActive(getEmbargoUntil(pid)); Map<String, Set<String>> princRoles = getPrincipalRoles(pid); List<RoleAssignment> result = new ArrayList<>(); Set<String> patronPrincipals = getPatronPrincipals(princRoles.keySet()); for (String princ: patronPrincipals) { Set<String> roles = princRoles.get(princ); String roleString = roles.iterator().next(); UserRole role = UserRole.getRoleByProperty(roleString); if (isEmbargoed) { int objIndex = PATRON_ROLE_PRECEDENCE.indexOf(roleString); if (objIndex > EMBARGO_ROLE_PRECEDENCE) { role = UserRole.canViewMetadata; } } result.add(new RoleAssignment(princ, role)); } return result; }
public SimpleChromeCustomTabsIntentBuilder withMenuItem(String label, PendingIntent pendingIntent) { composers.add(new MenuItemComposer(label, pendingIntent)); return this; }
public <T extends Annotation> Collection<Annotation> allWith(Class<T> javaAnnotationType) { return doWith(javaAnnotationType).collect(Collectors.toList()); }
public static final void registerCalculator(BinaryHashCodeCalculator calculator) { if (calculator == null) { throw new NullPointerException("Cannot register null"); } synchronized (binaryHashCodeCalculatorRegistry) { if (binaryHashCodeCalculatorRegistry.containsKey(calculator.getId())) { throw new RuntimeException( "BinaryHashCodeCalculator with id " + calculator.getId() + " has been already registerd"); } binaryHashCodeCalculatorRegistry.put(calculator.getId(), calculator); } }
public static <T> Collection<T> nonNull(Collection<T> c) { return asCollection(c); }
public boolean intersects(Bitlist other) { return data.intersects(other.data); }
String inflateGroups(String input, Set<String> groups) { String result = input; for (String key : groups) { Optional<String> $value = world.get(key); if ($value.isPresent()) { result = result.replaceAll("\\{\\(" + key + "\\)\\}", $value.get()); } } return result; }
@GET @Path("/{entityType}/{entityId}") @Produces({ MediaType.APPLICATION_JSON }) public TimelineEntity getEntity( @Context HttpServletRequest req, @Context HttpServletResponse res, @PathParam("entityType") String entityType, @PathParam("entityId") String entityId, @QueryParam("fields") String fields) { init(res); TimelineEntity entity = null; try { entity = timelineDataManager.getEntity( parseStr(entityType), parseStr(entityId), parseFieldsStr(fields, ","), getUser(req)); } catch (IllegalArgumentException e) { throw new BadRequestException( "requested invalid field."); } catch (Exception e) { LOG.error("Error getting entity", e); throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR); } if (entity == null) { throw new NotFoundException("Timeline entity " + new EntityIdentifier(parseStr(entityId), parseStr(entityType)) + " is not found"); } return entity; }
@Override public Response changeInstanceState( String applicationName, String newState, String instancePath ) { this.logger.fine( "Request: change state of " + instancePath + " to '" + newState + "' in " + applicationName + "." ); Response response = Response.ok().build(); String lang = lang( this.manager ); try { ManagedApplication ma; Instance instance; if( ! InstanceStatus.isValidState( newState )) response = handleError( Status.FORBIDDEN, new RestError( REST_INEXISTING, name( newState )), lang ).build(); else if(( ma = this.manager.applicationMngr().findManagedApplicationByName( applicationName )) == null ) response = handleError( Status.NOT_FOUND, new RestError( REST_INEXISTING, application( applicationName )), lang ).build(); else if(( instance = InstanceHelpers.findInstanceByPath( ma.getApplication(), instancePath )) == null ) response = handleError( Status.NOT_FOUND, new RestError( REST_INEXISTING, instance( instancePath ), application( applicationName )), lang ).build(); else this.manager.instancesMngr().changeInstanceState( ma, instance, InstanceStatus.whichStatus( newState )); } catch( IOException | TargetException e ) { response = RestServicesUtils.handleError( Status.FORBIDDEN, new RestError( ErrorCode.REST_UNDETAILED_ERROR, e ), lang ).build(); } catch( Exception e ) { response = RestServicesUtils.handleError( Status.INTERNAL_SERVER_ERROR, new RestError( ErrorCode.REST_UNDETAILED_ERROR, e ), lang ).build(); } return response; }
@Override public String toString() { String tagsString = ""; if (!Strings.isNullOrEmpty(tags)) { tagsString = ":" + tags; } if (type == null || type.isEmpty()) { return typedIdentifier.getName() + tagsString; } else { return typedIdentifier.getName() + ":" + type + tagsString; } }
public String getAmountAsString() throws ISOException { StringBuilder sb = new StringBuilder(16); sb.append (ISOUtil.zeropad (Integer.toString (currencyCode),3)); sb.append (Integer.toString(amount.scale() % 10)); sb.append (ISOUtil.zeropad (amount.unscaledValue().toString(), 12)); return sb.toString(); }
public Date getNextExecutionAfter(Date date) { if (date == null) return null; if (nextExecution > date.getTime()) return new Date(nextExecution); else if (once) { if (lastExecution > -1) return null; lastExecution = date.getTime(); return date; } Calendar c = Calendar.getInstance(); c.setFirstDayOfWeek(Calendar.SUNDAY); c.setTime(date); c.set(Calendar.MILLISECOND, 0); c.add(Calendar.SECOND, 60 - c.get(Calendar.SECOND)); if (c.getTime().equals(date)) c.add(Calendar.MINUTE, 1); while (!matches(c, Calendar.MINUTE, minutes)) { c.add(Calendar.MINUTE, 1); } while (!matches(c, Calendar.HOUR_OF_DAY, hours)) { c.add(Calendar.HOUR_OF_DAY, 1); } while (!matches(c, daysOfMonth, daysOfWeek)) { c.add(Calendar.DAY_OF_MONTH, 1); } while (!matches(c, Calendar.MONTH, months)) { c.add(Calendar.MONTH, 1); c.set(Calendar.DAY_OF_MONTH, 1); } while (!matches(c, daysOfMonth, daysOfWeek)) { c.add(Calendar.DAY_OF_MONTH, 1); } return new Date(c.getTimeInMillis()); }
public static String makeSlug(String input, boolean transliterate) { String origInput = input; String tempInputValue = ""; if (input == null) { ProjectLogger.log("Provided input value is null"); return input; } tempInputValue = input.trim(); tempInputValue = urlDecode(tempInputValue); if (transliterate) { String transliterated = transliterate(tempInputValue); tempInputValue = transliterated; } tempInputValue = WHITESPACE.matcher(tempInputValue).replaceAll("-"); tempInputValue = Normalizer.normalize(tempInputValue, Form.NFD); tempInputValue = NONLATIN.matcher(tempInputValue).replaceAll(""); tempInputValue = normalizeDashes(tempInputValue); validateResult(tempInputValue, origInput); return tempInputValue.toLowerCase(Locale.ENGLISH); }
@Override public void process(JCas jcas) throws AnalysisEngineProcessException { CAS cas = jcas.getCas(); if (reloadScript || (!initialized && !cas.getViewName().equals(CAS.NAME_DEFAULT_SOFA))) { initializeScript(cas.getViewName()); } else { resetEnvironments(cas); initializeVariableValues(); } boolean typeSystemChanged = lastTypeSystem != cas.getTypeSystem(); if (!initialized || reloadScript || typeSystemChanged) { initializeTypes(script, cas, new ArrayList<String>()); if (typeUsageInformation != null) { typeUsageInformation.resolveTypes(script, cas.getTypeSystem()); } initialized = true; lastTypeSystem = cas.getTypeSystem(); } InferenceCrowd crowd = initializeCrowd(); RutaStream stream = initializeStream(cas, crowd); stream.setDynamicAnchoring(dynamicAnchoring); stream.setGreedyRuleElement(greedyRuleElement); stream.setGreedyRule(greedyRule); stream.setMaxRuleMatches(maxRuleMatches); stream.setMaxRuleElementMatches(maxRuleElementMatches); try { script.apply(stream, crowd); } catch (Throwable e) { throw new AnalysisEngineProcessException(AnalysisEngineProcessException.ANNOTATOR_EXCEPTION, new Object[] {}, e); } crowd.finished(stream); if (removeBasics) { jcas.removeAllIncludingSubtypes(RutaBasic.type); jcas.removeAllIncludingSubtypes(TokenSeed.type); List<AnnotationFS> toRemove = new ArrayList<AnnotationFS>(); for (Type seedType : seedTypes) { AnnotationIndex<AnnotationFS> seedIndex = cas.getAnnotationIndex(seedType); for (AnnotationFS fs : seedIndex) { toRemove.add(fs); } } for (AnnotationFS annotationFS : toRemove) { cas.removeFsFromIndexes(annotationFS); } } }
public Long insert(User user) { String sid = getBaseWebResource("users").header("Content-Type", MediaType.TEXT_XML) .accept(MediaType.TEXT_PLAIN).post(String.class, user); return Long.parseLong(sid); }
@Override public Path relativePathFromScmRoot(Path path) { RepositoryBuilder builder = getVerifiedRepositoryBuilder(path); return builder.getGitDir().toPath().getParent().relativize(path); }
@Override public long getFirstMillisecond() { return this.firstMillisecond; }
@Override public void validate(Object object, Errors errors) { if (log.isDebugEnabled()) { log.debug(this.getClass().getName() + ".validate..."); } if (object == null) { throw new IllegalArgumentException("The personAddress object should not be null"); } PersonAddress personAddress = (PersonAddress) object; String addressString; if (StringUtils.isNotBlank(personAddress.getAddress1())) { addressString = personAddress.getAddress1(); } else if (StringUtils.isNotBlank(personAddress.getAddress2())) { addressString = personAddress.getAddress2(); } else if (StringUtils.isNotBlank(personAddress.getCityVillage())) { addressString = personAddress.getCityVillage(); } else { addressString = personAddress.toString(); } if (OpenmrsUtil.compareWithNullAsEarliest(personAddress.getStartDate(), new Date()) > 0) { errors.rejectValue("startDate", "PersonAddress.error.startDateInFuture", new Object[] { "'" + addressString + "'" }, "The Start Date for address '" + addressString + "' shouldn't be in the future"); } if (personAddress.getStartDate() != null && OpenmrsUtil.compareWithNullAsLatest(personAddress.getStartDate(), personAddress.getEndDate()) > 0) { errors.rejectValue("endDate", "PersonAddress.error.endDateBeforeStartDate", new Object[] { "'" + addressString + "'" }, "The End Date for address '" + addressString + "' shouldn't be earlier than the Start Date"); } String xml = Context.getLocationService().getAddressTemplate(); List<String> requiredElements; try { AddressTemplate addressTemplate = Context.getSerializationService().getDefaultSerializer().deserialize(xml, AddressTemplate.class); requiredElements = addressTemplate.getRequiredElements(); } catch (Exception e) { errors.reject(Context.getMessageSourceService().getMessage("AddressTemplate.error")); return; } if (requiredElements != null) { for (String fieldName : requiredElements) { try { Object value = PropertyUtils.getProperty(personAddress, fieldName); if (StringUtils.isBlank((String) value)) { errors.reject(Context.getMessageSourceService().getMessage( "AddressTemplate.error.requiredAddressFieldIsBlank", new Object[] { fieldName }, Context.getLocale())); } } catch (Exception e) { errors .reject(Context.getMessageSourceService().getMessage( "AddressTemplate.error.fieldNotDeclaredInTemplate", new Object[] { fieldName }, Context.getLocale())); } } } ValidateUtil.validateFieldLengths(errors, object.getClass(), "address1", "address2", "cityVillage", "stateProvince", "postalCode", "country", "latitude", "longitude", "voidReason", "countyDistrict", "address3", "address4", "address5", "address6", "address7", "address8", "address9", "address10", "address11", "address12", "address13", "address14", "address15"); }
public Object evaluate(Object feature) { Expression arg0 = getExpression(0); Expression arg1 = getExpression(1); MatchAction matchAction = null; if (getParameters().size() > 2) { try { matchAction = (MatchAction) getExpression(2).evaluate(feature, MatchAction.class); } catch (Exception e) { throw new IllegalArgumentException( "Filter Function problem for function equalTo argument #2 - expected one of ANY, ONE or ALL"); } } Filter equalTo = matchAction == null ? getFilterFactory2().equal(arg0, arg1, false) : getFilterFactory2().equal(arg0, arg1, false, matchAction); return equalTo.evaluate(feature); }
public InternalCacheBuilder setIsClient(boolean isClient) { this.isClient = isClient; metricsSessionBuilder.setIsClient(isClient); return this; }
@Override public void init(Cluster cluster, Collection<Host> hosts) { LOG.info("Using provided data-center name '{}' for DataCenterAwareLoadBalancingPolicy", myLocalDc); myClusterMetadata = cluster.getMetadata(); myProtocolVersion = cluster.getConfiguration().getProtocolOptions().getProtocolVersion(); myCodecRegistry = cluster.getConfiguration().getCodecRegistry(); ArrayList<String> notInLocalDC = new ArrayList<>(); for (Host host : hosts) { String dc = getDc(host); if (!dc.equals(myLocalDc)) { notInLocalDC.add(String.format("%s (%s)", host.toString(), dc)); } CopyOnWriteArrayList<Host> hostList = myPerDcLiveHosts.get(dc); if (hostList == null) { myPerDcLiveHosts.put(dc, new CopyOnWriteArrayList<>(Collections.singletonList(host))); } else { hostList.addIfAbsent(host); } } if (!notInLocalDC.isEmpty()) { String nonLocalHosts = Joiner.on(",").join(notInLocalDC); LOG.warn("Some contact points don't match local data center. Local DC = {}. Non-conforming contact points: {}", myLocalDc, nonLocalHosts); } myIndex.set(new SecureRandom().nextInt(Math.max(hosts.size(), 1))); myChildPolicy.init(cluster, hosts); }
public boolean isGE(final XfsVersion version) { return compareTo(version) >= 0; }
@SuppressWarnings("unchecked") public T toClient(ResourceReference serverObject, ToClientConversionOptions options) throws ClassCastException { ClientUriHolder result = null; if (serverObject != null) { if (options != null && options.isExpansionEnabled(serverObject.isLocal())) { try { Resource localResource; if (serverObject.isLocal()) { localResource = serverObject.getLocalResource(); } else { localResource = repositoryService.getResource(getRestrictedRuntimeExecutionContext(), serverObject.getReferenceURI()); } String clientType = resourceConverterProvider.getToClientConverter(localResource).getClientResourceType(); if (options.isExpansionByType(serverObject.isLocal())) { clientType = options.getExpandTypes().stream().filter(((expandClientType) -> isClientConverterExist(localResource.getResourceType(), expandClientType))) .findFirst().orElse(clientType); } if (options.isExpanded(clientType, serverObject.isLocal())) { result = resourceConverterProvider. getToClientConverter(localResource.getResourceType(), clientType) .toClient(localResource, options); } else { result = new ClientReference(serverObject.getTargetURI()); } } catch (AccessDeniedException e) { result = new ClientReference(serverObject.getTargetURI()); } } else { result = new ClientReference(serverObject.getTargetURI()); } } return (T) result; }
@Override public String toString() { return name + ":" + (first == null ? "NA" : first) + "/" + (second == null ? "NA" : second); }
public boolean hasPermission(PID target, Set<String> agentPrincipals, Permission permission) { Set<String> agentPatronPrincipals = new HashSet<>(); Set<String> agentStaffPrincipals = new HashSet<>(); classifyPrincipals(agentPrincipals, agentPatronPrincipals, agentStaffPrincipals); List<PID> path = getObjectPath(target); if (hasStaffPermission(path, agentStaffPrincipals, permission)) { return true; } if (isPatronPermission(permission)) { return hasPatronPermission(path, agentPatronPrincipals, permission); } else { return false; } }
public static ConfigFile parse(String configurationFilePath) throws IOException { return parse(configurationFilePath, null); }
@Override public RawIterator<Object[], ProcedureException> apply( Context ctx, Object[] input, ResourceTracker resourceTracker ) throws ProcedureException { String query = input[0].toString(); try { Iterator<ObjectName> names = jmxServer.queryNames( new ObjectName( query ), null ).iterator(); return RawIterator.from( () -> { if ( !names.hasNext() ) { return null; } ObjectName name = names.next(); try { MBeanInfo beanInfo = jmxServer.getMBeanInfo( name ); return new Object[]{ name.getCanonicalName(), beanInfo.getDescription(), toNeo4jValue( name, beanInfo.getAttributes() ) }; } catch ( JMException e ) { throw new ProcedureException( Status.General.UnknownError, e, "JMX error while accessing `%s`, please report this. Message was: %s", name, e.getMessage() ); } }); } catch ( MalformedObjectNameException e ) { throw new ProcedureException( Status.Procedure.ProcedureCallFailed, "'%s' is an invalid JMX name pattern. Valid queries should use" + "the syntax outlined in the javax.management.ObjectName API documentation." + "For instance, try 'org.neo4j:*' to find all JMX beans of the 'org.neo4j' " + "domain, or '*:*' to find every JMX bean.", query ); } }
@Override public void parse(final JsonNode request) throws InvalidParseOperationException { parseJson(request); internalParseSelect(); }
public static String join(List<String> list, String delim) { StringBuilder sb = new StringBuilder(); String loopDelim = ""; for (String s : list) { sb.append(loopDelim); sb.append(s); loopDelim = delim; } return sb.toString(); }
public static ABICallElection deserializeElection(byte[] data, AddressBasedAuthorizer authorizer) { if (data == null || data.length == 0) { return new ABICallElection(authorizer); } RLPList rlpList = (RLPList) RLP.decode2(data).get(0); if (rlpList.size() % 2 != 0) { throw new RuntimeException("deserializeElection: expected an even number of entries, but odd given"); } int numEntries = rlpList.size() / 2; Map<ABICallSpec, List<UscAddress>> votes = new HashMap<>(); for (int k = 0; k < numEntries; k++) { ABICallSpec spec = deserializeABICallSpec(rlpList.get(k * 2).getRLPData()); List<UscAddress> specVotes = deserializeVoters(rlpList.get(k * 2 + 1).getRLPData()); votes.put(spec, specVotes); } return new ABICallElection(authorizer, votes); }
protected Map<String, String> generateCommonIamPrincipalAuthMetadata( final String iamPrincipalArn) { Map<String, String> metadata = Maps.newHashMap(); metadata.put(CerberusPrincipal.METADATA_KEY_USERNAME, iamPrincipalArn); metadata.put(CerberusPrincipal.METADATA_KEY_IS_IAM_PRINCIPAL, Boolean.TRUE.toString()); Set<String> groups = new HashSet<>(); groups.add("registered-iam-principals"); Set<String> adminRoleArnSet = getAdminRoleArnSet(); if (adminRoleArnSet.contains(iamPrincipalArn) || awsIamRoleArnParser.isAssumedRoleArn(iamPrincipalArn) && adminRoleArnSet.contains( awsIamRoleArnParser.convertPrincipalArnToRoleArn(iamPrincipalArn))) { metadata.put(METADATA_KEY_IS_ADMIN, Boolean.toString(true)); groups.add("admin-iam-principals"); } else { metadata.put(METADATA_KEY_IS_ADMIN, Boolean.toString(false)); } metadata.put(CerberusPrincipal.METADATA_KEY_GROUPS, StringUtils.join(groups, ',')); return metadata; }
DateTime getStartTime() { return startTime; }
public void setMessage(Consumer c, ComplianceReason reason, Date onDate) { String marketingName, id; if (reason.isStacked()) { id = reason.getAttributes().get(ComplianceReason.Attributes.STACKING_ID); marketingName = getStackedMarketingName(id, c, onDate); reason.getAttributes().put(ComplianceReason.Attributes.MARKETING_NAME, marketingName); } else if (reason.isNonCovered()) { id = reason.getAttributes().get(ComplianceReason.Attributes.PRODUCT_ID); marketingName = getInstalledMarketingName(id, c); reason.getAttributes().put(ComplianceReason.Attributes.MARKETING_NAME, marketingName); } else { id = reason.getAttributes().get(ComplianceReason.Attributes.ENTITLEMENT_ID); marketingName = getMarketingName(id, c, onDate); reason.getAttributes().put(ComplianceReason.Attributes.MARKETING_NAME, marketingName); } String key = reason.getKey(); reason.setMessage(i18n.tr(getReasonMessage(key), key, reason.getAttributes().get(ComplianceReason.Attributes.COVERED), reason.getAttributes().get(ComplianceReason.Attributes.PRESENT) )); }
@Override public String process(String value, ResourceResolutionContext context, ResourceResolver resolver) throws ResourceException { BasicValueParserStateMachine machine = BasicValueParserStateMachine.start((key, property, params) -> { Object val = resolver.get(key, params); if (property != null) { for (PropertyResolver strategy : resolutionStrategies) { Object resolution = strategy.resolve(val, property, context, resolver); if (resolution != null) { val = resolution; break; } } } return val; }); char[] chars = value.toCharArray(); for (char c : chars) { machine.onReceived(c); } boolean partialResult = !machine.onComplete(); String result = machine.toString(); if (partialResult) { throw new ValuePostProcessingException(result); } return result; }
public <T> List<List<T>> partition(List<T> records, int partitionSize, boolean equalDistribution) { final List<List<T>> result = new ArrayList<>(partitionSize); final int subListCount = records.size() / partitionSize; final int remainedElements = records.size() % partitionSize; final boolean hasRemainedElements = records.size() % partitionSize != 0; List<T> subList = new ArrayList<>(subListCount); for (int i = 1; i <= records.size(); i++) { subList.add(records.get(i - 1)); if (i % subListCount == 0) { result.add(subList); subList = new ArrayList<>(subListCount); } } if (hasRemainedElements) { if (subList.size() != remainedElements) { throw new IllegalStateException(); } if (!equalDistribution) { result.get(partitionSize - 1).addAll(subList); } else { for (int k = 0, idx = 1; k < subList.size(); k++) { result.get(idx - 1).add(subList.get(k)); idx = (idx + 1) % partitionSize; } } } return result; }
@Override public MetadatasObject getObjectMetadata(String containerName, String objectName, boolean noCache) throws ContentAddressableStorageException { LOGGER.debug(String.format("Get metadata of object %s in container %s", objectName, containerName)); ParametersChecker.checkParameter(ErrorMessage.CONTAINER_OBJECT_NAMES_ARE_A_MANDATORY_PARAMETER.getMessage(), containerName, objectName); try { Optional<TapeObjectReferentialEntity> objectReferentialEntity = objectReferentialRepository.find(containerName, objectName); if (!objectReferentialEntity.isPresent()) { throw new ContentAddressableStorageNotFoundException( String.format("No such object %s in container %s", objectName, containerName)); } MetadatasStorageObject result = new MetadatasStorageObject(); result.setType(ContainerUtils.parseDataCategoryFromContainerName(containerName).getFolder()); result.setObjectName(objectName); result.setDigest(objectReferentialEntity.get().getDigest()); result.setFileSize(objectReferentialEntity.get().getSize()); result.setLastModifiedDate(objectReferentialEntity.get().getLastObjectModifiedDate()); return result; } catch (ObjectReferentialException ex) { throw new ContentAddressableStorageServerException( String.format("Could not get metadata of object %s in container %s", objectName, containerName), ex); } }
@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; String jwt = resolveToken(httpServletRequest); if (StringUtils.hasText(jwt) && this.tokenProvider.validateToken(jwt)) { Authentication authentication = this.tokenProvider.getAuthentication(jwt); SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(servletRequest, servletResponse); }
@Override public void reply(Response<ByteString> message) { metrics.fanout(requestCounter.get()); metrics.response(message); super.reply(message); }
public static byte[] doubleToBytesBE(double d, byte[] bytes, int off) { return longToBytesBE(Double.doubleToLongBits(d), bytes, off); }
@Override public Response toResponse(Throwable e) { if (log.isDebugEnabled()) { log.debug("Uncaught exception in REST call: ", e); } else if (log.isInfoEnabled()) { log.info("Uncaught exception in REST call: {}", e.getMessage()); } if (e instanceof NotFoundException) { return buildResponse(Response.Status.NOT_FOUND, e); } else if (e instanceof InvalidRequestException) { return buildResponse(Response.Status.BAD_REQUEST, e); } else if (e instanceof InvalidTypeIdException) { return buildResponse(Response.Status.NOT_IMPLEMENTED, e); } else if (e instanceof JsonMappingException) { return buildResponse(Response.Status.BAD_REQUEST, e); } else if (e instanceof ClassNotFoundException) { return buildResponse(Response.Status.NOT_IMPLEMENTED, e); } else if (e instanceof SerializationException) { return buildResponse(Response.Status.BAD_REQUEST, e); } else if (e instanceof RequestConflictException) { return buildResponse(Response.Status.CONFLICT, e); } else { return buildResponse(Response.Status.INTERNAL_SERVER_ERROR, e); } }
public void ensureActiveGroup() { ensureCoordinatorReady(); startHeartbeatThreadIfNeeded(); joinGroupIfNeeded(); }
public void controller(FragmentModel model, @SpringBean KenyaUiUtils kenyaui) { Map<String, Object> kenyaemrInfo = ServerInformation.getKenyaemrInformation(); String moduleVersion = (String) kenyaemrInfo.get("version"); boolean isSnapshot = moduleVersion.endsWith("SNAPSHOT"); if (isSnapshot) { Date moduleBuildDate = (Date) kenyaemrInfo.get("buildDate"); moduleVersion += " (" + kenyaui.formatDateTime(moduleBuildDate) + ")"; } model.addAttribute("moduleVersion", moduleVersion); model.addAttribute("systemLocation", Context.getService(KenyaEmrService.class).getDefaultLocation()); model.addAttribute("systemLocationCode", Context.getService(KenyaEmrService.class).getDefaultLocationMflCode()); }
public static byte[] encode(byte[] inBytes) { if (null == inBytes) { throw new NullPointerException("input buffer was null"); } if (inBytes.length < 1) { return new byte[] {}; } int len = inBytes.length; int encodeLen = y64encodeLen(len); byte[] out = new byte[encodeLen]; int j = 0; int tlen; for (int i = 0; i < len; i += 3) { tlen = (len - i); if (tlen > 3) { tlen = 3; } byte a; byte b; byte c; if (tlen == 1) { a = inBytes[i]; b = 0; out[j++] = encode1(a); out[j++] = encode2(a, b); out[j++] = '-'; out[j++] = '-'; } else if (tlen == 2) { a = inBytes[i]; b = inBytes[i + 1]; c = 0; out[j++] = encode1(a); out[j++] = encode2(a, b); out[j++] = encode3(b, c); out[j++] = '-'; } else { a = inBytes[i]; b = inBytes[i + 1]; c = inBytes[i + 2]; out[j++] = encode1(a); out[j++] = encode2(a, b); out[j++] = encode3(b, c); out[j++] = encode4(c); } } return Arrays.copyOf(out, j); }
@NonNull @Override public Single<T> postDelete(@Nullable T t) { return Single.fromCallable(() -> { if (t == null) { throw new Exception("Post delete failed due to a null value"); } return t; }); }
@Override public CreatorSession onLeaveMessage(Transaction txn, CreatorSession s, LeaveMessage m) throws DbException, FormatException { switch (s.getState()) { case START: case LEFT: return abort(txn, s); case INVITED: return onRemoteDecline(txn, s, m); case JOINED: return onRemoteLeave(txn, s, m); case DISSOLVED: case ERROR: return s; default: throw new AssertionError(); } }
@Override public void start() { int concurrency = getOptions().getKernelConcurrency(); log.log(Level.INFO, "kernel.launcher.kernel.concurrency", concurrency); executorService = Executors.newCachedThreadPool(new NamedThreadFactory("kernel")); }
@Override public Response saveChanges(Order order, HttpHeaders headers) { Order oldOrder = orderRepository.findById(order.getId()); if (oldOrder == null) { OrderServiceImpl.LOGGER.info("[Order Service][Modify Order] Fail.Order not found."); return new Response<>(0, orderNotFound, null); } else { oldOrder.setAccountId(order.getAccountId()); oldOrder.setBoughtDate(order.getBoughtDate()); oldOrder.setTravelDate(order.getTravelDate()); oldOrder.setTravelTime(order.getTravelTime()); oldOrder.setCoachNumber(order.getCoachNumber()); oldOrder.setSeatClass(order.getSeatClass()); oldOrder.setSeatNumber(order.getSeatNumber()); oldOrder.setFrom(order.getFrom()); oldOrder.setTo(order.getTo()); oldOrder.setStatus(order.getStatus()); oldOrder.setTrainNumber(order.getTrainNumber()); oldOrder.setPrice(order.getPrice()); oldOrder.setContactsName(order.getContactsName()); oldOrder.setContactsDocumentNumber(order.getContactsDocumentNumber()); oldOrder.setDocumentType(order.getDocumentType()); orderRepository.save(oldOrder); OrderServiceImpl.LOGGER.info("[Order Service] Success."); return new Response<>(1, success, oldOrder); } }
@Override public List<MethodInvokerFilter> getMethodInvokerFilters(String path) { ApplicationContext context = ApplicationContext.getCurrent(); List<MethodInvokerFilter> filters = doGetMatchedFilters(path, invokerFilters).stream() .map(factory -> (MethodInvokerFilter)factory.getInstance(context)) .collect(toList()); filters.addAll(getDefaults().getMethodInvokerFilters(path)); return filters; }
public static void validateExtensions(SaslExtensions extensions) throws SaslException { if (extensions == null) return; if (extensions.map().containsKey(OAuthBearerClientInitialResponse.AUTH_KEY)) throw new SaslException("Extension name " + OAuthBearerClientInitialResponse.AUTH_KEY + " is invalid"); for (Map.Entry<String, String> entry : extensions.map().entrySet()) { String extensionName = entry.getKey(); String extensionValue = entry.getValue(); if (!EXTENSION_KEY_PATTERN.matcher(extensionName).matches()) throw new SaslException("Extension name " + extensionName + " is invalid"); if (!EXTENSION_VALUE_PATTERN.matcher(extensionValue).matches()) throw new SaslException("Extension value (" + extensionValue + ") for extension " + extensionName + " is invalid"); } }
public boolean isPaymentValid(String bankCode, Double amount) { boolean isBankCodeValid = bankCodeValidator.isBankCodeValid(bankCode); if (isBankCodeValid) { if (!banksInFocus.contains(bankCode)) { return true; } else { return amount > 100; } } else { return false; } }
@Override public String toString() { return this.uriTemplate(); }
@Override public void process(final Exchange exchange) throws Exception { final Message message = exchange.getIn(); final Object body = message.getBody(); final JsonNode data = parseBody(body); if (data == null) { return; } final JsonNode paramMap = data.get("parameters"); final JsonNode bodyData = data.get("body"); if (paramMap != null || bodyData != null) { if (paramMap != null) { for (final String key : parameters) { final JsonNode valueNode = paramMap.get(key); if (valueNode != null) { final String val = valueNode.asText(); message.setHeader(key, val); } } } if (bodyData == null) { message.setBody(null); return; } if (bodyData.isContainerNode()) { message.setBody(JsonUtils.toString(bodyData)); return; } message.setHeader(Exchange.CONTENT_TYPE, "text/plain"); message.setBody(bodyData.asText()); } }
@Override public void removeSchema(Name typeName) throws IOException { this.removeSchema(typeName.getLocalPart()); }
public String deleteRedisPool(String poolId) throws IOException { try { configFile = PropertyFile.getProperties(propertyFile); String exist = configFile.getString(poolId + Configs.SEPARATE + Configs.POOL_ID); if (exist == null) { logger.error(ExceptionInfo.DELETE_POOL_NOT_EXIST + poolId); return null; } for (String key : MythReflect.getFieldByClass(RedisPoolProperty.class)) { PropertyFile.delete(poolId + Configs.SEPARATE + key); } } catch (Exception e) { logger.error(ExceptionInfo.OPEN_CONFIG_FAILED, e); return null; } logger.info(NoticeInfo.DELETE_POOL_SUCCESS + poolId, PoolManagement.class); return poolId; }
public long[] toJvmArray() throws IndexOutOfBoundsException { if (length > Integer.MAX_VALUE) { throw new IndexOutOfBoundsException( "array size (" + length + ") too large and cannot be converted into JVM array"); } final long[] arr = new long[(int) length]; PlatformDependent.UNSAFE.copyMemory( baseObj, baseOffset, arr, ARRAY_OFFSET, length * WIDTH); return arr; }
public InnerTypeDefinition.ForType<T> innerTypeOf(TypeDescription type) { throw new UnsupportedOperationException("Cannot change type declaration of decorated type: " + instrumentedType); }
public static CashSwaptionSettlement of(LocalDate settlementDate, CashSwaptionSettlementMethod method) { return new CashSwaptionSettlement(settlementDate, method); }
@SuppressWarnings({ "unchecked", "rawtypes" }) public boolean isEnabled(Properties configuration) { return isEnabled((Map) configuration); }
public EnvironmentModificationPhase MODIFY_QUOTA() { operationTracker.addLog( "Changing container quotas" ); try { new ChangeQuotaStep( environment, changedContainers, operationTracker ).execute(); environment = ( LocalEnvironment ) environmentManager.loadEnvironment( environment.getId() ); return hasContainerDestruction ? EnvironmentModificationPhase.DESTROY_CONTAINERS : EnvironmentModificationPhase.FINALIZE; } catch ( Exception e ) { fail( e.getMessage(), e ); } return null; }
@Override public boolean handleResponse(MessageContext messageContext) { parseContextFromSoapHeader(messageContext.getResponse(), IncomingResponse); return true; }
public String[] getAll (String name) { String[] ret; Object obj = props.get (name); if (obj instanceof String[]) { ret = (String[]) obj; } else if (obj instanceof String) { ret = new String[1]; ret[0] = (String) obj; } else ret = new String[0]; Environment env = Environment.getEnvironment(); IntStream.range(0, ret.length).forEachOrdered(i -> ret[i] = env.getProperty(ret[i])); return Arrays.stream(ret).filter(Objects::nonNull).toArray(String[]::new); }
public static ExplicitRxIndicatorPacket createPacket(byte[] payload) { if (payload == null) throw new NullPointerException("Explicit Rx Indicator packet payload cannot be null."); if (payload.length < MIN_API_PAYLOAD_LENGTH) throw new IllegalArgumentException("Incomplete Explicit Rx Indicator packet."); if ((payload[0] & 0xFF) != APIFrameType.EXPLICIT_RX_INDICATOR.getValue()) throw new IllegalArgumentException("Payload is not an Explicit Rx Indicator packet."); int index = 1; XBee64BitAddress destAddress64 = new XBee64BitAddress(Arrays.copyOfRange(payload, index, index + 8)); index = index + 8; XBee16BitAddress destAddress16 = new XBee16BitAddress(payload[index] & 0xFF, payload[index + 1] & 0xFF); index = index + 2; int sourceEndpoint = payload[index] & 0xFF; index = index + 1; int destEndpoint = payload[index] & 0xFF; index = index + 1; int clusterID = (payload[index] & 0xFF) << 8 | payload[index + 1] & 0xFF; index = index + 2; int profileID = (payload[index] & 0xFF) << 8 | payload[index + 1] & 0xFF; index = index + 2; int receiveOptions = payload[index] & 0xFF; index = index + 1; byte[] rfData = null; if (index < payload.length) rfData = Arrays.copyOfRange(payload, index, payload.length); return new ExplicitRxIndicatorPacket(destAddress64, destAddress16, sourceEndpoint, destEndpoint, clusterID, profileID, receiveOptions, rfData); }
public InsertionData prepareInsertionString(String oiriginInsertion, String textBeforeColumn) { return prepareInsertionString(oiriginInsertion, textBeforeColumn, true); }
@Override public void showTrailers(Movie movie) { trailersSubscription = movieDetailsInteractor.getTrailers(movie.getId()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::onGetTrailersSuccess, t -> onGetTrailersFailure()); }
@Override public DescriptorValue calculate(IBond bond, IAtomContainer atomContainer) { double value = 0; String originalAtomtypeName1 = bond.getBegin().getAtomTypeName(); Integer originalNeighborCount1 = bond.getBegin().getFormalNeighbourCount(); IAtomType.Hybridization originalHybridization1 = bond.getBegin().getHybridization(); Integer originalValency1 = bond.getBegin().getValency(); String originalAtomtypeName2 = bond.getEnd().getAtomTypeName(); Integer originalNeighborCount2 = bond.getEnd().getFormalNeighbourCount(); IAtomType.Hybridization originalHybridization2 = bond.getEnd().getHybridization(); Integer originalValency2 = bond.getEnd().getValency(); Double originalBondOrderSum1 = bond.getBegin().getBondOrderSum(); Order originalMaxBondOrder1 = bond.getBegin().getMaxBondOrder(); Double originalBondOrderSum2 = bond.getEnd().getBondOrderSum(); Order originalMaxBondOrder2 = bond.getEnd().getMaxBondOrder(); if (!isCachedAtomContainer(atomContainer)) { try { AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(atomContainer); LonePairElectronChecker lpcheck = new LonePairElectronChecker(); lpcheck.saturate(atomContainer); } catch (CDKException e) { return getDummyDescriptorValue(e); } } if (!bond.getOrder().equals(IBond.Order.SINGLE)) { try { value = IonizationPotentialTool.predictIP(atomContainer, bond); } catch (CDKException e) { return getDummyDescriptorValue(e); } } bond.getBegin().setAtomTypeName(originalAtomtypeName1); bond.getBegin().setHybridization(originalHybridization1); bond.getBegin().setValency(originalValency1); bond.getBegin().setFormalNeighbourCount(originalNeighborCount1); bond.getEnd().setAtomTypeName(originalAtomtypeName2); bond.getEnd().setHybridization(originalHybridization2); bond.getEnd().setValency(originalValency2); bond.getEnd().setFormalNeighbourCount(originalNeighborCount2); bond.getBegin().setMaxBondOrder(originalMaxBondOrder1); bond.getBegin().setBondOrderSum(originalBondOrderSum1); bond.getEnd().setMaxBondOrder(originalMaxBondOrder2); bond.getEnd().setBondOrderSum(originalBondOrderSum2); return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(value), DESCRIPTOR_NAMES); }
public static Builder newBuilder(SpanExporter spanExporter) { return new Builder(spanExporter); }
public FEELFnResult<BigDecimal> invoke(@ParameterName( "n" ) BigDecimal n) { if ( n == null ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "n", "cannot be null")); } return FEELFnResult.ofResult( n.setScale( 0, BigDecimal.ROUND_CEILING ) ); }
public <T> T post(String path, String content, ResponseCallback<T> callback) { return handleResponse(callback, client.post(path, content)); }
public String stringValue(String key) { return responseMap.get(key); }
public float interpolate(float x1, float x2) { return interpolate00(x1,x2); }
public static RegionSplitPolicy create(HRegion region, Configuration conf) throws IOException { Class<? extends RegionSplitPolicy> clazz = getSplitPolicyClass( region.getTableDesc(), conf); RegionSplitPolicy policy = ReflectionUtils.newInstance(clazz, conf); policy.configureForRegion(region); return policy; }
public static void evaluateBindings(CompositeTemplate compositeTemplate) { if (compositeTemplate.bindings == null || compositeTemplate.bindings.isEmpty()) { return; } Map<String, ComponentTemplate<?>> componentNameToTemplate = getComponentNameToDescription( compositeTemplate); Map<String, ComponentBinding> bindingByComponentName = getBindingByComponentName( compositeTemplate.bindings); for (Binding.ComponentBinding componentBinding : bindingByComponentName.values()) { @SuppressWarnings("rawtypes") ComponentTemplate componentTemplate = componentNameToTemplate .get(componentBinding.componentName); for (Binding binding : componentBinding.bindings) { if (binding.isProvisioningTimeBinding()) { continue; } try { evaluateBinding(binding, componentBinding.componentName, componentTemplate, componentNameToTemplate, bindingByComponentName, new HashSet<>()); } catch (ReflectiveOperationException | IOException e) { throw new RuntimeException(e); } } } }
protected int scrollBy(int amount, RecyclerView.Recycler recycler) { if (recyclerViewProxy.getChildCount() == 0) { return 0; } Direction direction = Direction.fromDelta(amount); int leftToScroll = calculateAllowedScrollIn(direction); if (leftToScroll <= 0) { return 0; } int delta = direction.applyTo(Math.min(leftToScroll, Math.abs(amount))); scrolled += delta; if (pendingScroll != 0) { pendingScroll -= delta; } orientationHelper.offsetChildren(-delta, recyclerViewProxy); if (orientationHelper.hasNewBecomeVisible(this)) { fill(recycler); } notifyScroll(); applyItemTransformToChildren(); return delta; }
public Column[] filterIncludedColumns(Column[] src) { if (src != null) { List<String> includedColumnNames = getIncludedColumnNamesAsList(); if (includedColumnNames.size() == 0) { return src; } List<Column> filtered = new ArrayList<Column>(src.length); for (int i = 0; i < src.length; i++) { Column col = src[i]; if (includedColumnNames.contains(col.getName().toLowerCase())) { filtered.add(col); } } return filtered.toArray(new Column[filtered.size()]); } else { return new Column[0]; } }
@Override public void executionSkipped( TestIdentifier testIdentifier, String reason ) { testStartTime.remove( testIdentifier ); runListener.testSkipped( createReportEntry( testIdentifier, null, emptyMap(), reason, null ) ); }
@Nullable @Override protected Long evictionCount() { return null; }
@Override public int getNumDocuments() { return docs.size(); }
public static Version of(@NotNull final String string) { ArrayList<Integer> b = new ArrayList<Integer>(5); final String[] substrings = string.split("[.,\\-_ ]|(?<=\\d)(?!\\d)|(?<!\\d)(?=\\d)"); for (String ss : substrings) { String ss2 = ss.trim().toLowerCase(Locale.ENGLISH); if (ss2.isEmpty()) continue; Integer special = SPECIAL_VALUES.get(ss2); if (special != null) b.add(special); else { try { Integer v = new Integer(ss2); b.add(v); } catch (NumberFormatException e) { break; } } } if (b.isEmpty()) throw new IllegalArgumentException("Failed to parse version \""+string+"\""); if (b.size() == 1 && b.get(0) == 0) return ZERO; return of(b.toArray(new Integer[b.size()])); }
public int getPackedLength(int nBytes) { return nBytes * 2; }
protected SessionLoginTokenData verifyFactor( final String deviceId, final String stateToken, final String otpToken) { final VerifyFactorResponse verifyFactorResponse = oneLoginClient.verifyFactor(deviceId, stateToken, otpToken); if (verifyFactorResponse.getStatus().isError()) { String msg = String.format( "stateToken: %s failed to verify 2nd factor for reason: %s", stateToken, verifyFactorResponse.getStatus().getMessage()); if (verifyFactorResponse.getStatus().getCode() == 401) { throw ApiException.newBuilder() .withApiErrors(DefaultApiError.AUTH_BAD_CREDENTIALS) .withExceptionMessage(msg) .build(); } else { throw ApiException.newBuilder() .withApiErrors(DefaultApiError.GENERIC_BAD_REQUEST) .withExceptionMessage(msg) .build(); } } return verifyFactorResponse.getData().get(0); }
public void lower() { high = mid - 1; }
public static String escapeString(String in, Map<String, String> headers) { return escapeString(in, headers, false, 0, 0); }
public Set<String> getMembersSet(String key) { return getJedis().smembers(key); }
@Override public String generateURL(XYDataset dataset, int series, int item) { String result = this.prefix; boolean firstParameter = result.indexOf("?") == -1; Comparable seriesKey = dataset.getSeriesKey(series); if (seriesKey != null) { result += firstParameter ? "?" : "&amp;"; result += this.seriesParameterName + "=" + URLUtilities.encode( seriesKey.toString(), "UTF-8"); firstParameter = false; } long x = (long) dataset.getXValue(series, item); String xValue = this.dateFormat.format(new Date(x)); result += firstParameter ? "?" : "&amp;"; result += this.itemParameterName + "=" + URLUtilities.encode(xValue, "UTF-8"); return result; }
@Override public Throwable getCause() { return super.getCause(); }
@Override public void release() throws IOException { synchronized (lock) { LOCK_TABLE.remove(lock); FileLocks.release(lock); } }
public static double getArgAsDouble(final Object arg) throws IllegalArgumentException { if (arg.getClass() == Double.class) return (Double)arg; if (arg.getClass() == Long.class) return (double)(Long)arg; if (arg.getClass() == String.class) { try { return Double.parseDouble((String)arg); } catch (final Exception e) { throw new IllegalArgumentException("can't convert \"" + arg + "\" to a floating point number.", e); } } if (arg.getClass() == Boolean.class) return (Boolean)arg ? 1.0 : 0.0; throw new IllegalArgumentException("can't convert argument to a floating point number."); }
public SessionContext onLogon(final CompositeKey compositeKey, final FixDictionary fixDictionary) { final SessionContext sessionContext = newSessionContext(compositeKey, fixDictionary); if (!currentlyAuthenticatedSessionIds.add(sessionContext.sessionId())) { return DUPLICATE_SESSION; } return sessionContext; }
@Override public boolean split(Lonely cstr, Instance origin, final List<Instance> partitions, TIntIntHashMap vmsPosition, TIntIntHashMap nodePosition) { final boolean c = cstr.isContinuous(); return SplittableElementSet.newVMIndex(cstr.getInvolvedVMs(), vmsPosition). forEachPartition((index, idx, from, to) -> { if (to != from) { partitions.get(idx).getSatConstraints().add(new Lonely(new ElementSubSet<>(index, idx, from, to), c)); } return true; }); }
public static <T> T[] getBeans(Class<T> interfaceClass) { Object object = serviceMap.get(interfaceClass.getName()); if(object == null) return null; if(object instanceof Object[]) { return (T[])object; } else { Object array = Array.newInstance(interfaceClass, 1); Array.set(array, 0, object); return (T[])array; } }
@Override public void remove() { throw new UnsupportedOperationException( "Removal is not supported"); }
void onCtrlD() { consumeIfDataTypeIsNotReadOnly(DataTypeListItem::insertFieldBelow); }
@Override public void draw(final ParameterizedCommand<CommandResult> loadCallback) { wrapped.draw(loadCallback); }
@SuppressWarnings("ResultOfMethodCallIgnored") @Override protected Void doInBackground(Void... params) { mFile.delete(); return null; }
public static LongDoublePair of(long first, double second) { return new LongDoublePair(first, second); }
@Override public boolean hasPrivileges(@Nullable Tree tree, @NotNull String... privilegeNames) { if (tree == null) { return false; } for (String privilegeName : privilegeNames) { if (!READ_PRIVILEGE_NAMES.contains(privilegeName)) { return false; } } return canRead(tree); }
public boolean revisit(Gadget gadget, List<Node> nodes) throws RewritingException { List<List<Element>> concatBuckets = Lists.newLinkedList(); List<Element> curBucket = Lists.newLinkedList(); Iterator<Node> nodeIter = nodes.iterator(); Element cur = (Element)nodeIter.next(); curBucket.add(cur); while (nodeIter.hasNext()) { Element next = (Element)nodeIter.next(); if ((!split && cur != getSibling(next, true)) || (type == ConcatUriManager.Type.CSS && !areLinkNodesBucketable(cur, next))) { concatBuckets.add(curBucket); curBucket = Lists.newLinkedList(); } curBucket.add(next); cur = next; } concatBuckets.add(curBucket); List<List<Element>> concatBatches = Lists.newLinkedList(); Iterator<List<Element>> batchesIter = concatBuckets.iterator(); while (batchesIter.hasNext()) { splitBatchOnMedia(batchesIter.next(), concatBatches); } List<List<Uri>> uriBatches = Lists.newLinkedList(); batchesIter = concatBatches.iterator(); while (batchesIter.hasNext()) { List<Element> batch = batchesIter.next(); List<Uri> uris = Lists.newLinkedList(); if (batch.isEmpty() || !getUris(type, batch, uris)) { batchesIter.remove(); continue; } uriBatches.add(uris); } if (uriBatches.isEmpty()) { return false; } List<ConcatUriManager.ConcatData> concatUris = uriManager.make( ConcatUriManager.ConcatUri.fromList(gadget, uriBatches, type), !split); Iterator<List<Element>> elemBatchIt = concatBatches.iterator(); Iterator<List<Uri>> uriBatchIt = uriBatches.iterator(); for (ConcatUriManager.ConcatData concatUri : concatUris) { List<Element> sourceBatch = elemBatchIt.next(); List<Uri> sourceUris = uriBatchIt.next(); Element firstElem = sourceBatch.get(0); for (Uri uri : concatUri.getUris()) { Element elemConcat = (Element)firstElem.cloneNode(true); elemConcat.setAttribute(type.getSrcAttrib(), uri.toString()); firstElem.getParentNode().insertBefore(elemConcat, firstElem); } Iterator<Uri> uriIt = sourceUris.iterator(); for (Element elem : sourceBatch) { Uri elemOrigUri = uriIt.next(); String snippet = concatUri.getSnippet(elemOrigUri); if (!Strings.isNullOrEmpty(snippet)) { Node scriptNode = elem.getOwnerDocument().createElement("script"); scriptNode.setTextContent(snippet); elem.getParentNode().insertBefore(scriptNode, elem); } elem.getParentNode().removeChild(elem); } } return true; }
public String generateLocalized( Asset asset, String content, RepositoryLocale repositoryLocale, String outputBcp47tag, FilterConfigIdOverride filterConfigIdOverride, List<String> filterOptions, Status status, InheritanceMode inheritanceMode) throws UnsupportedAssetFilterTypeException { String bcp47Tag; if (outputBcp47tag == null) { bcp47Tag = repositoryLocale.getLocale().getBcp47Tag(); } else { logger.debug("An output bcp47 tag: {} is specified (won't use the default tag (from the repository locale)", outputBcp47tag); bcp47Tag = outputBcp47tag; } logger.debug("Configuring pipeline for localized XLIFF generation"); BasePipelineStep translateStep = (BasePipelineStep) new TranslateStep(asset, repositoryLocale, inheritanceMode, status); return generateLocalizedBase(asset, content, filterConfigIdOverride, filterOptions, translateStep, bcp47Tag); }
public List<Key> toKeys() { List<Key> keys = new ArrayList<>(); if (StringUtils.isNotBlank(metric)) { keys.add(new Key(METRIC_PREFIX + metric)); } if (StringUtils.isNotBlank(tagKey)) { keys.add(new Key(TAG_PREFIX + metric, tagKey)); } if (StringUtils.isNotBlank(tagKey) && StringUtils.isNotBlank(tagValue)) { keys.add(new Key(VALUE_PREFIX + metric, tagKey, tagValue)); } return keys; }
static public byte[] sign(PrivateKey key, byte[] data) { return sign(key, data, true); }
@Override public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof ExtendedBlock)) { return false; } ExtendedBlock b = (ExtendedBlock)o; return b.block.equals(block) && (b.poolId != null ? b.poolId.equals(poolId) : poolId == null); }
@Override public boolean isDuplicateKeyViolation(Exception exception) { return causeIsEntityExistsException(exception) || findException(exception, SQLException.class) .map(sqlException -> isDuplicateKeyCode(sqlException, duplicateKeyCodes)).orElse(false); }
@Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException { return userRepository.findByEmail(email) .map(SnUserDetails::new) .orElseThrow(() -> new UsernameNotFoundException("User with email " + email + " doesn't exist")); }
@Override @SuppressWarnings("unchecked") public int compareTo(ImmutablePair<L, R> o) { if (o == null) { throw new IllegalArgumentException("Pair to compare to must not be null"); } try { int leftComparison = compare((Comparable<L>) getLeft(), (Comparable<L>) o.getLeft()); return leftComparison == 0 ? compare((Comparable<R>) getRight(), (Comparable<R>) o.getRight()) : leftComparison; } catch (ClassCastException cce) { throw new IllegalArgumentException("Please provide comparable elements", cce); } }
public void setDefault() { int i; int nrargs; nrargs = 0; allocate( nrargs ); for ( i = 0; i < nrargs; i++ ) { argumentField[ i ] = "arg" + i; argumentParameter[ i ] = "arg"; argumentHeader[ i ] = false; } int nrquery; nrquery = 0; allocateQuery( nrquery ); for ( i = 0; i < nrquery; i++ ) { queryField[ i ] = "query" + i; queryParameter[ i ] = "query"; } fieldName = "result"; resultCodeFieldName = ""; responseTimeFieldName = ""; responseHeaderFieldName = ""; encoding = DEFAULT_ENCODING; postafile = false; socketTimeout = String.valueOf( DEFAULT_SOCKET_TIMEOUT ); connectionTimeout = String.valueOf( DEFAULT_CONNECTION_TIMEOUT ); closeIdleConnectionsTime = String.valueOf( DEFAULT_CLOSE_CONNECTIONS_TIME ); }
@Override public Class<?> getCommonPropertyType(ELContext context, Object base) { if (base != null) { return null; } return String.class; }
@Override public synchronized JcrSession login() throws RepositoryException { return login(null, null); }
public static MultiAdaptersCreator empty() { return new MultiAdaptersCreator(new ArrayList<>()); }
protected void createExeDir() throws PGEException { logger.info("Creating PGE execution working directory: [{}]", pgeConfig.getExeDir()); File executionDir = new File(pgeConfig.getExeDir()); if (!(executionDir.exists() || executionDir.mkdirs())) { logger.warn("Unable to create execution working directory: {}", pgeConfig.getExeDir()); throw new PGEException("mkdirs returned false for creating [" + pgeConfig.getExeDir() + "]"); } }
public static <T> Option<T> getLast(T[] array) { return get(array, array.length - 1); }
public boolean canAddDependency(final Dependency newDependency, boolean checkVersion) { return newDependency != null && !isDependencyRegistered(newDependency, checkVersion) && !Dependency.isHigherLevel(newDependency.getType().toString(), packaging); }
public Map<String, Object> checkProjectAndAuth(User loginUser, Project project, String projectName) { Map<String, Object> result = new HashMap<>(5); if (project == null) { putMsg(result, Status.PROJECT_NOT_FOUNT, projectName); } else if (!checkReadPermission(loginUser, project)) { putMsg(result, Status.USER_NO_OPERATION_PROJECT_PERM, loginUser.getUserName(), projectName); }else { putMsg(result, Status.SUCCESS); } return result; }
@Override public Partition<E, V> apply(Graph<E, V> graph) { return apply(graph, EdgeFilters.acceptAll(), NodeFilters.acceptAll()); }
public void authenticate(final String userId, final String password) throws AuthenticationFailedException, UserIdLockedException, PasswordExpiredException { if (userId == null || password == null) { throw new AuthenticationFailedException(userId); } Date sysDate = new Timestamp(DateUtil.getDate(SystemTimeUtil.getDateString()).getTime()); final SystemAccount account; try { account = UniversalDao.findBySqlFile( SystemAccount.class, "FIND_SYSTEM_ACCOUNT", new Object[]{userId, sysDate}); } catch (NoDataException e) { throw new AuthenticationFailedException(userId); } authenticate(account, password, sysDate); }
public RuntimeOptionsBuilder parse(String... args) { return parse(Arrays.asList(args)); }
DMNValidator.ValidatorBuilder.ValidatorImportReaderResolver getValidatorImportReaderResolver(final Metadata metadata) { return (modelNamespace, modelName, locationURI) -> { final Path modelPath = importsHelper.getDMNModelPath(metadata, modelNamespace, modelName); final URI pmmlURI = getPMMLURI(modelPath, locationURI); final String pmmlXML = importsHelper.loadPath(getPath(pmmlURI)).map(dmnIOHelper::isAsString).orElse(""); return getStringReader(pmmlXML); }; }
public boolean isMatch(final String path) { if (validator == null || StringUtils.isEmpty(path)) { return false; } if (validator.isValid(path)) { return true; } for (String inputPattern : inputPatterns) { if (path.startsWith(inputPattern)) { return true; } } return false; }
@Nonnull public String string(@Nonnull String key) { DockerCloudUtils.requireNonNull(key, "Resource key cannot be null."); return queryString(key); }
public static boolean exists(String fileOrDirectoryName) { File fileOrDirectory = new File(fileOrDirectoryName); return fileOrDirectory.exists(); }
@Override public void handle(String chargingStationId, JsonObject commandObject, IdentityContext identityContext) throws UserIdentityUnauthorizedException { ChargingStationId csId = new ChargingStationId(chargingStationId); if (!commandAuthorizationService.isAuthorized(csId, identityContext.getUserIdentity(), RequestSendAuthorizationListCommand.class)) { throw new UserIdentityUnauthorizedException(chargingStationId, identityContext.getUserIdentity(), RequestSendAuthorizationListCommand.class); } try { Set<IdentifyingToken> authorizationList = Sets.newHashSet(); SendAuthorizationListApiCommand command = gson.fromJson(commandObject, SendAuthorizationListApiCommand.class); authorizationList.addAll(command.getItems()); AuthorizationListUpdateType updateType = AuthorizationListUpdateType.valueOf(command.getUpdateType()); ChargingStation chargingStation = repository.findOne(chargingStationId); if (chargingStation != null && chargingStation.communicationAllowed()) { commandGateway.send(new RequestSendAuthorizationListCommand(csId, authorizationList, command.getListVersion(), "", updateType, identityContext), new CorrelationToken()); } else { throw new IllegalStateException("It is not possible to send a authorization list to a charging station that is not registered"); } } catch (JsonSyntaxException ex) { throw new IllegalArgumentException("SendAuthorizationList command not able to parse the payload, is your json correctly formatted?", ex); } }
public static byte[] buildPsshAtom(UUID systemId, @Nullable byte[] data) { return buildPsshAtom(systemId, null, data); }
public static byte[] trimLeadingZeroes(byte[] bytes) { return trimLeadingBytes(bytes, (byte) 0); }
@Override public List<AppRelease> findAllByAppName(String appName) { List<AppRelease> result = appDao.findByAppName(appName).map(app -> { return appReleaseDao.findByAppIdOrderByIdDesc(app.getId()); }).orElse(Collections.emptyList()); result.forEach(release -> { release.setName(appName); }); return result; }
public FluentElementFilter<ELEMENT> removeDuplicates() { return new FluentElementFilter<>((List<ELEMENT>) TransitionFilters.REMOVE_DUPLICATES_ELEMENTS.transition(elements)); }
@Override public InputStream getInputStream() throws IOException { return new FileInputStream(file); }
@RequestMapping(value = "/register.action", method = RequestMethod.POST, produces = "application/json;charset=UTF-8") public @ResponseBody Map<String, Object> registerUser(HttpServletRequest request, @RequestParam String email, @RequestParam String password) { try { E user = getEntityClass().newInstance(); user.setEmail(email); user.setAccountName(email); user.setPassword(password); user.setActive(false); user = service.registerUser(user, request); return ResultSet.success("You have been registered. " + "Please check your mails (" + user.getEmail() + ") for further instructions."); } catch (Exception e) { logger.error("Could not register a new user: " + e.getMessage()); return ResultSet.error("Could not register a new user."); } }
@Override public int hashCode() { return Objects.hash( mode, modeSpecified, method, methodSpecified, interpPoints, parameters, fallback); }
void grsImport(final GrsSource grsSource, final boolean rebuild) { final AuthoritativeResource authoritativeResource = grsSource.getAuthoritativeResource(); if (sourceContext.isVirtual(grsSource.getName())) { grsSource.getLogger().info("Not updating GRS data"); } else { acquireAndUpdateGrsData(grsSource, rebuild, authoritativeResource); } resourceTagger.tagObjects(grsSource); }
public void writeTheme( final XMLStreamWriter writer, final Theme theme ) throws XMLStreamException { final LayerMetadata layerMetadata = new LayerMetadataMerger().merge( theme ); final DatasetMetadataFactory factory = new DatasetMetadataFactory(); final List<DatasetMetadata> dsMd1 = getDatasetMetadataFromProvider( theme ); final DatasetMetadata dsMd2 = factory.buildDatasetMetadata( layerMetadata, theme, mdUrlTemplate ); if ( dsMd1 != null && dsMd2 != null ) dsMd1.add( dsMd2 ); final DatasetMetadata datasetMetadata = new DatasetMetadataMerger().merge( dsMd1 ); final DoublePair scaleDenominators = new LayerMetadataMerger().mergeScaleDenominators( theme ); final Map<String, String> authorityNameToUrl = getExternalAuthorityNameToUrlMap( metadataProvider ); writeTheme( writer, layerMetadata, datasetMetadata, authorityNameToUrl, scaleDenominators, theme.getThemes() ); }
public void setStatusDescription(String statusDescription) { this.statusDescription = statusDescription; }
@Override protected BaseQueryBuilder build(final StudyPlanCycle context, final BaseQueryBuilder builder) { return builder .where() .openBracket() .addAndCondition(NAME_CONDITION, context.getName()) .addAndCondition(ABBR_NAME_CONDITION, context.getAbbrName()) .closeBracket(); }
@Override protected ConnectClientRequest cloneAsVersion(final ABIVersion version) { return new ConnectClientRequest(this, version); }
@SuppressWarnings("try") public Optional<Location> searchDeclarationLocation( final File file, final int line, final int column, final String symbol) throws ExecutionException, IOException { try (TelemetryUtils.ScopedSpan scope = TelemetryUtils.startScopedSpan("LocationSearcher.searchDeclarationLocation")) { TelemetryUtils.ScopedSpan.addAnnotation( TelemetryUtils.annotationBuilder() .put("line", line) .put("column", column) .put("symbol", symbol) .build("args")); final Source source = getSource(file); log.trace("search symbol {} {}", symbol, source.getFile()); return this.functions.stream() .map(f -> f.apply(source, line, column, symbol)) .filter(Optional::isPresent) .findFirst() .orElse(Optional.empty()); } }
public void setDisplayPrecision(boolean displayPrecision) { this.displayPrecision = displayPrecision; }
public SearchResponse submitSearch(SearchRequest request) throws InvalidSearchException { LOG.debug("About to submit a search; request={}", ElasticsearchUtils.toJSON(request).orElse("???")); org.elasticsearch.action.search.SearchResponse esResponse; try { esResponse = client.getHighLevelClient().search(request); LOG.debug("Got Elasticsearch response with {} hit(s); response={}", esResponse.getHits().getTotalHits(), esResponse.toString()); } catch (Exception e) { String msg = String.format( "Failed to execute search; error='%s', search='%s'", ExceptionUtils.getRootCauseMessage(e), ElasticsearchUtils.toJSON(request).orElse("???")); LOG.error(msg, e); throw new InvalidSearchException(msg, e); } if(esResponse.getFailedShards() > 0) { handleShardFailures(request, esResponse); } if(RestStatus.OK == esResponse.status()) { return esResponse; } else { String msg = String.format( "Bad search response; status=%s, timeout=%s, terminatedEarly=%s", esResponse.status(), esResponse.isTimedOut(), esResponse.isTerminatedEarly()); LOG.error(msg); throw new InvalidSearchException(msg); } }
public RaftLogEntry get( long logIndex ) throws IOException { RaftLogEntry entry = null; if ( useCache ) { entry = inFlightCache.get( logIndex ); } if ( entry == null ) { useCache = false; entry = getUsingCursor( logIndex ); } if ( pruneAfterRead ) { inFlightCache.prune( logIndex ); } return entry; }
public static SurfaceIborCapletFloorletVolatilityBootstrapDefinition of( IborCapletFloorletVolatilitiesName name, IborIndex index, DayCount dayCount, GridSurfaceInterpolator interpolator) { return of(name, index, dayCount, interpolator, null); }
@Override public StreamTableSource<Row> createStreamTableSource(Map<String, String> properties) { final DescriptorProperties descriptorProperties = getValidatedProperties(properties); return JDBCTableSource.builder() .setOptions(getJDBCOptions(descriptorProperties)) .setReadOptions(getJDBCReadOptions(descriptorProperties)) .setLookupOptions(getJDBCLookupOptions(descriptorProperties)) .setSchema(descriptorProperties.getTableSchema(SCHEMA)) .build(); }
@Nullable String getCollectionName(BsonDocument command, String commandName) { if (COMMANDS_WITH_COLLECTION_NAME.contains(commandName)) { String collectionName = getNonEmptyBsonString(command.get(commandName)); if (collectionName != null) { return collectionName; } } return getNonEmptyBsonString(command.get("collection")); }
@Override public TableProvider create(String dir) { TableProvider retVal = null; try { Path dirPath = Paths.get(dir); if (!Files.exists(dirPath)) { Files.createDirectory(dirPath); } retVal = new DataBaseProvider(dir); } catch (AccessDeniedException e) { String eMessage = String.format("%s: Access denied", e.getMessage()); throw new IllegalArgumentException(eMessage); } catch (NullPointerException e) { throw new IllegalArgumentException("fizteh.db.dir is not specified"); } catch (FileNotFoundException | NoSuchFileException e) { throw new IllegalArgumentException(dir + ": No such Directory"); } catch (IOException e) { throw new IllegalArgumentException(e.getMessage()); } return retVal; }
public void put(String path) { handleVoidResponse(client.put(path)); }
public Optional<SemanticVersion.ChangeType> computeChangeType() throws JApiCmpException { if (this.oldVersions.isEmpty()) { if (!ignoreMissingOldVersion) { throw new JApiCmpException(JApiCmpException.Reason.IllegalArgument, "Could not extract semantic version for at least one old version. Please " + "follow the rules for semantic versioning."); } else { return Optional.absent(); } } if (this.newVersions.isEmpty()) { if (!ignoreMissingNewVersion) { throw new JApiCmpException(JApiCmpException.Reason.IllegalArgument, "Could not extract semantic version for at least one new version. Please " + "follow the rules for semantic versioning."); } else { return Optional.absent(); } } if (allVersionsTheSame(oldVersions) && allVersionsTheSame(newVersions)) { SemanticVersion oldVersion = oldVersions.get(0); SemanticVersion newVersion = newVersions.get(0); return oldVersion.computeChangeType(newVersion); } else { if (oldVersions.size() != newVersions.size()) { throw new JApiCmpException(JApiCmpException.Reason.IllegalArgument, "Cannot compare versions because the number of old versions is different than the number of new versions."); } else { List<SemanticVersion.ChangeType> changeTypes = new ArrayList<>(); for (int i=0; i<oldVersions.size(); i++) { SemanticVersion oldVersion = oldVersions.get(i); SemanticVersion newVersion = newVersions.get(i); Optional<SemanticVersion.ChangeType> changeTypeOptional = oldVersion.computeChangeType(newVersion); if (changeTypeOptional.isPresent()) { changeTypes.add(changeTypeOptional.get()); } } SemanticVersion.ChangeType maxRank = SemanticVersion.ChangeType.UNCHANGED; for (SemanticVersion.ChangeType changeType : changeTypes) { if (changeType.getRank() > maxRank.getRank()) { maxRank = changeType; } } return Optional.fromNullable(maxRank); } } }
public int getRegistriesCount() { return MicroserviceManager.getInstance().getRegistries().size(); }
public int partition(long hash) { return segment[(int) (hash & AND_VALUE)]; }
@Override public void setValue(K key, Double value) { if (!containsKey(key)) { throw new IllegalArgumentException(MapGenotype.ERROR_MESSAGE_INVALID_KEY); } int i = keys.indexOf(key); if (value < bounds.getLowerBound(i) || value > bounds.getUpperBound(i)) { throw new IllegalArgumentException(MapGenotype.ERROR_MESSAGE_OUT_OF_BOUNDS); } while (size() <= i) { add(bounds.getLowerBound(i)); } set(i, value); }
public PermissionProvider getPermissionProvider() { return permissionProvider; }
@Nullable public ELEMENTTYPE next () { if (!hasNext ()) throw new NoSuchElementException (); final ELEMENTTYPE aRet = m_aCurrent; _gotoNextCurrent (); return aRet; }
public static Future<JsonObject> transform(String jsonInput, JoltSpec spec) { Future<JsonObject> future = Future.future(); try { Chainr chainr = spec.getChainr(); Object inputJSON = JsonUtils.jsonToObject(jsonInput); Object transformedOutput = chainr.transform(inputJSON); future.complete(new JsonObject(JsonUtils.toJsonString(transformedOutput))); } catch (Exception ex){ future.fail(ex); } return future; }
public static Date parseAndComplete(final String dateExpression, final boolean upComplete) throws ParseException { final String trimmedDateExpression = StringUtils.trim(dateExpression); DateTime parsedDate = new DateTime(org.apache.commons.lang3.time.DateUtils.parseDateStrictly(trimmedDateExpression, SUPPORTED_PATTERNS)); final String[] dateAndTime = trimmedDateExpression.split(" "); if (dateAndTime.length > 2 || parsedDate.getYear() < 1500 || parsedDate.getYear() > 2500) { throw new ParseException(L_WRONG_DATE, 1); } return round(parsedDate, upComplete, dateAndTime).toDate(); }
public static ScriptValue evalKarateExpression(String text, ScenarioContext context) { text = StringUtils.trimToNull(text); if (text == null) { return ScriptValue.NULL; } ScriptValue varValue = getIfVariableReference(text, context); if (varValue != null) { return varValue; } boolean callOnce = isCallOnceSyntax(text); if (callOnce || isCallSyntax(text)) { if (callOnce) { text = text.substring(9); } else { text = text.substring(5); } int pos = text.indexOf(' '); String arg; if (pos != -1) { arg = text.substring(pos); text = text.substring(0, pos); } else { arg = null; } if (callOnce) { return callWithCache(text, arg, context, false); } else { return call(text, arg, context, false); } } else if (isJsonPath(text)) { return evalJsonPathOnVarByName(ScriptValueMap.VAR_RESPONSE, text, context); } else if (isGetSyntax(text) || isDollarPrefixed(text)) { int index = -1; if (text.startsWith("$")) { text = text.substring(1); } else if (text.startsWith("get[")) { int pos = text.indexOf(']'); index = Integer.valueOf(text.substring(4, pos)); text = text.substring(pos + 2); } else { text = text.substring(4); } String left; String right; if (isJsonPath(text)) { left = ScriptValueMap.VAR_RESPONSE; right = text; } else if (isVariableAndSpaceAndPath(text)) { int pos = text.indexOf(' '); right = text.substring(pos + 1); left = text.substring(0, pos); } else { StringUtils.Pair pair = parseVariableAndPath(text); left = pair.left; right = pair.right; } ScriptValue sv; if (isXmlPath(right) || isXmlPathFunction(right)) { sv = evalXmlPathOnVarByName(left, right, context); } else { sv = evalJsonPathOnVarByName(left, right, context); } if (index != -1 && sv.isListLike()) { List list = sv.getAsList(); if (!list.isEmpty()) { return new ScriptValue(list.get(index)); } } return sv; } else if (isJson(text)) { DocumentContext doc = JsonUtils.toJsonDoc(text); evalJsonEmbeddedExpressions(doc, context); return new ScriptValue(doc); } else if (isXml(text)) { Document doc = XmlUtils.toXmlDoc(text); evalXmlEmbeddedExpressions(doc, context); return new ScriptValue(doc); } else if (isXmlPath(text)) { return evalXmlPathOnVarByName(ScriptValueMap.VAR_RESPONSE, text, context); } else { return evalJsExpression(text, context); } }
public static String getQueueName(Configuration jobConf) { String hRavenQueueName = jobConf.get(Constants.QUEUENAME_HADOOP2); if (StringUtils.isBlank(hRavenQueueName)) { hRavenQueueName = jobConf .get(Constants.FAIR_SCHEDULER_POOLNAME_HADOOP1); if (StringUtils.isBlank(hRavenQueueName)) { hRavenQueueName = jobConf .get(Constants.CAPACITY_SCHEDULER_QUEUENAME_HADOOP1); if (StringUtils.isBlank(hRavenQueueName)) { hRavenQueueName = Constants.DEFAULT_QUEUENAME; LOG.info(" Found neither " + Constants.FAIR_SCHEDULER_POOLNAME_HADOOP1 + " nor " + Constants.QUEUENAME_HADOOP2 + " nor " + Constants.CAPACITY_SCHEDULER_QUEUENAME_HADOOP1 + " hence presuming FIFO scheduler " + " and setting the queuename to " + Constants.DEFAULT_QUEUENAME); } } } return hRavenQueueName; }
public String getStateBuildFinishedAsChecked() { return getAsChecked(BUILD_FINISHED); }
static byte[] getOrderedRgbBytes(Mode ledMode, byte r, byte g, byte b) { switch (ledMode) { case RGB: return new byte[]{r, g, b}; case RBG: return new byte[]{r, b, g}; case BGR: return new byte[]{b, g, r}; case BRG: return new byte[]{b, r, g}; case GRB: return new byte[]{g, r, b}; case GBR: return new byte[]{g, b, r}; default: throw new IllegalArgumentException(ledMode.name() + " is an unknown " + Mode.class.getSimpleName()); } }
@VisibleForTesting static @NonNull UpdateResult updateInternal(@NonNull Map<String, Object> remote, @NonNull Map<String, Object> localMemory, @NonNull Map<String, Object> localDisk, @NonNull Set<String> remoteCapable, @NonNull Set<String> hotSwap, @NonNull Set<String> sticky) { Map<String, Object> newMemory = new TreeMap<>(localMemory); Map<String, Object> newDisk = new TreeMap<>(localDisk); Set<String> allKeys = new HashSet<>(); allKeys.addAll(remote.keySet()); allKeys.addAll(localDisk.keySet()); allKeys.addAll(localMemory.keySet()); Stream.of(allKeys) .filter(remoteCapable::contains) .forEach(key -> { Object remoteValue = remote.get(key); Object diskValue = localDisk.get(key); Object newValue = remoteValue; if (newValue != null && diskValue != null && newValue.getClass() != diskValue.getClass()) { Log.w(TAG, "Type mismatch! key: " + key); newDisk.remove(key); if (hotSwap.contains(key)) { newMemory.remove(key); } return; } if (sticky.contains(key) && (newValue instanceof Boolean || diskValue instanceof Boolean)) { newValue = diskValue == Boolean.TRUE ? Boolean.TRUE : newValue; } else if (sticky.contains(key)) { Log.w(TAG, "Tried to make a non-boolean sticky! Ignoring. (key: " + key + ")"); } if (newValue != null) { newDisk.put(key, newValue); } else { newDisk.remove(key); } if (hotSwap.contains(key)) { if (newValue != null) { newMemory.put(key, newValue); } else { newMemory.remove(key); } } }); Stream.of(allKeys) .filterNot(remoteCapable::contains) .filterNot(key -> sticky.contains(key) && localDisk.get(key) == Boolean.TRUE) .forEach(key -> { newDisk.remove(key); if (hotSwap.contains(key)) { newMemory.remove(key); } }); return new UpdateResult(newMemory, newDisk, computeChanges(localMemory, newMemory)); }
@Publish @Override public DataSetListResponse dataSetList(DataSetList request) { DataSetListResponse response = WSHelper.makeResponse(DataSetListResponse.class, WSHelper.makeResultOK()); try { ConnectionHandleType connectionHandle = SALUtils.getConnectionHandle(request); CardStateEntry cardStateEntry = SALUtils.getCardStateEntry(states, connectionHandle, false); byte[] cardApplicationID = connectionHandle.getCardApplication(); Assert.securityConditionApplication(cardStateEntry, cardApplicationID, NamedDataServiceActionName.DATA_SET_LIST); CardInfoWrapper cardInfoWrapper = cardStateEntry.getInfo(); DataSetNameListType dataSetNameList = cardInfoWrapper.getDataSetNameList(cardApplicationID); response.setDataSetNameList(dataSetNameList); } catch (ECardException e) { response.setResult(e.getResult()); } catch (Exception e) { LOG.error(e.getMessage(), e); throwThreadKillException(e); response.setResult(WSHelper.makeResult(e)); } return response; }
@Override public FluentWebElementAssert isNotPresent() { if (actual.present()) { failWithMessage("Element in assertion is present"); } return this; }
public String toDisplay(final String input) { final String timeString = removePrefixAndSuffix(input); return formatTime(timeString); }
@Override public Optional<CreateConsentAuthorizationResponse> createConsentAuthorization(PsuIdData psuData, String consentId) { Optional<AisConsent> aisConsentOptional = aisConsentService.getAccountConsentById(consentId); if (aisConsentOptional.isEmpty()) { log.info("Consent-ID [{}]. Create consent authorisation has failed. Consent not found by id.", consentId); return Optional.empty(); } return aisConsentService.createAisConsentAuthorisation(consentId, ScaStatus.RECEIVED, psuData) .map(auth -> { CreateConsentAuthorizationResponse resp = new CreateConsentAuthorizationResponse(); resp.setConsentId(consentId); resp.setAuthorisationId(auth.getAuthorizationId()); resp.setScaStatus(auth.getScaStatus()); resp.setPsuIdData(psuData); return resp; }); }
@Override public int indexOf(Object o) { source.getReadWriteLock().readLock().lock(); try { return source.indexOf(o); } finally { source.getReadWriteLock().readLock().unlock(); } }
public static <T> Builder<T> builder(Class<T> itemClass) { return new Builder<>(itemClass); }
public List<String> generate() { return makeListOfSize(getMaxCombinations()); }
@SuppressWarnings("unchecked") @Override public int compareTo(NextHop o) { CompareToBuilder builder = (new CompareToBuilder()) .append(getType(), o.getType()); if(o.getType() == Type.InetAddress) { builder.append(getAddress().getAddress(), ((InetAddressNextHop<InetAddress>)o).getAddress().getAddress()); } return builder.toComparison(); }
public static Result<Boolean> isRowsEquals(TableMeta tableMetaData, List<Row> oldRows, List<Row> newRows) { if (!CollectionUtils.isSizeEquals(oldRows, newRows)) { return Result.build(false, null); } return compareRows(tableMetaData, oldRows, newRows); }
void authenticate(ConnectionFactoryBuilder builder, OverridableReadOnlyProperties properties) { String authGeneratorClassName = properties.getProperty(AUTH_GENERATOR_PROPERTY_KEY); if (StringUtils.isEmpty(authGeneratorClassName)) { return; } try { Class<AuthDescriptorGenerator> authGeneratorClass = (Class<AuthDescriptorGenerator>) Class.forName(authGeneratorClassName); AuthDescriptorGenerator authDescriptorGenerator = authGeneratorClass.newInstance(); builder.setAuthDescriptor(authDescriptorGenerator.generate(properties)); } catch (ClassNotFoundException e) { throw new IllegalArgumentException(authGeneratorClassName + " does not exists.", e); } catch (InstantiationException e) { throw new IllegalArgumentException(authGeneratorClassName + " class can not be instanticated", e); } catch (IllegalAccessException e) { throw new IllegalArgumentException(authGeneratorClassName + " class can not be instanticated", e); } String authWaitTimeMillis = properties.getProperty(AUTH_WAIT_TIME_MILLIS_PROPERTY_KEY, String.valueOf(DEFAULT_AUTH_WAIT_TIME_MILLIS)); builder.setAuthWaitTime(Long.parseLong(authWaitTimeMillis)); }
public void run() { log.debug("Starting Kafka producer I/O thread."); while (running) { try { run(time.milliseconds()); } catch (Exception e) { log.error("Uncaught error in kafka producer I/O thread: ", e); } } log.debug("Beginning shutdown of Kafka producer I/O thread, sending remaining records."); while (!forceClose && (this.accumulator.hasUndrained() || this.client.inFlightRequestCount() > 0)) { try { run(time.milliseconds()); } catch (Exception e) { log.error("Uncaught error in kafka producer I/O thread: ", e); } } if (forceClose) { log.debug("Aborting incomplete batches due to forced shutdown"); this.accumulator.abortIncompleteBatches(); } try { this.client.close(); } catch (Exception e) { log.error("Failed to close network client", e); } log.debug("Shutdown of Kafka producer I/O thread has completed."); }
@Override public Location loadLocationFor(String bindType, String caseId) { if (bindType.equalsIgnoreCase(CHILD_TYPE)) return loadLocationForChild(caseId); if (bindType.equalsIgnoreCase(MOTHER_TYPE)) return loadLocationForMother(caseId); if (bindType.equalsIgnoreCase(ELIGIBLE_COUPLE_TYPE)) return loadLocationForEC(caseId); return null; }
public static DateTime parseEmbedded(String string0) throws IllegalArgumentException { return parseEmbedded(string0, "yyyy-MM-dd", DateTimeZone.UTC); }
@GET @Path("/history") @Produces(MediaType.APPLICATION_JSON) public Response specGetAllHistory(@Context final HttpServletRequest req) { return asLeaderWithSupervisorManager( manager -> Response.ok( AuthorizationUtils.filterAuthorizedResources( req, manager.getSupervisorHistory(), SPEC_DATASOURCE_READ_RA_GENERATOR, authorizerMapper ) ).build() ); }
@Override public boolean accept(Corc corc) throws IOException { TruthValue[] truthValues = new TruthValue[evaluators.size()]; for (int i = 0; i < evaluators.size(); i++) { truthValues[i] = evaluators.get(i).evaluate(corc); } TruthValue truthValue = searchArgument.evaluate(truthValues); switch (truthValue) { case YES: return true; default: return false; } }
public void setDefaultTimeout(long time, @NonNull TimeUnit timeUnit) { if(timeUnit != null) { timeoutTime = time; timeoutUnit = timeUnit; } else { throw new IllegalArgumentException("timeUnit parameter must not be null"); } }
public static JsonObject parse(InputStream input) { JSONMaker maker = new JSONMaker() ; _parse(input, maker) ; return (JsonObject)maker.jsonValue() ; }
public String deriveViewId(FacesContext context, String viewId) { return deriveViewId(context, viewId, true); }
public synchronized void add_filter(EventFilter f) { Ensure.not_null(f); Ensure.is_false(f.locked()); f.connect(first()); m_filters.add(f); f.lock(m_filters); }
public Elements empty() { for (Element element : this) { element.empty(); } return this; }
@Override public FilterFieldExpression filterBy(final String propertyNameWithOptionalLeadingSlash) throws IllegalArgumentException { requireNonNull(propertyNameWithOptionalLeadingSlash); final String propertyName = stripLeadingSlash(propertyNameWithOptionalLeadingSlash); final Supplier<FilterFieldExpression> defaultSupplier = () -> (FilterFieldExpression) common(propertyName); return FieldExpressionUtil.parseFeatureField(requireNonNull(propertyName)) .<FilterFieldExpression>flatMap(f -> f.getProperty() .flatMap(property -> f.getFeatureId().map(id -> new FeatureIdPropertyExpressionImpl(id, property)) ) ) .orElseGet(defaultSupplier); }
public void addToSearchQueue(BankBranchRequest request) { Map<String, Object> message = new HashMap<>(); message.put("bankbranch_persisted", request); bankBranchQueueRepository.addToSearch(message); }
public DependencyGraph parse(final List<String> cpanListText, final List<String> directDependenciesText) { final Map<String, String> nameVersionMap = createNameVersionMap(cpanListText); final List<String> directModuleNames = getDirectModuleNames(directDependenciesText); final MutableDependencyGraph graph = new MutableMapDependencyGraph(); for (final String moduleName : directModuleNames) { final String version = nameVersionMap.get(moduleName); if (null != version) { final String name = moduleName.replace("::", "-"); final ExternalId externalId = externalIdFactory.createNameVersionExternalId(Forge.CPAN, name, version); final Dependency dependency = new Dependency(name, version, externalId); graph.addChildToRoot(dependency); } else { logger.warn(String.format("Could node find resolved version for module: %s", moduleName)); } } return graph; }
String buildQueryString(RecordType type, String tsdrKey) { StringBuffer queryBuffer = new StringBuffer(); appendCondition(queryBuffer, TsdrRecordPayload.ELK_DATA_CATEGORY, resolveDataCategory(tsdrKey)); try { Long timestamp = FormatUtil.getTimeStampFromTSDRKey(tsdrKey); if (timestamp != null) { appendCondition(queryBuffer, TsdrRecordPayload.ELK_TIMESTAMP, String.valueOf(timestamp)); } } catch (NumberFormatException e) { } if (type == RecordType.METRIC) { appendCondition(queryBuffer, TsdrRecordPayload.ELK_NODE_ID, FormatUtil.getNodeIdFromTSDRKey(tsdrKey)); appendCondition(queryBuffer, TsdrRecordPayload.ELK_METRIC_NAME, FormatUtil.getMetriNameFromTSDRKey(tsdrKey)); List<RecordKeys> recKeys = FormatUtil.getRecordKeysFromTSDRKey(tsdrKey); if (recKeys != null) { for (RecordKeys recKey : recKeys) { appendCondition(queryBuffer, TsdrRecordPayload.ELK_RK_KEY_NAME, recKey.getKeyName()); appendCondition(queryBuffer, TsdrRecordPayload.ELK_RK_KEY_VALUE, recKey.getKeyValue()); } } } if (type == RecordType.LOG) { List<RecordAttributes> recAttrs = FormatUtil.getRecordAttributesFromTSDRKey(tsdrKey); if (recAttrs != null) { for (RecordAttributes recAttr : recAttrs) { appendCondition(queryBuffer, TsdrRecordPayload.ELK_RA_KEY_NAME, recAttr.getName()); appendCondition(queryBuffer, TsdrRecordPayload.ELK_RA_KEY_VALUE, recAttr.getValue()); } } } return queryBuffer.toString(); }
public RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters ) throws ScmException { return (RemoveScmResult) execute( repository, fileSet, parameters ); }
public void resetPosition(long positionUs) { standaloneClock.resetPosition(positionUs); }
public static void clearIndexTable(final String tableName, final Connection connection){ final String clearTable = String.format("DELETE FROM cqtbl_%s;",tableName); Statement statement = null; try { statement = connection.createStatement(); statement.executeUpdate(clearTable); }catch (SQLException e){ throw new IllegalStateException("Unable to clear index table: " + tableName, e); }finally{ DBUtils.closeQuietly(statement); } }
@Override public String[] getFormatNames() { return WorldView2Constants.FORMAT_NAMES; }
@Override public int hashCode() { return Objects.hash(email, password, properties); }
@Override public Date getDate() { return crime.getDate(); }
public void registerBindable(Bindable bindable) { registrar.registerBindable(bindable); }
@Override public Map<String, Object> getDataMap() { Map<String, Object> result = new HashMap<>(2); result.put("configurationService", configurationService); result.put("repository", repository); return result; }
public static AtomKeyValueParser parse(Key key, Value value) throws IOException { AtomKeyValueParser atom = new AtomKeyValueParser(); String row = key.getRow().toString(); int splitPoint = row.indexOf(DELIMITER); if (splitPoint != -1) { atom.setCollectionName(row.substring(0, splitPoint)); int delim = key.getRow().find(DELIMITER); byte[] b = key.getRow().getBytes(); long diff = LongCombiner.FIXED_LEN_ENCODER.decode(Arrays.copyOfRange(b, delim + 1, key.getRow().getLength())); long time = (Long.MAX_VALUE - diff); atom.setUpdated(new Date(time)); } else { throw new IllegalArgumentException("Atom entry is missing row parts: " + key); } atom.setId(AtomKeyValueParser.encodeId(key.getColumnFamily().toString())); String colf = key.getColumnFamily().toString(); splitPoint = colf.indexOf(DELIMITER); if (splitPoint != -1 && splitPoint + 1 != colf.length()) { atom.setValue(colf.substring(0, splitPoint)); atom.setUuid(colf.substring(splitPoint + 1)); } else { throw new IllegalArgumentException("Atom entry is missing column qualifier parts: " + key); } atom.setColumnVisibility(key.getColumnQualifier().toString()); return atom; }
public static CompositeDriverFinder createDriverFinder(ClassLoader testClassLoader, PrintStream logOutput) { List<DriverFinder> driverFinders = new ArrayList<>(); driverFinders.add(new AbstractClassIgnoringDriverFinder()); driverFinders.add(new RunViaAnnotationDriverFinder()); if (isOnClasspath("org.junit.Test", testClassLoader)) { driverFinders.add(createJUnitCompatibilityDriverFinder(testClassLoader)); } else { logOutput.println("JUnit not found on classpath; disabling JUnit compatibility"); } driverFinders.add(new NonTestClassesIgnoringDriverFinder(logOutput)); return new CompositeDriverFinder(driverFinders); }
@Override public LongCounterSdk.Builder longCounterBuilder(String name) { return new LongCounterSdk.Builder(name, meterProviderSharedState, meterSharedState); }
@Complexity(EASY) public static Mono<String> grabDataFromTheGivenContext(Object key) { throw new RuntimeException("Not implemented"); }
@Override public boolean equals(@Nullable Object o) { if (this == o) { return true; } if (!(o instanceof ExtendedCommunity)) { return false; } ExtendedCommunity that = (ExtendedCommunity) o; return _type == that._type && _subType == that._subType && _globalAdministrator == that._globalAdministrator && _localAdministrator == that._localAdministrator; }
@Override public boolean equals(Object o) { if (o == this) { return true; } if (!(o instanceof XdrOpaque)) { return false; } return Arrays.equals(_opaque, ((XdrOpaque) o)._opaque); }
public String getTooltip() { return tooltip; }
@Override public void write(OutputStream os) throws IOException { IOUtils.skipFully(is, offset); if (len == -1) { IOUtils.copyBytes(is, os, 4096, true); } else { IOUtils.copyBytes(is, os, len, true); } }
@SuppressWarnings("deprecation") public Properties exportLocalizedProperties(SchemaMeta schemaMeta, String locale) throws Exception { if(schemaMeta == null || locale == null) { if(schemaMeta == null) throw new IllegalArgumentException("Parameter \"schemaMeta\" MUST not be null"); if(locale == null) throw new IllegalArgumentException("Parameter \"locale\" MUST not be null"); } try{ Domain domain = ThinModelConverter.convertFromLegacy(schemaMeta); return localizationUtil.exportLocalizedProperties(domain, locale); } catch (Exception e) { if(logger.isDebugEnabled()) { logger.debug("Failed to export properties from legacy schema [" + schemaMeta.getName() + "]", e); } throw e; } }
public static RangeHeader parse(@Nullable final String header) { if (header == null) { return RangeHeader.create(); } final RangeHeader.Builder builder = RangeHeader.builder(); final List<String> parts = ImmutableList.copyOf(Splitter.on(';').trimResults().split(header)); final int count = parts.size(); if (count > 0) { final Matcher first = ID_PATTERN.matcher(parts.get(0)); if (first.matches()) { final String fromId = first.group("fromId"); final String toId = first.group("toId"); builder.field(first.group("field")).fromId(fromId).toId(toId); if (fromId != null) { builder.fromInclusive(Strings.isNullOrEmpty(first.group("fromInclusive"))); } if (toId != null) { builder.toInclusive(Strings.isNullOrEmpty(first.group("toInclusive"))); } } } if (count > 1) { final Matcher second = OPTIONS_PATTERN.matcher(parts.get(1)); if (second.matches()) { try { builder.max(Integer.parseInt(second.group("max"))); } catch (NumberFormatException ignore) { } } } return builder.build(); }
@Override public void initialize(Properties overridingProperties) throws XWikiVelocityException { RuntimeInstance runtime = new RuntimeInstance(); runtime.setApplicationAttribute(ComponentManager.class.getName(), this.componentManager); initializeProperties(runtime, this.velocityConfiguration.getProperties(), overridingProperties); runtime.loadDirective(TryCatchDirective.class.getName()); try { runtime.init(); } catch (Exception e) { throw new XWikiVelocityException("Cannot start the Velocity engine", e); } this.runtimeInstance = runtime; this.globalEntry = new TemplateEntry(""); }
public void decode (@Nullable final byte [] aEncodedBuffer, @Nonnegative final int nOfs, @Nonnegative final int nLen, @Nonnull @WillNotClose final OutputStream aOS) { if (aEncodedBuffer == null || nLen == 0) return; try { boolean bFirstByte = true; int nFirstByte = 0; for (int i = 0; i < nLen; ++i) { final byte nEncByte = aEncodedBuffer[nOfs + i]; if (nEncByte == '>') break; if (Character.isWhitespace (nEncByte)) continue; final byte nDecByte = (byte) StringHelper.getHexValue ((char) nEncByte); if (nDecByte == CGlobal.ILLEGAL_UINT) throw new DecodeException ("Failed to convert byte '" + nEncByte + "/" + ((char) nEncByte) + "' to hex value in ASCIIHexDecode"); if (bFirstByte) nFirstByte = nDecByte; else aOS.write ((byte) (nFirstByte << 4 | nDecByte & 0xff)); bFirstByte = !bFirstByte; } if (!bFirstByte) aOS.write ((byte) (nFirstByte << 4)); } catch (final IOException ex) { throw new DecodeException ("Failed to decode ASCII Hex", ex); } }
@Override public void onRemove(@NotNull Authorizable authorizable, @NotNull Root root, @NotNull NamePathMapper namePathMapper) throws RepositoryException { clearMembership(authorizable); }
private ConfigurationOption<?> validateConfigurationOption(String key, String value) throws IllegalArgumentException { final ConfigurationOption configurationOption = getConfigurationOptionByKey(key); if (configurationOption != null) { configurationOption.assertValid(value); return configurationOption; } else { throw new IllegalArgumentException("Config key '" + key + "' does not exist."); } }
public static ExtendedMimeMessage wrap(MimeMessage message) { if (message instanceof ExtendedMimeMessage) { return (ExtendedMimeMessage) message; } else { try { return new ExtendedMimeMessage(message); } catch (MessagingException e) { throw new RuntimeException("Unexpected exception while wrapping a MimeMessage into an extended one", e); } } }
@NotNull @Override public User createUser(@NotNull final String userID, @Nullable String password) throws RepositoryException { Principal principal = new PrincipalImpl(userID); return createUser(userID, password, principal, null); }
@Override public boolean supportsGroupBy() { return false; }
public HeightCandidate getHeightData(List<BootstrapDataIndex> indexes) { Map<Long, Map<String, BootstrapDataEntry>> entriesPerHeight = getEntriesPerHeight(indexes); return getHeightCandidate(entriesPerHeight); }
public WebXMLDefinition loadWebXMLDefinition(URL url) throws Exception { if (url == null) { return _webXMLDefinition; } try (InputStream inputStream = url.openStream()) { SAXParser saxParser = _saxParserFactory.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.setContentHandler(this); xmlReader.parse(new InputSource(inputStream)); return _webXMLDefinition; } catch (SAXParseException saxParseException) { String message = saxParseException.getMessage(); if (message.contains("DOCTYPE is disallowed")) { throw new Exception( url + " must be updated to the Servlet 3.0 specification"); } throw saxParseException; } }
@Override public synchronized List<AtomAtomMapping> getAllAtomMapping() { return Collections.unmodifiableList(allAtomMCS); }
public String getVnfInstanceName() { return vduInstanceName; }
@Override public boolean load(String id) { PlayerSave save = saver.loadGame(id); if (save == PlayerSave.NULL) { return false; } resetPlayer(id, save); return true; }
public HttpResponse retrieve(HttpRequest request) { final String logCorrelationId = UUIDService.getUUID(); CompletableFuture<HttpResponse> httpResponseFuture = new CompletableFuture<>(); HttpResponse response = response().withStatusCode(OK.code()); if (request != null) { try { final RequestDefinition requestDefinition = isNotBlank(request.getBodyAsString()) ? getRequestDefinitionSerializer().deserialize(request.getBodyAsJsonOrXmlString()) : request(); requestDefinition.withLogCorrelationId(logCorrelationId); Format format = Format.valueOf(defaultIfEmpty(request.getFirstQueryStringParameter("format").toUpperCase(), "JSON")); RetrieveType type = RetrieveType.valueOf(defaultIfEmpty(request.getFirstQueryStringParameter("type").toUpperCase(), "REQUESTS")); switch (type) { case LOGS: { mockServerLog.retrieveMessageLogEntries(requestDefinition, (List<LogEntry> logEntries) -> { StringBuilder stringBuffer = new StringBuilder(); for (int i = 0; i < logEntries.size(); i++) { LogEntry messageLogEntry = logEntries.get(i); stringBuffer .append(messageLogEntry.getTimestamp()) .append(" - ") .append(messageLogEntry.getMessage()); if (i < logEntries.size() - 1) { stringBuffer.append(LOG_SEPARATOR); } } stringBuffer.append(NEW_LINE); response.withBody(stringBuffer.toString(), MediaType.PLAIN_TEXT_UTF_8); mockServerLogger.logEvent( new LogEntry() .setType(RETRIEVED) .setLogLevel(Level.INFO) .setCorrelationId(logCorrelationId) .setHttpRequest(requestDefinition) .setMessageFormat("retrieved logs that match:{}") .setArguments(requestDefinition) ); httpResponseFuture.complete(response); }); break; } case REQUESTS: { LogEntry logEntry = new LogEntry() .setType(RETRIEVED) .setLogLevel(Level.INFO) .setCorrelationId(logCorrelationId) .setHttpRequest(requestDefinition) .setMessageFormat("retrieved requests in " + format.name().toLowerCase() + " that match:{}") .setArguments(requestDefinition); switch (format) { case JAVA: mockServerLog .retrieveRequests( requestDefinition, requests -> { response.withBody( getRequestDefinitionSerializer().serialize(requests), MediaType.create("application", "java").withCharset(UTF_8) ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; case JSON: mockServerLog .retrieveRequests( requestDefinition, requests -> { response.withBody( getRequestDefinitionSerializer().serialize(true, requests), MediaType.JSON_UTF_8 ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; case LOG_ENTRIES: mockServerLog .retrieveRequestLogEntries( requestDefinition, logEntries -> { response.withBody( getLogEntrySerializer().serialize(logEntries), MediaType.JSON_UTF_8 ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; } break; } case REQUEST_RESPONSES: { LogEntry logEntry = new LogEntry() .setType(RETRIEVED) .setLogLevel(Level.INFO) .setCorrelationId(logCorrelationId) .setHttpRequest(requestDefinition) .setMessageFormat("retrieved requests and responses in " + format.name().toLowerCase() + " that match:{}") .setArguments(requestDefinition); switch (format) { case JAVA: response.withBody("JAVA not supported for REQUEST_RESPONSES", MediaType.create("text", "plain").withCharset(UTF_8)); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); break; case JSON: mockServerLog .retrieveRequestResponses( requestDefinition, httpRequestAndHttpResponses -> { response.withBody( getHttpRequestResponseSerializer().serialize(httpRequestAndHttpResponses), MediaType.JSON_UTF_8 ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; case LOG_ENTRIES: mockServerLog .retrieveRequestResponseMessageLogEntries( requestDefinition, logEntries -> { response.withBody( getLogEntrySerializer().serialize(logEntries), MediaType.JSON_UTF_8 ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; } break; } case RECORDED_EXPECTATIONS: { LogEntry logEntry = new LogEntry() .setType(RETRIEVED) .setLogLevel(Level.INFO) .setCorrelationId(logCorrelationId) .setHttpRequest(requestDefinition) .setMessageFormat("retrieved recorded expectations in " + format.name().toLowerCase() + " that match:{}") .setArguments(requestDefinition); switch (format) { case JAVA: mockServerLog .retrieveRecordedExpectations( requestDefinition, requests -> { response.withBody( getExpectationToJavaSerializer().serialize(requests), MediaType.create("application", "java").withCharset(UTF_8) ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; case JSON: mockServerLog .retrieveRecordedExpectations( requestDefinition, requests -> { response.withBody( getExpectationSerializer().serialize(requests), MediaType.JSON_UTF_8 ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; case LOG_ENTRIES: mockServerLog .retrieveRecordedExpectationLogEntries( requestDefinition, logEntries -> { response.withBody( getLogEntrySerializer().serialize(logEntries), MediaType.JSON_UTF_8 ); mockServerLogger.logEvent(logEntry); httpResponseFuture.complete(response); } ); break; } break; } case ACTIVE_EXPECTATIONS: { List<Expectation> expectations = requestMatchers.retrieveActiveExpectations(requestDefinition); switch (format) { case JAVA: response.withBody(getExpectationToJavaSerializer().serialize(expectations), MediaType.create("application", "java").withCharset(UTF_8)); break; case JSON: response.withBody(getExpectationSerializer().serialize(expectations), MediaType.JSON_UTF_8); break; case LOG_ENTRIES: response.withBody("LOG_ENTRIES not supported for ACTIVE_EXPECTATIONS", MediaType.create("text", "plain").withCharset(UTF_8)); break; } mockServerLogger.logEvent( new LogEntry() .setType(RETRIEVED) .setLogLevel(Level.INFO) .setCorrelationId(logCorrelationId) .setHttpRequest(requestDefinition) .setMessageFormat("retrieved active expectations in " + format.name().toLowerCase() + " that match:{}") .setArguments(requestDefinition) ); httpResponseFuture.complete(response); break; } } try { return httpResponseFuture.get(maxFutureTimeout(), MILLISECONDS); } catch (ExecutionException | InterruptedException | TimeoutException ex) { mockServerLogger.logEvent( new LogEntry() .setLogLevel(Level.ERROR) .setCorrelationId(logCorrelationId) .setMessageFormat("exception handling request:{}error:{}") .setArguments(request, ex.getMessage()) .setThrowable(ex) ); throw new RuntimeException("Exception retrieving state for " + request, ex); } } catch (IllegalArgumentException iae) { mockServerLogger.logEvent( new LogEntry() .setLogLevel(Level.ERROR) .setCorrelationId(logCorrelationId) .setMessageFormat("exception handling request:{}error:{}") .setArguments(request, iae.getMessage()) .setThrowable(iae) ); if (iae.getMessage().contains(RetrieveType.class.getSimpleName())) { throw new IllegalArgumentException("\"" + request.getFirstQueryStringParameter("type") + "\" is not a valid value for \"type\" parameter, only the following values are supported " + Arrays.stream(RetrieveType.values()).map(input -> input.name().toLowerCase()).collect(Collectors.toList())); } else { throw new IllegalArgumentException("\"" + request.getFirstQueryStringParameter("format") + "\" is not a valid value for \"format\" parameter, only the following values are supported " + Arrays.stream(Format.values()).map(input -> input.name().toLowerCase()).collect(Collectors.toList())); } } } else { return response().withStatusCode(200); } }
@Override public void onConstruct(EnhancedInstance objInst, Object[] allArguments) { objInst.setSkyWalkingDynamicField(allArguments[1]); }
public Object extractObject(ObjectToJsonConverter pConverter, Object pValue, Stack<String> pPathParts, boolean jsonify) throws AttributeNotFoundException { if (!jsonify) { return pValue; } Date date = (Date) pValue; String pathPart = pPathParts.isEmpty() ? null : pPathParts.pop(); if (pathPart != null) { if (!"time".equals(pathPart)) { return pConverter.getValueFaultHandler().handleException( new AttributeNotFoundException("A date accepts only a single inner path element " + "of value 'time' (and not '" + pathPart + "')")); } return date.getTime(); } else { return DateUtil.toISO8601(date); } }
@Override public void serialize(ClaimsHolder holder, JsonGenerator gen, SerializerProvider provider) throws IOException { gen.writeStartObject(); for (Map.Entry<String, Object> e : holder.getClaims().entrySet()) { switch (e.getKey()) { case PublicClaims.AUDIENCE: if (e.getValue() instanceof String) { gen.writeFieldName(e.getKey()); gen.writeString((String) e.getValue()); break; } String[] audArray = (String[]) e.getValue(); if (audArray.length == 1) { gen.writeFieldName(e.getKey()); gen.writeString(audArray[0]); } else if (audArray.length > 1) { gen.writeFieldName(e.getKey()); gen.writeStartArray(); for (String aud : audArray) { gen.writeString(aud); } gen.writeEndArray(); } break; default: gen.writeFieldName(e.getKey()); if (e.getValue() instanceof Date) { gen.writeNumber(dateToSeconds((Date) e.getValue())); } else { gen.writeObject(e.getValue()); } break; } } gen.writeEndObject(); }
@Override public String loadScript(CatalystInstanceImpl instance) { while (true) { try { return getDelegateLoader().loadScript(instance); } catch (Exception e) { if (e.getMessage() == null || !e.getMessage().startsWith(RECOVERABLE)) { throw e; } mLoaders.pop(); mRecoveredErrors.add(e); FLog.wtf(TAG, "Falling back from recoverable error", e); } } }
public Table read(CsvReadOptions options) throws IOException { return read(options, false); }
public void trySamples() { if (userCanCreateProjects()) { libraryPlaces.goToTrySamples(); } }
public final void showOrdersWithProductMain(final ViewDefinitionState view, final ComponentState componentState, final String[] args) { FormComponent productForm = (FormComponent) view.getComponentByReference(L_FORM); Entity product = productForm.getEntity(); if (product.getId() == null) { return; } String productNumber = product.getStringField(NUMBER); if (productNumber == null) { return; } Map<String, String> filters = Maps.newHashMap(); filters.put("productNumber", applyInOperator(productNumber)); Map<String, Object> gridOptions = Maps.newHashMap(); gridOptions.put(L_FILTERS, filters); Map<String, Object> parameters = Maps.newHashMap(); parameters.put(L_GRID_OPTIONS, gridOptions); parameters.put(L_WINDOW_ACTIVE_MENU, "orders.productionOrders"); String url = "../page/orders/ordersList.html"; view.redirectTo(url, false, true, parameters); }
public T send() throws IOException { return web3jService.send(this, responseType); }
public static void createChildren(String zkAddress, String parentPath, List<ZNRecord> list) { RealmAwareZkClient zkClient = getHelixZkClient(zkAddress); try { createChildren(zkClient, parentPath, list); } finally { zkClient.close(); } }
public static Collection<Edge> optimize( Collection<Edge> edges, Set<StateExpr> statesToKeep, boolean keepSelfLoops) { BDDReachabilityGraphOptimizer opt = new BDDReachabilityGraphOptimizer(edges, statesToKeep, keepSelfLoops); opt.optimize(); return opt._edges.cellSet().stream() .map(cell -> new Edge(cell.getRowKey(), cell.getColumnKey(), cell.getValue())) .collect(ImmutableList.toImmutableList()); }
public List<PriceLevel> getBids() { return bids; }
public static String decrypt(String source, WeChatMpProperties mpProperties) { byte[] aesKey = getEncodingAesKey(mpProperties.getSecurity().getEncodingAesKey()); byte[] original; try { Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding"); SecretKeySpec keySpec = new SecretKeySpec(aesKey, "AES"); IvParameterSpec iv = new IvParameterSpec(Arrays.copyOfRange(aesKey, 0, 16)); cipher.init(Cipher.DECRYPT_MODE, keySpec, iv); byte[] encrypted = Base64.getDecoder().decode(source); original = cipher.doFinal(encrypted); } catch (Exception e) { throw new WeChatException("decrypt message failed", e); } String decryptStr; String fromAppId; try { byte[] bytes = PksS7Encoder.decode(original); byte[] networkOrder = Arrays.copyOfRange(bytes, 16, 20); int xmlLength = recoverNetworkBytesOrder(networkOrder); decryptStr = new String(Arrays.copyOfRange(bytes, 20, 20 + xmlLength), DEFAULT_CHARSET); fromAppId = new String(Arrays.copyOfRange(bytes, 20 + xmlLength, bytes.length), DEFAULT_CHARSET); } catch (Exception e) { throw new WeChatException("decrypt message error", e); } if (!mpProperties.getAuth().getAppid().equals(fromAppId)) { throw new WeChatException("invalid from appid"); } return decryptStr; }
public static String createLabel(final double value, final String unit, final GridLabelFormat format) { final double zero = 0.000000001; if (format != null) { return format.format(value, unit); } else { if (Math.abs(value - Math.round(value)) < zero) { return String.format("%d %s", Math.round(value), unit); } else if ("m".equals(unit)) { return String.format("%1.0f %s", value, unit); } else if (NonSI.DEGREE_ANGLE.toString().equals(unit)) { return String.format("%1.6f %s", value, unit); } else { return String.format("%f %s", value, unit); } } }
private void updateProfileAgreement(User user, Agreement agreement) { Profile profile = getOrCreateUserProfile(user); profile.setAgreementSignedDate(ZonedDateTime.now()); profile.setAgreement(agreement); profileRepository.save(profile); }
public static String encode(final String value) { return encoder.encodeInternal(value); }
public static void gone(View view) { if (view != null) { view.setVisibility(View.GONE); } }
public Table inShard(String shardId) { this.shardId = shardId; return this; }
@Nullable static TaskProvider<Task> getBootWarTaskProvider(Project project) { if (project.getPlugins().hasPlugin("org.springframework.boot")) { try { return project.getTasks().named("bootWar"); } catch (UnknownTaskException ignored) { } } return null; }
public Map<String, Object> getCerticatesExpiryByApplication( String assetGroup) throws ServiceException { try{return certificateRepository .getCertificatesExpiryByApplication(assetGroup); }catch(DataException e){ throw new ServiceException(e); } }
@Nullable protected static Long getLongProperty(String name, Map<String, String> map) { try { return Long.parseLong(map.get(name)); } catch (NumberFormatException ex) { return null; } }
@Override public List<Component> getAllComponentsByNamespaceCode(String namespaceCode) { if (StringUtils.isBlank(namespaceCode)) { throw new RiceIllegalArgumentException("namespaceCode was a null or blank value"); } Map<String, String> criteria = new HashMap<String, String>(); criteria.put("namespaceCode", namespaceCode); QueryResults<ComponentBo> componentBos = getDataObjectService().findMatching(ComponentBo.class, QueryByCriteria.Builder.andAttributes(criteria).build()); QueryResults<DerivedComponentBo> derivedComponentBos = getDataObjectService().findMatching(DerivedComponentBo.class, QueryByCriteria.Builder.andAttributes( criteria).build()); return translateCollections(componentBos, derivedComponentBos); }
@Override public void process() throws Exception { if (this.deploymentContext != null && this.deploymentContext.isImplicit()) { return; } if (!archive.getName().endsWith(".war")) { return; } if (hasApplicationPathOrServletMapping(archive)) { return; } if (applicationPath.isExplicit()) { addGeneratedApplication(archive.as(JAXRSArchive.class)); } }
public byte[] save(InterfaceDefinition def) { if (def.isIf3) { return saveIf3(def); } else { return saveIf1(def); } }
public int getValueListCount() { return null == setAssignment ? values.size() : 1; }
public MultifileTable createTable(String name) throws SomethingIsWrongException { if (name == null) { throw new IllegalArgumentException("Table's name cannot be null"); } if (content.containsKey(name)) { throw new IllegalStateException("Table already exists"); } MultifileTable table = new MultifileTable(databaseDirectoryPath, name); content.put(name, table); return table; }
public static Object deserializeBlob(byte[] blob) throws IOException, ClassNotFoundException { return deserializeBlob(blob, null, null); }
@SafeVarargs public static List<Event> publishedEvents(final InMemoryMessagePublisher<TypedMessage> inMemoryMessagePublisher, final Class<? extends Event>... eventClasses) { final Map<String, Class<? extends Event>> typeToEventClass = new HashMap<>(); for (final Class<? extends Event> eventClass : eventClasses) { try { typeToEventClass.put(eventClass.newInstance().type(), eventClass); } catch (InstantiationException | IllegalAccessException e) { throw new IllegalStateException("Unable to instatiate prototype event " + eventClass.getName()); } } final List<Event> events = new LinkedList<>(); for (final TypedMessage typedMessage : inMemoryMessagePublisher.getPublishedMessages()) { final Class<? extends Event> eventClass = typeToEventClass.get(typedMessage.getType()); if (eventClass != null) { events.add(AbstractEvent.newEvent(eventClass, typedMessage.getPayload())); } } return events; }
public long hash(String key) { return -2; }
public void consume(Purchase purchase) throws IabException { checkNotDisposed(); checkSetupDone("consume"); if (purchase.getItemType() != INAPP) { throw new IabException(IABHELPER_INVALID_CONSUMPTION, "Items of type '" + purchase.getItemType() + "' can't be consumed."); } try { String token = purchase.getToken(); String sku = purchase.getSku(); if (token == null || token.equals("")) { logError("Can't consume " + sku + ". No token."); throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: " + sku + " " + purchase); } logDebug("Consuming sku: " + sku + ", token: " + token); int response = mService.consumePurchase(API_VERSION, mContext.getPackageName(), token); if (response == OK.code) { logDebug("Successfully consumed sku: " + sku); } else { logDebug("Error consuming consuming sku " + sku + ". " + getDescription(response)); throw new IabException(response, "Error consuming sku " + sku); } } catch (RemoteException e) { throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + purchase, e); } }
@NotNull @Override public Iterator<? extends Principal> findPrincipals(@Nullable String nameHint, int searchType) { if (PrincipalManager.SEARCH_TYPE_NOT_GROUP != searchType) { Result result = findPrincipals(Strings.nullToEmpty(nameHint), false); if (result != null) { return Iterators.filter(new GroupPrincipalIterator(nameHint, result), Predicates.notNull()); } } return Collections.emptyIterator(); }
public static HostnameVerifier getHostnameVerifier(ClientConfig config) { if (config.isDisableSSLValidation()) { return new NoopHostnameVerifier(); } if (config.getOverrideHostnameVerifier() == null) { return new DefaultHostnameVerifier(); } else { return config.getOverrideHostnameVerifier(); } }
public static IntrinsicMapTaskExecutor withSharedCounterSet( List<Operation> operations, CounterSet counters, ExecutionStateTracker executionStateTracker) { return new IntrinsicMapTaskExecutor(operations, counters, executionStateTracker); }
public byte[] getRFData() { if (rfData == null) return null; return Arrays.copyOf(rfData, rfData.length); }
public static AdditiveStyle combine(List<AdditiveStyle> styles) { checkNotNull(styles, "styles to combine cannot be null"); checkArgument(styles.size() > 0, "cannot combine an empty list of styles"); if (styles.size() == 1) { return styles.get(0); } List<AdditiveStyle> parts = new ArrayList<AdditiveStyle>(); for (AdditiveStyle style : styles) { if (style instanceof CompositeStyle) { parts.addAll(((CompositeStyle) style).getStyles()); } else { parts.add(style); } } return new CompositeStyle(parts); }
public final void setLayers(Set<CakeLayer> layers) { this.layers = layers; }
@Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final VersionNumber other = (VersionNumber) obj; if (!groups.equals(other.groups)) { return false; } if (!extension.equals(other.extension)) { return false; } return true; }
@Override public void verify(DecodedJWT jwt) throws SignatureVerificationException { byte[] signatureBytes = Base64.decodeBase64(jwt.getSignature()); try { RSAPublicKey publicKey = keyProvider.getPublicKeyById(jwt.getKeyId()); if (publicKey == null) { throw new IllegalStateException("The given Public Key is null."); } boolean valid = crypto.verifySignatureFor(getDescription(), publicKey, jwt.getHeader(), jwt.getPayload(), signatureBytes); if (!valid) { throw new SignatureVerificationException(this); } } catch (NoSuchAlgorithmException | SignatureException | InvalidKeyException | IllegalStateException e) { throw new SignatureVerificationException(this, e); } }
protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results) { final StringBuilder sb = new StringBuilder(); sb.append(title); sb.append(System.lineSeparator()); if (results.size() == 0) { sb.append("No " + StringUtils.lowerCase(title) + " could be found!"); sb.append(System.lineSeparator()); } else { sb.append(StringUtils.repeat("-", NUM_DASHES)); sb.append(System.lineSeparator()); for (final HealthCheckExecutionResult result : results) { sb.append(StringUtils.rightPad("[ " + result.getHealthCheckResult().getStatus().name() + " ]", HEALTH_CHECK_STATUS_PADDING)); sb.append(" "); sb.append(result.getHealthCheckMetadata().getTitle()); sb.append(System.lineSeparator()); } } return sb.toString(); }
@Override public String getName() { return translationService.format(DMNEditorConstants.ExpressionEditor_JavaFunctionType); }
@Override public ValidatorResult validate(AccessList accessList, Object httpRequestType) { ValidatorResult result = validator.validate(accessList, httpRequestType); return ValidatorUtilities.removeEmptyMessages(result); }
public static Product createProductSubset(Product sourceProduct, ProductSubsetDef subsetDef, String name, String desc) throws IOException { return createProductSubset(sourceProduct, false, subsetDef, name, desc); }
@Override public Collection<T> deepCopy(Collection<T> source) { if (source == null) { return null; } List<T> copiedCollection = Lists.newArrayListWithCapacity(source.size()); for (T value : source) { copiedCollection.add(elementType.getDetachedValue(value)); } return copiedCollection; }
public boolean ephemeral() { return ephemeral; }
@Override public void cmdExecute(final Message clientMessage, final ServerConnection serverConnection, final SecurityService securityService, long start) throws IOException, InterruptedException { Part regionNamePart = null; String regionName = null; serverConnection.setAsTrue(REQUIRES_RESPONSE); serverConnection.setAsTrue(REQUIRES_CHUNKED_RESPONSE); regionNamePart = clientMessage.getPart(0); regionName = regionNamePart.getCachedString(); ChunkedMessage chunkedResponseMsg = serverConnection.getChunkedResponseMessage(); final boolean isDebugEnabled = logger.isDebugEnabled(); if (isDebugEnabled) { logger.debug("{}: Received key set request ({} bytes) from {} for region {}", serverConnection.getName(), clientMessage.getPayloadLength(), serverConnection.getSocketString(), regionName); } if (regionName == null) { String message = null; { message = String.format("%s: The input region name for the key set request is null", serverConnection.getName()); logger.warn("{}: The input region name for the key set request is null", serverConnection.getName()); } writeKeySetErrorResponse(clientMessage, MessageType.KEY_SET_DATA_ERROR, message, serverConnection); serverConnection.setAsTrue(RESPONDED); return; } LocalRegion region = (LocalRegion) serverConnection.getCache().getRegion(regionName); if (region == null) { String reason = String.format("%s was not found during key set request", regionName); writeRegionDestroyedEx(clientMessage, regionName, reason, serverConnection); serverConnection.setAsTrue(RESPONDED); return; } if (isInTransaction() && region.getPartitionAttributes() != null) { if (clientMessage.isRetry()) { keySetWriteChunkedException(clientMessage, new TransactionException( "Failover on a set operation of a partitioned region is not allowed in a transaction."), serverConnection); serverConnection.setAsTrue(RESPONDED); return; } } try { securityService.authorize(Resource.DATA, Operation.READ, regionName); } catch (NotAuthorizedException ex) { keySetWriteChunkedException(clientMessage, ex, serverConnection); serverConnection.setAsTrue(RESPONDED); return; } KeySetOperationContext keySetContext = null; AuthorizeRequest authzRequest = serverConnection.getAuthzRequest(); if (authzRequest != null) { try { keySetContext = authzRequest.keySetAuthorize(regionName); } catch (NotAuthorizedException ex) { writeChunkedException(clientMessage, ex, serverConnection); serverConnection.setAsTrue(RESPONDED); return; } } chunkedResponseMsg.setMessageType(MessageType.RESPONSE); chunkedResponseMsg.setTransactionId(clientMessage.getTransactionId()); chunkedResponseMsg.sendHeader(); try { fillAndSendKeySetResponseChunks(region, regionName, keySetContext, serverConnection); serverConnection.setAsTrue(RESPONDED); } catch (Exception e) { checkForInterrupt(serverConnection, e); writeChunkedException(clientMessage, e, serverConnection, serverConnection.getChunkedResponseMessage()); serverConnection.setAsTrue(RESPONDED); return; } if (isDebugEnabled) { logger.debug("{}: Sent key set response for the region {}", serverConnection.getName(), regionName); } }
@SuppressWarnings("unchecked") @Override public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permissionString) { if (targetDomainObject == null) { return false; } return getEvaluator(targetDomainObject.getClass()).hasPermission(authentication, targetDomainObject, getPermission(targetDomainObject, (String) permissionString)); }
public static String durationTranslator(String sonarDuration) { String daysPart = "P" + (sonarDuration.contains("d") ? sonarDuration.substring(0, sonarDuration.indexOf('d')) + "D" : ""); String timePart = (sonarDuration.contains("d") ? sonarDuration.substring(sonarDuration.indexOf('d') + 1) : sonarDuration); return daysPart + (timePart.isEmpty() ? "" : "T" + timePart.replaceAll("min", "M").replaceAll("h", "H")); }
@Override public void modifyTestElement(TestElement element) { super.configureTestElement(element); }
public long eip1559GasPool(final long blockNumber) { guardActivation(); if (blockNumber >= finalForkBlknum) { return feeMarket.getMaxGas(); } return (feeMarket.getMaxGas() / 2) + ((blockNumber - initialForkBlknum) * feeMarket.getGasIncrementAmount()); }
@Override public boolean isValid(NotificationRow value, ConstraintValidatorContext context) { if (!isValid(value)) { context.disableDefaultConstraintViolation(); context.buildConstraintViolationWithTemplate(WRONG_EXPIRES_AT_EXPRESSION) .addConstraintViolation(); return false; } return true; }
@Override public String toLoggingForm() { return scope; }
public static String newMultiTaskId(String jobId, int sequence) { return Id.MultiTask.create(Id.parse(jobId).get(Id.Parts.INSTANCE_NAME), sequence).toString(); }
public void collect(SensorContext context, List<File> reportsDirs, boolean reportDirSetByUser) { List<File> xmlFiles = getReports(reportsDirs, reportDirSetByUser); if (!xmlFiles.isEmpty()) { parseFiles(context, xmlFiles); } }
public final static String[] getPrivateField(String className) { Class classz = loadClass(className); Set<String> set = new HashSet<>(); Field[] fields = classz.getDeclaredFields(); if (fields != null) { for (Field f : fields) { String modifier = Modifier.toString(f.getModifiers()); if (modifier.startsWith("private")) { set.add(f.getName()); } } } return set.toArray(new String[set.size()]); }
public Collection<Export> getExports() { return Collections.unmodifiableCollection(exportsMap.values()); }
@Override public long flushAndSync() throws IOException { return impl.commit(); }
@Override protected DecodeResult decode(Element element, Node thisNode) { setProgramNameOnNode(element, thisNode); setEntityIdOnNode(element, thisNode); setPracticeSiteAddress(element, thisNode); setCehrtOnNode(element, thisNode); String entityType = thisNode.getValue(ENTITY_TYPE); if (ENTITY_APM.equalsIgnoreCase(entityType)){ setMultipleNationalProviderIdsOnNode(element, thisNode); setMultipleTaxProviderTaxIdsOnNode(element, thisNode); } else { setTaxProviderTaxIdOnNode(element, thisNode); if (ENTITY_INDIVIDUAL.equals(entityType)) { setNationalProviderIdOnNode(element, thisNode); } if (ENTITY_VIRTUAL_GROUP.equals(entityType)) { setVirtualGroupOnNode(element, thisNode); } } return DecodeResult.TREE_CONTINUE; }
@RequestMapping(value = "{canonicalClassName:.+}", method = RequestMethod.GET) public ModelConstraint getConstraintsForClassName(@PathVariable String canonicalClassName, @RequestParam(required = false) String locale) { Locale loc = null; try { if (locale != null) { loc = parseLocale(locale); } return this.validationService.getConstraintsForClassName(canonicalClassName, loc); } catch (ClassNotFoundException e) { throw new NotFoundException("Class " + canonicalClassName + " could not be found", e); } }
public boolean canSetValue(int rowIndex, int columnIndex, boolean isInsertRow, boolean isInsertColumn) { if (isInsertRow && isInsertColumn) { return false; } if (rowIndex < 0 || columnIndex < 0) { return false; } if (rowIndex > rowList.size() || columnIndex > columnCount) { return false; } if (type == TableType.ZERO_DIMENSIONAL) { return false; } if (type == TableType.ONE_DIMENSIONAL) { if (columnIndex != 0) { return false; } if (isInsertRow) { return 0<=rowIndex && rowIndex <= rowList.size(); } else { return 0<=rowIndex && rowIndex < rowList.size(); } } if (rowList.size() == 0) { return rowIndex==0 && columnIndex==0 && isInsertRow; } if (isInsertRow) { return columnIndex==0 && 0<=rowIndex && rowIndex <= getRowCount(); } if (rowIndex < 0 || rowIndex >= getRowCount()) { return false; } List<TableCell> row = rowList.get(rowIndex); if (isInsertColumn) { return 0<=columnIndex && columnIndex <= row.size(); } else { return 0<=columnIndex && columnIndex <= row.size() && columnIndex < columnCount; } }
static Parser<Statement> forStatement(Parser<Expression> expr, Parser<Statement> stmt) { return Parsers.sequence( phrase("for (").next(Parsers.or(varStatement(expr), expressionList(expr), NOP)), expr.optional(), between(term(";"), expr.sepBy(term(",")), term(")")), stmt, ForStatement::new); }
@Override public AccessResource parse(RemotingCommand request, String remoteAddr) { PlainAccessResource accessResource = new PlainAccessResource(); if (remoteAddr != null && remoteAddr.contains(":")) { accessResource.setWhiteRemoteAddress(remoteAddr.split(":")[0]); } else { accessResource.setWhiteRemoteAddress(remoteAddr); } accessResource.setRequestCode(request.getCode()); if (request.getExtFields() == null) { return accessResource; } accessResource.setAccessKey(request.getExtFields().get(SessionCredentials.ACCESS_KEY)); accessResource.setSignature(request.getExtFields().get(SessionCredentials.SIGNATURE)); accessResource.setSecretToken(request.getExtFields().get(SessionCredentials.SECURITY_TOKEN)); try { switch (request.getCode()) { case RequestCode.SEND_MESSAGE: accessResource.addResourceAndPerm(request.getExtFields().get("topic"), Permission.PUB); break; case RequestCode.SEND_MESSAGE_V2: accessResource.addResourceAndPerm(request.getExtFields().get("b"), Permission.PUB); break; case RequestCode.CONSUMER_SEND_MSG_BACK: accessResource.addResourceAndPerm(request.getExtFields().get("originTopic"), Permission.PUB); accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get("group")), Permission.SUB); break; case RequestCode.PULL_MESSAGE: accessResource.addResourceAndPerm(request.getExtFields().get("topic"), Permission.SUB); accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get("consumerGroup")), Permission.SUB); break; case RequestCode.QUERY_MESSAGE: accessResource.addResourceAndPerm(request.getExtFields().get("topic"), Permission.SUB); break; case RequestCode.HEART_BEAT: HeartbeatData heartbeatData = HeartbeatData.decode(request.getBody(), HeartbeatData.class); for (ConsumerData data : heartbeatData.getConsumerDataSet()) { accessResource.addResourceAndPerm(getRetryTopic(data.getGroupName()), Permission.SUB); for (SubscriptionData subscriptionData : data.getSubscriptionDataSet()) { accessResource.addResourceAndPerm(subscriptionData.getTopic(), Permission.SUB); } } break; case RequestCode.UNREGISTER_CLIENT: final UnregisterClientRequestHeader unregisterClientRequestHeader = (UnregisterClientRequestHeader) request .decodeCommandCustomHeader(UnregisterClientRequestHeader.class); accessResource.addResourceAndPerm(getRetryTopic(unregisterClientRequestHeader.getConsumerGroup()), Permission.SUB); break; case RequestCode.GET_CONSUMER_LIST_BY_GROUP: final GetConsumerListByGroupRequestHeader getConsumerListByGroupRequestHeader = (GetConsumerListByGroupRequestHeader) request .decodeCommandCustomHeader(GetConsumerListByGroupRequestHeader.class); accessResource.addResourceAndPerm(getRetryTopic(getConsumerListByGroupRequestHeader.getConsumerGroup()), Permission.SUB); break; case RequestCode.UPDATE_CONSUMER_OFFSET: final UpdateConsumerOffsetRequestHeader updateConsumerOffsetRequestHeader = (UpdateConsumerOffsetRequestHeader) request .decodeCommandCustomHeader(UpdateConsumerOffsetRequestHeader.class); accessResource.addResourceAndPerm(getRetryTopic(updateConsumerOffsetRequestHeader.getConsumerGroup()), Permission.SUB); accessResource.addResourceAndPerm(updateConsumerOffsetRequestHeader.getTopic(), Permission.SUB); break; default: break; } } catch (Throwable t) { throw new AclException(t.getMessage(), t); } SortedMap<String, String> map = new TreeMap<String, String>(); for (Map.Entry<String, String> entry : request.getExtFields().entrySet()) { if (!SessionCredentials.SIGNATURE.equals(entry.getKey())) { map.put(entry.getKey(), entry.getValue()); } } accessResource.setContent(AclUtils.combineRequestContent(request, map)); return accessResource; }
public static String getIdForFlowContinuableMediator(String mediatorName, ComponentType componentType, ArtifactHolder holder) { if (ComponentType.SEQUENCE == componentType && mediatorName.contains("AnonymousSequence")) { return null; } String idString = holder.getParent() + "@" + holder.getIdString() + ":" + mediatorName; holder.setHashCode(holder.getHashCode() + idString.hashCode()); if (log.isDebugEnabled()) { log.debug("Adding Flow Continuable Mediator : " + idString); } if (RuntimeStatisticCollector.isOpenTracingEnabled()) { ArtifactHolderStore.addStructuringElementStack(idString, holder); } process(idString, componentType, holder); return idString; }
public T getClone() { try (Input input = new Input(bin)) { return kryo.readObject(input, clazz); } }
public List<org.odpi.openmetadata.accessservices.assetcatalog.model.Classification> getEntityClassificationByName(String userId, String assetGUID, String assetTypeName, String classificationName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException { String methodName = "getEntityClassificationByName"; invalidParameterHandler.validateUserId(userId, methodName); invalidParameterHandler.validateGUID(assetGUID, GUID_PARAMETER, methodName); List<Classification> entityClassifications = getEntityClassifications(userId, assetGUID, assetTypeName); if (CollectionUtils.isEmpty(entityClassifications)) { return Collections.emptyList(); } if (classificationName != null) { entityClassifications = filterClassificationByName(entityClassifications, classificationName); } return assetConverter.convertClassifications(entityClassifications); }
public static int getLastIndexOf (@Nullable final String sText, @Nullable final String sSearch) { return sText != null && sSearch != null && sText.length () >= sSearch.length () ? sText.lastIndexOf (sSearch) : STRING_NOT_FOUND; }
public final String getMetaAsString(final String key) { checkKey(key); return getMetaAsString(key, null); }
@RequestMapping(path = "/{id}", method = RequestMethod.PATCH) public @ResponseBody BananaResource patch(@PathVariable long id, @RequestBody Banana banana) { Banana existing = bananaRepository.findOne(id); if(Objects.isNull(banana)) { return null; } if(Objects.nonNull(banana.getPeeled())) { existing.setPeeled(banana.getPeeled()); } if(Objects.nonNull(banana.getPickedAt())) { existing.setPickedAt(banana.getPickedAt()); } return bananaResourceAssembler.toResource(bananaRepository.save(existing)); }
public boolean find(int key) { throw new RuntimeException("Not Implemented"); }
public int getDrainTimeout() { return drainTimeout; }
public static boolean isIpAddressLocalNetwork(InetAddress addr) { return addr != null && addr.isSiteLocalAddress(); }
public String getLine() { return revision + " " + date + " " + author + " " + message + "\n"; }
public com.silanis.esl.api.model.SupportConfiguration toAPISupportConfiguration() { if (sdkSupportConfiguration == null) { return apiSupportConfiguration; } com.silanis.esl.api.model.SupportConfiguration result = new com.silanis.esl.api.model.SupportConfiguration(); result.setEmail(sdkSupportConfiguration.getEmail()); result.setPhone(sdkSupportConfiguration.getPhone()); return result; }
public static int compare(final long aMsb, final long aLsb, final long bMsb, final long bLsb) { if (aMsb == bMsb) { if (aLsb == bLsb) { return 0; } if ((aLsb < bLsb) ^ (aLsb < 0) ^ (bLsb < 0)) { return -1; } } else if ((aMsb < bMsb) ^ (aMsb < 0) ^ (bMsb < 0)) { return -1; } return 1; }
@Override public List<Adaptable> map(final ExternalMessage message) { return incomingMapping.apply(message); }
@Override public SystemStatus getSystemStatus() throws IOException { String path = getBasePath(); HttpResponse httpResponse = this.restClient.perform(RestClient.Method.GET, path, null); this.restClient.checkResponse(httpResponse, HttpStatus.SC_OK); return this.restClient.parseHttpResponse( httpResponse, new TypeReference<SystemStatus>() { } ); }
public synchronized void initialize() throws StateManagementException { this.validateStateTransition(ManagerState.INITIALIZED); try { log.info("Initializing job manager"); if (this.state == ManagerState.CREATED) { if (this.isSchedulerEnabled()) { if (this.scheduler == null || this.scheduler.isShutdown()) { this.scheduler = this.schedulerFactory.getScheduler(); } this.synchronizeJobSchedule(); this.scheduler.setJobFactory(this.qrtzExecutor); this.scheduler.getListenerManager() .addTriggerListener(this.qrtzExecutor); } if (!this.receiver.isInitialized()) { this.receiver.initialize(this); } this.modeManager.registerModeChangeListener(this); if (this.modeManager.getCurrentMode() == Mode.SUSPEND) { this.suspendKeys.add(SUSPEND_KEY_TRIGGERED); } } log.info("Job manager initialization complete"); this.state = ManagerState.INITIALIZED; } catch (Exception e) { String errmsg = "Unexpected exception occurred during initialization"; log.error(errmsg, e); try { if (this.scheduler != null) { this.scheduler.shutdown(); this.scheduler = null; } } catch (SchedulerException se) { log.error("Unable to shutdown quartz scheduler while processing other exceptions", se); } throw new StateManagementException(this.state, ManagerState.INITIALIZED, errmsg, e); } }
@Override public RoleToken getRoleToken(ResourceContext ctx, String domainName, String roleNames, Integer minExpiryTime, Integer maxExpiryTime, String proxyForPrincipal) { final String caller = "getroletoken"; final String callerTiming = "getroletoken_timing"; metric.increment(HTTP_GET); final String principalDomain = logPrincipalAndGetDomain(ctx); validateRequest(ctx.request(), principalDomain, caller); validate(domainName, TYPE_DOMAIN_NAME, principalDomain, caller); if (roleNames != null && !roleNames.isEmpty()) { validate(roleNames, TYPE_ENTITY_LIST, principalDomain, caller); } if (proxyForPrincipal != null && !proxyForPrincipal.isEmpty()) { validate(proxyForPrincipal, TYPE_ENTITY_NAME, principalDomain, caller); } domainName = domainName.toLowerCase(); if (roleNames != null) { roleNames = roleNames.toLowerCase(); } if (proxyForPrincipal != null) { proxyForPrincipal = normalizeDomainAliasUser(proxyForPrincipal.toLowerCase()); } Object timerMetric = metric.startTiming(callerTiming, domainName, principalDomain); final Principal principal = ((RsrcCtxWrapper) ctx).principal(); String principalName = principal.getFullName(); if (LOGGER.isDebugEnabled()) { LOGGER.debug("getRoleToken(domain: {}, principal: {}, role-name: {}, proxy-for: {})", domainName, principalName, roleNames, proxyForPrincipal); } roleNames = convertEmptyStringToNull(roleNames); proxyForPrincipal = convertEmptyStringToNull(proxyForPrincipal); if (leastPrivilegePrincipal && roleNames == null) { throw requestError("getRoleToken: Client must specify a roleName to request a token for", caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); } if (proxyForPrincipal != null && !isAuthorizedProxyUser(authorizedProxyUsers, principalName)) { LOGGER.error("getRoleToken: Principal {} not authorized for proxy role token request", principalName); throw forbiddenError("getRoleToken: Principal: " + principalName + " not authorized for proxy role token request", caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); } DataCache data = dataStore.getDataCache(domainName); if (data == null) { metric.increment(HTTP_REQUEST, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); metric.increment(caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); throw notFoundError("getRoleToken: No such domain: " + domainName, caller, ZTSConsts.ZTS_UNKNOWN_DOMAIN, principalDomain); } metric.increment(HTTP_REQUEST, domainName, principalDomain); metric.increment(caller, domainName, principalDomain); checkRoleTokenAuthorizedServiceRequest(principal, domainName, caller); String[] requestedRoleList = null; if (roleNames != null) { requestedRoleList = roleNames.split(","); } Set<String> roles = new HashSet<>(); dataStore.getAccessibleRoles(data, domainName, principalName, requestedRoleList, roles, false); if (roles.isEmpty()) { throw forbiddenError("getRoleToken: No access to any roles in domain: " + domainName, caller, domainName, principalDomain); } String proxyUser = null; if (proxyForPrincipal != null) { Set<String> rolesForProxy = new HashSet<>(); dataStore.getAccessibleRoles(data, domainName, proxyForPrincipal, requestedRoleList, rolesForProxy, false); roles.retainAll(rolesForProxy); if (roles.isEmpty()) { throw forbiddenError("getRoleToken: No access to any roles by User and Proxy Principals", caller, domainName, principalDomain); } proxyUser = principalName; principalName = proxyForPrincipal; } if (!isPrincipalRoleCertificateAccessValid(principal, domainName, roles)) { throw forbiddenError("getRoleToken: Role based Principal does not include all roles", caller, domainName, principalDomain); } long tokenTimeout = determineTokenTimeout(data, roles, minExpiryTime, maxExpiryTime); List<String> roleList = new ArrayList<>(roles); boolean domainCompleteRoleSet = (includeRoleCompleteFlag && roleNames == null); com.yahoo.athenz.auth.token.RoleToken token = new com.yahoo.athenz.auth.token.RoleToken.Builder(ZTS_ROLE_TOKEN_VERSION, domainName, roleList) .expirationWindow(tokenTimeout).host(serverHostName).keyId(privateKey.getId()) .principal(principalName).ip(ServletRequestUtil.getRemoteAddress(ctx.request())) .proxyUser(proxyUser).domainCompleteRoleSet(domainCompleteRoleSet).build(); token.sign(privateKey.getKey()); RoleToken roleToken = new RoleToken(); roleToken.setToken(token.getSignedToken()); roleToken.setExpiryTime(token.getExpiryTime()); metric.stopTiming(timerMetric, domainName, principalDomain); return roleToken; }
public Record convert(Record input) throws AvroConversionException { Record result = new Record(outputSchema); for (Field outputField : outputSchema.getFields()) { String inputFieldName = outputField.name(); if (fieldMapping.containsKey(outputField.name())) { inputFieldName = fieldMapping.get(outputField.name()); } IndexedRecord currentRecord = input; Schema currentSchema = getNonNullSchema(inputSchema); while (inputFieldName.contains(".")) { int dotIndex = inputFieldName.indexOf('.'); String entityName = inputFieldName.substring(0, dotIndex); Object innerRecord = currentRecord.get(currentSchema.getField( entityName).pos()); if (innerRecord == null) { currentRecord = null; break; } if (innerRecord != null && !(innerRecord instanceof IndexedRecord)) { throw new AvroConversionException(inputFieldName + " stepped through a non-record"); } currentRecord = (IndexedRecord) innerRecord; currentSchema = currentSchema.getField(entityName).schema(); currentSchema = getNonNullSchema(currentSchema); inputFieldName = inputFieldName.substring(dotIndex + 1); } Field f = currentSchema.getField(inputFieldName); if (currentRecord == null) { Schema s = null; if (f != null) { s = f.schema(); } result.put(outputField.name(), convertData(null, s, outputField.schema())); } else { result.put( outputField.name(), convertData(currentRecord.get(f.pos()), f.schema(), outputField.schema())); } } return result; }
public static OspfExternalRoute.Builder builder() { return OspfExternalRoute.builder().setOspfMetricType(OspfMetricType.E1); }
@Override public Object run() { RequestContext context = RequestContext.getCurrentContext(); final String serviceId = (String) context.get(SERVICE_ID_KEY); final String proxy = UrlUtils.removeFirstAndLastSlash((String) context.get(PROXY_KEY)); final String requestPath = UrlUtils.addFirstSlash((String) context.get(REQUEST_URI_KEY)); if (isRequestThatCanBeProcessed(serviceId, proxy, requestPath)) { RoutedServices routedServices = routedServicesMap.get(serviceId); if (routedServices != null) { @SuppressWarnings("squid:S2259") int i = proxy.lastIndexOf('/'); if (i > 0) { String route = proxy.substring(0, i); String originalPath = normalizeOriginalPath(routedServices.findServiceByGatewayUrl(route).getServiceUrl()); context.set(REQUEST_URI_KEY, originalPath + requestPath); log.debug("Routing: The request was routed to {}", originalPath + requestPath); } } else { log.trace("Routing: No routing metadata for service {} found.", serviceId); } } else { log.trace("Routing: Incorrect serviceId {}, proxy {} or requestPath {}.", serviceId, proxy, requestPath); } return null; }
@Override public boolean tryAdvance(IntConsumer consumer) { Objects.requireNonNull(consumer); if (estimatedSize > 0) { estimatedSize--; consumer.accept(element); return true; } return false; }
@Override public List<AgentInstance> getAgentInstances(String instanceGroupId) { return new ArrayList<>(agentCache.getAgentInstances(instanceGroupId)); }
@Override public CalculationResultMap evaluate(Collection<Integer> cohort, Map<String, Object> parameterValues, PatientCalculationContext context) { Program hivProgram = MetadataUtils.existing(Program.class, HivMetadata._Program.HIV); Set<Integer> alive = Filters.alive(cohort, context); Set<Integer> inHivProgram = Filters.inProgram(hivProgram, alive, context); CalculationResultMap lastCD4Obss = Calculations.lastObs(Dictionary.getConcept(Dictionary.CD4_COUNT), inHivProgram, context); CalculationResultMap oldCD4Obss = Calculations.lastObsAtLeastDaysAgo(Dictionary.getConcept(Dictionary.CD4_COUNT), HivConstants.DECLINING_CD4_COUNT_ACROSS_DAYS, inHivProgram, context); Set<Integer> ltfu = CalculationUtils.patientsThatPass(calculate(new LostToFollowUpCalculation(), cohort, context)); CalculationResultMap ret = new CalculationResultMap(); for (Integer ptId : cohort) { boolean declining = false; if (inHivProgram.contains(ptId)) { Double lastCD4Count = EmrCalculationUtils.numericObsResultForPatient(lastCD4Obss, ptId); Double oldCD4Count = EmrCalculationUtils.numericObsResultForPatient(oldCD4Obss, ptId); if (lastCD4Count != null && oldCD4Count != null) { declining = lastCD4Count < oldCD4Count; } if(ltfu.contains(ptId)){ declining = false; } } ret.put(ptId, new BooleanResult(declining, this, context)); } return ret; }
@Override public boolean accept(final ConsoleState state) { Assertions.checkNotNull("state", state); if (state.getActiveCommand() == null && state.getInput().trim().equals("display properties")) { return true; } return false; }
@Override protected Object customConvertValue(String str, Class<?> targetType, ConverterContext context) { DataProvider dataProvider = createProxyDataProvider(context); return customConvertValue(str, targetType, dataProvider); }
protected String buildLocalFilePath( @NotBlank final String dir, @NotBlank final String id, @NotBlank final String filePath, @NotNull final FileType fileType, @NotNull final AdminResources adminResources ) { String entityPathVar = null; String filePathVar = null; switch (adminResources) { case APPLICATION: entityPathVar = JobConstants.APPLICATION_PATH_VAR; break; case COMMAND: entityPathVar = JobConstants.COMMAND_PATH_VAR; break; case CLUSTER: entityPathVar = JobConstants.CLUSTER_PATH_VAR; break; default: break; } switch (fileType) { case CONFIG: filePathVar = JobConstants.CONFIG_FILE_PATH_PREFIX; break; case SETUP: break; case DEPENDENCIES: filePathVar = JobConstants.DEPENDENCY_FILE_PATH_PREFIX; break; default: break; } final String fileName = filePath.substring(filePath.lastIndexOf(JobConstants.FILE_PATH_DELIMITER) + 1); final StringBuilder localPath = new StringBuilder() .append(dir) .append(JobConstants.FILE_PATH_DELIMITER) .append(JobConstants.GENIE_PATH_VAR); localPath.append(JobConstants.FILE_PATH_DELIMITER) .append(entityPathVar); localPath.append(JobConstants.FILE_PATH_DELIMITER) .append(id); if (filePathVar != null) { localPath.append(JobConstants.FILE_PATH_DELIMITER) .append(filePathVar); } localPath.append(JobConstants.FILE_PATH_DELIMITER).append(fileName); return localPath.toString(); }
@Override public ResponseEntity cancelPayment(String paymentService, String paymentProduct, String paymentId, UUID xRequestID, String digest, String signature, byte[] tpPSignatureCertificate, Boolean tpPRedirectPreferred, String tpPNokRedirectURI, String tpPRedirectURI, Boolean tppExplicitAuthorisationPreferred, String psUIPAddress, String psUIPPort, String psUAccept, String psUAcceptCharset, String psUAcceptEncoding, String psUAcceptLanguage, String psUUserAgent, String psUHttpMethod, UUID psUDeviceID, String psUGeoLocation) { PisPaymentCancellationRequest paymentCancellationRequest = paymentModelMapperPsd2.mapToPaymentCancellationRequest(paymentProduct, paymentService, paymentId, tppExplicitAuthorisationPreferred, tpPRedirectURI, tpPNokRedirectURI); ResponseObject<CancelPaymentResponse> serviceResponse = PaymentType.getByValue(paymentService) .map(type -> xs2aPaymentService.cancelPayment(paymentCancellationRequest)) .orElseGet(ResponseObject.<CancelPaymentResponse>builder() .fail(MESSAGE_ERROR_RESOURCE_UNKNOWN_404)::build); if (serviceResponse.hasError()) { return responseErrorMapper.generateErrorResponse(serviceResponse.getError()); } CancelPaymentResponse cancelPayment = serviceResponse.getBody(); PaymentInitiationCancelResponse202 response = paymentModelMapperPsd2.mapToPaymentInitiationCancelResponse(cancelPayment); return cancelPayment.isStartAuthorisationRequired() ? responseMapper.accepted(ResponseObject.builder().body(response).build()) : responseMapper.delete(serviceResponse); }
public int count() { return query.count(); }
public static Builder newBuilder(final String jobName, final String cron, final int shardingTotalCount) { return new Builder(jobName, cron, shardingTotalCount); }
@Override public Metadata getMetadata(Path productPath) throws IOException { VirtualPath virtualPath = null; try { Path inputPath = S2ProductNamingUtils.processInputPath(productPath); virtualPath = S2NamingConventionUtils.transformToSentinel2VirtualPath(inputPath); L1bProductMetadataReader productMetadataReader = new L1bProductMetadataReader(virtualPath); VirtualPath inputVirtualPath = productMetadataReader.getNamingConvention().getInputXml(); if (inputVirtualPath.exists()) { S2Config config = productMetadataReader.readTileLayouts(inputVirtualPath); if (config == null) { throw new NullPointerException(String.format("Unable to retrieve the JPEG tile layout associated to product [%s]", inputVirtualPath.getFileName().toString())); } L1bMetadata l1bMetadataHeader = productMetadataReader.readMetadataHeader(inputVirtualPath, config); S2SpatialResolution productResolution = S2SpatialResolution.R10M; if (this.interpretation == Sentinel2L1BProductReader.ProductInterpretation.RESOLUTION_20M) { productResolution = S2SpatialResolution.R20M; } else if (this.interpretation == Sentinel2L1BProductReader.ProductInterpretation.RESOLUTION_60M) { productResolution = S2SpatialResolution.R60M; } L1bSceneDescription sceneDescription = L1bSceneDescription.create(l1bMetadataHeader, productResolution); Metadata metadata = new Metadata(); metadata.setProductWidth(sceneDescription.getSceneRectangle().width); metadata.setProductHeight(sceneDescription.getSceneRectangle().height); List<L1bMetadata.Tile> tileList = l1bMetadataHeader.computeTiles(); Map<String, Sentinel2L1BProductReader.L1BBandInfo> bandInfoByKey = l1bMetadataHeader.computeBandInfoByKey(tileList); List<String> bandIndexes = new ArrayList<>(bandInfoByKey.keySet()); Collections.sort(bandIndexes); for (String bandIndex : bandIndexes) { Sentinel2L1BProductReader.L1BBandInfo tileBandInfo = bandInfoByKey.get(bandIndex); if (isMultiResolution() || tileBandInfo.getBandInformation().getResolution() == productResolution) { metadata.getBandList().add(tileBandInfo.getBandName()); } } if (sceneDescription.getOrderedTileIds().size() > 1 && !bandInfoByKey.isEmpty()) { List<S2SpatialResolution> resolutions = Sentinel2L1BProductReader.computeResolutions(this.interpretation); if (!(resolutions.isEmpty() || tileList.isEmpty())) { List<Sentinel2L1BProductReader.L1BBandInfo> tileInfoList = Sentinel2L1BProductReader.computeTileIndexesList(resolutions, tileList, sceneDescription, config); if (tileInfoList.size() > 0) { for (Sentinel2L1BProductReader.L1BBandInfo bandInfo : tileInfoList) { if (isMultiResolution() || bandInfo.getBandInformation().getResolution() == productResolution) { metadata.getBandList().add(bandInfo.getBandInformation().getPhysicalBand()); } } for (Sentinel2L1BProductReader.L1BBandInfo bandInfo : tileInfoList) { if (bandInfo.getBandInformation() instanceof S2IndexBandInformation) { S2IndexBandInformation indexBandInformation = (S2IndexBandInformation) bandInfo.getBandInformation(); IndexCoding indexCoding = indexBandInformation.getIndexCoding(); for (String indexName : indexCoding.getIndexNames()) { String maskName = indexBandInformation.getPrefix() + indexName.toLowerCase(); metadata.getMaskList().add(maskName); } } } } } } return metadata; } else { throw new FileNotFoundException(inputVirtualPath.getFullPathString()); } } catch (RuntimeException | IOException exception) { throw exception; } catch (Exception exception) { throw new IOException(exception); } finally { if (virtualPath != null) { virtualPath.close(); } } }
public @NonNull List<ActorSelection> getAlternates() { return alternates; }
@Override protected void processMessage(IoSession protocolSession, Message message) throws Exception { Session qfSession = (Session) protocolSession.getAttribute(SessionConnector.QF_SESSION); if (qfSession == null) { final Optional<String> msgTypeField = message.getHeader().getOptionalString(MsgType.FIELD); if (msgTypeField.isPresent() && msgTypeField.get().equals(MsgType.LOGON)) { final SessionID sessionID = MessageUtils.getReverseSessionID(message); qfSession = sessionProvider.getSession(sessionID, eventHandlingStrategy.getSessionConnector()); if (qfSession != null) { final Log sessionLog = qfSession.getLog(); Responder responder = qfSession.getResponder(); if (responder != null) { sessionLog.onErrorEvent("Multiple logons/connections for this session are not allowed." + " Closing connection from " + protocolSession.getRemoteAddress() + " since session is already established from " + responder.getRemoteAddress()); protocolSession.closeNow(); return; } sessionLog.onEvent("Accepting session " + qfSession.getSessionID() + " from " + protocolSession.getRemoteAddress()); final int heartbeatInterval = message.isSetField(HeartBtInt.FIELD) ? message.getInt(HeartBtInt.FIELD) : 0; qfSession.setHeartBeatInterval(heartbeatInterval); sessionLog.onEvent("Acceptor heartbeat set to " + heartbeatInterval + " seconds"); protocolSession.setAttribute(SessionConnector.QF_SESSION, qfSession); final NetworkingOptions networkingOptions = getNetworkingOptions(); qfSession.setResponder(new IoSessionResponder(protocolSession, networkingOptions.getSynchronousWrites(), networkingOptions .getSynchronousWriteTimeout(), qfSession.getMaxScheduledWriteRequests())); if (sessionID.isFIXT()) { if (message.isSetField(DefaultApplVerID.FIELD)) { final ApplVerID applVerID = new ApplVerID( message.getString(DefaultApplVerID.FIELD)); qfSession.setTargetDefaultApplicationVersionID(applVerID); sessionLog.onEvent("Setting DefaultApplVerID (" + DefaultApplVerID.FIELD + "=" + applVerID.getValue() + ") from Logon"); } } } else { log.error("Unknown session ID during logon: {} cannot be found in session list {} (connecting from {} to {})", sessionID, eventHandlingStrategy.getSessionConnector().getSessions(), protocolSession.getRemoteAddress(), protocolSession.getLocalAddress()); return; } } else { log.warn("Ignoring non-logon message before session establishment: {}", message); protocolSession.closeNow(); return; } } eventHandlingStrategy.onMessage(qfSession, message); }
public String getFinalOutputPath() { return finalPath.toString(); }
@Override public double getSimilarity(Collection<String> terms1, Collection<String> terms2) throws SimilarityException { Set<String> unionTermSet = new HashSet<String>(terms1); unionTermSet.addAll(terms2); if (terms1.size() == terms2.size() && terms1.size() == unionTermSet.size()) { return 1.0; } Vector vector1 = getVector(unionTermSet, terms1); Vector vector2 = getVector(unionTermSet, terms2); double num = InnerVectorProduct.COSINE.apply(vector1, vector2); double norm; switch (normalizationMode) { case L1: norm = VectorNorm.L1.apply(vector1, vector2); break; case L2: norm = VectorNorm.L2.apply(vector1, vector2); break; default: throw new IllegalStateException("Unsupported norm: "+normalizationMode); } if (norm == 0.0) { return 0.0; } return num / norm; }
@Override public boolean equals( Object obj ) { try { if ( !EqualsBuilder.reflectionEquals( this, obj ) ) { return false; } DataProviderConnection toCompare = (DataProviderConnection) obj; List<NameValueProperty> thisAttributeList = this.getAttributeList(); List<NameValueProperty> toCompareAttributeList = toCompare.getAttributeList(); if ( thisAttributeList != null && toCompareAttributeList != null ) { if ( thisAttributeList.size() != toCompareAttributeList.size() ) { return false; } for ( int i = 0; i < thisAttributeList.size(); i++ ) { if ( !thisAttributeList.get( i ).equals( toCompareAttributeList.get( i ) ) ) { return false; } } } return true; } catch ( Exception e ) { return false; } }
@Override public void addRunner(@NotNull Runner runner) { if (runnerWidgets.get(runner) != null) { return; } selectionManager.setRunner(runner); RunnerWidget runnerWidget = widgetFactory.createRunner(); runnerWidget.setDelegate(this); runnerWidget.update(runner); runnerWidgets.put(runner, runnerWidget); view.addRunner(runnerWidget); selectRunner(runner); }
@Override public void completeSuccess() { ToastUtil.showForLongTime(R.string.msg_mmia_submit_tip); finish(); }
public FieldModel fill(final FieldModel fieldModel) { final Map<String, FieldValueModel> fieldValueModelMap = new HashMap<>(); fieldValueModelMap.putAll(getKeyToValues()); final Map<String, FieldValueModel> fieldsToAdd = fieldModel.getKeyToValues(); for (final Map.Entry<String, FieldValueModel> entry : fieldsToAdd.entrySet()) { final String key = entry.getKey(); if (!fieldValueModelMap.containsKey(key) || fieldValueModelMap.get(key).getValue().isEmpty()) { fieldValueModelMap.put(key, entry.getValue()); } } final String modelDescriptorName = StringUtils.isNotBlank(getDescriptorName()) ? getDescriptorName() : fieldModel.getDescriptorName(); final String modelContext = StringUtils.isNotBlank(getContext()) ? getContext() : fieldModel.getContext(); final String modelCreatedAt = StringUtils.isNotBlank(getCreatedAt()) ? getCreatedAt() : fieldModel.getCreatedAt(); final String modelLastUpdated = StringUtils.isNotBlank(getLastUpdated()) ? getLastUpdated() : fieldModel.getLastUpdated(); final FieldModel newFieldModel = new FieldModel(modelDescriptorName, modelContext, modelCreatedAt, modelLastUpdated, fieldValueModelMap); final String id = StringUtils.isNotBlank(getId()) ? getId() : fieldModel.getId(); newFieldModel.setId(id); return newFieldModel; }
Map<String,Collection<String>> getGroupToRoleMapping() { return groupToRoleMapping; }
@Override protected BaseQueryBuilder build(final DepartmentSpecialty context, final BaseQueryBuilder builder) { return builder .where() .openBracket() .addAndCondition(DEPARTMENT_CONDITION, context.getDepartment()) .addAndCondition(SPECIALTY_CONDITION, context.getSpecialty()) .closeBracket(); }
@Override public CertificateCredentialValue findTransitionalVersion(final String caName) { final List<CredentialVersion> credentialVersions = certificateVersionDataService.findBothActiveCertAndTransitionalCert(caName); if (credentialVersions == null) { throw new EntryNotFoundException(ErrorMessages.Credential.INVALID_ACCESS); } final CertificateCredentialVersion transitionalVersion = (CertificateCredentialVersion) credentialVersions.stream().filter(version -> { if (!(version instanceof CertificateCredentialVersion)) { throw new ParameterizedValidationException(ErrorMessages.NOT_A_CA_NAME); } return ((CertificateCredentialVersion) version).isVersionTransitional(); }).findFirst().orElse(null); if (transitionalVersion == null) { return null; } else if (!transitionalVersion.getParsedCertificate().isCa()) { throw new ParameterizedValidationException(ErrorMessages.CERT_NOT_CA); } return new CertificateCredentialValue( transitionalVersion.getCertificate(), transitionalVersion.getPrivateKey(), transitionalVersion.isCertificateAuthority(), transitionalVersion.isSelfSigned(), transitionalVersion.getGenerated(), transitionalVersion.isVersionTransitional(), transitionalVersion.getVersionCreatedAt()); }
@Override @SuppressWarnings("squid:S2095") public InputStream getFileInputStream() { try { return new BufferedInputStream(new FileInputStream(file)); } catch (final FileNotFoundException e) { throw Throwables.propagate(e); } }
@Override public SearchResponse search(SearchRequest searchRequest) throws InvalidSearchException { return this.searchDao.search(searchRequest); }
public static long toUnixTime(long javaTime) { return javaTime / 1000; }
@Override public ImmutableJsonObjectBuilder setAll(final Iterable<JsonField> fields, final Predicate<JsonField> predicate) { requireNonNull(fields, "The JSON fields to be set must not be null!"); checkPredicate(predicate); StreamSupport.stream(fields.spliterator(), false) .filter(field -> !field.getDefinition().isPresent() || predicate.test(field)) .forEach(fieldToBeSet -> this.fields.put(fieldToBeSet.getKeyName(), fieldToBeSet)); return this; }
static <TT> String getBeanName(Bean<TT> bean, Clustered annotation) { try { return firstNonNull(annotation.keyName(), bean.getName(), bean.getBeanClass().getName()); } catch (Throwable t) { throw new IllegalArgumentException("Could not find the name for bean: " + bean.toString(), t); } }
public void setRole(String role) { this.role = role; }
@Override public String formatMessage(final LogRecord record) { String msg = super.formatMessage(record); msg = replaceClassName(msg, record.getThrown()); msg = replaceClassName(msg, record.getParameters()); return msg; }
public Element toElement(ContractInput contractInput, List<List<Element>> rows) { return contractInput.isMultiple() ? toMultipleComponent(contractInput, rows) : toSimpleComponent(contractInput); }
@Override public boolean hasPermission(Authentication authentication, Category category, Permission permission) { return hasPermission(authentication, category, permission, false); }
@Override public Iterator<Integer> iterator() { if (start < end && step < 0 || start > end && step > 0) { return Iterators.emptyIterator(); } return new IntegerRangeIterator(); }
public void execute() { _gunDataManager.execute(_robot.getRoundNum(), _robot.getTime(), calculateBulletPower(), _robot.getGunHeat(), myLocation(), is1v1(), paintStatus()); if (is1v1()) { GunEnemy duelEnemy = _gunDataManager.duelEnemy(); if (duelEnemy != null) { aimAndFire(duelEnemy); if (!_startedDuel) { _startedDuel = true; printCurrentGun(duelEnemy); } } } else { aimAndFireAtEveryone(); } if (paintStatus() && _drawVictory) { _gunDataManager.drawVictory(_robot.getTime()); _drawVictory = false; } }
public String toXML() throws KVException { if (msgType == null || (msgType.equals("delreq") && key == null) || (msgType.equals("putreq") && (value == null || key == null)) || (msgType.equals("resp") && key != null && value == null)) { throw new KVException(new KVMessage("resp", "Message format incorrect")); } DocumentBuilder db = null; try { db = DocumentBuilderFactory.newInstance().newDocumentBuilder(); } catch (ParserConfigurationException e) { throw new KVException(new KVMessage("resp", "Message format incorrect")); } Document doc = db.newDocument(); Element kv = doc.createElement("KVMessage"); Element keey, valoo, massage, toy; kv.setAttribute("type", msgType); if (key != null) { keey = doc.createElement("Key"); keey.setTextContent(key); kv.appendChild(keey); } if (value != null) { valoo = doc.createElement("Value"); valoo.setTextContent(value); kv.appendChild(valoo); } if (message != null) { massage = doc.createElement("Message"); massage.setTextContent(message); kv.appendChild(massage); } if (tpcOpId != null) { toy = doc.createElement("TPCOpId"); toy.setTextContent(tpcOpId); kv.appendChild(toy); } doc.appendChild(kv); duck = doc; doc.setXmlStandalone(true); TransformerFactory tf = TransformerFactory.newInstance(); Transformer transformer = null; try { transformer = tf.newTransformer(); } catch (TransformerConfigurationException e) { e.printStackTrace(); } transformer.setOutputProperty(OutputKeys.INDENT, "yes"); StringWriter writer = new StringWriter(); try { transformer.transform(new DOMSource(doc), new StreamResult(writer)); } catch (TransformerException e) { e.printStackTrace(); } String output = writer.getBuffer().toString(); return output; }
public AttributeDesc getAttributeDesc(DbTableMeta tableMeta, DbColumnMeta columnMeta) { AttributeDesc attributeDesc = new AttributeDesc(); doName(tableMeta, columnMeta, attributeDesc); doId(tableMeta, columnMeta, attributeDesc); doTransient(tableMeta, columnMeta, attributeDesc); doColumn(tableMeta, columnMeta, attributeDesc); doVersion(tableMeta, columnMeta, attributeDesc); doGenerationType(tableMeta, columnMeta, attributeDesc); return attributeDesc; }
public GetOptions range(long start, long end) { checkArgument(start >= 0, "start must be >= 0"); checkArgument(end >= 0, "end must be >= 0"); ranges.add(String.format("%d-%d", start, end)); return this; }
void setEnableConcurrentAddRemove(boolean b) { enableConcurrentAddRemove = b; }
static void start(Keys key, String value, StringBuilder b) { b.append(key.name()).append(AuditConstants.KEY_VAL_SEPARATOR).append(value); }
@GET @Produces(MediaType.APPLICATION_OCTET_STREAM) @SuppressWarnings({"MustBeClosedChecker", "PMD.CloseResource"}) public @Nonnull Response get(@QueryParam(QP_KEY) String key) throws IOException { InputStream inputStream = Main.getWorkMgr().getNetworkObject(_network, key); if (inputStream == null) { return Response.status(Status.NOT_FOUND).build(); } String filename = Paths.get(key).getFileName().toString(); return Response.ok(inputStream, MediaType.APPLICATION_OCTET_STREAM) .header("Content-Disposition", "attachment; filename=\"" + filename + "\"") .header(CoordConsts.SVC_FILENAME_HDR, filename) .build(); }
@Override public void setXClassReference(EntityReference xClassReference) { super.setXClassReference(xClassReference); this.referenceCache = null; }
public void authenticate(SecurityContext securityContext, String authHeader) { if (!httpsEnabled) { throw new WebApplicationException(Response.status(FORBIDDEN) .header("Content-Type", "text/plain") .entity("HTTPS not enabled") .build()); } if (securityContext.isUserInRole("server.admin") && !"none".equals(securityContext.getAuthenticationScheme())) { return; } if (username == null || password == null) { throw new WebApplicationException(Response.status(FORBIDDEN) .header("Content-Type", "text/plain") .entity("Administrator password not configured") .build()); } if (authHeader == null || !authHeader.startsWith("Basic ")) { unauthorized(); } String credentials = new String(decoder.decode(authHeader.substring("Basic ".length())), UTF_8); int index = credentials.indexOf(':'); if (index < 0 || !username.equals(credentials.substring(0, index)) || !password.equals(credentials.substring(index + 1))) { unauthorized(); } }
public Stroke getStroke(Comparable key) { ParamChecks.nullNotPermitted(key, "key"); return this.store.get(key); }
public boolean evaluate(Object o) { MCRUserInformation userInformation = Optional.ofNullable(o) .filter(obj -> obj instanceof MCRAccessData) .map(MCRAccessData.class::cast) .map(MCRAccessData::getUserInformation) .orElseGet(MCRSessionMgr.getCurrentSession()::getUserInformation); return userInformation.isUserInRole(groupname) ^ not; }
@Override public GetOptions apply(org.jclouds.blobstore.options.GetOptions from) { checkNotNull(from, "options"); if (from == org.jclouds.blobstore.options.GetOptions.NONE) return GetOptions.NONE; GetOptions httpOptions = new GetOptions(); if (from.getIfMatch() != null) { httpOptions.ifETagMatches(from.getIfMatch()); } if (from.getIfModifiedSince() != null) { httpOptions.ifModifiedSince(from.getIfModifiedSince()); } if (from.getIfNoneMatch() != null) { httpOptions.ifETagDoesntMatch(from.getIfNoneMatch()); } if (from.getIfUnmodifiedSince() != null) { httpOptions.ifUnmodifiedSince(from.getIfUnmodifiedSince()); } for (String range : from.getRanges()) { String[] firstLast = range.split("\\-", 2); if (!firstLast[0].isEmpty() && !firstLast[1].isEmpty()) httpOptions.range(Long.parseLong(firstLast[0]), Long.parseLong(firstLast[1])); else if (firstLast[0].isEmpty() && !firstLast[1].isEmpty()) httpOptions.tail(Long.parseLong(firstLast[1])); else httpOptions.startAt(Long.parseLong(firstLast[0])); } return httpOptions; }
public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore, IAuthenticator authenticator, boolean allowAnonymous, IAuthorizator authorizator, BrokerInterceptor interceptor, SessionsRepository sessionsRepository) { init(subscriptions, storageService, sessionsStore, authenticator, allowAnonymous, false, authorizator, interceptor, sessionsRepository); }
@Override public SelectorQuery assembleQueryPlan(SemanticSelector semanticSelector) { return buildQueryPlan(semanticSelector); }
@Override public Future<Void> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId, final String adapterInstanceId, final Duration lifespan, final Span span) { Objects.requireNonNull(tenantId); Objects.requireNonNull(deviceId); Objects.requireNonNull(adapterInstanceId); Objects.requireNonNull(span); final long lifespanMillis = lifespan == null || lifespan.isNegative() || lifespan.getSeconds() > (Long.MAX_VALUE / 1000L) ? -1 : lifespan.toMillis(); return cache.put(getAdapterInstanceEntryKey(tenantId, deviceId), adapterInstanceId, lifespanMillis, TimeUnit.MILLISECONDS) .map(replacedValue -> { LOG.debug("set command handling adapter instance [tenant: {}, device-id: {}, adapter-instance: {}, lifespan: {}ms]", tenantId, deviceId, adapterInstanceId, lifespanMillis); return (Void) null; }) .recover(t -> { LOG.debug("failed to set command handling adapter instance [tenant: {}, device-id: {}, adapter-instance: {}, lifespan: {}ms]", tenantId, deviceId, adapterInstanceId, lifespanMillis, t); return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR, t)); }); }
public Background createBackground(Path context, ScenarioSimulationModel.Type type, String value) { switch (type) { case RULE: return ruleSimulationCreationStrategy.createBackground(context, value); case DMN: return dmnSimulationCreationStrategy.createBackground(context, value); default: throw new IllegalStateException("Unknown ScenarioSimulationModel.Type " + type); } }
public static Cache.Entry parseCacheHeaders(NetworkResponse response) { long now = System.currentTimeMillis(); Map<String, String> headers = response.headers; long serverDate = 0; long lastModified = 0; long serverExpires = 0; long softExpire = 0; long finalExpire = 0; long maxAge = 0; long staleWhileRevalidate = 0; boolean hasCacheControl = false; boolean mustRevalidate = false; String serverEtag = null; String headerValue; headerValue = headers.get("Date"); if (headerValue != null) { serverDate = parseDateAsEpoch(headerValue); } headerValue = headers.get("Cache-Control"); if (headerValue != null) { hasCacheControl = true; String[] tokens = headerValue.split(","); for (int i = 0; i < tokens.length; i++) { String token = tokens[i].trim(); if (token.equals("no-cache") || token.equals("no-store")) { return null; } else if (token.startsWith("max-age=")) { try { maxAge = Long.parseLong(token.substring(8)); } catch (Exception e) { } } else if (token.startsWith("stale-while-revalidate=")) { try { staleWhileRevalidate = Long.parseLong(token.substring(23)); } catch (Exception e) { } } else if (token.equals("must-revalidate") || token.equals("proxy-revalidate")) { mustRevalidate = true; } } } headerValue = headers.get("Expires"); if (headerValue != null) { serverExpires = parseDateAsEpoch(headerValue); } headerValue = headers.get("Last-Modified"); if (headerValue != null) { lastModified = parseDateAsEpoch(headerValue); } serverEtag = headers.get("ETag"); if (hasCacheControl) { softExpire = now + maxAge * 1000; finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * 1000; } else if (serverDate > 0 && serverExpires >= serverDate) { softExpire = now + (serverExpires - serverDate); finalExpire = softExpire; } Cache.Entry entry = new Cache.Entry(); entry.data = response.data; entry.etag = serverEtag; entry.softTtl = softExpire; entry.ttl = finalExpire; entry.serverDate = serverDate; entry.lastModified = lastModified; entry.responseHeaders = headers; return entry; }
public static long fileNameToPersistenceTime(String fileName) { if (StringUtils.isBlank(fileName)) { throw new IllegalArgumentException("the 'fileName' cannot be 'null' or empty"); } String formattedTimeString = StringUtils.strip(fileName, FILE_FORMAT_EXTENSION); DateTime persistedTime = FILE_FORMATTER.parseDateTime(formattedTimeString); return persistedTime.getMillis(); }
public static <T> Set<T> intersection(Set<? extends T> setLeft, Set<? extends T> setRight) { Set<T> results = new HashSet<>(setLeft) ; results.retainAll(setRight) ; return results ; }
public static URI parse(String gluePath) { requireNonNull(gluePath, "gluePath may not be null"); if (gluePath.isEmpty()) { return rootPackageUri(); } if (CLASSPATH_SCHEME_PREFIX.equals(gluePath)) { return rootPackageUri(); } if (nonStandardPathSeparatorInUse(gluePath)) { String standardized = replaceNonStandardPathSeparator(gluePath); return parseAssumeClasspathScheme(standardized); } if (isProbablyPackage(gluePath)) { String path = resourceNameOfPackageName(gluePath); return parseAssumeClasspathScheme(path); } return parseAssumeClasspathScheme(gluePath); }
@Override public List<MessageTemplate> findByTypeAndLanguage(String type, String language, long tenantId) { StringBuffer query = new StringBuffer("_entity.language='" + language + "' "); query.append(" and _entity.tenantId=" + tenantId); if (StringUtils.isNotEmpty(type)) query.append(" and _entity.type='" + type + "' "); try { return findByWhere(query.toString(), "order by _entity.name", null); } catch (PersistenceException e) { log.error(e.getMessage(), e); return new ArrayList<MessageTemplate>(); } }
public Class<?> getClassDecorator(Class<? extends Annotation> clazzPositionalFieldAnnotation){ if (!isFFPojoAnnotationField(clazzPositionalFieldAnnotation)){ throw new FFPojoException(String.format("The class %s not seem a DelimitedField or PositionalField annotation.", clazzPositionalFieldAnnotation)); } final String dataType = clazzPositionalFieldAnnotation.getSimpleName() .replaceAll("DelimitedField", "") .replaceAll("PositionalField", "") .toLowerCase(); return mapAnnotationDecoratorClass.get(dataType); }
public final void clear() { for (ViewModel vm : mMap.values()) { vm.onCleared(); } mMap.clear(); }
protected RuntimeException handleError(String url, HttpAdapterResponse response) throws IOException { RuntimeException e = handleError(client, response, client.getFormat()); if (e instanceof CrnkException) { CrnkException crnkException = (CrnkException) e; crnkException.setUrl(url); } return e; }
@Override public DataFile getDatafile(int id) { return (DataFile) persistenceManager.pick("select f from DataFile f where f.id = ?1", id); }
public boolean isEndpointAccessible(String authorisationId, boolean confirmationCodeReceived) { boolean confirmationCodeCase = confirmationCodeReceived && aspspProfileService.isAuthorisationConfirmationRequestMandated(); return xs2aAuthorisationService.getAuthorisationById(authorisationId) .map(a -> isAccessible(a.getChosenScaApproach(), a.getScaStatus(), confirmationCodeCase)) .orElse(true); }
public static String getContentAsString(final FileObject file, final Charset charset) throws IOException { try (final FileContent content = file.getContent()) { return content.getString(charset); } }
public static <W extends WitnessType<W>,A> OptionT<W,A> of(final AnyM<W,Option<A>> monads) { return new OptionT<>( monads); }
@VisibleForTesting int generateBucketValue(int hashCode) { double ratio = (double) (hashCode & 0xFFFFFFFFL) / Math.pow(2, 32); return (int) Math.floor(MAX_TRAFFIC_VALUE * ratio); }
public static RepeatUnrollStrategy instance() { return INSTANCE; }
@Override public void setTitle(final String title) { titleSetter.accept(title); }
@Override public Subject convert(final SubjectResource source, final Subject target) { target.setName(source.getName()); if (source.getSubjectTypeId() != null) { SubjectType subjectType = new SubjectType(); subjectType.setId(source.getSubjectTypeId()); target.setSubjectType(subjectType); } return target; }
public List<SimpleKeyword> convertJudgmentKeywords(List<JudgmentKeyword> judgmentKeywords) { return judgmentKeywords.stream() .map(judgmentKeyword -> convertFromJudgmentKeyword(judgmentKeyword)) .collect(Collectors.toList()); }
@Override public FilterPolicy filterEvent(Event event, DocumentReference user, Collection<NotificationFilterPreference> filterPreferences, NotificationFormat format) { return FilterPolicy.NO_EFFECT; }
public static String getSharedPackageName(List<Class<?>> classes) { if (classes.isEmpty()) { return ""; } List<List<String>> lParts = new ArrayList<>(classes.size()); List<String> currentParts = new ArrayList<>(); for (Class<?> cls : classes) { if (!Proxy.isProxyClass(cls)) { lParts.add(Arrays.asList(getPackageName(cls).split("\\."))); } } for (int i = 0; i < lParts.get(0).size(); i++) { int j = 1; for (; j < lParts.size(); j++) { if (i > (lParts.get(j).size() - 1) || !lParts.get(j).get(i).equals(lParts.get(0).get(i))) { break; } } if (j == lParts.size()) { currentParts.add(lParts.get(j - 1).get(i)); } else { break; } } return String.join(".", currentParts); }
@POST @Path("/friends") @Consumes("application/json") @Produces("application/json") public Friend addFriend(@PathParam("id") LongParam id, Friend body) { return friendService.addFriend(id.get(), body); }
public boolean isValid( Set<IamRolePermission> iamRolePermissionSet, ConstraintValidatorContext context) { if (iamRolePermissionSet == null || iamRolePermissionSet.isEmpty()) { return true; } boolean isValid = true; Set<String> iamRoles = new HashSet<>(); for (IamRolePermission iamRolePermission : iamRolePermissionSet) { final String key = buildKey(iamRolePermission); if (iamRoles.contains(key)) { isValid = false; break; } else { iamRoles.add(key); } } return isValid; }
@Override public void close() { if (isRunning() || isPaused()) { sequence.stop(); } }
TaskDag createTaskDag() { long start = System.currentTimeMillis(); TaskDag taskDag = new TaskDag(); List<ProvisionerAction> actionOrder = actions.getActionOrder().get(clusterAction); for (Node node : nodeMap.values()) { if (!shouldPlanNode(node.getId())) { continue; } for (Service service : node.getServices()) { if (!shouldPlanService(service.getName())) { continue; } addDependencies(taskDag, actionOrder, service, node); } } long dur = System.currentTimeMillis() - start; LOG.debug("took {} ms to create action plan.", dur); return taskDag; }
public static Builder builder() { return new Builder(); }
public int compareTo(Object obj) { LdapRdnComponent that = (LdapRdnComponent) obj; int keyCompare = this.key.toLowerCase().compareTo(that.key.toLowerCase()); if(keyCompare == 0) { return this.value.toLowerCase().compareTo(that.value.toLowerCase()); } else { return keyCompare; } }
public long availableMemory() { return availableMemory; }
public Path getAppsDirectory() { return Paths.get(this.dataRootPath, APPS_DIRECTORY_NAME); }
public <S, T> UniRepeat<T> uni(Supplier<S> stateSupplier, Function<S, ? extends Uni<? extends T>> producer) { Uni<T> upstream = Uni.createFrom().deferred(stateSupplier, producer); return new UniRepeat<>(upstream); }
@Override public void update(int[] x, int y) { if (!isGoodInstance(x)) { logger.info("Skip updating the model with a sample without any feature word"); return; } if (model == Model.TWCNB) { throw new UnsupportedOperationException("TWCNB supports only batch learning"); } y = labels.indexOf(y); switch (model) { case MULTINOMIAL: case CNB: case WCNB: case TWCNB: for (int i = 0; i < p; i++) { ntc[y][i] += x[i]; nt[y] += x[i]; } break; case POLYAURN: for (int i = 0; i < p; i++) { ntc[y][i] += x[i] * 2; nt[y] += x[i] * 2; } break; case BERNOULLI: for (int i = 0; i < p; i++) { if (x[i] > 0) { ntc[y][i]++; } } break; default: throw new IllegalStateException("Unknown model: " + model); } n++; nc[y]++; update(); }
public List<T> calculateCriticalPath(ICriticalPathCalculable<T> graph) { this.graph = graph; dependencies = new HashMap<T, Map<T, DependencyType>>(); initDate = calculateInitDate(); bop = createBeginningOfProjectNode(); eop = createEndOfProjectNode(); nodes = createGraphNodes(); forward(bop, null, new VisitorTracker()); eop.updateLatestValues(); backward(eop, null, new VisitorTracker()); return getTasksOnCriticalPath(); }
public static void notNull(Object o, String message) { isTrue(o != null, message); }
@SafeVarargs public static <E> NonEmptyList<E> of(E value, E... values) { return of(listOf(value).appendAll(listOf(values))); }
public void copyFilesFromJarTrimmingBasePath(File jar, String jarDirectoryToCopyFrom, File outputDirectory, String... wildcardPathExclusions) { requireFileExistence(jar); if (!Objects.requireNonNull(outputDirectory).isDirectory()) { throw new IllegalArgumentException( String.format("Expect '%s' to be an existing directory", outputDirectory)); } String basePath = normalizeJarBasePath(jarDirectoryToCopyFrom); try (JarFile jarFile = new JarFile(jar, false)) { jarFile.stream().filter(file -> !file.isDirectory()) .filter(file -> file.getName().toLowerCase(Locale.ENGLISH) .startsWith(basePath.toLowerCase(Locale.ENGLISH))) .filter(file -> isFileIncluded(file, wildcardPathExclusions)) .forEach(jarEntry -> copyJarEntryTrimmingBasePath(jarFile, jarEntry, basePath, outputDirectory)); } catch (IOException e) { throw new UncheckedIOException(String.format( "Failed to extract files from jarFile '%s' to directory '%s'", jar, outputDirectory), e); } }
public String getCollectionSize() { final Element size = this.getSizePropertyElement(); return this.getAttributeValue(size, "sum"); }
public String getId() { return id; }
public static boolean validate(final char[] pin) { return describe(pin).isValid(); }
public List<Set<Card>> shuffleAndDeal(Random random, int hands, int cardsPerHand) { var shuffled = this.shuffle(random); return this.dealHands(shuffled, hands, cardsPerHand); }
public MetaDataValue convertToMetaDataValue(Object value) { MetaDataValue.Builder builder = MetaDataValue.newBuilder(); if (value instanceof CharSequence) { builder.setTextValue(value.toString()); } else if (value instanceof Double || value instanceof Float) { builder.setDoubleValue(((Number) value).doubleValue()); } else if (value instanceof Number) { builder.setNumberValue(((Number) value).longValue()); } else if (value instanceof Boolean) { builder.setBooleanValue((Boolean) value); } else { SerializedObject<byte[]> serializedObject = serializer.serialize(value, byte[].class); SerializedType serializedType = serializedObject.getType(); if (!SerializedType.isEmptyType(serializedType)) { builder.setBytesValue(io.axoniq.axonserver.grpc.SerializedObject .newBuilder() .setType(serializedType.getName()) .setData(ByteString.copyFrom(serializedObject.getData())) .setRevision(getOrDefault(serializedType.getRevision(), "")) .build()); } } return builder.build(); }
@Override public ConfigFile getOrCreateConfigFile(String namespace, ConfigFileFormat configFileFormat) { String namespaceFileName = String.format("%s.%s", namespace, configFileFormat.getValue()); ConfigFile configFile = m_configFiles.get(namespaceFileName); if (configFile == null) { synchronized (this) { configFile = m_configFiles.get(namespaceFileName); if (configFile == null) { ConfigFactory factory = m_factoryManager.getFactory(namespaceFileName); configFile = factory.createConfigFile(namespaceFileName, configFileFormat); m_configFiles.put(namespaceFileName, configFile); } } } return configFile; }
@Override public ReleaseResult execute( ReleaseDescriptor releaseDescriptor, ReleaseEnvironment releaseEnvironment, List<MavenProject> reactorProjects ) throws ReleaseExecutionException { ReleaseResult result = new ReleaseResult(); resourceBundle = getResourceBundle( releaseEnvironment.getLocale() ); MavenProject rootProject = ReleaseUtil.getRootProject( reactorProjects ); if ( releaseDescriptor.isAutoVersionSubmodules() && ArtifactUtils.isSnapshot( rootProject.getVersion() ) ) { MavenProject project = rootProject; String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() ); String nextVersion = resolveNextVersion( project, projectId, releaseDescriptor, result ); if ( !convertToSnapshot ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else if ( releaseDescriptor.isBranchCreation() && convertToBranch ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else { releaseDescriptor.addDevelopmentVersion( projectId, nextVersion ); } for ( MavenProject subProject : reactorProjects ) { String subProjectId = ArtifactUtils.versionlessKey( subProject.getGroupId(), subProject.getArtifactId() ); if ( convertToSnapshot ) { String v; if ( ArtifactUtils.isSnapshot( subProject.getVersion() ) ) { v = nextVersion; } else { v = subProject.getVersion(); } if ( releaseDescriptor.isBranchCreation() && convertToBranch ) { releaseDescriptor.addReleaseVersion( subProjectId, v ); } else { releaseDescriptor.addDevelopmentVersion( subProjectId, v ); } } else { releaseDescriptor.addReleaseVersion( subProjectId, nextVersion ); } } } else { for ( MavenProject project : reactorProjects ) { String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() ); String nextVersion = resolveNextVersion( project, projectId, releaseDescriptor, result ); if ( !convertToSnapshot ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else if ( releaseDescriptor.isBranchCreation() && convertToBranch ) { releaseDescriptor.addReleaseVersion( projectId, nextVersion ); } else { releaseDescriptor.addDevelopmentVersion( projectId, nextVersion ); } } } result.setResultCode( ReleaseResult.SUCCESS ); return result; }
@Override public Object transform(Object o) throws SQLException { if (o == null) return null; if (!(o instanceof oracle.sql.CLOB)) { throw new UnsupportedOperationException( "OracleClobNormaliser cannot work with " + o.getClass()); } oracle.sql.CLOB clob = (oracle.sql.CLOB) o; if (clob.length() > MAX_CLOB_LENGTH) throw new UnsupportedOperationException("Clobs larger than " + MAX_CLOB_LENGTH + " bytes are not supported by DBFIT"); char[] buffer = new char[MAX_CLOB_LENGTH]; int total = clob.getChars(1, MAX_CLOB_LENGTH, buffer); return String.valueOf(buffer, 0, total); }
public String prettyprint(ASTExpression node) { getPrinter().clearBuffer(); node.accept(getRealThis()); return getPrinter().getContent(); }
@Override public <T> T invoke(Context context, Class<T> classOfT, Type genericType) { T t; try { t = classOfT.newInstance(); } catch (Exception e) { LOGGER.error("Failed to create a new instance of {}", classOfT, e); return null; } Map<String, ReflectionHelper.Property> properties = ReflectionHelper.getProperties(classOfT, genericType); for (Entry<String, List<String>> ent : context.parameters().entrySet()) { try { ReflectionHelper.Property property = properties.get(ent.getKey()); if (property != null) { Object value = converters.convertValues(ent.getValue(), property.getClassOfProperty(), property.getGenericTypeOfProperty(), null); property.set(t, value); } } catch (Exception e) { LOGGER.warn(ERROR_KEY + ent.getKey() + ERROR_AND + ent.getValue(), e); } } final Map<String, String> fromPath = context.route().getPathParametersEncoded(context.request().uri()); for (Entry<String, String> ent : fromPath .entrySet()) { try { ReflectionHelper.Property property = properties.get(ent.getKey()); if (property != null) { Object value = converters.convertValue(ent.getValue(), property.getClassOfProperty(), property.getGenericTypeOfProperty(), null); property.set(t, value); } } catch (Exception e) { LOGGER.debug(ERROR_KEY + ent.getKey() + ERROR_AND + ent.getValue(), e); } } if (context.form() == null || context.form().isEmpty()) { return t; } for (Entry<String, List<String>> ent : context.form().entrySet()) { try { ReflectionHelper.Property property = properties.get(ent.getKey()); if (property != null) { Object value = converters.convertValues(ent.getValue(), property.getClassOfProperty(), property.getGenericTypeOfProperty(), null); property.set(t, value); } } catch (Exception e) { LOGGER.warn(ERROR_KEY + ent.getKey() + ERROR_AND + ent.getValue(), e); } } if (context.files() == null || context.files().isEmpty()) { return t; } for (FileItem item : context.files()) { try { ReflectionHelper.Property property = properties.get(item.field()); if (property != null) { if (InputStream.class.isAssignableFrom(property.getClassOfProperty())) { property.set(t, item.stream()); } else if (FileItem.class.isAssignableFrom(property.getClassOfProperty())) { property.set(t, item); } else if (property.getClassOfProperty().isArray() && property.getClassOfProperty().getComponentType().equals(Byte.TYPE)) { property.set(t, item.bytes()); } } } catch (Exception e) { LOGGER.warn(ERROR_KEY + item.field() + ERROR_AND + item, e); } } return t; }
Object convertCloudResponse(Object result) { if (result instanceof JSONObject) { JSONObject jsonResult = (JSONObject) result; if (jsonResult.isNull("result")) { return null; } result = jsonResult.opt("result"); } ParseDecoder decoder = ParseDecoder.get(); Object finalResult = decoder.decode(result); if (finalResult != null) { return finalResult; } return result; }
public CompileResult analyzeAndCompile(final List<File> files, final String classpath, String out) throws IOException { return analyzeAndCompile(files, classpath, out, true); }
static String readPacket(ByteBuffer input) { if (input.remaining() < LENGTH_FIELD_SIZE) { return null; } input.get(BUFFER, 0, LENGTH_FIELD_SIZE); int length = parseLength(BUFFER); if (length > BUFFER.length) { throw new IllegalArgumentException("Packet size should not be that big: " + length); } if (input.remaining() < length) { input.rewind(); return null; } input.get(BUFFER, 0, length); return new String(BUFFER, 0, length, StandardCharsets.UTF_8); }
public static String tr(String message, Object... params) { return tr(getBundle(), message, params); }
static JavaInput reorderModifiers(String text) throws FormatterException { return reorderModifiers( new JavaInput(text), ImmutableList.of(Range.closedOpen(0, text.length()))); }
@Override public Map<UUID, List<LongRunningProcessStatus>> ping(Map<UUID, List<UUID>> procIds) { return delegate.ping(procIds); }
@Override public void validate(UastNode node) { is(UastNode.Kind.DEFAULT_CASE); hasKeyword("default"); noChild(UastNode.Kind.CONDITION); }
public MavenExecutionRequest getMavenExecutionRequest() { return mavenExecutionRequest; }
@Udf(description = "Returns a new string encoded using the outputEncoding ") public String encode( @UdfParameter( description = "The source string. If null, then function returns null.") final String str, @UdfParameter( description = "The input encoding." + " If null, then function returns null.") final String inputEncoding, @UdfParameter( description = "The output encoding." + " If null, then function returns null.") final String outputEncoding) { if (str == null || inputEncoding == null || outputEncoding == null) { return null; } final String encodedString = inputEncoding.toLowerCase() + outputEncoding.toLowerCase(); if (ENCODER_MAP.get(encodedString) == null) { throw new KsqlFunctionException("Supported input and output encodings are: " + "hex, utf8, ascii and base64"); } return ENCODER_MAP.get(encodedString).apply(str); }
public DbRequestResult execute(Select request) throws InvalidParseOperationException, DatabaseException, BadRequestException, InvalidCreateOperationException, VitamDBException, SchemaValidationException { DynamicParserTokens parserTokens = new DynamicParserTokens(vitamCollection.getVitamDescriptionResolver(), ontologyLoader.loadOntologies()); return findDocuments(request.getFinalSelect(), parserTokens); }
public static long[] colSums(int[][] data) { long[] x = new long[data[0].length]; for (int i = 0; i < data.length; i++) { for (int j = 0; j < x.length; j++) { x[j] += data[i][j]; } } return x; }
@Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { if (authentication == null) { return authentication; } UsernamePasswordAuthenticationToken output = null; if (authentication instanceof UsernamePasswordAuthenticationToken) { output = (UsernamePasswordAuthenticationToken) authentication; } else { output = new UsernamePasswordAuthenticationToken(authentication.getPrincipal(), authentication.getCredentials(), authentication.getAuthorities()); output.setDetails(authentication.getDetails()); } boolean authenticated = false; Authentication auth = null; AuthenticationException lastException = null; boolean lastResult = false; boolean shallContinue = true; if (delegates==null || delegates.length==0) { throw new ProviderNotFoundException("No available authentication providers."); } for (int i=0; shallContinue && i<delegates.length; i++) { boolean shallAuthenticate = (i==0) || (lastResult && IF_PREVIOUS_TRUE.equals(delegates[i].getRequired())) || ((!lastResult) && IF_PREVIOUS_FALSE.equals(delegates[i].getRequired())); if (shallAuthenticate) { if (logger.isDebugEnabled()) { logger.debug("Attempting chained authentication of " + output + " with manager:" + delegates[i].getAuthenticationManager() + " required:" + delegates[i].getRequired()); } Authentication thisAuth = null; try { thisAuth = delegates[i].getAuthenticationManager().authenticate(auth!=null ? auth : output); } catch (AuthenticationException x) { if (logger.isDebugEnabled()) { logger.debug("Chained authentication exception:"+x.getMessage()+" at:"+(x.getStackTrace().length>0?x.getStackTrace()[0]:"(no stack trace)")); } lastException = x; if (delegates[i].getStopIf()!=null) { for (Class<? extends AuthenticationException> exceptionClass : delegates[i].getStopIf()) { if (exceptionClass.isAssignableFrom(x.getClass())) { shallContinue = false; break; } } } } lastResult = thisAuth != null && thisAuth.isAuthenticated(); if (lastResult) { authenticated = true; auth = thisAuth; } else { authenticated = false; auth = null; } } else { shallContinue = false; } if (logger.isDebugEnabled()) { logger.debug("Chained Authentication status of "+output+ " with manager:"+delegates[i]+"; Authenticated:"+authenticated); } } if (authenticated) { return auth; } else if (lastException!=null) { throw lastException; } else { return auth; } }
public static Collection subtract(final Collection a, final Collection b) { if (a == null) return new ArrayList(); if (b == null) return new ArrayList<Object>(a); ArrayList<Object> list = new ArrayList<Object>(a); for (Object o : b) { list.remove(o); } return list; }
@Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = jHipsterProperties.getCors(); if (config.getAllowedOrigins() != null && !config.getAllowedOrigins().isEmpty()) { log.debug("Registering CORS filter"); source.registerCorsConfiguration("/api/**", config); source.registerCorsConfiguration("/v2/api-docs", config); } return new CorsFilter(source); }
public boolean isPruned(long transactionId, boolean hasPrunablePlainMessage, boolean hasPrunableEncryptedMessage) { if (!hasPrunablePlainMessage && !hasPrunableEncryptedMessage) { return false; } try (Connection con = getDatabaseManager().getDataSource().getConnection(); PreparedStatement pstmt = con.prepareStatement("SELECT message, encrypted_message FROM prunable_message WHERE id = ?")) { pstmt.setLong(1, transactionId); try (ResultSet rs = pstmt.executeQuery()) { return !rs.next() || (hasPrunablePlainMessage && rs.getBytes("message") == null) || (hasPrunableEncryptedMessage && rs.getBytes("encrypted_message") == null); } } catch (SQLException e) { throw new RuntimeException(e.toString(), e); } }
public void close(FormSubmission submission) { Mother mother = allMothers.findByCaseId(submission.entityId()); if (mother == null) { logger.warn(format("Failed to close PNC as there is no mother registered with ID: {0}", submission.entityId())); return; } logger.info("Closing PNC case. Entity Id: " + submission.entityId()); allMothers.close(submission.entityId()); actionService.markAllAlertsAsInactive(submission.entityId()); pncSchedulesService.unEnrollFromSchedules(submission.entityId()); List<String> reportFields = reportFieldsDefinition.get(submission.formName()); motherReportingService.closePNC(new SafeMap(submission.getFields(reportFields))); if (DEATH_OF_MOTHER_VALUE.equalsIgnoreCase(submission.getField(CLOSE_REASON_FIELD_NAME)) || PERMANENT_RELOCATION_VALUE.equalsIgnoreCase(submission.getField(CLOSE_REASON_FIELD_NAME))) { logger.info("Closing EC case along with PNC case. Submission: " + submission); allEligibleCouples.close(mother.ecCaseId()); } }
public void truncate( LogPosition positionAfterLastRecoveredTransaction ) throws IOException { long recoveredTransactionLogVersion = positionAfterLastRecoveredTransaction.getLogVersion(); long recoveredTransactionOffset = positionAfterLastRecoveredTransaction.getByteOffset(); if ( isRecoveredLogCorrupted( recoveredTransactionLogVersion, recoveredTransactionOffset ) || haveMoreRecentLogFiles( recoveredTransactionLogVersion ) ) { backupCorruptedContent( recoveredTransactionLogVersion, recoveredTransactionOffset ); truncateLogFiles( recoveredTransactionLogVersion, recoveredTransactionOffset ); } }
public List<String> getSuggestions() { final List<Object> diagramDefinitions = getDiagramDefinitions(); final List<String> dataTypesSuggestions = getDataTypesSuggestions(diagramDefinitions); final List<String> namedElementSuggestions = getNamedElementSuggestions(diagramDefinitions); return Stream .of(dataTypesSuggestions, namedElementSuggestions) .flatMap(Collection::stream) .distinct() .filter(name -> !name.isEmpty()) .sorted() .collect(Collectors.toList()); }
void handleEvent(FSMEvent event) { FSMChannel channel = null; InternalFSMChannelManager channelManager = null; if(event instanceof FSMEvent.ChannelFSMEvent) { channel = ((FSMEvent.ChannelFSMEvent)event).getChannel(); if(connectedChannelManager.isManagedChannel(channel)) channelManager = connectedChannelManager; else if(activeChannelManager.isManagedChannel(channel)) channelManager = activeChannelManager; } switch(event.getType()) { case AutomaticStart: case ManualStart: handleStartEvent(event.getType()); break; case AutomaticStop: case ManualStop: handleStopEvent(event.getType()); break; case ConnectRetryTimer_Expires: handleConnectRetryTimerExpiredEvent(); break; case IdleHoldTimer_Expires: handleIdleHoldTimerExpiredEvent(); break; case TcpConnectionConfirmed: if(channel != null) handleTcpConnectionConfirmed(channel); else haveFSMError = true; break; case Tcp_CR_Acked: if(channel != null) handleTcpConnectionAcked(channel); else haveFSMError = true; break; case TcpConnectionFails: if(channel != null) handleTcpConnectionFails(channel); else haveFSMError = true; break; case DelayOpenTimer_Expires: handleDelayOpenTimerExpiredEvent(); break; case HoldTimer_Expires: handleHoldTimerExpiredEvent(); break; case BGPOpen: if(channel != null && channelManager != null) handleBgpOpenEvent(channel, channelManager); else haveFSMError = true; break; case KeepAliveMsg: handleKeepaliveMessageEvent(); break; case KeepaliveTimer_Expires: handleKeepaliveTimerExpiresEvent(); break; case NotifyMsg: handleNotifyMessageEvent(); break; case NotifyMsgVerErr: handleNotifyMessageVersionErrorEvent(); break; case BGPOpenMsgErr: handleBGPOpenMessageErrorEvent(); break; case BGPHeaderErr: handleBGPHeaderErrorEvent(); break; case UpdateMsg: handleUpdateMessageEvent(); break; case UpdateMsgErr: handleUpdateMessageErrorEvent(); break; } if(channelManager != null) channelManager.pushInboundFSMEvent(event.getType()); if(haveFSMError) { switch(state) { case Established: case OpenConfirm: case OpenSent: connectedChannelManager.fireSendInternalErrorNotification(); activeChannelManager.fireSendInternalErrorNotification(); break; } connectRetryCounter++; moveStateToIdle(); haveFSMError = false; } }
public Object execute(ScriptWorld world) { ScriptEngine engine = createEngine(); engine.put("request", world.getRequest()); engine.put("response", world.getResponse()); engine.put("exchange", world); try { return engine.eval(source); } catch (ScriptException e) { throw new RuntimeException("Error executing script", e); } }
<T> Map<String, HColumn<String, byte[]>> createColumnMap(T obj) { if (null == obj) { throw new IllegalArgumentException("Class type cannot be null"); } @SuppressWarnings("unchecked") CFMappingDef<T> cfMapDef = (CFMappingDef<T>) cacheMgr.getCfMapDef((Class<T>) obj.getClass(), true); try { Map<String, HColumn<String, byte[]>> colSet = new HashMap<String, HColumn<String, byte[]>>(); Collection<PropertyMappingDefinition> coll = cfMapDef.getAllProperties(); for (PropertyMappingDefinition md : coll) { Collection<HColumn<String, byte[]>> colColl = createColumnsFromProperty(obj, md); if (null != colColl) { for (HColumn<String, byte[]> col : colColl) { colSet.put(col.getName(), col); } } } if (null != cfMapDef.getCfBaseMapDef()) { CFMappingDef<?> cfSuperMapDef = cfMapDef.getCfBaseMapDef(); String discColName = cfSuperMapDef.getDiscColumn(); DiscriminatorType discType = cfSuperMapDef.getDiscType(); colSet.put( discColName, createHColumn(discColName, convertDiscTypeToColValue(discType, cfMapDef.getDiscValue()))); } addAnonymousProperties(obj, cfMapDef, colSet); return colSet; } catch (SecurityException e) { throw new RuntimeException(e); } catch (NoSuchFieldException e) { throw new RuntimeException(e); } catch (IllegalArgumentException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } catch (InvocationTargetException e) { throw new RuntimeException(e); } }
@Override protected SafeDeleteNodeCommand createSafeDeleteNodeCommand(final Node<?, Edge> node, final SafeDeleteNodeCommand.Options options, final DeleteCallback callback) { return new DMNSafeDeleteNodeCommand(node, callback.onDeleteNode(node, options), options); }
@Override public CompletableFuture<SendResult> publish(WeEvent event, String groupIdStr) throws BrokerException { log.debug("publish {} groupId: {}", event, groupIdStr); String groupId = selectGroupId(groupIdStr); this.validateGroupId(groupId); ParamCheckUtils.validateEvent(event); if (event.getExtensions().containsKey(WeEvent.WeEvent_SIGN)) { return fiscoBcosDelegate.sendRawTransaction(event.getTopic(), Long.parseLong(groupId), new String(event.getContent(), StandardCharsets.UTF_8)); } else { if (event.getExtensions().containsKey(WeEvent.WeEvent_EPHEMERAL)) { log.info("ephemeral event"); return fiscoBcosDelegate.sendAMOP(event.getTopic(), Long.parseLong(groupId), JsonHelper.object2Json(event)); } else { return fiscoBcosDelegate.publishEvent(event.getTopic(), Long.parseLong(groupId), new String(event.getContent(), StandardCharsets.UTF_8), JsonHelper.object2Json(event.getExtensions())); } } }
@Override public Principal authenticate(String username, String password, XWikiContext context) throws XWikiException { if (username == null) { return null; } if (StringUtils.isBlank(username)) { context.put("message", "nousername"); return null; } if (password == null || password.isEmpty()) { context.put("message", "nopassword"); return null; } String cannonicalUsername = username.replaceAll(" ", ""); if (isSuperAdmin(cannonicalUsername)) { return authenticateSuperAdmin(password, context); } if (context != null) { String susername = cannonicalUsername; String virtualXwikiName = null; int i = cannonicalUsername.indexOf("."); int j = cannonicalUsername.indexOf(":"); if (j > 0) { virtualXwikiName = cannonicalUsername.substring(0, j); } if (i != -1) { susername = cannonicalUsername.substring(i + 1); } else if (j > 0) { susername = cannonicalUsername.substring(j + 1); } String db = context.getWikiId(); try { if (virtualXwikiName != null) { context.setWikiId(virtualXwikiName); } try { String user = findUser(susername, context); if (user != null && checkPassword(user, password, context)) { return new SimplePrincipal(virtualXwikiName != null ? context.getWikiId() + ":" + user : user); } } catch (Exception e) { } if (!context.isMainWiki()) { context.setWikiId(context.getMainXWiki()); try { String user = findUser(susername, context); if (user != null && checkPassword(user, password, context)) { return new SimplePrincipal(context.getWikiId() + ":" + user); } } catch (Exception e) { context.put("message", "loginfailed"); return null; } } context.put("message", "invalidcredentials"); return null; } finally { context.setWikiId(db); } } else { LOGGER.error("XWikiContext is null"); return null; } }
@Override public Integer getScore(final Operation operation) { if (null == operation) { return 0; } if (operation instanceof Operations && !(operation instanceof NamedOperation)) { int score = 0; for (final Operation op : ((Operations<?>) operation).getOperations()) { score += getScore(op); } return score; } else { final Class<? extends Operation> opClass = operation.getClass(); if (null == skipResolvingOperation || skipResolvingOperation != operation) { ScoreResolver resolver = scoreResolvers.get(opClass); if (null != resolver) { final DefaultScoreResolver delegateResolver = new DefaultScoreResolver(opScores, scoreResolvers, operation); Integer opScore = resolver.getScore(operation, delegateResolver); if (null != opScore) { return opScore; } } } final List<Class<? extends Operation>> keys = new ArrayList<>(opScores.keySet()); for (int i = keys.size() - 1; i >= 0; i--) { final Class<? extends Operation> key = keys.get(i); if (key.isAssignableFrom(opClass)) { return opScores.get(key); } } } return DEFAULT_OPERATION_SCORE; }
@SuppressWarnings("unchecked") public static <T> T getValue(Object object, Member fieldOrMethod) { if (fieldOrMethod instanceof Field) { return (T)getFieldValue(object, fieldOrMethod); } else if (fieldOrMethod instanceof Method) { Function<Object, Object> accessor = ACCESSOR_CACHE .computeIfAbsent(fieldOrMethod, key -> new MemberAccessors((Method)key).createFunction()); return (T)accessor.apply(object); } else { throw new IllegalArgumentException("Only field or method is supported, found " + fieldOrMethod.getClass().getCanonicalName() + " as type of " + getNameOf(fieldOrMethod)); } }
@Override public FallbackResult score(long user, long item) { Result r = primaryScorer.score(user, item); if (r != null) { return new FallbackResult(r, true); } r = baselineScorer.score(user, item); if (r != null) { return new FallbackResult(r, false); } else { return null; } }
public final Pattern atMost(int max) { return new UpperBoundedPattern(Checks.checkMax(max), this); }
public FEELFnResult<BigDecimal> invoke(@ParameterName( "n" ) BigDecimal n, @ParameterName( "scale" ) BigDecimal scale) { if ( n == null ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "n", "cannot be null")); } if ( scale == null ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "scale", "cannot be null")); } return FEELFnResult.ofResult( n.setScale( scale.intValue(), BigDecimal.ROUND_HALF_EVEN ) ); }
public static void scrub(Map<String, String> attributes, ObjectNode json) throws MessageShouldBeDroppedException, AffectedByBugException { final String namespace = attributes.get(Attribute.DOCUMENT_NAMESPACE); final String docType = attributes.get(Attribute.DOCUMENT_TYPE); final String appName = attributes.get(Attribute.APP_NAME); final String appVersion = attributes.get(Attribute.APP_VERSION); final String appUpdateChannel = attributes.get(Attribute.APP_UPDATE_CHANNEL); final String appBuildId = attributes.get(Attribute.APP_BUILD_ID); if (ParseUri.TELEMETRY.equals(namespace) && "crash".equals(docType) && "nightly".equals(appUpdateChannel) && "20190719094503".equals(appBuildId) && Optional.of(json) .map(j -> j.path("payload").path("metadata").path("MozCrashReason").textValue()) .filter(s -> s.contains("do not use eval with system privileges")) .isPresent()) { throw new MessageShouldBeDroppedException("1567596"); } if (ParseUri.TELEMETRY.equals(namespace) && "crash".equals(docType) && (("nightly".equals(appUpdateChannel) && (appVersion.startsWith("68") || appVersion.startsWith("69"))) || ("beta".equals(appUpdateChannel) && appVersion.startsWith("68"))) && Optional.of(json) .map(j -> j.path("payload").path("metadata").path("RemoteType").textValue()) .filter(s -> s.startsWith("webIsolated=")) .isPresent()) { throw new MessageShouldBeDroppedException("1562011"); } if (ParseUri.TELEMETRY.equals(namespace) && "bhr".equals(docType) && (appVersion.startsWith("68") || appVersion.startsWith("69")) && Optional.of(json) .map(j -> j.path("payload").path("hangs").elements()) .map(Streams::stream).orElseGet(Stream::empty).map(j -> j.path("remoteType")) .filter(JsonNode::isTextual) .anyMatch(j -> j.textValue().startsWith("webIsolated="))) { throw new MessageShouldBeDroppedException("1562011"); } if (IGNORED_NAMESPACES.containsKey(namespace)) { throw new UnwantedDataException(IGNORED_NAMESPACES.get(namespace)); } if (ParseUri.TELEMETRY.equals(namespace) && IGNORED_TELEMETRY_DOCTYPES.containsKey(docType)) { throw new UnwantedDataException(IGNORED_TELEMETRY_DOCTYPES.get(docType)); } if ("FirefoxOS".equals(appName)) { throw new UnwantedDataException("1618684"); } if (ParseUri.TELEMETRY.equals(namespace) && FIREFOX_ONLY_DOCTYPES.contains(docType) && !"Firefox".equals(appName)) { throw new UnwantedDataException("1592010"); } if (bug1489560Affected(attributes, json)) { throw new AffectedByBugException("1489560"); } if ("default-browser-agent".equals(namespace) && "1".equals(docType)) { throw new AffectedByBugException("1626020"); } if (bug1602844Affected(attributes)) { json.path("events").elements().forEachRemaining(event -> { JsonNode eventMapValues = event.path(5); if (eventMapValues.has("fxauid")) { ((ObjectNode) eventMapValues).replace("fxauid", NullNode.getInstance()); } markBugCounter("1602844"); }); } if (bug1162183Affected(attributes)) { JsonNode payload = json.path("payload"); if (payload.has("slowSQL")) { ((ObjectNode) payload).remove("slowSQL"); markBugCounter("1162183"); } } if (bug1642386Affected(attributes)) { json.path("payload").path("syncs").elements().forEachRemaining(syncItem -> { syncItem.path("engines").elements().forEachRemaining(engine -> { ((ObjectNode) engine).remove("outgoing"); markBugCounter("1642386"); }); }); } }
@Override public List<IFileSpec> getChangelistFiles(final int id) throws ConnectionException, RequestException, AccessException { try { List<Map<String, Object>> resultMaps = execMapCmdList(DESCRIBE, new String[]{"-s", String.valueOf(id)}, null); return ResultMapParser.parseCommandResultMapAsFileSpecs(id, server, resultMaps); } catch (P4JavaException p4je) { throw new RequestException(p4je); } }
public boolean isSidebarCalendarViewLinkVisible() { return getLocalBoolean("sidebar.calendar.visible", true); }
public static byte[] encodeExtHash(String algorithm, byte[] data) throws Exception { Security.addProvider(new BouncyCastleProvider()); MessageDigest md = MessageDigest.getInstance(algorithm); return md.digest(data); }
public static long[] parse(String paramText) { if ( paramText == null || paramText.trim().length() == 0 ) { return new long[0]; } String[] params = paramText.split( "," ); long[] result = new long[params.length]; for ( int i = 0; i < params.length; i++ ) { result[i] = parseSingle( params[i] ); } return result; }
@Override public Processor<K, Change<V1>> get() { return new KTableKTableOuterJoinProcessor(valueGetterSupplier2.get()); }
public SW360Connection createConnection(Getter<String> getConfigValue, HttpClient httpClient, ObjectMapper mapper) { String restUrl = getConfigValue.apply(REST_SERVER_URL_KEY); String authUrl = getConfigValue.apply(AUTH_SERVER_URL_KEY); String user = getConfigValue.apply(USERNAME_KEY); String password = getConfigValue.apply(PASSWORD_KEY); String clientId = getConfigValue.apply(CLIENT_USER_KEY); String clientPassword = getConfigValue.apply(CLIENT_PASSWORD_KEY); SW360ClientConfig clientConfig = SW360ClientConfig.createConfig(restUrl, authUrl, user, password, clientId, clientPassword, httpClient, mapper); return connectionFactory.newConnection(clientConfig); }
public List<UldECKey> getPublicKeys() { return publicKeys; }
@Override public void onPasswordChange(@NotNull User user, @Nullable String newPassword, @NotNull Root root, @NotNull NamePathMapper namePathMapper) throws RepositoryException { validatePassword(newPassword, true); }
@Override public ServiceResult<Token> getEmailToken(final String hash) { return find(repository.findByHashAndTypeAndClassName(hash, VERIFY_EMAIL_ADDRESS, User.class.getName()), new Error(USERS_EMAIL_VERIFICATION_TOKEN_NOT_FOUND)).andOnSuccess( token -> isTokenValid(token) ? serviceSuccess(token) : serviceFailure(USERS_EMAIL_VERIFICATION_TOKEN_EXPIRED)); }
static String buildCreationTimeString() { return DateTimeFormat.forPattern("yyyyMMddHHmmss").print(new DateTime(DateTimeZone.UTC)); }
public static List<String> mergeValues(Class<?> type, String cfg, List<String> def) { List<String> defaults = new ArrayList<String>(); if (def != null) { for (String name : def) { if (ExtensionLoader.getExtensionLoader(type).hasExtension(name)) { defaults.add(name); } } } List<String> names = new ArrayList<String>(); String[] configs = (cfg == null || cfg.trim().length() == 0) ? new String[0] : COMMA_SPLIT_PATTERN.split(cfg); for (String config : configs) { if (config != null && config.trim().length() > 0) { names.add(config); } } if (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) { int i = names.indexOf(DEFAULT_KEY); if (i > 0) { names.addAll(i, defaults); } else { names.addAll(0, defaults); } names.remove(DEFAULT_KEY); } else { names.remove(DEFAULT_KEY); } for (String name : new ArrayList<String>(names)) { if (name.startsWith(REMOVE_VALUE_PREFIX)) { names.remove(name); names.remove(name.substring(1)); } } return names; }
public static Schema convert(TableSchema schema) { Preconditions.checkArgument(schema.toRowDataType() instanceof FieldsDataType, "Should be FieldsDataType"); FieldsDataType root = (FieldsDataType) schema.toRowDataType(); Type converted = FlinkTypeVisitor.visit(root, new FlinkTypeToType(root)); return new Schema(converted.asStructType().fields()); }
public Long getTotalAsseCountByTargetType(String targetType) throws ServiceException { try { return repository.getTotalAssetCountByTargetType(targetType); } catch (DataException e) { logger.error("Error @ getTotalAsseCountByTargetType", e); throw new ServiceException(e); } }
public void isDeployable() throws ValidationException { if (projectInformation.isDeployment()) { validateIsDeployable(); } }
@ScalarOperator(SUBTRACT) @SqlType(StandardTypes.DOUBLE) public static double subtract(@SqlType(StandardTypes.DOUBLE) double left, @SqlType(StandardTypes.DOUBLE) double right) { return left - right; }
@Override public Path getPartitionSubPath(Path partitionLocation) { String sourceDataPathString = sourceDataPath.toString(); String partitionLocationString = partitionLocation.toString(); if (!partitionLocationString.startsWith(sourceDataPathString)) { throw new CircusTrainException("Partition path '" + partitionLocationString + "' does not seem to belong to data source path '" + sourceDataPathString + "'"); } String subPath = partitionLocationString.replace(sourceDataPathString, ""); if (subPath.charAt(0) == '/') { subPath = subPath.substring(1); } return new Path(subPath); }
public static ServiceURI create(String uriStr) { checkNotNull(uriStr, "service uri string is null"); URI uri = URI.create(uriStr); return create(uri); }
private boolean checkAnimationIdle(Duration waitDuration, Player local) { if (lastAnimation == IDLE) { return false; } final int animation = local.getAnimation(); if (animation == IDLE) { if (lastAnimating != null && Instant.now().compareTo(lastAnimating.plus(waitDuration)) >= 0) { lastAnimation = IDLE; lastAnimating = null; lastInteract = null; lastInteracting = null; return true; } } else { lastAnimating = Instant.now(); } return false; }
public void requireLogin() { if (!isLoggedIn()) { throw new NotAuthorizedException(Response.status(Status.UNAUTHORIZED).build()); } }
public T fromEntry(Entry entry, Class<? extends T> entityClass) { if (entry.getDn() == null) throw new LdapMappingException("LDAP Entry DN cannot be null"); try { final T bean = entityClass.newInstance(); Class<?> currentClass = entityClass; while (currentClass != null) { mapToProperties(entry, currentClass, bean); currentClass = currentClass.getSuperclass(); if (currentClass == Object.class) break; } return bean; } catch (InstantiationException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (IllegalAccessException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (InvocationTargetException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (LdapInvalidAttributeValueException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (NoSuchMethodException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } }
public float getGain(int bandIndex) { if (bandGains == null) { extractGainsAndBiases(); } return bandGains[bandIndex]; }
@Override public synchronized void append(Event e) throws IOException, InterruptedException { this.stomach.reset(); this.stomach.update(e.getBody()); byte digest[] = this.stomach.digest(); if (this.encodeBase64) { digest = Base64.encodeBase64(digest); } e.set(this.attr, digest); super.append(e); }
@Nullable public ConfigContainer getBlocking() { return getBlocking(DISK_READ_TIMEOUT_IN_SECONDS); }
public void querySongsByChannelId(ReportType songType, String currentSongId, int playTime, int channelId, BitRate bitRate, Callback callback) { if(channelId== ChannelConstantIds.PRIVATE_CHANNEL ||channelId== ChannelConstantIds.FAV){ this.isAuthRequire=true; } apiGateway.makeRequest(new SongsRequest(channelId, bitRate, songType,currentSongId, playTime), new SongApiResponseCallback(callback, this, douban)); }
public static UIf create( UExpression condition, UStatement thenStatement, UStatement elseStatement) { return new AutoValue_UIf(condition, thenStatement, elseStatement); }
public void write(ComplexWriter writer, BsonReader reader) throws IOException { this.reader = reader; reader.readStartDocument(); BsonType readBsonType = reader.getCurrentBsonType(); switch (readBsonType) { case DOCUMENT: writeToListOrMap(reader, new MapOrListWriterImpl(writer.rootAsMap()), false, null); break; default: throw new DrillRuntimeException("Root object must be DOCUMENT type. Found: " + readBsonType); } }
@Override public int compareTo(final RoleMapping other) { if (other == null) { return -1; } return new CompareToBuilder() .append(role, other.getRole()) .append(privileges, other.getPrivileges(), new CollectionComparator<>()) .toComparison(); }
public static boolean isUndefinedRange(Program program, Address startAddress, Address endAddress) { MemoryBlock block = program.getMemory().getBlock(startAddress); if (block == null || !block.contains(endAddress)) { return false; } if (startAddress.compareTo(endAddress) > 0) { return false; } Listing listing = program.getListing(); Data data = listing.getDataContaining(startAddress); if (data == null || !Undefined.isUndefined(data.getDataType())) { return false; } Address maxAddress = data.getMaxAddress(); while (maxAddress.compareTo(endAddress) < 0) { CodeUnit codeUnit = listing.getDefinedCodeUnitAfter(maxAddress); if (codeUnit == null) { return true; } Address minAddress = codeUnit.getMinAddress(); if (minAddress.compareTo(endAddress) > 0) { return true; } if (!(codeUnit instanceof Data) || !Undefined.isUndefined(((Data) codeUnit).getDataType())) { return false; } maxAddress = codeUnit.getMaxAddress(); } return true; }
public static WebSocketService create(URI uri) throws WebSocketServiceException { WebSocketServiceImpl webSocketService = new WebSocketServiceImpl(); webSocketService.connect(uri); return webSocketService; }
public static String replaceFirst( String string, final String regex, final String replacement, final int occurrences ) { StringBuffer sb = new StringBuffer(); Matcher matcher = Pattern.compile( regex ).matcher( string ); int c = 0; while ( matcher.find() && c < occurrences ) { matcher.appendReplacement( sb, replacement ); c++; } return appendTail( matcher, sb ); }
public static String format( String filterTemplate, String... values ) { if ( values == null ) { values = Strings.EMPTY_STRING_ARRAY; } MessageFormat mf = new MessageFormat( filterTemplate, Locale.ROOT ); Format[] formats = mf.getFormatsByArgumentIndex(); if ( formats.length != values.length ) { throw new IllegalArgumentException( I18n.err( I18n.ERR_13300_BAD_PLACE_HOLDERS_NUMBER, filterTemplate, formats.length, values.length ) ); } for ( int i = 0; i < values.length; i++ ) { values[i] = encodeFilterValue( values[i] ); } return mf.format( values ); }
@Override public ExpressionResult evaluate(EvaluationContext evaluationContext, List<FunctionArgument> arguments) { Bag elementBag = new Bag(); if (arguments != null && arguments.size() > 0) { for (FunctionArgument argument : arguments) { ConvertedArgument<I> convertedArgument = new ConvertedArgument<I>(argument, this.getDataTypeArgs(), false); if ( ! convertedArgument.isOk()) { return ExpressionResult.newError(getFunctionStatus(convertedArgument.getStatus())); } elementBag.add(argument.getValue()); } } return ExpressionResult.newBag(elementBag); }
@Override public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context) throws WorkflowOperationException { MediaPackage mediaPackage = workflowInstance.getMediaPackage(); WorkflowOperationInstance operation = workflowInstance.getCurrentOperation(); String skipOption = StringUtils.trimToNull(operation.getConfiguration(SKIP_IF_FLAVOR_EXISTS)); if (skipOption != null) { MediaPackageElement[] mpes = mediaPackage.getElementsByFlavor(MediaPackageElementFlavor.parseFlavor(skipOption)); if (mpes != null && mpes.length > 0) { logger.info( "Start transcription operation will be skipped because flavor {} already exists in the media package", skipOption); return createResult(Action.SKIP); } } logger.debug("Start transcription for mediapackage {} started", mediaPackage); String sourceTagOption = StringUtils.trimToNull(operation.getConfiguration(SOURCE_TAG)); String sourceFlavorOption = StringUtils.trimToNull(operation.getConfiguration(SOURCE_FLAVOR)); AbstractMediaPackageElementSelector<Track> elementSelector = new TrackSelector(); if (StringUtils.isBlank(sourceTagOption) && StringUtils.isBlank(sourceFlavorOption)) throw new WorkflowOperationException("No source tag or flavor have been specified!"); if (StringUtils.isNotBlank(sourceFlavorOption)) { String flavor = StringUtils.trim(sourceFlavorOption); try { elementSelector.addFlavor(MediaPackageElementFlavor.parseFlavor(flavor)); } catch (IllegalArgumentException e) { throw new WorkflowOperationException("Source flavor '" + flavor + "' is malformed"); } } if (sourceTagOption != null) elementSelector.addTag(sourceTagOption); Collection<Track> elements = elementSelector.select(mediaPackage, false); Job job = null; for (Track track : elements) { if (track.hasVideo()) { logger.info("Skipping track {} since it contains a video stream", track); continue; } try { job = service.startTranscription(mediaPackage.getIdentifier().toString(), track); break; } catch (TranscriptionServiceException e) { throw new WorkflowOperationException(e); } } if (job == null) { logger.info("No matching tracks found"); return createResult(mediaPackage, Action.CONTINUE); } if (!waitForStatus(job).isSuccess()) { throw new WorkflowOperationException("Transcription job did not complete successfully"); } logger.debug("External transcription job for mediapackage {} was created", mediaPackage); return createResult(Action.CONTINUE); }
public int run(String... argv) { if (argv.length == 0) { printUsage(); return -1; } String cmd = argv[0]; Command command = mCommands.get(cmd); if (command == null) { String[] replacementCmd = getReplacementCmd(cmd); if (replacementCmd == null) { System.err.println(String.format("%s is an unknown command.", cmd)); printUsage(); return -1; } else { if (mUnstableAlias != null && mUnstableAlias.contains(cmd)) { String deprecatedMsg = String.format("WARNING: %s is not a stable CLI command. It may be removed in the " + "future. Use with caution in scripts. You may use '%s' instead.", cmd, StringUtils.join(replacementCmd, " ")); System.out.println(deprecatedMsg); } String[] replacementArgv = (String[]) ArrayUtils.addAll(replacementCmd, ArrayUtils.subarray(argv, 1, argv.length)); return run(replacementArgv); } } CommandLine cmdline; try { String[] currArgs = Arrays.copyOf(argv, argv.length); while (command.hasSubCommand()) { if (currArgs.length < 2) { throw new InvalidArgumentException("No sub-command is specified"); } if (!command.getSubCommands().containsKey(currArgs[1])) { throw new InvalidArgumentException("Unknown sub-command: " + currArgs[1]); } command = command.getSubCommands().get(currArgs[1]); if (currArgs.length >= 2) { currArgs = Arrays.copyOfRange(currArgs, 1, currArgs.length); } } currArgs = Arrays.copyOfRange(currArgs, 1, currArgs.length); cmdline = command.parseAndValidateArgs(currArgs); } catch (InvalidArgumentException e) { System.out.println(e.getMessage()); System.out.println("Usage: " + command.getUsage()); System.out.println(command.getDescription()); LOG.error("Invalid arguments for command {}:", command.getCommandName(), e); return -1; } try { return command.run(cmdline); } catch (Exception e) { System.out.println(e.getMessage()); LOG.error("Error running " + StringUtils.join(argv, " "), e); return -1; } }
public static <T> Collection<Set<T>> stronglyConnectedComponent(Map<T,? extends Collection<T>> graph) { Map<T, Set<T>> reversed = reverse(graph); Map<T, Set<T>> sccsByRoot = new HashMap<T, Set<T>>(); Set<T> assigned = new HashSet<T>(); for (T root : kosarajuSort(graph)) { Deque<T> todo = new LinkedList<T>(); todo.add(root); while (!todo.isEmpty()) { T current = todo.removeLast(); if (assigned.add(current)) { Set<T> component = getOrAdd(sccsByRoot, root); component.add(current); todo.addAll(reversed.get(current)); } } } return sccsByRoot.values(); }
@Override public void filter(ClientRequestContext requestContext) { HttpRequestContext context = handler.handleStart(null, requestContext, requestContext); requestContext.setProperty(OPENCENSUS_CONTEXT, context); }
@Override public void accept(Event<? extends Payload> event) { String key = (String) event.getKey(); Payload payload = event.getData(); String flowId = getFlowId(event); String flowChainId = getFlowChainId(event); String flowTriggerUserCrn = getFlowTriggerUserCrn(event); Span activeSpan = tracer.activeSpan(); SpanContext spanContext = event.getHeaders().get(FlowConstants.SPAN_CONTEXT); String operationName = event.getKey().toString(); if (TracingUtil.isActiveSpanReusable(activeSpan, spanContext, operationName)) { LOGGER.debug("Reusing existing span. {}", activeSpan.context()); doAccept(event, key, payload, flowId, flowChainId, flowTriggerUserCrn, spanContext); } else { Span span = TracingUtil.getSpan(tracer, operationName, spanContext, flowId, flowChainId, flowTriggerUserCrn); spanContext = TracingUtil.useOrCreateSpanContext(spanContext, span); try (Scope ignored = tracer.activateSpan(span)) { doAccept(event, key, payload, flowId, flowChainId, flowTriggerUserCrn, spanContext); } finally { span.finish(); } } }
public static Builder builder() { return new Builder(); }
public static int lcm(int a, int b) { if (a == 0 || b == 0) { return 0; } final int lcm = Math.abs(Math.multiplyExact(a / gcd(a, b), b)); if (lcm == Integer.MIN_VALUE) { throw new NumbersArithmeticException("overflow: lcm({0}, {1}) is 2^31", a, b); } return lcm; }
@Override public Principal getPrincipal(HttpRequest httpRequest) { X509Certificate[] certs = (X509Certificate[]) httpRequest.getAttribute(CERTIFICATES_ATTR); if (certs == null || certs.length < 1) { if (log.isDebugEnabled()) { log.debug("no certificate was present to authenticate the client"); } return null; } X509Certificate identityCert = certs[0]; return createPrincipal(parseUuid(identityCert)); }
boolean match(SamplingRequest req) { Map<String, String> requestAttributes = req.getAttributes(); for (Map.Entry<String, String> a : attributes.entrySet()) { if (!requestAttributes.containsKey(a.getKey())) { return false; } if (!SearchPattern.wildcardMatch(a.getValue(), requestAttributes.get(a.getKey()))) { return false; } } return SearchPattern.wildcardMatch(url, req.getUrl().orElse("")) && SearchPattern.wildcardMatch(service, req.getService().orElse("")) && SearchPattern.wildcardMatch(method, req.getMethod().orElse("")) && SearchPattern.wildcardMatch(host, req.getHost().orElse("")) && SearchPattern.wildcardMatch(serviceType, req.getServiceType().orElse("")); }
@Override public Counter counter(String name) { return counter(name, NO_TAGS); }
public static Boolean isPrimitiveOrWrapper(Class<?> clazz) { try { Class<?> utils = Thread.currentThread().getContextClassLoader().loadClass("org.apache.commons.lang3.ClassUtils"); Method method = utils.getMethod("isPrimitiveOrWrapper", Class.class); return (Boolean) method.invoke(null, clazz); } catch (Exception e) { throw new ActiveJpaException("Failed while getting the property descriptor", e); } }
public static ExternalSorter create(Options options) { return options.getSorterType() == Options.SorterType.HADOOP ? HadoopExternalSorter.create(options) : NativeExternalSorter.create(options); }
public void createFromAssets(final Repository repository, final Iterable<? extends Asset> assets) { checkNotNull(repository); checkNotNull(assets); final DatastoreBrowseNodeGenerator generator = pathGenerators.getOrDefault(formatOf(repository), defaultGenerator); assets.forEach(asset -> createBrowseNodes(repository, generator, asset)); }
@Override public InMemoryId deserialize(String serializedMailboxId) throws MailboxIdDeserialisationException { try { return InMemoryId.of(Long.parseLong(serializedMailboxId)); } catch (Exception e) { throw new MailboxIdDeserialisationException("Error deserializing " + serializedMailboxId, e); } }
@Override public void delete(Position start, Position end) { if (start.isAfter(end)) { throw new IllegalArgumentException("start position " + start + " is after end position " + end); } String prefix = getLinePrefix(start); String suffix = getLineSuffix(end); String stichedLine = prefix + suffix; lines.set(start.lineIndex(), stichedLine); deleteLines(start.lineIndex() + 1, end.lineIndex() + 1); incrementVersion(); }
@Override public double apply(double availableDiskQuotaPercentage) { double workFactor = entryIndex == -1 ? 1.0 : this.entries.get(entryIndex).getWorkFactor(); int entryIndex = this.entryIndex; while (entryIndex >= 0 && entries.get(entryIndex).getHighWaterMarkPercent() <= availableDiskQuotaPercentage) { --entryIndex; } while (entryIndex < entries.size() - 1 && entries.get(entryIndex + 1).getLowWaterMarkPercent() > availableDiskQuotaPercentage) { ++entryIndex; } if (entryIndex != this.entryIndex) { workFactor = entryIndex == -1 ? 1.0 : entries.get(entryIndex).getWorkFactor(); this.entryIndex = entryIndex; log.info("Work factor has been updated: {}.", workFactor); } return workFactor; }
@Override public FilterResult runFilter(VariantEvaluation variantEvaluation) { VariantContextFilterState vcfFilterState = determineVariantContextState(variantEvaluation.getVariantContext()); if (vcfFilterState == VariantContextFilterState.PASSED || vcfFilterState == VariantContextFilterState.UNFILTERED) { return PASS; } return FAIL; }
public static Iterable<VcfSample> samples(final Readable readable) throws IOException { return VcfSampleParser.samples(readable); }
public Set<String> listKeys(String sdbId, String partialPath) { if (!partialPath.endsWith("/")) { partialPath = partialPath + "/"; } Set<String> keys = new HashSet<>(); String[] pArray = secureDataDao.getPathsByPartialPathAndType(sdbId, partialPath, SecureDataType.OBJECT); if (pArray == null || pArray.length < 1) { return keys; } for (int i = 0; i < pArray.length; i++) { String fullPath = pArray[i]; keys.add(StringUtils.removeStart(fullPath, partialPath).replaceAll("\\/.*$", "/")); } return keys; }
public void update(final Customer customer) throws SQLException, DuplicateException { if (LOG.isTraceEnabled()) { LOG.trace("CustomerDAO.update(customer=" + customer + ")"); } final Customer currentCustomer = get(customer.getId()); if (isDuplicateName(customer) && !currentCustomer.equals(customer)) { throw new DuplicateException("Customers with duplicate names are not allowed. Customer: " + customer); } final Connection connection = getConnection(); final PreparedStatement statement = connection.prepareStatement("UPDATE customer SET name = '" + customer.getName() + "' WHERE id = '" + customer.getId() + "';"); statement.executeUpdate(); connection.close(); }
@Override public LoginToken verifyToken(final String tokenHeader) { LOGGER.debug("Authentication token received as: {}", tokenHeader); UserCredential credential = parseUsernamePassword(fromNullable(tokenHeader)); if (isBasicAuthenicationValid(credential)) { return withAccessToken(credential.toBase64Encode()).withTokenType(BASIC).build(); } else { throw new AuthenticationException("Authentication Token is not valid"); } }
boolean scan( LogFiles logFiles, InconsistenciesHandler handler, CheckType<?,?>... checkTypes ) throws IOException { boolean success = true; boolean checkTxIds = true; for ( CheckType<?,?> checkType : checkTypes ) { success &= scan( logFiles, handler, checkType, checkTxIds ); checkTxIds = false; } return success; }
@Override public Collection<BitbucketTeam> getTeams() throws BitbucketException, SourceConnectorException { logger.debug("Getting the Bitbucket teams for current user"); Collection<BitbucketTeam> rVal = new HashSet<>(); try { String teamsUrl = endpoint("/user") .toString(); HttpRequest request = Unirest.get(teamsUrl); addSecurityTo(request); HttpResponse<com.mashape.unirest.http.JsonNode> response = request.asJson(); JSONObject responseObj = response.getBody().getObject(); if (response.getStatus() != 200) { throw new UnirestException("Unexpected response from Bitbucket: " + response.getStatus() + "::" + response.getStatusText()); } BitbucketTeam team = new BitbucketTeam(); team.setDisplayName(responseObj.getString("display_name")); team.setUsername(responseObj.getString("username")); team.setUserTeam(true); team.setUuid(responseObj.getString("uuid")); rVal.add(team); } catch (UnirestException e) { throw new BitbucketException("Error getting Bitbucket teams.", e); } try { String teamsUrl = endpoint("/teams") .queryParam("role", "member") .queryParam("pagelen", "25") .toString(); boolean done = false; while (!done) { HttpRequest request = Unirest.get(teamsUrl); addSecurityTo(request); HttpResponse<com.mashape.unirest.http.JsonNode> response = request.asJson(); JSONObject responseObj = response.getBody().getObject(); if (response.getStatus() != 200) { throw new UnirestException("Unexpected response from Bitbucket: " + response.getStatus() + "::" + response.getStatusText()); } responseObj.getJSONArray("values").forEach(obj -> { BitbucketTeam bbt = new BitbucketTeam(); JSONObject team = (JSONObject) obj; bbt.setDisplayName(team.getString("display_name")); bbt.setUsername(team.getString("username")); bbt.setUuid(team.getString("uuid")); rVal.add(bbt); }); done = true; if (responseObj.has("next")) { String next = responseObj.getString("next"); if (!StringUtils.isEmpty(next) && !next.equals(teamsUrl)) { done = false; teamsUrl = next; } } } } catch (UnirestException e) { throw new BitbucketException("Error getting Bitbucket teams.", e); } return rVal; }
public AuthorizationContext convert(AvroAuthzContext authzContext) { if (authzContext == null) return null; Set<String> roles = new HashSet<String>(); for (String role : authzContext.getRoles()) { roles.add(role); } return new AuthorizationContext(authzContext.getName(), authzContext.getTenant(), roles); }
@Override public boolean match(EventPropertyPrimitive offer, EventPropertyPrimitive requirement, List<MatchingResultMessage> errorLog) { boolean matchesUnit = unitMatch(offer.getMeasurementUnit(), requirement.getMeasurementUnit(), errorLog); boolean matchesDatatype = datatypeMatch(offer.getRuntimeType(), requirement.getRuntimeType(), errorLog); boolean matchesDomainProperty = domainPropertyMatch(offer.getDomainProperties(), requirement.getDomainProperties (), errorLog); return MatchingUtils.nullCheck(offer, requirement) || (matchesUnit && matchesDatatype && matchesDomainProperty); }
private void setControlBits(int[] perm, int[][] controlBits, int rowIdx, int colIdx) { int n = perm.length; if (n == 2) { controlBits[rowIdx][colIdx] = perm[0]; return; } int[] rowI = new int[n / 2]; int[] rowO = new int[n / 2]; for (int j = 0; j < rowO.length; j++) { rowI[j] = -1; rowO[j] = -1; } int[] topPerm = new int[n / 2]; int[] bottomPerm = new int[n / 2]; int[] permInv = invert(perm); while (hasNextUnsetSwapper(rowO)) { int rowOSwIdx = nextUnsetSwapperIdx(rowO); rowO[rowOSwIdx] = 0; int firstOElIdx = topElIndexOf(rowOSwIdx); int rowOElIdx = firstOElIdx; int rowIElIdx = routeFromOutputToInput(rowOElIdx, permInv, topPerm, rowI); rowOElIdx = routeFromInputToOutput(rowIElIdx, perm, bottomPerm, rowO); while (!(rowOElIdx == firstOElIdx)) { rowIElIdx = routeFromOutputToInput(rowOElIdx, permInv, topPerm, rowI); rowOElIdx = routeFromInputToOutput(rowIElIdx, perm, bottomPerm, rowO); } } int numCols = controlBits[0].length; for (int j = 0; j < rowI.length; j++) { controlBits[rowIdx + j][colIdx] = rowI[j]; controlBits[rowIdx + j][numCols - 1 - colIdx] = rowO[j]; } setControlBits(topPerm, controlBits, rowIdx, colIdx + 1); setControlBits(bottomPerm, controlBits, rowIdx + rowI.length / 2, colIdx + 1); }
public boolean faultRaised() { return null != fault || faultExpected; }
@Override public FeatureState getFeatureState(final Feature feature) { final Optional<FeatureState> featureState = findOne(feature.name()); return featureState.orElse(null); }
public static Address fromBase58(@Nullable NetworkParameters params, String base58) throws AddressFormatException { return new Address(params, base58); }
@Override public byte getJmsMsgType() { return JMS_OBJECT_MESSAGE; }
@Endpoint(name = "append") public static Operand<TInt32> append(Scope scope, Shape<TInt32> shape, int lastDimension) { Operand<TInt32> dim = Constant.arrayOf(scope, lastDimension); return Concat.create(scope, Arrays.asList(shape, dim), Constant.scalarOf(scope, 0)); }
protected List<FileStatus> listStatus(JobContext job ) throws IOException { Path[] dirs = getInputPaths(job); if (dirs.length == 0) { throw new IOException("No input paths specified in job"); } TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs, job.getConfiguration()); boolean recursive = getInputDirRecursive(job); List<PathFilter> filters = new ArrayList<PathFilter>(); filters.add(hiddenFileFilter); PathFilter jobFilter = getInputPathFilter(job); if (jobFilter != null) { filters.add(jobFilter); } PathFilter inputFilter = new MultiPathFilter(filters); List<FileStatus> result = null; int numThreads = job.getConfiguration().getInt(LIST_STATUS_NUM_THREADS, DEFAULT_LIST_STATUS_NUM_THREADS); StopWatch sw = new StopWatch().start(); if (numThreads == 1) { result = singleThreadedListStatus(job, dirs, inputFilter, recursive); } else { Iterable<FileStatus> locatedFiles = null; try { LocatedFileStatusFetcher locatedFileStatusFetcher = new LocatedFileStatusFetcher( job.getConfiguration(), dirs, recursive, inputFilter, true); locatedFiles = locatedFileStatusFetcher.getFileStatuses(); } catch (InterruptedException e) { throw new IOException("Interrupted while getting file statuses"); } result = Lists.newArrayList(locatedFiles); } sw.stop(); if (LOG.isDebugEnabled()) { LOG.debug("Time taken to get FileStatuses: " + sw.now(TimeUnit.MILLISECONDS)); } LOG.info("Total input files to process : " + result.size()); return result; }
synchronized void append( long index, long term ) { if ( index != max + 1 ) { throw new IllegalStateException( format( "Must append in order. %s but expected index is %d", appendMessage( index, term ), max + 1 ) ); } else if ( size > 0 && term < terms[size - 1] ) { throw new IllegalStateException( format( "Non-monotonic term. %s but highest term is %d", appendMessage( index, term ), terms[size - 1] ) ); } max = index; if ( size == 0 || term != terms[size - 1] ) { setSize( size + 1 ); indexes[size - 1] = index; terms[size - 1] = term; } }
@Override public void registerService(String name, Object service) { checkRunning(); if (name == null) { throw new IllegalArgumentException("name cannot be null"); } if (service == null) { throw new IllegalArgumentException("service cannot be null"); } try { applicationContext.getBeanFactory().autowireBean(service); } catch (BeansException e) { throw new IllegalArgumentException( "Invalid service (" + service + ") with name (" + name + ") registration: " + e.getMessage(), e); } registerBean(name, service); }
public InputStream getResourceFromUrl(String url, @Nullable org.apache.brooklyn.util.http.auth.Credentials credentials) { if (credentials != null) { return getResourceFromUrl(url, credentials.getUser(), credentials.getPassword()); } return getResourceFromUrl(url, null, null); }
protected static String formatMessage(String message, byte[] hostData, int start, int curPos, int bytesLen) { StringBuilder sb = new StringBuilder(); sb.append(message); if (hostData != null && hostData.length > 0 && curPos < hostData.length && curPos >= start && bytesLen > 0 && start + bytesLen <= hostData.length) { sb.append(". Error at offset "); sb.append(curPos); sb.append(" : [0x"); int spyStart = Math.max(start - SPYBUF_MAX_LEN, 0); appendData(sb, hostData, spyStart, start - spyStart); sb.append(start > spyStart ? "->" : ""); if (curPos > start) { appendData(sb, hostData, start, curPos - start); sb.append("^"); appendData(sb, hostData, curPos, bytesLen + start - curPos); } else { appendData(sb, hostData, start, bytesLen); } int spyStop = Math.min(start + bytesLen + SPYBUF_MAX_LEN, hostData.length); sb.append(spyStop > start + bytesLen ? "<-" : ""); appendData(sb, hostData, start + bytesLen, spyStop - start - bytesLen); sb.append("]"); } else { sb.append(". Position is "); sb.append(curPos); } return sb.toString(); }
public static String trim(final String str) { return rtrim(ltrim(str)); }
public void decode(int streamId, ByteBuf in, Http2Headers headers, boolean validateHeaders) throws Http2Exception { int index = 0; long headersLength = 0; int nameLength = 0; int valueLength = 0; byte state = READ_HEADER_REPRESENTATION; boolean huffmanEncoded = false; CharSequence name = null; HeaderType headerType = null; IndexType indexType = IndexType.NONE; while (in.isReadable()) { switch (state) { case READ_HEADER_REPRESENTATION: byte b = in.readByte(); if (maxDynamicTableSizeChangeRequired && (b & 0xE0) != 0x20) { throw MAX_DYNAMIC_TABLE_SIZE_CHANGE_REQUIRED; } if (b < 0) { index = b & 0x7F; switch (index) { case 0: throw DECODE_ILLEGAL_INDEX_VALUE; case 0x7F: state = READ_INDEXED_HEADER; break; default: HpackHeaderField indexedHeader = getIndexedHeader(index); headerType = validate(indexedHeader.name, headerType, validateHeaders); headersLength = addHeader(headers, indexedHeader.name, indexedHeader.value, headersLength); } } else if ((b & 0x40) == 0x40) { indexType = IndexType.INCREMENTAL; index = b & 0x3F; switch (index) { case 0: state = READ_LITERAL_HEADER_NAME_LENGTH_PREFIX; break; case 0x3F: state = READ_INDEXED_HEADER_NAME; break; default: name = readName(index); headerType = validate(name, headerType, validateHeaders); nameLength = name.length(); state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX; } } else if ((b & 0x20) == 0x20) { index = b & 0x1F; if (index == 0x1F) { state = READ_MAX_DYNAMIC_TABLE_SIZE; } else { setDynamicTableSize(index); state = READ_HEADER_REPRESENTATION; } } else { indexType = ((b & 0x10) == 0x10) ? IndexType.NEVER : IndexType.NONE; index = b & 0x0F; switch (index) { case 0: state = READ_LITERAL_HEADER_NAME_LENGTH_PREFIX; break; case 0x0F: state = READ_INDEXED_HEADER_NAME; break; default: name = readName(index); headerType = validate(name, headerType, validateHeaders); nameLength = name.length(); state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX; } } break; case READ_MAX_DYNAMIC_TABLE_SIZE: setDynamicTableSize(decodeULE128(in, (long) index)); state = READ_HEADER_REPRESENTATION; break; case READ_INDEXED_HEADER: HpackHeaderField indexedHeader = getIndexedHeader(decodeULE128(in, index)); headerType = validate(indexedHeader.name, headerType, validateHeaders); headersLength = addHeader(headers, indexedHeader.name, indexedHeader.value, headersLength); state = READ_HEADER_REPRESENTATION; break; case READ_INDEXED_HEADER_NAME: name = readName(decodeULE128(in, index)); headerType = validate(name, headerType, validateHeaders); nameLength = name.length(); state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX; break; case READ_LITERAL_HEADER_NAME_LENGTH_PREFIX: b = in.readByte(); huffmanEncoded = (b & 0x80) == 0x80; index = b & 0x7F; if (index == 0x7f) { state = READ_LITERAL_HEADER_NAME_LENGTH; } else { if (index > maxHeaderListSizeGoAway - headersLength) { headerListSizeExceeded(maxHeaderListSizeGoAway); } nameLength = index; state = READ_LITERAL_HEADER_NAME; } break; case READ_LITERAL_HEADER_NAME_LENGTH: nameLength = decodeULE128(in, index); if (nameLength > maxHeaderListSizeGoAway - headersLength) { headerListSizeExceeded(maxHeaderListSizeGoAway); } state = READ_LITERAL_HEADER_NAME; break; case READ_LITERAL_HEADER_NAME: if (in.readableBytes() < nameLength) { throw notEnoughDataException(in); } name = readStringLiteral(in, nameLength, huffmanEncoded); headerType = validate(name, headerType, validateHeaders); state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX; break; case READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX: b = in.readByte(); huffmanEncoded = (b & 0x80) == 0x80; index = b & 0x7F; switch (index) { case 0x7f: state = READ_LITERAL_HEADER_VALUE_LENGTH; break; case 0: headerType = validate(name, headerType, validateHeaders); headersLength = insertHeader(headers, name, EMPTY_STRING, indexType, headersLength); state = READ_HEADER_REPRESENTATION; break; default: if ((long) index + nameLength > maxHeaderListSizeGoAway - headersLength) { headerListSizeExceeded(maxHeaderListSizeGoAway); } valueLength = index; state = READ_LITERAL_HEADER_VALUE; } break; case READ_LITERAL_HEADER_VALUE_LENGTH: valueLength = decodeULE128(in, index); if ((long) valueLength + nameLength > maxHeaderListSizeGoAway - headersLength) { headerListSizeExceeded(maxHeaderListSizeGoAway); } state = READ_LITERAL_HEADER_VALUE; break; case READ_LITERAL_HEADER_VALUE: if (in.readableBytes() < valueLength) { throw notEnoughDataException(in); } CharSequence value = readStringLiteral(in, valueLength, huffmanEncoded); headerType = validate(name, headerType, validateHeaders); headersLength = insertHeader(headers, name, value, indexType, headersLength); state = READ_HEADER_REPRESENTATION; break; default: throw new Error("should not reach here state: " + state); } } if (headersLength > maxHeaderListSize) { headerListSizeExceeded(streamId, maxHeaderListSize, true); } if (state != READ_HEADER_REPRESENTATION) { throw connectionError(COMPRESSION_ERROR, "Incomplete header block fragment."); } }
public List<Derivative> getDerivatives(PID pid) { notNull(pid); return listDerivativeTypes().stream() .map(derivType -> getDerivative(pid, derivType)) .filter(deriv -> deriv != null) .collect(Collectors.toList()); }
@Override public byte[] sign(final byte[] data, final String algorithm, final PrivateKey key, final Certificate[] certChain, final Properties xParams) throws AOException { return triPhaseOperation( this.signFormat, CRYPTO_OPERATION_SIGN, data, algorithm, key, certChain, xParams ); }
public Template decorate(Credential credential, Template template, String region, String availabilityZone, String variant, CdpResourceType cdpResourceType) { setRootVolumeSize(template); PlatformDisks platformDisks = cloudParameterService.getDiskTypes(); CloudVmTypes vmTypesV2 = cloudParameterService.getVmTypesV2( extendedCloudCredentialConverter.convert(credential), region, variant, cdpResourceType, new HashMap<>()); String locationString = locationService.location(region, availabilityZone); VolumeParameterConfig config; for (VolumeTemplate volumeTemplate : template.getVolumeTemplates()) { try { config = resolveVolumeParameterConfig(template, volumeTemplate, platformDisks, vmTypesV2, locationString); } catch (NoSuchElementException ignored) { LOGGER.debug("No VolumeParameterConfig found, which might be normal for platforms like OpenStack"); config = VolumeParameterConfig.EMPTY; } if (config.volumeParameterType() != null) { if (volumeTemplate.getVolumeCount() == null) { volumeTemplate.setVolumeCount(config.maximumNumber()); } if (volumeTemplate.getVolumeSize() == null) { volumeTemplate.setVolumeSize(config.maximumSize()); } } } return template; }
@Nonnull @OmitSymbol( unless = "arez.enable_names" ) static String safeGetString( @Nonnull final Supplier<String> message ) { try { return message.get(); } catch ( final Throwable t ) { return "Exception generated whilst attempting to get supplied message.\n" + throwableToString( t ); } }
boolean updateNewAndRestoringTasks() { active.initializeNewTasks(); standby.initializeNewTasks(); final Collection<TopicPartition> restored = changelogReader.restore(active); active.updateRestored(restored); if (active.allTasksRunning()) { Set<TopicPartition> assignment = consumer.assignment(); log.trace("Resuming partitions {}", assignment); consumer.resume(assignment); assignStandbyPartitions(); return true; } return false; }
public ForeignKeyDesc getForeignKeyDesc(EntityMeta entityMeta, PropertyMeta propertyMeta) { if (!propertyMeta.isRelationship() || propertyMeta.getMappedBy() != null) { return null; } ReferentialConstraint referentialConstraint = propertyMeta.getField() .getAnnotation(ReferentialConstraint.class); if (referentialConstraint == null) { if (!regardRelationshipAsFk) { return null; } } else { if (!referentialConstraint.enable()) { return null; } } ForeignKeyDesc foreignKeyDesc = new ForeignKeyDesc(); doColumn(entityMeta, propertyMeta, foreignKeyDesc); doTable(entityMeta, propertyMeta, foreignKeyDesc); doReferetialAction(entityMeta, propertyMeta, foreignKeyDesc); return foreignKeyDesc; }
public static List<LdifEntry> reverseRename( Entry entry, Rdn newRdn, boolean deleteOldRdn ) throws LdapInvalidDnException { return reverseMoveAndRename( entry, null, newRdn, deleteOldRdn ); }
public static UriPattern parse(String uri) { if (uri.endsWith("?")) { throw new InvalidUriPatternException("URI patterns must not end with '?'. Found " + uri); } else if (!uri.startsWith("/")) { throw new InvalidUriPatternException("URI pattern must start with '/'. Found " + uri); } else if (uri.contains("#")) { throw new InvalidUriPatternException("URI pattern must not contain a fragment. Found " + uri); } String[] parts = uri.split(java.util.regex.Pattern.quote("?"), 2); String[] unparsedSegments = parts[0].split(java.util.regex.Pattern.quote("/")); List<Segment> segments = new ArrayList<>(); int offset = 1; for (int i = 1; i < unparsedSegments.length; i++) { String segment = unparsedSegments[i]; segments.add(Segment.parse(segment, offset)); offset += segment.length(); } Map<String, String> queryLiterals = new LinkedHashMap<>(); if (parts.length == 2) { if (parts[1].contains("{") || parts[1].contains("}")) { throw new InvalidUriPatternException("URI labels must not appear in the query string. Found " + uri); } for (String kvp : parts[1].split(java.util.regex.Pattern.quote("&"))) { String[] parameterParts = kvp.split("=", 2); String actualKey = parameterParts[0]; if (queryLiterals.containsKey(actualKey)) { throw new InvalidUriPatternException("Literal query parameters must not be repeated: " + uri); } queryLiterals.put(actualKey, parameterParts.length == 2 ? parameterParts[1] : ""); } } return new UriPattern(builder().pattern(uri).segments(segments), queryLiterals); }
@NotNull public static String unescapeChars(@NotNull final String string, final char[] toUnescape) { String toReturn = string; for (char character : toUnescape) { toReturn = unescapeChar(toReturn, character); } return toReturn; }
public BGPv4Packet decodeUpdatePacket(ByteBuf buffer) { UpdatePacket packet = new UpdatePacket(); ProtocolPacketUtils.verifyPacketSize(buffer, BGPv4Constants.BGP_PACKET_MIN_SIZE_UPDATE, -1); if(buffer.readableBytes() < 2) throw new MalformedAttributeListException(); int withdrawnOctets = buffer.readUnsignedShort(); if(withdrawnOctets > buffer.readableBytes()) throw new MalformedAttributeListException(); ByteBuf withdrawnBuffer = null; if(withdrawnOctets > 0) { withdrawnBuffer = buffer.readSlice(withdrawnOctets); } if(buffer.readableBytes() < 2) throw new MalformedAttributeListException(); int pathAttributeOctets = buffer.readUnsignedShort(); if(pathAttributeOctets > buffer.readableBytes()) throw new MalformedAttributeListException(); ByteBuf pathAttributesBuffer = null; if(pathAttributeOctets > 0) { pathAttributesBuffer = buffer.readSlice(pathAttributeOctets); } if(withdrawnBuffer != null) { try { packet.getWithdrawnRoutes().addAll(decodeWithdrawnRoutes(withdrawnBuffer)); } catch(IndexOutOfBoundsException e) { throw new MalformedAttributeListException(); } } if(pathAttributesBuffer != null) { try { packet.getPathAttributes().addAll(decodePathAttributes(pathAttributesBuffer)); } catch (IndexOutOfBoundsException ex) { throw new MalformedAttributeListException(); } } if(buffer.readableBytes() > 0) { try { while (buffer.isReadable()) { packet.getNlris().add(NLRICodec.decodeNLRI(buffer)); } } catch (IndexOutOfBoundsException e) { throw new InvalidNetworkFieldException(); } catch(IllegalArgumentException e) { throw new InvalidNetworkFieldException(); } } return packet; }
public static ParsedTemporal parse(String rawDate) { return parse("", "", "", rawDate); }
public static void main(String[] args) throws Exception { File file = new File(args[0]); try (BufferedReader buffer = new BufferedReader(new FileReader(file))) { String line; while ((line = buffer.readLine()) != null) { line = line.trim(); if (line.equals("0")) { System.out.println("ZeroDollars"); } else { boolean weird = false; StringBuilder builder = new StringBuilder(); while (line.length() != 0) { int digit = Integer.parseInt(line.substring(0, 1)); int place = line.length(); String string = getString(digit, place, weird, builder.toString()); if (string != null) { builder.append(string); weird = false; } else { weird = true; } line = line.substring(1); } System.out.println(builder); } } } }
@VisibleForTesting void builtParagons(int count, boolean survived, List<AchievementUpdate> achievementUpdates, int playerId) { if (survived && count > 0) { unlock(AchievementId.ACH_SO_MUCH_RESOURCES, achievementUpdates, playerId); } }
@Override public Accessibility deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) { if (!json.isJsonPrimitive()) { throw new JsonParseException("Accessibility must be a JSON string"); } return Accessibility.fromValue(json.getAsString()); }
@Override protected void shutDown() throws Exception { logger.log(Level.INFO, "Shutdown Indexing service"); if ((indexingService != null) && indexingService.isRunning()) { indexingService.stopAsync().awaitTerminated(); } super.shutDown(); }
@Override public Object getProperty(String name) { Object obj = properties.getProperty(ClassBreaksDescriptor.CLASSIFICATION_PROPERTY); if (obj == Image.UndefinedProperty) { Classification c = preCalculate(); if (c != null) { properties.setProperty(ClassBreaksDescriptor.CLASSIFICATION_PROPERTY, c); } } return super.getProperty(name); }
PatientSearchMode getSearchMode(String name, String identifier, List<PatientIdentifierType> identifierTypes, boolean searchOnNamesOrIdentifiers) { if (searchOnNamesOrIdentifiers) { return PatientSearchMode.PATIENT_SEARCH_BY_NAME_OR_IDENTIFIER; } if (!StringUtils.isBlank(name) && StringUtils.isBlank(identifier) && CollectionUtils.isEmpty(identifierTypes)) { return PatientSearchMode.PATIENT_SEARCH_BY_NAME; } if (StringUtils.isBlank(name) && !(StringUtils.isBlank(identifier) && CollectionUtils.isEmpty(identifierTypes))) { return PatientSearchMode.PATIENT_SEARCH_BY_IDENTIFIER; } return PatientSearchMode.PATIENT_SEARCH_BY_NAME_AND_IDENTIFIER; }
public static <T> RetryTransformer<T> of(Retry retry) { return new RetryTransformer<>(retry); }
protected final String insertSpans(List<EntityAnnotation> annotationList, String content, EntityFormatConfiguration config) throws IOException { StringBuilder buffer = new StringBuilder(content); Set<String> terms = newHashSet(); Set<String> attrs = newHashSet(); Set<String> cssClasses = newHashSet(); for (EntityAnnotationGroup group : getAnnotationGroups(annotationList, config.isLongestOnly())) { cssClasses.clear(); attrs.clear(); terms.clear(); for (Entity entity : group.getAnnotations()) { String serialized = entity.serialize(); if (!isNullOrEmpty(serialized)) { terms.add(serialized); } cssClasses.add(recognizer.getCssClass()); } if (!terms.isEmpty()) { attrs.add(format("%s=\"%s\"", config.getDataAttrName(), on("|").join(terms))); } buffer.insert(group.getEnd(), "</span>"); buffer.insert(group.getStart(), format("<span class=\"%s\" %s>", on(" ").join(cssClasses), on(" ").join(attrs))); } return buffer.toString(); }
public void pauseTask() { taskInstance = processService.findTaskInstanceById(taskInstance.getId()); if(taskInstance == null){ return; } if(StringUtils.isBlank(taskInstance.getHost())){ taskInstance.setState(ExecutionStatus.PAUSE); taskInstance.setEndTime(new Date()); processService.updateTaskInstance(taskInstance); } }
@SuppressWarnings({ "rawtypes", "unchecked" }) public static void load(Object model, Map<String, Object> attributes) { for (Entry<String, Object> entry : attributes.entrySet()) { try { Method method = PropertyUtil.getReadMethod(model, entry.getKey()); if (method == null) { continue; } Type propertyType = method.getGenericReturnType() != null ? method.getGenericReturnType() : method.getReturnType(); Object property = PropertyUtil.getProperty(model, entry.getKey()); if (PropertyUtil.isSimpleProperty(entry.getValue().getClass())) { PropertyUtil.setProperty(model, entry.getKey(), entry.getValue()); } else if (PropertyUtil.isCollectionProperty(propertyType, false)) { } else if (PropertyUtil.isMapProperty(propertyType)) { if (property == null) { property = new HashMap(); } loadMap((Map)property, (Map)attributes.get(entry.getKey()), getCollectionElementType(propertyType)); PropertyUtil.setProperty(model, entry.getKey(), property); } else { if (property == null && propertyType instanceof Class) { property = ((Class)propertyType).newInstance(); } load(property, (Map<String, Object>) entry.getValue()); PropertyUtil.setProperty(model, entry.getKey(), property); } } catch (Exception e) { logger.warn("Failed while loading the attributes to the bean", e); } } }
@Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); int seq = sequence.getAndIncrement(); thread.setName(prefix + (seq > 1 ? "-" + seq : "")); if (!thread.isDaemon()) thread.setDaemon(true); return thread; }
@Override public Row setFarFutureTime(Row row) { return RowUtils.set(row, field.name(), farFuture); }
public Single<StoreResponse> invokeStoreAsync( Uri physicalAddressUri, ResourceOperation resourceOperation, RxDocumentServiceRequest request) { try { URI physicalAddress = physicalAddressUri.getURI(); String activityId = request.getActivityId(); if (resourceOperation.operationType == OperationType.Recreate) { Map<String, String> errorResponseHeaders = new HashMap<>(); errorResponseHeaders.put(HttpConstants.HttpHeaders.REQUEST_VALIDATION_FAILURE, "1"); logger.error("Received Recreate request on Http client"); throw new InternalServerErrorException(RMResources.InternalServerError, null, errorResponseHeaders, null); } HttpClientRequest<ByteBuf> httpRequest = prepareHttpMessage(activityId, physicalAddressUri.getURIAsString(), resourceOperation, request); RxClient.ServerInfo serverInfo = new RxClient.ServerInfo(physicalAddress.getHost(), physicalAddress.getPort()); MutableVolatile<Instant> sendTimeUtc = new MutableVolatile<>(); Single<HttpClientResponse<ByteBuf>> responseMessage = this.httpClient.submit(serverInfo, httpRequest).toSingle(); responseMessage = responseMessage.doOnSubscribe(() -> { sendTimeUtc.v = Instant.now(); this.beforeRequest( activityId, httpRequest.getUri(), request.getResourceType(), httpRequest.getHeaders()); }); responseMessage = responseMessage.onErrorResumeNext(t -> { Exception exception = Utils.as(t, Exception.class); if (exception == null) { logger.error("critical failure", t); t.printStackTrace(); assert false : "critical failure"; return Single.error(t); } if (WebExceptionUtility.isWebExceptionRetriable(exception)) { logger.debug("Received retriable exception {} " + "sending the request to {}, will re-resolve the address " + "send time UTC: {}", exception, physicalAddress, sendTimeUtc); GoneException goneException = new GoneException( String.format( RMResources.ExceptionMessage, RMResources.Gone), exception, null, physicalAddress); return Single.error(goneException); } else if (request.isReadOnlyRequest()) { logger.trace("Received exception {} on readonly request" + "sending the request to {}, will reresolve the address " + "send time UTC: {}", exception, physicalAddress, sendTimeUtc); GoneException goneException = new GoneException( String.format( RMResources.ExceptionMessage, RMResources.Gone), exception, null, physicalAddress); return Single.error(goneException); } else { ServiceUnavailableException serviceUnavailableException = new ServiceUnavailableException( String.format( RMResources.ExceptionMessage, RMResources.ServiceUnavailable), exception, null, physicalAddress.toString()); serviceUnavailableException.getResponseHeaders().put(HttpConstants.HttpHeaders.REQUEST_VALIDATION_FAILURE, "1"); serviceUnavailableException.getResponseHeaders().put(HttpConstants.HttpHeaders.WRITE_REQUEST_TRIGGER_ADDRESS_REFRESH, "1"); return Single.error(serviceUnavailableException); } }).doOnSuccess(httpClientResponse -> { Instant receivedTimeUtc = Instant.now(); double durationInMilliSeconds = (receivedTimeUtc.toEpochMilli() - sendTimeUtc.v.toEpochMilli()); this.afterRequest( activityId, httpClientResponse.getStatus().code() , durationInMilliSeconds, httpClientResponse.getHeaders()); }).doOnError( e -> { Instant receivedTimeUtc = Instant.now(); double durationInMilliSeconds = (receivedTimeUtc.toEpochMilli() - sendTimeUtc.v.toEpochMilli()); this.afterRequest( activityId, 0, durationInMilliSeconds, null); }); return responseMessage.flatMap(rsp -> processHttpResponse(request.getResourceAddress(), httpRequest, activityId.toString(), rsp, physicalAddress)); } catch (Exception e) { return Single.error(e); } }
public void checkKeyUniqueness(String key, String value, boolean isEncrypted) { if (StringUtils.isBlank(key) || StringUtils.isBlank(value)) { ProjectLogger.log( "UserService:checkKeyUniqueness: Key or value is null. key = " + key + " value= " + value, LoggerEnum.ERROR.name()); return; } String val = value; if (isEncrypted) { try { val = getEncryptionService().encryptData(val); } catch (Exception e) { ProjectLogger.log( "UserService:checkKeyUniqueness: Exception occurred with error message = " + e.getMessage(), e); } } Response result = getCassandraOperation() .getRecordsByIndexedProperty(userDb.getKeySpace(), userDb.getTableName(), key, val); List<Map<String, Object>> userMapList = (List<Map<String, Object>>) result.get(JsonKey.RESPONSE); if (!userMapList.isEmpty()) { ResponseCode responseCode = null; if (JsonKey.EMAIL.equals(key)) { responseCode = ResponseCode.emailInUse; } else if (JsonKey.PHONE.equals(key)) { responseCode = ResponseCode.PhoneNumberInUse; } ProjectCommonException.throwClientErrorException(responseCode, null); } }
public synchronized boolean hasPassword() { return getPassword() != null && !getPassword().isEmpty(); }
@Override public Map<String, Object> getParameters(final HonorType entity, final Map<String, Object> parameters) { addParameter(entity.getName(), "name", parameters); addParameter(entity.getAbbrName(), "abbrName", parameters); return parameters; }
@Override public void deleteTask() { mRepository.deleteTask(mTaskId); mTaskDetailView.showTaskDeleted(); }
@Override public boolean equals(Object obj) { if(!super.equals(obj) || !(obj instanceof EventedSimpleVehicleMessage)) { return false; } final EventedSimpleVehicleMessage other = (EventedSimpleVehicleMessage) obj; return mEvent.equals(other.mEvent); }
public Set<OrganizationSet> createCompactionSets(Table tableInfo, Collection<ShardIndexInfo> shards) { Collection<Collection<ShardIndexInfo>> shardsByDaysBuckets = getShardsByDaysBuckets(tableInfo, shards, temporalFunction); ImmutableSet.Builder<OrganizationSet> compactionSets = ImmutableSet.builder(); for (Collection<ShardIndexInfo> shardInfos : shardsByDaysBuckets) { compactionSets.addAll(buildCompactionSets(tableInfo, ImmutableSet.copyOf(shardInfos))); } return compactionSets.build(); }
@Override public byte[] decrypt(final byte[] ciphertext) throws GeneralSecurityException { if (ciphertext.length < ivSize) { throw new GeneralSecurityException("ciphertext too short"); } byte[] iv = new byte[ivSize]; System.arraycopy(ciphertext, 0, iv, 0, ivSize); byte[] plaintext = new byte[ciphertext.length - ivSize]; doCtr(ciphertext, ivSize, ciphertext.length - ivSize, plaintext, 0, iv, false); return plaintext; }
@Override public Status importAgenciesFile(InputStream stream, String filename) throws ReferentialException { ParametersChecker.checkParameter(STREAM_IS_A_MANDATORY_PARAMETER, stream); LOGGER.debug("import file Agencies request:"); StreamUtils.closeSilently(stream); return Status.CREATED; }
public static BlockTripInstance getBlockTripInstance( BlockInstance blockInstance, AgencyAndId tripId) { BlockConfigurationEntry blockConfig = blockInstance.getBlock(); List<BlockTripEntry> blockTrips = blockConfig.getTrips(); for (int i = 0; i < blockTrips.size(); ++i) { BlockTripEntry blockTrip = blockTrips.get(i); if (blockTrip.getTrip().getId().equals(tripId)) { return new BlockTripInstance(blockTrip, blockInstance.getState()); } } return null; }
@Override public void persistProcessWorkflow(String folderName, ProcessWorkflow processWorkflow) throws ProcessingStorageWorkspaceException, InvalidParseOperationException { LOGGER.debug("[PERSIST] workflow process with execution status : <{}>", processWorkflow.getState()); try (WorkspaceClient client = workspaceClientFactory.getClient()) { client.putObject(PROCESS_CONTAINER, getPathToObjectFromFolder(folderName, processWorkflow.getOperationId()), JsonHandler.writeAsString(processWorkflow).getBytes()); } catch (ContentAddressableStorageServerException exc) { throw new ProcessingStorageWorkspaceException(exc); } }
public boolean isApplicationResourceType(){ try{ return DefaultResourceTypeDefinition.APPLICATION.name().equals(getName()); } catch (IllegalArgumentException e) { return false; } }
public static byte[][] split(byte[] raw, int partSize) { int length = raw.length % partSize == 0 ? raw.length / partSize : ((int) (raw.length / partSize)) + 1; byte[][] parts = new byte[length][]; int start = 0; for (int i = 0; i < length; i++) { int end = Integer.min(raw.length, start + partSize); parts[i] = Arrays.copyOfRange(raw, start, end); start = end; } return parts; }
public void clearSnapshot(String snapshotName, Node host) throws ReaperException { clusterFacade.clearSnapshot(snapshotName, host); }
public RegisterRequestData startRegistration(String appId, Iterable<? extends DeviceRegistration> devices) throws U2fBadConfigurationException { if(validateAppId) { AppId.checkIsValid(appId); } return new RegisterRequestData(appId, devices, primitives, challengeGenerator); }
public static boolean hasAnyRealm(Authentication authentication, String[] realms) { if (authentication instanceof OAuth2Authentication) { Object details = ((OAuth2Authentication) authentication).getUserAuthentication().getDetails(); if (details instanceof Map) { Map<String, Object> map = (Map<String, Object>) details; Object realmFromMap = map.get("realm"); if (realmFromMap != null && realmFromMap instanceof String) { String realm = (String) realmFromMap; for (String s : realms) { if (realm.equals(s)) { return true; } } } } } return false; }
@Override public void addContextGroupMenuItem(final String menuItemId, final String id, final String label, final MenuPosition position) { final ListDropDown listDropDown = GWT.create(ListDropDown.class); listDropDown.addStyleName(UF_PERSPECTIVE_CONTEXT_MENU); final AnchorButton anchor = GWT.create(AnchorButton.class); anchor.setDataToggle(Toggle.DROPDOWN); anchor.setText(label); final DropDownMenu dropDownMenu = GWT.create(DropDownMenu.class); listDropDown.add(anchor); listDropDown.add(dropDownMenu); menuItemContextMenus.get(menuItemId).add(listDropDown); getMenuItemContextWidgetMap().put(id, dropDownMenu); }
@Override public boolean check(ExecutableElement element) { return element != null && TypeUtils.CheckTypeKind.isVoid(element.getReturnType()); }
@VisibleForTesting Footer.Props getFooterProps(@NonNull final Context context) { Button.Props buttonAction = null; Button.Props linkAction = null; final PaymentResultViewModel paymentResultViewModel = PaymentResultViewModelFactory .createPaymentResultViewModel(props); if (paymentResultViewModel.getLinkAction() != null) { linkAction = new Button.Props(paymentResultViewModel.getLinkActionTitle(context), paymentResultViewModel.getLinkAction()); } if (paymentResultViewModel.getMainAction() != null) { buttonAction = new Button.Props(paymentResultViewModel.getMainActionTitle(context), paymentResultViewModel.getMainAction()); } return new Footer.Props(buttonAction, linkAction); }
public static String join(String[] array) { if (ArrayUtils.isEmpty(array)) { return EMPTY_STRING; } StringBuilder sb = new StringBuilder(); for (String s : array) { sb.append(s); } return sb.toString(); }
@Override public RestResult<Void> resendInternalUserInvite(long inviteId) { return putWithRestResult(INVITE_REST_URL + "/internal/pending/" + inviteId + "/resend", Void.class); }
public static long parseByteSize(String sizeString) throws InvalidConfigException { if (null == sizeString) return 0; long unit = 1L; Matcher m = BYTE_SIZE_PATTERN.matcher(sizeString); if (!m.matches()) throw new InvalidConfigException("invalid byte-size string: " + sizeString); if (1 < m.groupCount() && null != m.group(2) && 0 < m.group(2).length()) { char unitChar1 = m.group(2).charAt(0); switch (unitChar1) { case 'k': unit = 1000L; break; case 'K': unit = 1024L; break; case 'm': unit = 1000L * 1000L; break; case 'M': unit = 1024L * 1024L; break; case 'g': unit = 1000L * 1000L * 1000L; break; case 'G': unit = 1024L * 1024L * 1024L; break; case 't': unit = 1000L * 1000L * 1000L * 1000L; break; case 'T': unit = 1024L * 1024L * 1024L * 1024L; break; case 'p': unit = 1000L * 1000L * 1000L * 1000L * 1000L; break; case 'P': unit = 1024L * 1024L * 1024L * 1024L * 1024L; break; case 'e': unit = 1000L * 1000L * 1000L * 1000L * 1000L * 1000L; break; case 'E': unit = 1024L * 1024L * 1024L * 1024L * 1024L * 1024L; break; } } long value = Long.parseLong(m.group(1)); return unit * value; }
@Override public ChangeLogSet parse(final Run build, final RepositoryBrowser<?> browser, final File changelogFile) throws IOException, SAXException { try (FileInputStream stream = new FileInputStream(changelogFile); Reader reader = new InputStreamReader(stream, Charset.defaultCharset())) { return parse(build, browser, reader); } }
public static DataflowRunner fromOptions(PipelineOptions options) { DataflowPipelineOptions dataflowOptions = PipelineOptionsValidator.validate(DataflowPipelineOptions.class, options); ArrayList<String> missing = new ArrayList<>(); if (dataflowOptions.getAppName() == null) { missing.add("appName"); } if (Strings.isNullOrEmpty(dataflowOptions.getRegion()) && isServiceEndpoint(dataflowOptions.getDataflowEndpoint())) { missing.add("region"); } if (missing.size() > 0) { throw new IllegalArgumentException( "Missing required pipeline options: " + Joiner.on(',').join(missing)); } validateWorkerSettings(PipelineOptionsValidator.validate(GcpOptions.class, options)); PathValidator validator = dataflowOptions.getPathValidator(); String gcpTempLocation; try { gcpTempLocation = dataflowOptions.getGcpTempLocation(); } catch (Exception e) { throw new IllegalArgumentException( "DataflowRunner requires gcpTempLocation, " + "but failed to retrieve a value from PipelineOptions", e); } validator.validateOutputFilePrefixSupported(gcpTempLocation); String stagingLocation; try { stagingLocation = dataflowOptions.getStagingLocation(); } catch (Exception e) { throw new IllegalArgumentException( "DataflowRunner requires stagingLocation, " + "but failed to retrieve a value from PipelineOptions", e); } validator.validateOutputFilePrefixSupported(stagingLocation); if (!isNullOrEmpty(dataflowOptions.getSaveProfilesToGcs())) { validator.validateOutputFilePrefixSupported(dataflowOptions.getSaveProfilesToGcs()); } if (dataflowOptions.getFilesToStage() == null) { dataflowOptions.setFilesToStage( detectClassPathResourcesToStage(DataflowRunner.class.getClassLoader(), options)); if (dataflowOptions.getFilesToStage().isEmpty()) { throw new IllegalArgumentException("No files to stage has been found."); } else { LOG.info( "PipelineOptions.filesToStage was not specified. " + "Defaulting to files from the classpath: will stage {} files. " + "Enable logging at DEBUG level to see which files will be staged.", dataflowOptions.getFilesToStage().size()); LOG.debug("Classpath elements: {}", dataflowOptions.getFilesToStage()); } } String jobName = dataflowOptions.getJobName().toLowerCase(); checkArgument( jobName.matches("[a-z]([-a-z0-9]*[a-z0-9])?"), "JobName invalid; the name must consist of only the characters " + "[-a-z0-9], starting with a letter and ending with a letter " + "or number"); if (!jobName.equals(dataflowOptions.getJobName())) { LOG.info( "PipelineOptions.jobName did not match the service requirements. " + "Using {} instead of {}.", jobName, dataflowOptions.getJobName()); } dataflowOptions.setJobName(jobName); String project = dataflowOptions.getProject(); if (project.matches("[0-9]*")) { throw new IllegalArgumentException( "Project ID '" + project + "' invalid. Please make sure you specified the Project ID, not project number."); } else if (!project.matches(PROJECT_ID_REGEXP)) { throw new IllegalArgumentException( "Project ID '" + project + "' invalid. Please make sure you specified the Project ID, not project description."); } DataflowPipelineDebugOptions debugOptions = dataflowOptions.as(DataflowPipelineDebugOptions.class); if (debugOptions.getNumberOfWorkerHarnessThreads() < 0) { throw new IllegalArgumentException( "Number of worker harness threads '" + debugOptions.getNumberOfWorkerHarnessThreads() + "' invalid. Please make sure the value is non-negative."); } if (dataflowOptions.isStreaming() && dataflowOptions.getGcsUploadBufferSizeBytes() == null) { dataflowOptions.setGcsUploadBufferSizeBytes(GCS_UPLOAD_BUFFER_SIZE_BYTES_DEFAULT); } String javaVersion = Float.parseFloat(System.getProperty("java.specification.version")) >= 9 ? "(JDK 11 environment)" : "(JRE 8 environment)"; DataflowRunnerInfo dataflowRunnerInfo = DataflowRunnerInfo.getDataflowRunnerInfo(); String userAgent = String.format( "%s/%s%s", dataflowRunnerInfo.getName(), dataflowRunnerInfo.getVersion(), javaVersion) .replace(" ", "_"); dataflowOptions.setUserAgent(userAgent); return new DataflowRunner(dataflowOptions); }
@Udf public String chr(@UdfParameter( description = "Decimal codepoint") final Integer decimalCode) { if (decimalCode == null) { return null; } if (!Character.isValidCodePoint(decimalCode)) { return null; } final char[] resultChars = Character.toChars(decimalCode.intValue()); return String.valueOf(resultChars); }
@Override public boolean isShowAnnotationTools() { return showAnnotationTools; }
public static Expression parseExpression(String expressionString, Map<String, Object> model) { ModelPathResolver.modelMapThreadLocal.set(model); return parseExpression(expressionString); }
public static II createInteractionId(String extension) { return IIHelper.IIFactory(Constants.HL7_OID, extension); }
public static TenorDateParameterMetadata of(LocalDate date, Tenor tenor) { ArgChecker.notNull(date, "date"); ArgChecker.notNull(tenor, "tenor"); return new TenorDateParameterMetadata(date, tenor, tenor.toString()); }
public static <E extends Enum<E>> EnumSet<E> parseActionStringToSet(Class<E> actionType, String actionString) throws IllegalArgumentException { Assert.checkNotNullParam("actionType", actionType); Assert.checkNotNullParam("actionString", actionString); final SetMatchAction<E> matchAction = new SetMatchAction<>(EnumSet.noneOf(actionType)); doParse(actionType, actionString, matchAction); return matchAction.getSet(); }
public ServerConfiguration getServerConfiguration () { return (ServerConfiguration) notStoredPartOfConfiguration. getServerConfiguration (); }
@SuppressWarnings("unchecked") public void validateMandatoryFrameworkFields( Map<String, Object> userMap, List<String> frameworkFields, List<String> frameworkMandatoryFields) { if (userMap.containsKey(JsonKey.FRAMEWORK)) { Map<String, Object> frameworkRequest = (Map<String, Object>) userMap.get(JsonKey.FRAMEWORK); for (String field : frameworkFields) { if (CollectionUtils.isNotEmpty(frameworkMandatoryFields) && frameworkMandatoryFields.contains(field)) { if (!frameworkRequest.containsKey(field)) { validateParam(null, ResponseCode.mandatoryParamsMissing, field); } validateListParamWithPrefix(frameworkRequest, JsonKey.FRAMEWORK, field); List<String> fieldValue = (List) frameworkRequest.get(field); if (fieldValue.isEmpty()) { throw new ProjectCommonException( ResponseCode.errorMandatoryParamsEmpty.getErrorCode(), ResponseCode.errorMandatoryParamsEmpty.getErrorMessage(), ERROR_CODE, StringFormatter.joinByDot(JsonKey.FRAMEWORK, field)); } } else { if (frameworkRequest.containsKey(field) && frameworkRequest.get(field) != null && !(frameworkRequest.get(field) instanceof List)) { throw new ProjectCommonException( ResponseCode.dataTypeError.getErrorCode(), ResponseCode.dataTypeError.getErrorMessage(), ERROR_CODE, field, JsonKey.LIST); } } } List<String> frameworkRequestFieldList = frameworkRequest.keySet().stream().collect(Collectors.toList()); for (String frameworkRequestField : frameworkRequestFieldList) { if (!frameworkFields.contains(frameworkRequestField)) { throw new ProjectCommonException( ResponseCode.errorUnsupportedField.getErrorCode(), ResponseCode.errorUnsupportedField.getErrorMessage(), ERROR_CODE, StringFormatter.joinByDot(JsonKey.FRAMEWORK, frameworkRequestField)); } } } }
public void updateFee(FeeRequest feeRequest){ feeRepository.updateFee(feeRequest); }
@Override public JsonRpcResponse response(final JsonRpcRequestContext requestContext) { final Optional<Address> coinbase = miningCoordinator.getCoinbase(); if (coinbase.isPresent()) { return new JsonRpcSuccessResponse( requestContext.getRequest().getId(), coinbase.get().toString()); } return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.COINBASE_NOT_SPECIFIED); }
@Override public double score(Clustering<E, C> clusters, Props params) throws ScoreException { CountingPairs<E, C> cp = CountingPairs.getInstance(); Table<String, String, Integer> contTable = cp.contingencyTable(clusters); return vi(clusters, contTable); }
public void step(Program aprogram) { steps(aprogram,1); }
public void revokeToken(String token, final RequestCallback<Boolean, AuthorizationException> cb) { cancelFuture(); mFutureTask = mDispatcher.submit(() -> { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); try { Boolean isRevoke = mSyncSessionClient.revokeToken(token); mDispatcher.submitResults(() -> cb.onSuccess(isRevoke)); } catch (AuthorizationException ae) { mDispatcher.submitResults(() -> cb.onError(ae.error, ae)); } catch (Exception ex) { mDispatcher.submitResults(() -> cb.onError(ex.getMessage(), new AuthorizationException(ex.getMessage(), ex))); } }); }
@Override public synchronized AtomAtomMapping getFirstAtomMapping() { if (allAtomMCS.iterator().hasNext()) { return allAtomMCS.iterator().next(); } return new AtomAtomMapping(getReactantMol(), getProductMol()); }
@Override public String resolve(String statNameWithFormatSpecifier, final Resolver unused) { String[] split = statNameWithFormatSpecifier.split(":", 2); String statName = split[0]; Object statisticValue = _statistics.get(statName); if (split.length > 1) { String formatterName = split[1].toLowerCase(); if (statisticValue instanceof Number) { final long value = ((Number) statisticValue).longValue(); switch (formatterName.toLowerCase()) { case BYTEUNIT: statisticValue = toIEC80000BinaryPrefixedValue(value); break; case DURATION: statisticValue = value < 0 ? "-" : Duration.ofMillis(value); break; case DATETIME: statisticValue = value < 0 ? "-" : Instant.ofEpochMilli(value).toString(); break; } } else if (statisticValue instanceof Date) { switch (formatterName.toLowerCase()) { case DATETIME: long time = ((Date) statisticValue).getTime(); statisticValue = time < 0 ? "-" : Instant.ofEpochMilli(time).toString(); break; } } } return statisticValue == null ? null : String.valueOf(statisticValue); }
public String encode(Object result) throws JSONException { StringBuilder builder = new StringBuilder(); encode(result, builder, null); return builder.toString(); }
@VisibleForTesting void setFormat(String format) { this.format = format; }
@Override public void store(StoreReference store, CertifiedKeyPair keyPair) throws KeyStoreException { storeKeyPair(store, getPublicKey(keyPair.getCertificate()), keyPair.getPrivateKey().getEncoded(), PRIVATE_KEY); }
public synchronized void updateConfig( final ALLOWLIST_TYPE allowlistType, final Collection<String> updatedAllowlistValues) throws IOException { removeExistingConfigItem(allowlistType); addNewConfigItem(allowlistType, updatedAllowlistValues); }
@Override public void configure(Context context) { if (!isLocal) { if (StringUtils.isNotBlank(context.getString(HOSTNAMES))) { serverAddresses = StringUtils.deleteWhitespace( context.getString(HOSTNAMES)).split(","); } Preconditions.checkState(serverAddresses != null && serverAddresses.length > 0, "Missing Param:" + HOSTNAMES); } if (StringUtils.isNotBlank(context.getString(INDEX_NAME))) { this.indexName = context.getString(INDEX_NAME); } if (StringUtils.isNotBlank(context.getString(INDEX_TYPE))) { this.indexType = context.getString(INDEX_TYPE); } if (StringUtils.isNotBlank(context.getString(CLUSTER_NAME))) { this.clusterName = context.getString(CLUSTER_NAME); } if (StringUtils.isNotBlank(context.getString(BATCH_SIZE))) { this.batchSize = Integer.parseInt(context.getString(BATCH_SIZE)); } if (StringUtils.isNotBlank(context.getString(TTL))) { this.ttlMs = parseTTL(context.getString(TTL)); Preconditions.checkState(ttlMs > 0, TTL + " must be greater than 0 or not set."); } if (StringUtils.isNotBlank(context.getString(CLIENT_TYPE))) { clientType = context.getString(CLIENT_TYPE); } elasticSearchClientContext = new Context(); elasticSearchClientContext.putAll(context.getSubProperties(CLIENT_PREFIX)); String serializerClazz = DEFAULT_SERIALIZER_CLASS; if (StringUtils.isNotBlank(context.getString(SERIALIZER))) { serializerClazz = context.getString(SERIALIZER); } Context serializerContext = new Context(); serializerContext.putAll(context.getSubProperties(SERIALIZER_PREFIX)); try { @SuppressWarnings("unchecked") Class<? extends Configurable> clazz = (Class<? extends Configurable>) Class .forName(serializerClazz); Configurable serializer = clazz.newInstance(); if (serializer instanceof ElasticSearchIndexRequestBuilderFactory) { indexRequestFactory = (ElasticSearchIndexRequestBuilderFactory) serializer; indexRequestFactory.configure(serializerContext); } else if (serializer instanceof ElasticSearchEventSerializer) { eventSerializer = (ElasticSearchEventSerializer) serializer; eventSerializer.configure(serializerContext); } else { throw new IllegalArgumentException(serializerClazz + " is not an ElasticSearchEventSerializer"); } } catch (Exception e) { logger.error("Could not instantiate event serializer.", e); Throwables.propagate(e); } if (sinkCounter == null) { sinkCounter = new SinkCounter(getName()); } String indexNameBuilderClass = DEFAULT_INDEX_NAME_BUILDER_CLASS; if (StringUtils.isNotBlank(context.getString(INDEX_NAME_BUILDER))) { indexNameBuilderClass = context.getString(INDEX_NAME_BUILDER); } Context indexnameBuilderContext = new Context(); serializerContext.putAll( context.getSubProperties(INDEX_NAME_BUILDER_PREFIX)); try { @SuppressWarnings("unchecked") Class<? extends IndexNameBuilder> clazz = (Class<? extends IndexNameBuilder>) Class .forName(indexNameBuilderClass); indexNameBuilder = clazz.newInstance(); indexnameBuilderContext.put(INDEX_NAME, indexName); indexNameBuilder.configure(indexnameBuilderContext); } catch (Exception e) { logger.error("Could not instantiate index name builder.", e); Throwables.propagate(e); } if (sinkCounter == null) { sinkCounter = new SinkCounter(getName()); } Preconditions.checkState(StringUtils.isNotBlank(indexName), "Missing Param:" + INDEX_NAME); Preconditions.checkState(StringUtils.isNotBlank(indexType), "Missing Param:" + INDEX_TYPE); Preconditions.checkState(StringUtils.isNotBlank(clusterName), "Missing Param:" + CLUSTER_NAME); Preconditions.checkState(batchSize >= 1, BATCH_SIZE + " must be greater than 0"); }
public static SOAPMessage stringToSoap( String soapString ) throws SOAPException { byte[] bytes; try { bytes = soapString.getBytes( "UTF-8" ); } catch ( UnsupportedEncodingException e ) { log.fatal( "### Error - this should never happen: " + e.getMessage() ); bytes = "".getBytes(); } String protocol; if ( soapString.contains( SOAP_11_NAMESPACE_URL ) ) { protocol = javax.xml.soap.SOAPConstants.SOAP_1_1_PROTOCOL; } else if ( soapString.contains( SOAP_12_NAMESPACE_URL ) ) { protocol = javax.xml.soap.SOAPConstants.SOAP_1_2_PROTOCOL; } else { throw new SOAPException( "Could't not detect SOAP protocol Version" ); } SOAPMessage sm; try { sm = MessageFactory.newInstance( protocol ).createMessage( null, new ByteArrayInputStream( bytes ) ); } catch ( IOException e ) { log.fatal( "### Error - this should never happen: " + e.getMessage() ); sm = MessageFactory.newInstance().createMessage(); } return sm; }
@Override public void writeData(byte[] data) throws IOException { if (data == null) throw new NullPointerException("Data to be sent cannot be null."); if (getOutputStream() != null) { if (isHardwareFlowControl()) { int tries = 0; while (tries < 3 && !isCTS()) { try { Thread.sleep(100); } catch (InterruptedException e) { } tries += 1; } if (isCTS()) { getOutputStream().write(data); getOutputStream().flush(); } } else { getOutputStream().write(data); getOutputStream().flush(); } } }
public void inject(ActionCreator ac) { ac.setDispatcher(getDispatcher()); }
@Override public final DoubleVector subtract(double v) { DenseDoubleVector newv = new DenseDoubleVector(vector.length); for (int i = 0; i < vector.length; i++) { newv.set(i, vector[i] - v); } return newv; }
public SortedSet<ConfigRecord<?>> inspect(ConfigurationFactory configurationFactory) { ImmutableSortedSet.Builder<ConfigRecord<?>> builder = ImmutableSortedSet.naturalOrder(); for (ConfigurationIdentity<?> configurationIdentity : configurationFactory.getRegisteredConfigs()) { builder.add(ConfigRecord.createConfigRecord(configurationFactory, configurationIdentity)); } return builder.build(); }
public static String getSuffix(final SlingHttpServletRequest request) { RequestPathInfo pathInfo = request.getRequestPathInfo(); if (pathInfo == null || pathInfo.getSuffix() == null) { return null; } return pathInfo.getSuffix(); }
@Override public String toMessage() { try { final List<Object> arguments = new ArrayList<>(); final Map<String, Object> value = ImmutableMap.of("interrupt", arguments); return mapper.writeValueAsString(value); } catch (final IOException e) { throw new ResponseException("Unable to serialize interrupt response arguments to json", e); } }
@Override public void receive(final Message msg) { try { handle(msg); } catch (Exception exception) { if (!(exception instanceof SilverWareClusteringException)) { throw new SilverWareClusteringException(PROCESSING_ERROR, exception); } throw (SilverWareClusteringException) exception; } }
public <R1> R1 transform(Function6<? super T1, ? super T2, ? super T3,? super T4, ? super T5,? super T6, ? extends R1> fn){ return fn.apply(_1(),_2(),_3(),_4(),_5(),_6()); }
@Override public List<Expression<?>> getArgs() { return args; }
public void setOccurrence(String occurrence) throws CDKException { if (occurrence == null || occurrence.equals("")) { occurrence = ">0"; } else { occurrence = occurrence.trim().replaceAll(" ", ""); if (isValidOccurrenceSyntax(occurrence)) { this.occurrence = occurrence; } else throw new CDKException("Invalid occurence line: " + occurrence); } }
protected static boolean isPretty(HttpHeaders httpHeaders, UriInfo uriInfo) { String value = httpHeaders.getHeaderString(FHIRConfiguration.DEFAULT_PRETTY_RESPONSE_HEADER_NAME); if (value == null) { value = uriInfo.getQueryParameters().getFirst("_pretty"); } if (value != null) { if (Boolean.parseBoolean(value)) { return true; } else if ("false".equalsIgnoreCase(value)) { return false; } } return FHIRConfigHelper.getBooleanProperty(FHIRConfiguration.PROPERTY_DEFAULT_PRETTY_PRINT, false); }
@Override public boolean equals(Object objectToCompare) { if (this == objectToCompare) { return true; } if (!(objectToCompare instanceof ConnectionProperties)) { return false; } if (!super.equals(objectToCompare)) { return false; } ConnectionProperties that = (ConnectionProperties) objectToCompare; return Objects.equals(getConnectionBean(), that.getConnectionBean()); }
public Bytes encoded() { final int size = encodedSize(); if (size == 0) { return Bytes.EMPTY; } final MutableBytes output = MutableBytes.create(size); writeEncoded(output); return output; }
public String executeCommand(String command) { Writer output = new StringWriter(); try { Process p = Runtime.getRuntime().exec(command); p.waitFor(); IOUtils.copy(p.getInputStream(), output); } catch (IOException | InterruptedException e) { logger.error(String.format("An error happened while executing command[%s]", command), e); } return output.toString(); }
@Override public XWikiAttachment parse(final Element docel) throws IOException { if (!ROOT_ELEMENT_NAME.equals(docel.getName())) { throw new IOException("XML not recognizable as attachment metadata, expecting <attachment> tag"); } if (docel.attribute(SERIALIZER_PARAM) == null || !THIS_SERIALIZER.equals(docel.attribute(SERIALIZER_PARAM).getValue())) { throw new IOException("Cannot parse this attachment metadata, it was saved with a different " + "serializer."); } final XWikiAttachment out = new XWikiAttachment(); out.setFilename(docel.element(FILENAME).getText()); out.setLongSize(Long.parseLong(docel.element(FILESIZE).getText())); out.setAuthor(docel.element(AUTHOR).getText()); out.setVersion(docel.element(VERSION).getText()); out.setComment(docel.element(COMMENT).getText()); final String sdate = docel.element(DATE).getText(); final Date date = new Date(Long.parseLong(sdate)); out.setDate(date); return out; }
@Override public String buildQuery() { validateQuery(); StringBuilder stringBuilder = new StringBuilder(); if (!Strings.isNullOrEmpty(select)) { stringBuilder = stringBuilder.append(SELECT).append(" ").append(select).append(" "); } if (!Strings.isNullOrEmpty(from)) { stringBuilder = stringBuilder.append(FROM).append(" ").append(from).append(" "); } if (!Strings.isNullOrEmpty(where)) { stringBuilder = stringBuilder.append(WHERE).append(" ").append(where).append(" "); } if (!Strings.isNullOrEmpty(orderBy)) { stringBuilder = stringBuilder.append(ORDER_BY).append(" ").append(orderBy).append(" "); } if (limit != null) { stringBuilder = stringBuilder.append(LIMIT).append(" ").append(limit).append(" "); } if (offset != null) { stringBuilder = stringBuilder.append(OFFSET).append(" ").append(offset).append(" "); } return stringBuilder.toString().trim(); }
public void copyPropertiesTo(Object otherBean) { copyProperties(bean, otherBean); }
Key reduceKeySize(final Key inputKey, final Versification v11n) throws NoSuchKeyException { Key key = inputKey; final int cardinality = key.getCardinality(); final Passage requestedPassage = KeyUtil.getPassage(key); if (cardinality > MAX_VERSES_RETRIEVED) { VerseRange firstChapter = requestedPassage.getRangeAt(0, RestrictionType.CHAPTER); if (firstChapter.getStart().getChapter() == 0) { key = requestedPassage.getRangeAt(1, RestrictionType.CHAPTER); } else { key = firstChapter; } } else if (isWholeBook(requestedPassage) && !requestedPassage.getRangeAt(0, RestrictionType.CHAPTER).getStart().getBook().isShortBook()) { key = requestedPassage.getRangeAt(1, RestrictionType.CHAPTER); } return key; }
@Override public Total calculate(final MutableShoppingCart cart) { if (!cart.getCarrierSlaId().isEmpty()) { Total total = null; final Set<DeliveryBucket> cartBuckets = new HashSet<>(cart.getCartItemMap().keySet()); final Set<DeliveryBucket> supplierBuckets = new HashSet<>(); for (final Map.Entry<String, Long> supplierCarrierSla : cart.getCarrierSlaId().entrySet()) { final String supplier = supplierCarrierSla.getKey(); supplierBuckets.clear(); for (final DeliveryBucket bucket : cartBuckets) { if (bucket.getSupplier().equals(supplier)) { supplierBuckets.add(bucket); } } if (supplierBuckets.isEmpty()) { continue; } final CarrierSla carrierSla = carrierSlaService.getById(supplierCarrierSla.getValue()); if (carrierSla != null && CarrierSla.FIXED.equals(carrierSla.getSlaType())) { final String carrierSlaGUID = carrierSla.getGuid(); final String carrierSlaName = new FailoverStringI18NModel( carrierSla.getDisplayName(), carrierSla.getName()).getValue(cart.getCurrentLocale()); final PricingPolicyProvider.PricingPolicy policy = pricingPolicyProvider.determinePricingPolicy( cart.getShoppingContext().getShopCode(), cart.getCurrencyCode(), cart.getCustomerEmail(), cart.getShoppingContext().getCountryCode(), cart.getShoppingContext().getStateCode() ); final BigDecimal qty = QTY; final SkuPrice price = getSkuPrice(cart, carrierSlaGUID, policy, supplier, qty); if (price != null && price.getSkuPriceId() > 0L) { final BigDecimal salePrice = MoneyUtils.minPositive(price.getSalePriceForCalculation()); final BigDecimal deliveryCost = salePrice.multiply(qty).multiply(new BigDecimal(supplierBuckets.size())).setScale(Constants.MONEY_SCALE, RoundingMode.HALF_UP); for (final DeliveryBucket bucket : supplierBuckets) { cart.addShippingToCart(bucket, carrierSlaGUID, carrierSlaName, qty); cart.setShippingPrice(carrierSlaGUID, bucket, salePrice, salePrice); } final Total supplierTotal = new TotalImpl( Total.ZERO, Total.ZERO, Total.ZERO, Total.ZERO, false, null, Total.ZERO, Total.ZERO, Total.ZERO, deliveryCost, deliveryCost, false, null, Total.ZERO, deliveryCost, deliveryCost, Total.ZERO, deliveryCost, deliveryCost ); total = total == null ? supplierTotal : total.add(supplierTotal); } else { return null; } } } return total; } return null; }
<K extends Entity.Key<S>, S extends Specification> Mutation<?, ?, ?> convert(Event<K, S> event) { var converter = (Converter<?, ?, ?, ?, K, S>) converters.get(event.getKey().getClass()); if (converter == null) { throw new IllegalArgumentException("Unknown key class " + event.getKey().getClass()); } if (event instanceof SpecificationEvent) { return converter.convertSpecificationEvent((SpecificationEvent<K, S>) event); } else if (event instanceof StatusEvent) { return converter.convertStatusEvent((StatusEvent<K, S>) event); } else if (event instanceof SpecificationDeletionEvent) { return converter.convertSpecificationDeletionEvent((SpecificationDeletionEvent<K, S>) event); } else if (event instanceof StatusDeletionEvent) { throw new UnsupportedOperationException("Status deletion events are currently unsupported"); } else { throw new IllegalArgumentException("Unknown event " + event); } }
@Override public String get(String name) { checkKey( name ); String value = null; String[] keyParts = splitKey( name ); String ns = registry.getNamespaceURI( keyParts[0] ); if (ns != null) { try { XMPProperty prop = xmpData.getProperty( ns, keyParts[1] ); if (prop != null && prop.getOptions().isSimple()) { value = prop.getValue(); } else if (prop != null && prop.getOptions().isArray()) { prop = xmpData.getArrayItem( ns, keyParts[1], 1 ); value = prop.getValue(); } } catch (XMPException e) { } } return value; }
public static Filter or(org.opengis.filter.FilterFactory ff, List<Filter> filters) { if (filters == null || filters.isEmpty()) { return Filter.EXCLUDE; } else if (filters.size() == 1) { return filters.get(0); } else { return ff.or(filters); } }
@Override public synchronized ExecuteAnonResult executeAnonymous(String code) throws ApiException { return new ExecuteAnonymousOp().execute(code); }
public void updateMetadata( String eventId, TableAndStatistics sourceTable, String replicaDatabaseName, String replicaTableName, ReplicaLocationManager locationManager) { try (CloseableMetaStoreClient client = getMetaStoreClientSupplier().get()) { Optional<Table> oldReplicaTable = updateTableMetadata(client, eventId, sourceTable, replicaDatabaseName, replicaTableName, locationManager.getTableLocation(), replicationMode); if (oldReplicaTable.isPresent() && LocationUtils.hasLocation(oldReplicaTable.get()) && isUnpartitioned(oldReplicaTable.get())) { Path oldLocation = locationAsPath(oldReplicaTable.get()); String oldEventId = oldReplicaTable.get().getParameters().get(REPLICATION_EVENT.parameterName()); locationManager.addCleanUpLocation(oldEventId, oldLocation); } } }
@VisibleForTesting public static void scanSingleFileForTests(InputFile file, VisitorsBridge visitorsBridge) { scanSingleFileForTests(file, visitorsBridge, new JavaVersionImpl(), null); }
public JobUpdateResponse updateJarJob(String xProjectId, Long jobId, Integer managerSpu, String name, String desc, Integer clusterId, Integer spuNumber, Integer parallelNumber, Integer executorNumber, Integer executorSpu, Boolean logEnabled, String obsBucket, String smnTopic, File jar, String jarUrl, File config, String configUrl, String mainClass, String args) throws ApiException { ApiResponse<JobUpdateResponse> resp = updateJarJobWithHttpInfo(xProjectId, jobId, managerSpu, name, desc, clusterId, spuNumber, parallelNumber, executorNumber, executorSpu, logEnabled, obsBucket, smnTopic, jar, jarUrl, config, configUrl, mainClass, args); return resp.getData(); }
public static Color opacitizeColor(Color startingColor, float alpha) { if (alpha < 0f || alpha > 1f) { throw new IllegalArgumentException("Alpha [" + alpha + "] cannot be less than 0 or greater than 1."); } if (startingColor == null || startingColor.getAlpha() == alpha) { return startingColor; } return new Color(startingColor.getRGB() & 0xffffff | (int)(alpha * 0xff + 0.5) << 24, true); }
@Override public <T> T unwrap(Class<T> iface) throws SQLException { return Wrapper.unwrap(iface, this); }
@Override public NodePointer createNodePointer( QName name, Object bean, Locale locale) { JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); if (bi.isDynamic()) { DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler( bi.getDynamicPropertyHandlerClass()); return new DynamicPointerEx(name, bean, handler, locale); } return null; }
public Message getMessage() { return message; }
public void setTextFont(String font) { context.setFont(font); }
long getModTimestamp(String matchingTag) { long timestamp = 0; if (matchingTag == null) { return timestamp; } matchingTag = removeQuotes(matchingTag); if (LOG.isDebugEnabled()) { LOG.debug("getModTimestamp: matching tag ({})", matchingTag); } if (matchingTag.isEmpty()) { return timestamp; } try { Timestamp tagStamp = Timestamp.fromString(matchingTag); if (tagStamp == null) { throw new IllegalArgumentException("Timestamp failed"); } timestamp = tagStamp.millis(); } catch (IllegalArgumentException exc) { if (LOG.isWarnEnabled()) { LOG.warn("getModTimestamp: matching tag({}) has bad format. Return 0 by default.", matchingTag); } } return timestamp; }
public synchronized void deleteRotatedLog() throws AdsWriteFailureLogException { closeRotatedFile(); super.deleteRotatedLog(rotatedAdsWriteFailureLog); }
@Override @POST @RequiresAuthentication @RequiresPermissions("nexus:privileges:create") @Path("repository-admin") public Response createPrivilege(final ApiPrivilegeRepositoryAdminRequest privilege) { return doCreate(RepositoryAdminPrivilegeDescriptor.TYPE, privilege); }
@Override public void accept(final long input) { final KEY key = keyFunction.apply(input); invoke(key, givenKey -> { consumer.accept(input); return Long.valueOf(input); }); }
@Override public boolean accept(String keyspace) { if (keyspace.startsWith("system") && !SYSTEM_AUTH_KEYSPACE.equals(keyspace)) { return false; } KeyspaceMetadata keyspaceMetadata = myMetadata.getKeyspace(keyspace); if (keyspaceMetadata != null) { Map<String, String> replication = keyspaceMetadata.getReplication(); String replicationClass = replication.get(STRATEGY_CLASS); switch(replicationClass) { case SIMPLE_STRATEGY: return validateSimpleStrategy(replication); case NETWORK_TOPOLOGY_STRATEGY: return validateNetworkTopologyStrategy(keyspace, replication); default: LOG.warn("Replication strategy of type {} is not supported", replicationClass); break; } } return false; }
@Override public WorkLog editWorkLog(Long id, WorkLog workLog) throws BaseException { validateEditWorkLog(workLog); WorkLog workLogFromBase = workLogRepository.findWorkLogById(id); if (workLogFromBase == null) { throw new WorkLogDontExistException("Edited work log dont exists"); } return workLogRepository.updateWorkLog(new WorkLog(id, workLog.getStartDate(), workLog.getTimeSpentInSeconds(), workLogFromBase.getAssociatedWorker(), workLog.getDescription())); }
@Deprecated public void primeQuery(PrimingRequest primeRequest) throws PrimeFailedException { if (primeRequest.primeType != PrimingRequest.PrimingRequestBuilder.PrimeType.QUERY) { throw new IllegalArgumentException("Can't pass a prepared statement prime to primeQuery, use queryBuilder()"); } prime(primeRequest, primeQueryUrl); }
public static int[] unique(int[] arr) { if (arr.length < 2) { return arr; } int lastDistinctIndex = 0; int lastId = arr[0]; int[] distinctIds = new int[arr.length]; distinctIds[0] = lastId; for (int index = 1; index < arr.length;) { int id = arr[index++]; if (id != lastId) { lastId = id; distinctIds[++lastDistinctIndex] = id; } } if (lastDistinctIndex < distinctIds.length - 1) { distinctIds = Arrays.copyOf(distinctIds, lastDistinctIndex + 1); } return distinctIds; }
@Override public AndDependencyFilter transform( AndFilter filter ) { Collection<DependencyFilter> filters = new ArrayList<DependencyFilter>( filter.getFilters().size() ); for ( TransformableFilter dependencyFilter : filter.getFilters() ) { filters.add( dependencyFilter.transform( this ) ); } return new AndDependencyFilter( filters ); }
@Override public List<Attachment> listAttachByTopic(int tid) { return this.list(getAttachmentSelect()+" from Attachment a where a.topic.id=? " + "and a.isAttach=1",tid); }
void logEmrClusterCreationImpl(EmrClusterAlternateKeyDto emrClusterAlternateKeyDto, EmrClusterDefinition emrClusterDefinition, String clusterId) throws Exception { EmrClusterCreationLogEntity emrClusterCreationLogEntity = new EmrClusterCreationLogEntity(); emrClusterCreationLogEntity.setNamespace(namespaceDaoHelper.getNamespaceEntity(emrClusterAlternateKeyDto.getNamespace())); emrClusterCreationLogEntity.setEmrClusterDefinitionName(emrClusterAlternateKeyDto.getEmrClusterDefinitionName()); emrClusterCreationLogEntity.setEmrClusterName(emrClusterAlternateKeyDto.getEmrClusterName()); emrClusterCreationLogEntity.setEmrClusterId(clusterId); emrClusterCreationLogEntity.setEmrClusterDefinition(xmlHelper.objectToXml(emrClusterDefinition)); herdDao.saveAndRefresh(emrClusterCreationLogEntity); }
public String[] getExtraCalculationFields() { return reportPreProcessorCore.getExtraCalculationFields( this ); }
@Override public String format(Object value) { if (value == null) { return null; } YearPeriod yearPeriod = (YearPeriod)value; if (yearPeriod.isOneYearPeriod()) { return ""+yearPeriod.getStartYear(); } return yearPeriod.getStartYear() + "-" + yearPeriod.getEndYear(); }
static TimeSpan valueOf(final String value) { if (value.isEmpty()) { return new TimeSpan(0, TimeUnit.NANOSECONDS); } final Matcher matcher = PATTERN.matcher(value); if (!matcher.matches()) { throw new IllegalArgumentException("'" + value + "' is not a valid time span"); } final long amount = Long.parseLong(matcher.group(1)); final TimeUnit unit = fromName(matcher.group(2)); return new TimeSpan(amount, unit); }
public void afterInjection(Destroyable injectee) { registry.add(injectee); }
public static String unquote(String text) { if (text == null) { return null; } int len = text.length(); if (len < 2 || text.charAt(0) != '"' || text.charAt(len - 1) != '"') { return text; } text = text.substring(1, len - 1); return unescape(text); }
public static String generate(final String generator) { if (generator == null) { throw new IllegalArgumentException("Generator cannot be null"); } final int split = generator.indexOf(':'); if (split < 0) { return generate(generator, null); } return generate(generator.substring(0, split), generator.substring(split + 1)); }
@Nullable static String service(Invoker<?> invoker) { URL url = invoker.getUrl(); if (url == null) return null; String service = url.getServiceInterface(); return service != null && !service.isEmpty() ? service : null; }
@Override public LiveData<List<CourseEntity>> getBookmarkedCourses() { MutableLiveData<List<CourseEntity>> courseResults = new MutableLiveData<>(); remoteDataSource.getAllCourses(courseResponses -> { ArrayList<CourseEntity> courseList = new ArrayList<>(); for (CourseResponse response : courseResponses) { CourseEntity course = new CourseEntity(response.getId(), response.getTitle(), response.getDescription(), response.getDate(), false, response.getImagePath()); courseList.add(course); } courseResults.postValue(courseList); }); return courseResults; }
public MultiLangDaemonConfiguration getConfiguration(Properties properties) { properties.entrySet().forEach(e -> { try { utilsBean.setProperty(configuration, (String) e.getKey(), e.getValue()); } catch (IllegalAccessException | InvocationTargetException ex) { throw new RuntimeException(ex); } }); Validate.notBlank(configuration.getApplicationName(), "Application name is required"); Validate.notBlank(configuration.getStreamName(), "Stream name is required"); Validate.isTrue(configuration.getKinesisCredentialsProvider().isDirty(), "A basic set of AWS credentials must be provided"); return configuration; }
@Override public FilterResult runFilter(VariantEvaluation variantEvaluation) { VariantContextFilterState vcfFilterState = determineVariantContextState(variantEvaluation.getVariantContext()); if (vcfFilterState == VariantContextFilterState.PASSED || vcfFilterState == VariantContextFilterState.UNFILTERED) { return PASS; } return FAIL; }
public List<GuidedDecisionTable52> getGuidedDecisionTables() { return _dtables; }
public Collection<ViolationOccurrence> check(ClassReader classReader) throws IOException { ModernizerClassVisitor classVisitor = new ModernizerClassVisitor( javaVersion, violations, exclusions, exclusionPatterns, ignorePackages, ignoreClassNames, ignoreFullClassNamePatterns); classReader.accept(classVisitor, 0); return classVisitor.getOccurrences(); }
void parseLocation(final ApiKey apiKey, final JsonParser jParser, final List<LocationFacet> locations) throws IOException { LocationFacet locationFacet = new LocationFacet(); if (apiKey!=null) { locationFacet.apiKeyId = apiKey.getId(); locationFacet.guestId = apiKey.getGuestId(); } locationFacet.timeUpdated = System.currentTimeMillis(); locationFacet.source = LocationFacet.Source.GOOGLE_LATITUDE; do { String fieldName = jParser.getCurrentName(); final JsonToken jsonToken = jParser.nextValue(); if (jsonToken.isScalarValue()) { if (fieldName.equals("timestampMs")) { long ts = Long.valueOf(jParser.getText()); locationFacet.timestampMs = ts; locationFacet.start = ts; locationFacet.end = ts; locationFacet.api = 2; } else if (fieldName.equals("accuracy")) { int accuracy = jParser.getIntValue(); locationFacet.accuracy = accuracy; } else if (fieldName.equals("altitude")) { int altitude = jParser.getIntValue(); locationFacet.altitude = altitude; } else if (fieldName.equals("heading")) { int heading = jParser.getIntValue(); locationFacet.heading = heading; } else if (fieldName.equals("latitudeE7")) { int lat = jParser.getIntValue(); locationFacet.latitude = lat/1E7f; } else if (fieldName.equals("longitudeE7")) { int lon = jParser.getIntValue(); locationFacet.longitude = lon/1E7f; } else if (fieldName.equals("velocity")) { int speed = jParser.getIntValue(); locationFacet.speed = speed; } } else { final JsonNode junk = jParser.readValueAsTree(); logger.info("we are not interested in this junk: " + junk.toString()); } } while (jParser.nextToken() != JsonToken.END_OBJECT); locations.add(locationFacet); }
protected static SourceFiles sourceFilesFromZip(ZipFile zipFile, DescriptorLanguage.FileType workflowFileType) { DockstoreYaml10 dockstoreYml = readAndPrevalidateDockstoreYml(zipFile); final String primaryDescriptor = dockstoreYml.primaryDescriptor; List<String> testParameterFiles = dockstoreYml.testParameterFiles; if (primaryDescriptor != null) { checkWorkflowType(workflowFileType, primaryDescriptor); zipFile.stream() .filter(zipEntry -> primaryDescriptor.equals(zipEntry.getName())) .findFirst() .orElseThrow(() -> new CustomWebApplicationException("Primary descriptor missing: " + primaryDescriptor, HttpStatus.SC_BAD_REQUEST)); final List<SourceFile> sourceFiles = zipFile .stream() .filter(zipEntry -> !zipEntry.isDirectory()) .map(zipEntry -> { SourceFile sourceFile = new SourceFile(); if (testParameterFiles != null && testParameterFiles.contains(zipEntry.getName())) { sourceFile.setType(paramFileType(workflowFileType)); } else if (".dockstore.yml".equals(zipEntry.getName())) { sourceFile.setType(DescriptorLanguage.FileType.DOCKSTORE_YML); } else { sourceFile.setType(workflowFileType); } sourceFile.setPath(zipEntry.getName()); sourceFile.setAbsolutePath(addLeadingSlashIfNecessary(zipEntry.getName())); sourceFile.setContent(getContent(zipFile, zipEntry)); return sourceFile; }).collect(Collectors.toList()); return new SourceFiles( sourceFiles.stream().filter(sf -> sf.getPath().equals(primaryDescriptor)).findFirst().get(), sourceFiles); } else { throw new CustomWebApplicationException("Invalid or no primary descriptor specified in .dockstore.yml", HttpStatus.SC_BAD_REQUEST); } }
@Override public void editProperties(String itemId) { propertyViewMap.get(itemId) .forEach(this::startEditPropertyView); }
public PackageNameSearch newTopLevelPackageNamesSearch( final POM pom ) { return new PackageNameSearch( pom ); }
@Override public <T extends Document> T findByDocumentHeaderId(Class<T> documentClass, String id) { return selectAdapter(documentClass).findByDocumentHeaderId(documentClass, id); }
@Override public List<SoapEvent> readAll() { final ReadAllSoapEventOutput output = serviceProcessor.process(ReadAllSoapEventInput.builder().build()); for(SoapEvent soapEvent : output.getSoapEvents()){ final String resourceLink = generateResourceLink(soapEvent); soapEvent.setResourceLink(resourceLink); } return output.getSoapEvents(); }
@Override public boolean addTopicConfig(final String topicName, final Map<String, ?> overrides) { final ConfigResource resource = new ConfigResource(ConfigResource.Type.TOPIC, topicName); final Map<String, String> stringConfigs = toStringConfigs(overrides); try { final Map<String, String> existingConfig = topicConfig(topicName, false); final boolean changed = stringConfigs.entrySet().stream() .anyMatch(e -> !Objects.equals(existingConfig.get(e.getKey()), e.getValue())); if (!changed) { return false; } final Set<AlterConfigOp> entries = stringConfigs.entrySet().stream() .map(e -> new ConfigEntry(e.getKey(), e.getValue())) .map(ce -> new AlterConfigOp(ce, AlterConfigOp.OpType.SET)) .collect(Collectors.toSet()); final Map<ConfigResource, Collection<AlterConfigOp>> request = Collections.singletonMap(resource, entries); ExecutorUtil.executeWithRetries( () -> adminClient.get().incrementalAlterConfigs(request).all().get(), ExecutorUtil.RetryBehaviour.ON_RETRYABLE); return true; } catch (final UnsupportedVersionException e) { return addTopicConfigLegacy(topicName, stringConfigs); } catch (final Exception e) { throw new KafkaResponseGetFailedException( "Failed to set config for Kafka Topic " + topicName, e); } }
public Location getLastLocation(Player player) { PlayerAuth auth = playerCache.getAuth(player.getName()); if (auth != null) { return new Location(Bukkit.getWorld(auth.getWorld()), auth.getQuitLocX(), auth.getQuitLocY(), auth.getQuitLocZ()); } return null; }
protected void notifyLoadingFinished(@NonNull final String webUrl) { if (contentLoadingListener != null) contentLoadingListener.onLoadingFinished(webUrl); }
@Override public void configure(ContainerSpecification container) throws IOException { if(ugi != null) { container.getEnvironmentVariables().put("HADOOP_USER_NAME", ugi.getUserName()); } }
@Override public void marshall(Event event, OutputStream destination) throws IOException { destination = new UncloseableOutputStream(destination); if (compression) { destination = new GZIPOutputStream(destination); } try (JsonGenerator generator = createJsonGenerator(destination)) { writeContent(generator, event); } catch (IOException e) { logger.error("An exception occurred while serialising the event.", e); } finally { try { destination.close(); } catch (IOException e) { logger.error("An exception occurred while serialising the event.", e); } } }
@Override public void enableSendStompMessage(Integer taskId, SimpMessagingTemplate messagingTemplate, String destinationPrefix) { Assert.notNull(taskId, "taskId 不能为空"); this.sendMessage = true; this.taskId = taskId; this.destinationPrefix = destinationPrefix; this.simpMessagingTemplate = messagingTemplate; }
public static List<DateTime> dateTimesForStartOfMonthBetweenDates(final DateTime start, final DateTime end) { final List<DateTime> results = Lists.newArrayList(); DateTime currDateTime = start.withDayOfMonth(1).withTimeAtStartOfDay(); while (!currDateTime.isAfter(end)) { results.add(currDateTime); currDateTime = currDateTime.plusMonths(1); } return results; }
public static Matcher<String> isJsonStringMatching(final Matcher<JsonNode> matcher) { return new IsJsonStringMatching(matcher); }
public void write(int n, long v) { if (n < 1 || n > 64) { throw new IllegalArgumentException( String.format("Unable to write %s bits to value %d", n, v)); } reserve(n); long v1 = v << 64 - n >>> shift; data[index] = data[index] | v1; shift += n; if (shift >= 64) { shift -= 64; index++; if (shift != 0) { long v2 = v << 64 - shift; data[index] = data[index] | v2; } } }
@VisibleForTesting static GoogleCloudStorageOptions.Builder getGcsOptionsBuilder(Configuration config) { String projectId = GCS_PROJECT_ID.get(config, config::get); return GoogleCloudStorageOptions.builder() .setStorageRootUrl(GCS_ROOT_URL.get(config, config::get)) .setStorageServicePath(GCS_SERVICE_PATH.get(config, config::get)) .setAutoRepairImplicitDirectoriesEnabled( GCS_REPAIR_IMPLICIT_DIRECTORIES_ENABLE.get(config, config::getBoolean)) .setInferImplicitDirectoriesEnabled( GCS_INFER_IMPLICIT_DIRECTORIES_ENABLE.get(config, config::getBoolean)) .setCopyWithRewriteEnabled(GCS_COPY_WITH_REWRITE_ENABLE.get(config, config::getBoolean)) .setMaxBytesRewrittenPerCall(GCS_REWRITE_MAX_BYTES_PER_CALL.get(config, config::getLong)) .setCopyMaxRequestsPerBatch(GCS_COPY_MAX_REQUESTS_PER_BATCH.get(config, config::getLong)) .setCopyBatchThreads(GCS_COPY_BATCH_THREADS.get(config, config::getInt)) .setTransportType( HTTP_TRANSPORT_SUFFIX.withPrefixes(CONFIG_KEY_PREFIXES).get(config, config::getEnum)) .setProxyAddress( PROXY_ADDRESS_SUFFIX.withPrefixes(CONFIG_KEY_PREFIXES).get(config, config::get)) .setProxyUsername( RedactedString.create( PROXY_USERNAME_SUFFIX.withPrefixes(CONFIG_KEY_PREFIXES).getPassword(config))) .setProxyPassword( RedactedString.create( PROXY_PASSWORD_SUFFIX.withPrefixes(CONFIG_KEY_PREFIXES).getPassword(config))) .setProjectId(projectId) .setMaxListItemsPerCall(GCS_MAX_LIST_ITEMS_PER_CALL.get(config, config::getLong)) .setMaxRequestsPerBatch(GCS_MAX_REQUESTS_PER_BATCH.get(config, config::getLong)) .setBatchThreads(GCS_BATCH_THREADS.get(config, config::getInt)) .setMaxHttpRequestRetries(GCS_HTTP_MAX_RETRY.get(config, config::getInt)) .setHttpRequestConnectTimeout(GCS_HTTP_CONNECT_TIMEOUT.get(config, config::getInt)) .setHttpRequestReadTimeout(GCS_HTTP_READ_TIMEOUT.get(config, config::getInt)) .setAppName(getApplicationName(config)) .setMaxWaitMillisForEmptyObjectCreation( GCS_MAX_WAIT_MILLIS_EMPTY_OBJECT_CREATE.get(config, config::getInt)) .setReadChannelOptions(getReadChannelOptions(config)) .setWriteChannelOptions(getWriteChannelOptions(config)) .setRequesterPaysOptions(getRequesterPaysOptions(config, projectId)) .setCooperativeLockingOptions(getCooperativeLockingOptions(config)) .setHttpRequestHeaders(GCS_HTTP_HEADERS.getPropsWithPrefix(config)) .setEncryptionAlgorithm(GCS_ENCRYPTION_ALGORITHM.get(config, config::get)) .setEncryptionKey(RedactedString.create(GCS_ENCRYPTION_KEY.getPassword(config))) .setEncryptionKeyHash(RedactedString.create(GCS_ENCRYPTION_KEY_HASH.getPassword(config))) .setGrpcEnabled(GCS_GRPC_ENABLE.get(config, config::getBoolean)); }
public String getInputPath() { return inputPath; }
public static String forwardProxyAuthenticationUsername() { return readPropertyHierarchically(MOCKSERVER_FORWARD_PROXY_AUTHENTICATION_USERNAME, "MOCKSERVER_FORWARD_PROXY_AUTHENTICATION_USERNAME", null); }
public MediaType detect(InputStream input, Metadata metadata) throws IOException { if (input == null) { return MediaType.OCTET_STREAM; } input.mark(offsetRangeEnd + length); try { int offset = 0; while (offset < offsetRangeBegin) { long n = input.skip(offsetRangeBegin - offset); if (n > 0) { offset += n; } else if (input.read() != -1) { offset += 1; } else { return MediaType.OCTET_STREAM; } } byte[] buffer = new byte[length + (offsetRangeEnd - offsetRangeBegin)]; int n = input.read(buffer); if (n > 0) { offset += n; } while (n != -1 && offset < offsetRangeEnd + length) { int bufferOffset = offset - offsetRangeBegin; n = input.read( buffer, bufferOffset, buffer.length - bufferOffset); if (n > 0) { offset += n; } } if (this.isRegex) { int flags = 0; if (this.isStringIgnoreCase) { flags = Pattern.CASE_INSENSITIVE; } Pattern p = Pattern.compile(new String(this.pattern, UTF_8), flags); ByteBuffer bb = ByteBuffer.wrap(buffer); CharBuffer result = ISO_8859_1.decode(bb); Matcher m = p.matcher(result); boolean match = false; for (int i = 0; i <= offsetRangeEnd - offsetRangeBegin; i++) { m.region(i, length+i); match = m.lookingAt(); if (match) { return type; } } } else { if (offset < offsetRangeBegin + length) { return MediaType.OCTET_STREAM; } for (int i = 0; i <= offsetRangeEnd - offsetRangeBegin; i++) { boolean match = true; int masked; for (int j = 0; match && j < length; j++) { masked = (buffer[i + j] & mask[j]); if (this.isStringIgnoreCase) { masked = Character.toLowerCase(masked); } match = (masked == pattern[j]); } if (match) { return type; } } } return MediaType.OCTET_STREAM; } finally { input.reset(); } }
public Denormalization denormalization(String docType) { return denormalizations.get(docType); }
public String run(final LpadWorkerExchange<DeleteProfileInputParams> lpadWorkerExchange) { inputValidation(lpadWorkerExchange == null, "Input params to invoke Delete Profile must not be null"); inputValidation(lpadWorkerExchange.getBody() == null, "Input params must have body defined"); inputValidation(StringUtils.isBlank(lpadWorkerExchange.getBody().getIccid()), "ICCID must not be null/empty"); String iccid = lpadWorkerExchange.getBody().getIccid(); String eResponse = transmitDeleteProfile(iccid, progress); return convertDeleteProfile(iccid, progress, eResponse); }
long getMaxRate() { return rateWindow.getMaxRate(); }
public Map<CountryCode, String> getCountryCodes() { Map<CountryCode, String> codes = new HashMap<>(); COUNTRY_CODES.forEach(c -> codes.put(c, c.getName())); return TppData.sortMapByValue(codes); }
public ConsentEntity migrateIfNeeded(ConsentEntity consentEntity) { if (consentEntity.getData() == null) { Optional<AisConsent> obsoleteAisConsentOptional = obsoleteAisConsentJpaRepository.findByExternalId(consentEntity.getExternalId()); if (obsoleteAisConsentOptional.isPresent()) { byte[] consentData = getConsentData(obsoleteAisConsentOptional.get()); consentEntity.setData(consentData); consentJpaRepository.save(consentEntity); } } return consentEntity; }
@Override public void setValue(final TaskEventSummary model) { logSummary.setModel(model); final TaskEventType type = TaskEventType.valueOf(model.getType()); final String logString = constants.Task() + " " + translationService.format(type.getTypeTranslationId()).toLowerCase(); setLogTime(model.getLogTime()); setLogIcon(type, logString); setLogInfo(type, model); setLogType(logString); }
public boolean registerUserWithCertificate(RegisterUserWithCertificate obj) { boolean isUserRegistered = false; log.debug("target: {}", getTarget().getUri().toString()); Object result = getTarget().path("rpc/register-user-with-certificate").request().accept(MediaType.APPLICATION_JSON).post(Entity.json(obj), Object.class); if (result.getClass().equals(LinkedHashMap.class)) { LinkedHashMap resultMap = (LinkedHashMap)result; if (resultMap.containsKey("result")) { isUserRegistered = Boolean.parseBoolean(resultMap.get("result").toString().trim()); log.debug("Result of user registration with certificate is {}.", isUserRegistered); } } return isUserRegistered; }
protected void installAcl(Set<AceBean> aceBeanSetFromConfig, String path, Set<String> principalsInConfiguration, Session session, InstallationLogger installLog) throws RepositoryException { boolean hadPendingChanges = session.hasPendingChanges(); int countDeleted = 0; int countAdded = 0; int countNoChange = 0; int countOutsideConfig = 0; StringBuilder diffLog = new StringBuilder(); aceBeanSetFromConfig = transformActionsIntoPrivileges(aceBeanSetFromConfig, session, installLog); aceBeanSetFromConfig = filterInitialContentOnlyNodes(aceBeanSetFromConfig); aceBeanSetFromConfig = filterDuplicates(aceBeanSetFromConfig, session); List<AceBean> configuredAceEntries = new ArrayList<AceBean>(aceBeanSetFromConfig); int currentPositionConfig = 0; boolean changeHasBeenFound = false; AccessControlManager acMgr = session.getAccessControlManager(); JackrabbitAccessControlList acl = getAccessControlList(acMgr, path); Iterator<AccessControlEntry> aceIt = Arrays.asList(acl.getAccessControlEntries()).iterator(); while (aceIt.hasNext()) { AccessControlEntry ace = aceIt.next(); AceBean actualAceBean = AcHelper.getAceBean(ace, acl); String acePrincipalName = actualAceBean.getPrincipalName(); String actualAceBeanCompareStr = toAceCompareString(actualAceBean, acMgr); if (!principalsInConfiguration.contains(acePrincipalName)) { countOutsideConfig++; diffLog.append(" OUTSIDE (not in Config) " + actualAceBeanCompareStr + "\n"); continue; } AceBean configuredAceAtThisLocation; if (currentPositionConfig < configuredAceEntries.size()) { configuredAceAtThisLocation = configuredAceEntries.get(currentPositionConfig); } else { changeHasBeenFound = true; configuredAceAtThisLocation = null; } String configuredAceAtThisLocationCompareStr = toAceCompareString(configuredAceAtThisLocation, acMgr); boolean dumpEqualToConfig = StringUtils.equals(actualAceBeanCompareStr, configuredAceAtThisLocationCompareStr); if (!changeHasBeenFound && !dumpEqualToConfig) { String configBeanStr = configuredAceAtThisLocationCompareStr; diffLog.append("<<< CHANGE (Repo Version) " + actualAceBeanCompareStr + "\n>>> CHANGE (Config Version) " + configBeanStr + "\n"); } if (changeHasBeenFound || !dumpEqualToConfig) { changeHasBeenFound = true; acl.removeAccessControlEntry(ace); countDeleted++; diffLog.append(" DELETED (from Repo) " + actualAceBeanCompareStr + "\n"); continue; } currentPositionConfig++; countNoChange++; diffLog.append(" UNCHANGED " + actualAceBeanCompareStr + "\n"); } for (int i = currentPositionConfig; i < configuredAceEntries.size(); i++) { AceBean aceBeanToAppend = configuredAceEntries.get(i); installPrivileges(aceBeanToAppend, new PrincipalImpl(aceBeanToAppend.getPrincipalName()), acl, session, acMgr); diffLog.append(" APPENDED (from Config) " + toAceCompareString(aceBeanToAppend, acMgr) + "\n"); countAdded++; } if (countAdded > 0 || countDeleted > 0) { acMgr.setPolicy(StringUtils.isNotBlank(path) ? path : null, acl); installLog.incCountAclsChanged(); installLog.addVerboseMessage(LOG, "Update result at path " + path + ": O=" + countOutsideConfig + " N=" + countNoChange + " D=" + countDeleted + " A=" + countAdded + (LOG.isDebugEnabled() ? "\nDIFF at " + path + "\n" + diffLog : "")); } else { installLog.incCountAclsNoChange(); } if (!hadPendingChanges) { if (session.hasPendingChanges()) { hadPendingChanges = true; installLog.addMessage(LOG, "Path " + path + " introduced pending changes to the session"); } } }
@Override public V get(final K key) { Objects.requireNonNull(key); final List<ReadOnlyKeyValueStore<K, V>> stores = storeProvider.stores(storeName, storeType); for (final ReadOnlyKeyValueStore<K, V> store : stores) { try { final V result = store.get(key); if (result != null) { return result; } } catch (final InvalidStateStoreException e) { throw new InvalidStateStoreException("State store is not available anymore and may have been migrated to another instance; please re-discover its location from the state metadata."); } } return null; }
@Override public void onPhaseExit() { torrentClient.getTrackersFor(torrent).forEach(tracker -> tracker.getInfo(torrent).get().setEvent(TrackerEvent.EVENT_COMPLETED)); LOGGER.info("Download of {} completed", torrent); }
long nextBackoff() { int jitter = mJitterMillis == 0 ? 0 : mRandom.nextInt(mJitterMillis); long backoff = mCurrentBackoffDurationMillis + (long) jitter; mCurrentBackoffDurationMillis <<= 1; if (mCurrentBackoffDurationMillis > mMaxBackoffMillis) { mCurrentBackoffDurationMillis = mMaxBackoffMillis; } return backoff; }
public void addConnectionFactory(final String key, final ConnectionFactory connectionFactory) { addConnectionFactory(key, connectionFactory, null, null); }
public static <E> boolean intersects(Collection<E> c0, Collection<E> c1) { for (E e : c1) { if (c0.contains(e)) { return true; } } return false; }
public static boolean eval(Condition condition, @Nullable Object json, @Nullable Intrinsics intrinsics) { return condition.visit(new ConditionEvaluator(intrinsics), json); }
@Override public UnitOfMeasure translate() { if (this.unitOfMeasure == null || this.unitOfMeasure.isEmpty()) { return UnitOfMeasure.WATT_HOUR; } UnitOfMeasure result; switch (this.unitOfMeasure) { case "Wh": result = UnitOfMeasure.WATT_HOUR; break; case "kWh": result = UnitOfMeasure.KILOWATT_HOUR; break; case "varh": result = UnitOfMeasure.VAR_HOUR; break; case "kvarh": result = UnitOfMeasure.KILOVAR_HOUR; break; case "W": result = UnitOfMeasure.WATT; break; case "kW": result = UnitOfMeasure.KILOWATT; break; case "var": result = UnitOfMeasure.VAR; break; case "kvar": result = UnitOfMeasure.KILOVAR; break; case "Amp": result = UnitOfMeasure.AMPERES; break; case "Volt": result = UnitOfMeasure.VOLTAGE; break; case "Celsius": result = UnitOfMeasure.CELSIUS; break; default: throw new AssertionError(String.format("Unknown value for UnitOfMeasure: '%s'", this.unitOfMeasure)); } return result; }
public boolean isStandalone() { return config.getStandalone(); }
@Override public boolean acceptable(int maxStartOffset, int minEndOffset) { if (!updateSegmenter(maxStartOffset)) { return false; } minEndOffset -= lastStartOffset; if (minEndOffset > segmenter.length || inSegmenterStartOffset < 0) { return false; } return segmenter.segmenter.acceptable(inSegmenterStartOffset, minEndOffset); }
@Override public void stop() throws Throwable { stopped = true; handler.stop(); job.stop(); }
@Override public <T> Optional<T> sanitize(T entity) { T sanitized = entitySanitizer.sanitize(entity).orElse(entity); if (sanitized instanceof com.netflix.titus.api.jobmanager.model.job.JobDescriptor) { sanitized = (T) sanitizeJobDescriptor((JobDescriptor) sanitized); } return entity == sanitized ? Optional.empty() : Optional.of(sanitized); }
@Override public String toQueryString() { return getPropNameWithAlias() + " is not null"; }
@Experimental public static Read read() { return Read.create(); }
public static <T, K, U> Map<K, U> simpleToLinkedMap( List<T> list, Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper) { if (list == null || list.isEmpty()) { return Collections.emptyMap(); } return list.stream().collect(toMap(keyMapper, valueMapper, throwingMerger(), LinkedHashMap::new)); }
protected RequestDetails getRequestDetails(String requestId) throws IOException { if (requestId != null && !requestId.isEmpty()) { InfraActiveRequests activeRequest = this.getInfraActiveRequest(requestId); String requestBody = activeRequest.getRequestBody().replaceAll("\\\\", ""); objectMapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true); objectMapper.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, true); return objectMapper.readValue(requestBody, RequestDetails.class); } else { return null; } }
public static TypeToken<?> getTypeParameter(TypeToken<?> type, int index) { Preconditions.checkArgument( type.getType() instanceof ParameterizedType, "type is not parameterized"); Type[] typeArgs = ((ParameterizedType) type.getType()).getActualTypeArguments(); if (typeArgs.length <= index) { throw new IndexOutOfBoundsException( String.format("type '%s' has %d <= %d type arguments", type, typeArgs.length, index)); } return type.resolveType(typeArgs[index]); }
public String clean(String value) { value = sub.clean(value); if (value == null || value.equals("")) return value; String[] tokens = StringUtils.split(value); for (int ix = 0; ix < tokens.length; ix++) { String mapsto = mapping.get(tokens[ix]); if (mapsto != null) tokens[ix] = mapsto; } return StringUtils.join(tokens); }
@Override protected void resolveDataPolicy(RegionFactory<K, V> regionFactory, Boolean persistent, DataPolicy dataPolicy) { if (dataPolicy == null) { dataPolicy = isPersistent() ? DataPolicy.PERSISTENT_REPLICATE : DataPolicy.REPLICATE; } else if (DataPolicy.EMPTY.equals(dataPolicy)) { dataPolicy = DataPolicy.EMPTY; } else { Assert.isTrue(dataPolicy.withReplication(), String.format( "Data Policy [%s] is not supported in Replicated Regions.", dataPolicy)); } RegionUtils.assertDataPolicyAndPersistentAttributeAreCompatible(dataPolicy, persistent); regionFactory.setDataPolicy(dataPolicy); setDataPolicy(dataPolicy); }
public TranslatedIRODSGenQuery getTranslatedQuery(final IRODSGenQuery irodsQuery) throws JargonQueryException, JargonException { List<String> selects = parseSelectsIntoListOfNames(irodsQuery.getQueryString()); boolean isDistinct = true; if (doesQueryFlagNonDistinct(irodsQuery.getQueryString())) { isDistinct = false; } List<GenQuerySelectField> translatedSelects = translateSelects(selects); List<TranslatedGenQueryCondition> translatedConditions = translateConditions(irodsQuery); reviewTranslationBeforeReturningQuery(translatedSelects, translatedConditions); return TranslatedIRODSGenQuery.instance(translatedSelects, translatedConditions, irodsQuery, isDistinct); }
static Type judgeEvaluationType(Params params) { Type type; if (params.contains(MultiEvaluationParams.PREDICTION_DETAIL_COL)) { type = Type.PRED_DETAIL; } else if (params.contains(MultiEvaluationParams.PREDICTION_COL)) { type = Type.PRED_RESULT; } else { throw new IllegalArgumentException("Error Input, must give either predictionCol or predictionDetailCol!"); } return type; }
@Override public Map<String, String> findActionByRoute(final String routeId) { ActionRoutingTable localTable = localData(); Map<String, String> rpcMap = new HashMap<>(getActionMemberMapByAction(localTable, routeId, LOCAL_CONSTANT)); Map<Address, Bucket<ActionRoutingTable>> buckets = remoteBuckets(); for (Map.Entry<Address, Bucket<ActionRoutingTable>> entry : buckets.entrySet()) { ActionRoutingTable table = entry.getValue().getData(); rpcMap.putAll(getActionMemberMapByAction(table, routeId, entry.getKey().toString())); } log.debug("list of Actions {} searched by route {}", rpcMap, routeId); return rpcMap; }
static boolean enableBasicAuth(String authMethod) { return RestConfig.AUTHENTICATION_METHOD_BASIC.equals(authMethod); }
protected void doDetermineAndSetFinalSpanName( @NotNull Span span, @Nullable REQ request, @Nullable RES response, @Nullable Throwable error, @NotNull HttpTagAndSpanNamingAdapter<REQ, RES> adapter ) { String finalSpanName = adapter.getFinalSpanName(request, response); if (StringUtils.isNotBlank(finalSpanName)) { SpanMutator.changeSpanName(span, finalSpanName); } }
@Udf public String rpad( @UdfParameter(description = "String to be padded") final String input, @UdfParameter(description = "Target length") final Integer targetLen, @UdfParameter(description = "Padding string") final String padding) { if (input == null) { return null; } if (padding == null || padding.isEmpty() || targetLen == null || targetLen < 0) { return null; } final StringBuilder sb = new StringBuilder(targetLen + padding.length()); sb.append(input); final int padChars = Math.max(targetLen - input.length(), 0); for (int i = 0; i < padChars; i += padding.length()) { sb.append(padding); } sb.setLength(targetLen); return sb.toString(); }
public static G1Point fromBytesCompressed(Bytes bytes) { checkArgument( bytes.size() == fpPointSize, "Expected %s bytes but received %s.", fpPointSize, bytes.size()); byte[] xBytes = bytes.toArray(); boolean aIn = (xBytes[0] & (byte) (1 << 5)) != 0; boolean bIn = (xBytes[0] & (byte) (1 << 6)) != 0; boolean cIn = (xBytes[0] & (byte) (1 << 7)) != 0; xBytes[0] &= (byte) 31; if (!cIn) { throw new IllegalArgumentException("The serialized input does not have the C flag set."); } if (bIn) { if (!aIn && Bytes.wrap(xBytes).isZero()) { return new G1Point(); } else { throw new IllegalArgumentException( "The serialized input has B flag set, but A flag is set, or X is non-zero."); } } BIG xBig = BIG.fromBytes(xBytes); BIG modulus = new BIG(ROM.Modulus); if (BIG.comp(modulus, xBig) <= 0) { throw new IllegalArgumentException("X coordinate is too large."); } ECP point = new ECP(xBig); if (point.is_infinity()) { throw new IllegalArgumentException("X coordinate is not on the curve."); } if (!isInGroup(point)) { throw new IllegalArgumentException("The deserialized point is not in the G1 subgroup."); } if (aIn != calculateYFlag(point.getY())) { FP x = new FP(point.getX()); FP yneg = new FP(point.getY()); yneg.neg(); point = new ECP(x.redc(), yneg.redc()); } return new G1Point(point); }
@Override @Transactional() public Passenger findPassengerOnFlight(Flight f, PassengerVo pvo) { if (isNull(f.getId())) { return null; } Set<Passenger> passengerSet; Passenger existingPassenger = null; Long flightId = f.getId(); String firstName = pvo.getFirstName(); String lastName = pvo.getLastName(); Date dob = pvo.getDob(); String gender = pvo.getGender(); String recordLocator = pvo.getPnrRecordLocator(); String ref = pvo.getPnrReservationReferenceNumber(); List<DocumentVo> documentVo = pvo.getDocuments(); boolean newPaxHasRecordLocator = !isNull(recordLocator); boolean newPaxHasRef = !isNull(ref); boolean newPaxHasGender = !isNull(gender); boolean newPaxHasDob = !isNull(dob); boolean newPaxHasDocument = !CollectionUtils.isEmpty(documentVo); boolean foundPassenger = false; if (newPaxHasRecordLocator && newPaxHasRef) { passengerSet = passengerRepository.getPassengerUsingREF(flightId, ref, recordLocator); foundPassenger = !CollectionUtils.isEmpty(passengerSet); existingPassenger = foundPassenger ? passengerSet.iterator().next() : null; } passengerSet = passengerRepository.returnAPassengerFromParameters(flightId, firstName, lastName); if (!foundPassenger && !CollectionUtils.isEmpty(passengerSet)) { if (newPaxHasGender && newPaxHasDob) { String passengerIdTag = createPassengerIdTag(pvo); for (Passenger pax : passengerSet) { if (pax.getPassengerIDTag() != null) { String paxIdTag = pax.getPassengerIDTag().getIdTag(); if (paxIdTag.equals(passengerIdTag)) { existingPassenger = pax; foundPassenger = true; } } } } if (!foundPassenger && allowLoosenResolution) { if (newPaxHasDocument && newPaxHasDob) { for (Passenger pax : passengerSet) { if (haveSameDocument(pax, pvo) && haveSameDateOfBirth(pax, pvo)) { existingPassenger = pax; foundPassenger = true; break; } } } if (!foundPassenger && newPaxHasDocument && newPaxHasGender) { for (Passenger pax : passengerSet) { if (haveSameDocument(pax, pvo) && haveSameGender(pax, pvo)) { existingPassenger = pax; foundPassenger = true; break; } } } if (!foundPassenger && newPaxHasDocument) { for (Passenger pax : passengerSet) { if (haveSameDocument(pax, pvo)) { existingPassenger = pax; foundPassenger = true; break; } } } if (!foundPassenger && newPaxHasDob) { for (Passenger pax : passengerSet) { if (haveSameDateOfBirth(pax, pvo)) { existingPassenger = pax; break; } } } if (!foundPassenger && newPaxHasGender) { for (Passenger pax : passengerSet) { if (haveSameGender(pax, pvo) && isNull(pax.getPassengerDetails().getDob()) && isNull(pax.getDocuments())) { existingPassenger = pax; break; } } } if (!foundPassenger) { for (Passenger pax : passengerSet) { if (isNull(pax.getPassengerDetails().getDob()) && isNull(pax.getPassengerDetails().getGender()) && isNull(pax.getDocuments())) { existingPassenger = pax; } } } } } return existingPassenger; }
@Nullable public Integer getFeatureVariableInteger(@Nonnull String featureKey, @Nonnull String variableKey, @Nonnull String userId) { return getFeatureVariableInteger(featureKey, variableKey, userId, Collections.<String, String>emptyMap()); }
public static ResponseEntity<Problem> fallback( final Problem problem, final HttpHeaders headers) { return ResponseEntity .status(HttpStatus.valueOf(Optional.ofNullable(problem.getStatus()) .orElse(Status.INTERNAL_SERVER_ERROR) .getStatusCode())) .headers(headers) .contentType(PROBLEM) .body(problem); }
@Override public final String getRestMethodName() { return HTTP_METHOD_NAME; }
@Override public <T> FileLineIterator<T> execute(String fileName, Class<T> clazz) { FixedFileLineIterator<T> fileLineIterator = new FixedFileLineIterator<T>( fileName, clazz, getColumnParserMap()); return fileLineIterator; }
@NotNull public List<? extends TextChange> getChanges() { return myChanges; }
public void refresh() { if (mKeyword != null && mDateRange != null) { refresh(mKeyword, mDateRange, mIsSortByDate); } else { mSearchView.hideSwipeRefresh(); } }
public static void main(String[] args) { Log.ensureInitalization(); if (args.length != 1) { Log.error("0xEE744 Please specify only one single path to the input model."); return; } Log.info("SM2 DSL Tool", "SM2Tool"); Log.info("------------------", "SM2Tool"); String model = args[0]; final ASTAutomaton ast = parse(model); Log.info(model + " parsed successfully!", "SM2Tool"); SM2ArtifactScope modelTopScope = createSymbolTable(ast); Optional<StateSymbol> aSymbol = modelTopScope.resolveState("Ping"); if (aSymbol.isPresent()) { Log.info("Resolved state symbol \"Ping\"; FQN = " + aSymbol.get().toString(), "SM2Tool"); } runDefaultCoCos(ast); SM2CoCoChecker customCoCos = new SM2CoCoChecker(); customCoCos.addCoCo(new StateNameStartsWithCapitalLetter()); customCoCos.checkAll(ast); CountStates cs = new CountStates(); cs.handle(ast); Log.info("The model contains " + cs.getCount() + " states.", "SM2Tool"); PrettyPrinter pp = new PrettyPrinter(); pp.handle(ast); Log.info("Pretty printing the parsed sm2 into console:", "SM2Tool"); Log.println(pp.getResult()); }
@Override public boolean trySplitAtPosition(Long splitOffset) { return trySplitAtPosition(splitOffset.longValue()); }
public void playCard(Player opponent) { Move move = strategy.nextMove(mana, health, hand); Optional<Card> card = move.getCard(); if (card.isPresent()) { playCard(card.get(), opponent, move.getAction()); } else { throw new IllegalMoveException("No card can be played from hand " + hand + " with (" + mana + ") mana."); } }
public static String avroDestination(String pathToDestinationFolder, String eventId, String tableLocation) { checkArgument(isNotBlank(pathToDestinationFolder), "There must be a pathToDestinationFolder provided"); checkArgument(isNotBlank(eventId), "There must be a eventId provided"); pathToDestinationFolder = appendForwardSlashIfNotPresent(pathToDestinationFolder); eventId = appendForwardSlashIfNotPresent(eventId); if (tableLocation != null && pathToDestinationFolder.equals(appendForwardSlashIfNotPresent(tableLocation))) { return pathToDestinationFolder + eventId + ".schema"; } return pathToDestinationFolder + eventId; }
public static double distanceSq(double x1, double y1, double x2, double y2) { x2 -= x1; y2 -= y1; return x2 * x2 + y2 * y2; }
@Override public Document parseDom(String source) throws GadgetException { return parseDomImpl(source); }
@Override protected boolean permittedTopology(DimensionInfo sourceDimensionInfo, DimensionInfo targetDimensionInfo) { return sourceDimensionInfo.isArea() && targetDimensionInfo.isArea(); }
public static List<WordChunk> getWordChunks(String string) { string = string.replaceAll("\\s+", " "); for (char c : SENTENCE_ENDING_INTERPUNCTIONS.toCharArray()) { string = string.replace(" " + c, "" + c); } ArrayList<WordChunk> res = new ArrayList<>(); String[] parts = string.split("\\s+"); for (int i = 0; i < parts.length; i++) { String part = parts[i]; String word = getWord(part); if (res.size() > 0 && StringUtils.isEmpty(word)) { res.get(res.size() - 1).chunk += " " + part; } else { res.add(new WordChunk(part, word)); } } WordChunk firstChunk = res.get(0); if (res.size() > 1 && StringUtils.isEmpty(firstChunk.word)) { res.remove(0); res.get(0).chunk = firstChunk.chunk + " " + res.get(0).chunk; } return res; }
@Override public void stopAtOnce(String namespace, String jobName) throws SaturnJobConsoleException { JobStatus jobStatus = getJobStatus(namespace, jobName); if (!JobStatus.STOPPING.equals(jobStatus)) { throw new SaturnJobConsoleException(ERROR_CODE_BAD_REQUEST, String.format("该作业(%s)不处于STOPPING状态，不能立即终止", jobName)); } List<String> jobServerList = getJobServerList(namespace, jobName); if (jobServerList != null && !jobServerList.isEmpty()) { CuratorFrameworkOp curatorFrameworkOp = registryCenterService.getCuratorFrameworkOp(namespace); for (String executorName : jobServerList) { String path = JobNodePath.getStopOneTimePath(jobName, executorName); if (curatorFrameworkOp.checkExists(path)) { curatorFrameworkOp.delete(path); } curatorFrameworkOp.create(path); log.info("stopAtOnce namespace:{}, jobName:{}, executorName:{}", namespace, jobName, executorName); } } else { throw new SaturnJobConsoleException(ERROR_CODE_BAD_REQUEST, String.format("没有executor接管该作业(%s)，不能立即终止", jobName)); } }
@Override public boolean processOrderModificationMessages(final PaymentTransactionType paymentTransactionType) { boolean success = true; final List<WorldpayOrderModificationModel> orderModificationsByType = orderModificationDao.findUnprocessedOrderModificationsByType(paymentTransactionType); for (final WorldpayOrderModificationModel orderModificationModel : orderModificationsByType) { final String worldpayOrderCode = orderModificationModel.getWorldpayOrderCode(); if (REFUSED.equals(paymentTransactionType)) { LOG.info(format("Marking order modification with [{0}] transaction for refused worldpayOrder [{1}] as processed", paymentTransactionType, worldpayOrderCode)); worldpayOrderNotificationHandler.setNonDefectiveAndProcessed(orderModificationModel); } else { success = precessOrderModificationsMessagesNotRefused(paymentTransactionType, orderModificationModel, worldpayOrderCode); } } return success; }
List<FieldSet> getOrderedFieldSets(Document document) { Set<Multimap<String,String>> fieldSets = getFieldSets(document); List<FieldSet> orderedFieldSets = new ArrayList<>(fieldSets.size()); for (Multimap<String,String> fieldSet : fieldSets) { FieldSet orderedFieldSet = new FieldSet(); for (String field : fieldSet.keySet()) { List<String> values = new ArrayList<>(fieldSet.get(field)); Collections.sort(values); String value = Joiner.on(',').join(values); orderedFieldSet.put(field, value); } orderedFieldSets.add(orderedFieldSet); } Collections.sort(orderedFieldSets); return orderedFieldSets; }
@Override public List<Token> tokenize(String text) { return createTokenList(text); }
boolean isForbiddenType(ContentType type) { String fullType = type.toString(false); for (String _type : BLACKLISTED_CONTENT_TYPES) { if (_type.equalsIgnoreCase(fullType)) { return true; } } return false; }
@Override protected void findMovableRows(final GridWidget view, final BaseGridRendererHelper.RenderingInformation renderingInformation, final double cx, final double cy) { super.findMovableRows(view, renderingInformation, cx, cy); if (view instanceof HasRowDragRestrictions) { final HasRowDragRestrictions hasRowDragRestrictions = (HasRowDragRestrictions) view; if (!hasRowDragRestrictions.isRowDragPermitted(state)) { state.reset(); layer.getViewport().getElement().getStyle().setCursor(state.getCursor()); } } }
@Override public void updateManualFetchFabStatus(boolean isDisplayingList, boolean isFavoriteList) { if (isDisplayingList) { mView.updateManualFetchFabStatus(!isFavoriteList); } else { mView.updateManualFetchFabStatus(false); } }
public static byte[] toByteArray(final HttpEntity entity) throws IOException { Args.notNull(entity, "HttpEntity"); final int contentLength = toContentLength((int) Args.checkContentLength(entity)); try (final InputStream inStream = entity.getContent()) { if (inStream == null) { return null; } final ByteArrayBuffer buffer = new ByteArrayBuffer(contentLength); final byte[] tmp = new byte[DEFAULT_BYTE_BUFFER_SIZE]; int l; while ((l = inStream.read(tmp)) != -1) { buffer.append(tmp, 0, l); } return buffer.toByteArray(); } }
@Override public void validate(CacheElementOperation operation, Region config) throws IllegalArgumentException { switch (operation) { case UPDATE: case CREATE: validateCreate(config); break; case DELETE: validateDelete(config); default: } }
@Override public void deleteRow() throws SQLException { notClosed(); noUpdates(); }
public int size() { return colors.size(); }
public void updateRepository(RepositoryConfig config) throws IOException, RepositoryException { String baseURI = Protocol.getRepositoryLocation(serverURL, config.getID()); setRepository(baseURI); Resource ctx = SimpleValueFactory.getInstance().createIRI(baseURI + "#" + config.getID()); Model model = new LinkedHashModel(); config.export(model, ctx); ByteArrayOutputStream baos = new ByteArrayOutputStream(); Rio.write(model, baos, getPreferredRDFFormat()); HttpEntityEnclosingRequestBase method = null; try (InputStream contents = new ByteArrayInputStream(baos.toByteArray())) { HttpEntity entity = new InputStreamEntity(contents, -1, ContentType.parse(getPreferredRDFFormat().getDefaultMIMEType())); method = applyAdditionalHeaders(new HttpPost(Protocol.getRepositoryConfigLocation(baseURI))); method.setEntity(entity); executeNoContent((HttpUriRequest) method); } catch (RepositoryException | RDFParseException e) { throw e; } catch (RDF4JException e) { throw new RepositoryException(e); } finally { if (method != null) { method.reset(); } } }
@Override public long getMillisForTimestamp(long timestamp) { return getMillisForTimestamp(keyValueService, timestamp); }
@VisibleForTesting Optional<T> getValue(long sequenceNumber) { Preconditions.checkState( sequenceNumber > 0, "Only positive sequence numbers are supported, but found %s", sequenceNumber); return readFromCoordinationTable(getCellForSequence(sequenceNumber)) .map(Value::getContents) .map(this::deserializeValue); }
@Override public void sergeantReady() { logger.info("[Sergeant] " + unit.getName() + " is ready! "); }
@Override public UserModel getUserByUsername(RealmModel realm, String username) { LOG.infof("Get by username: %s", username); try { return this.createUserModel(realm, username); } catch (NotFoundException ex) { LOG.errorf("Federated user not found: %s", username); return null; } }
public static String replaceVariable(final String param) { Map<String, String> mapping = new HashMap<String, String>(); Matcher matcher = VARIABLE_PATTERN.matcher(param); while (matcher.find()) { String variable = matcher.group(2); String value = System.getProperty(variable); if (StringUtils.isBlank(value)) { value = matcher.group(); } mapping.put(matcher.group(), value); } String retString = param; for (final String key : mapping.keySet()) { retString = retString.replace(key, mapping.get(key)); } return retString; }
@Override public Insets getBorderInsets(Component c) { Insets insets = null; if (borderDelegate != null) { insets = (Insets) borderDelegate.getBorderInsets(textField).clone(); } else { insets = new Insets(0, 0, 0, 0); } if (textField == null) { return insets; } for (Component comp : BuddySupport.getLeft(textField)) { insets.left += comp.isVisible() ? comp.getPreferredSize().width : 0; } for (Component comp : BuddySupport.getRight(textField)) { insets.right += comp.isVisible() ? comp.getPreferredSize().width : 0; } Insets outerMargin = BuddySupport.getOuterMargin(textField); if (outerMargin != null) { insets.left += outerMargin.left; insets.right += outerMargin.right; insets.top += outerMargin.top; insets.bottom += outerMargin.bottom; } return insets; }
@Override public Bundle addAccount( @NonNull AccountAuthenticatorResponse response, @NonNull String accountType, @Nullable String authTokenType, @Nullable String[] requiredFeatures, @Nullable Bundle options) throws NetworkErrorException { log( "addAccount for %s as %s with features %s and options %s", accountType, authTokenType, Arrays.toString(requiredFeatures), BundleUtil.toString(options)); final Bundle bundle = new Bundle(); final Intent intent = service.getLoginIntent(); if (intent != null) { intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response); bundle.putParcelable(AccountManager.KEY_INTENT, intent); } return bundle; }
@Override public CompletableFuture<SendResult> publish(WeEvent event, String groupIdStr) throws BrokerException { log.debug("publish {} groupId: {}", event, groupIdStr); String groupId = selectGroupId(groupIdStr); this.validateGroupId(groupId); ParamCheckUtils.validateEvent(event); if (event.getExtensions().containsKey(WeEvent.WeEvent_SIGN)) { return fiscoBcosDelegate.sendRawTransaction(event.getTopic(), Long.parseLong(groupId), new String(event.getContent(), StandardCharsets.UTF_8)); } else { if (event.getExtensions().containsKey(WeEvent.WeEvent_EPHEMERAL)) { log.info("ephemeral event"); return fiscoBcosDelegate.sendAMOP(event.getTopic(), Long.parseLong(groupId), JsonHelper.object2Json(event)); } else { return fiscoBcosDelegate.publishEvent(event.getTopic(), Long.parseLong(groupId), new String(event.getContent(), StandardCharsets.UTF_8), JsonHelper.object2Json(event.getExtensions())); } } }
public void setMethodRolesMap(Map<String, String> rolesMap) { methodRolesMap.putAll(parseRolesMap(rolesMap)); }
public NodeRef update(final ObjectId newId, final @Nullable Envelope newBounds) { Node newNode = node.update(newId, newBounds); return NodeRef.create(parentPath, newNode, metadataId); }
public void shutdown() { started = false; closeClosable(this.stream); closeClosable(this.connection); zkLock.unlock(); zkLock.close(); }
protected void validateSource(Factory factory) throws ApiException { String type = factory.getSource().getProject().getType(); String location = factory.getSource().getProject().getLocation(); String parameterTypeName = "source.project.type"; String parameterLocationName = "source.project.location"; if (!("git".equals(type) || "esbwso2".equals(type))) { throw new ConflictException("Parameter '" + parameterTypeName + "' has illegal value."); } if (isNullOrEmpty(location)) { throw new ConflictException( format(FactoryConstants.PARAMETRIZED_ILLEGAL_PARAMETER_VALUE_MESSAGE, parameterLocationName, location)); } else { try { URLDecoder.decode(location, "UTF-8"); } catch (IllegalArgumentException | UnsupportedEncodingException e) { throw new ConflictException( format(FactoryConstants.PARAMETRIZED_ILLEGAL_PARAMETER_VALUE_MESSAGE, parameterLocationName, location)); } } }
public static File doChooseFile(String extension, String directory, String type) { if (MainWindow.getInstance().getActiveProject() != null) { File projectPath = new File(System.getProperty("project.path") + File.separator + directory); if (projectPath.exists()) { JFileChooser fileChooser = new JFileChooser(new SingleRootFileSystemView(projectPath)); fileChooser.setAcceptAllFileFilterUsed(false); FileNameExtensionFilter filter = new FileNameExtensionFilter(type, extension); fileChooser.setFileFilter(filter); if (fileChooser.showOpenDialog(MainWindow.getInstance()) == JFileChooser.APPROVE_OPTION) { return fileChooser.getSelectedFile(); } } } return null; }
public static String getShortClassName(final Class clazz) { String fullName = clazz.getName(); int idx = fullName.lastIndexOf('.'); if(idx == -1) { return fullName; } idx++; return fullName.substring(idx); }
public static Builder builder() { return new Builder(); }
public boolean isPsuDataNew(PsuData psuData, List<PsuData> psuDataList) { return Optional.ofNullable(psuData) .map(psu -> !isPsuDataInList(psu, psuDataList)) .orElseGet(() -> { log.info("Check is psu data a new instance failed - psuData is null"); return false; }); }
@Override public String toString() { return "MersennePrimeFieldElement{" + "value=" + value + ", modulus =" + modulus + '}'; }
@Override public List<Location> getTopRated(LatLng l, double radius, int n, ICallback<List<Location>> callback) { Flowable<List<Location>> res = Flowable.fromCallable(() -> { List<Location> locsList = getLocationsAround(l, radius, null); return locsList.stream().map(BestReviews::new) .sorted((br1, br2) -> br1.getTotalRatingByAvg() - br2.getTotalRatingByAvg()).limit(n) .map(BestReviews::getLocation).collect(Collectors.toList()); }).subscribeOn(Schedulers.io()).observeOn(Schedulers.single()); if (callback == null) return res.blockingFirst(); res.subscribe(callback::onFinish, Throwable::printStackTrace); return new ArrayList<>(); }
@Override public DescriptorValue calculate(IAtomContainer atomContainer) { if (!GeometryUtil.has3DCoordinates(atomContainer)) return getDummyDescriptorValue(new CDKException("Molecule must have 3D coordinates")); double angle = 10.0; double maxLOB = 0; double minArea = 1e6; double mmLOB = 0; double lob, bol, area; double[] xyzRanges; double[][] coords = new double[atomContainer.getAtomCount()][3]; for (int i = 0; i < atomContainer.getAtomCount(); i++) { coords[i][0] = atomContainer.getAtom(i).getPoint3d().x; coords[i][1] = atomContainer.getAtom(i).getPoint3d().y; coords[i][2] = atomContainer.getAtom(i).getPoint3d().z; } Point3d com = GeometryUtil.get3DCentreOfMass(atomContainer); if (com == null) return getDummyDescriptorValue(new CDKException("Error in center of mass calculation, has exact mass been set on all atoms?")); for (int i = 0; i < coords.length; i++) { coords[i][0] -= com.x; coords[i][1] -= com.y; coords[i][2] -= com.z; } int nangle = (int) (90 / angle); for (int i = 0; i < nangle; i++) { rotateZ(coords, Math.PI / 180.0 * angle); try { xyzRanges = extents(atomContainer, coords, true); } catch (CDKException e) { return getDummyDescriptorValue(e); } lob = xyzRanges[0] / xyzRanges[1]; bol = 1.0 / lob; if (lob < bol) { double tmp = lob; lob = bol; bol = tmp; } area = xyzRanges[0] * xyzRanges[1]; if (lob > maxLOB) maxLOB = lob; if (area < minArea) { minArea = area; mmLOB = lob; } } DoubleArrayResult result = new DoubleArrayResult(2); result.add(maxLOB); result.add(mmLOB); return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames()); }
public LedgerMetadata parseConfig(byte[] bytes, Optional<Long> metadataStoreCtime) throws IOException { if (log.isDebugEnabled()) { log.debug("Deserializing {}", Base64.getEncoder().encodeToString(bytes)); } try (ByteArrayInputStream is = new ByteArrayInputStream(bytes)) { int metadataFormatVersion = readHeader(is); if (log.isDebugEnabled()) { String contentStr = ""; if (metadataFormatVersion <= METADATA_FORMAT_VERSION_2) { contentStr = ", content: " + new String(bytes, UTF_8); } log.debug("Format version {} detected{}", metadataFormatVersion, contentStr); } switch (metadataFormatVersion) { case METADATA_FORMAT_VERSION_3: return parseVersion3Config(is, metadataStoreCtime); case METADATA_FORMAT_VERSION_2: return parseVersion2Config(is, metadataStoreCtime); case METADATA_FORMAT_VERSION_1: return parseVersion1Config(is); default: throw new IOException( String.format("Metadata version not compatible. Expected between %d and %d, but got %d", LOWEST_COMPAT_METADATA_FORMAT_VERSION, CURRENT_METADATA_FORMAT_VERSION, metadataFormatVersion)); } } }
@Override public String getString() { return string; }
public static Map<String, Object> getLocalValues() { return Collections.unmodifiableMap(localLookup.getTable()); }
public static String difference( @Nonnull String s1, @Nonnull String s2 ) { int at = differenceAt( s1, s2 ); if ( at == -1 ) { return ""; } return s2.substring( at ); }
@Override public void saveChangeRequestComment(final String repositoryAlias, final Long changeRequestId, final ChangeRequestComment changeRequestComment) { objectStorage.write(buildChangeRequestCommentFilePath(repositoryAlias, changeRequestId, changeRequestComment.getId()), changeRequestComment); }
public FEELFnResult<String> invoke(@ParameterName("from") Object val) { if ( val == null ) { return FEELFnResult.ofResult( null ); } else { return FEELFnResult.ofResult( TypeUtil.formatValue(val, false) ); } }
@VisibleForTesting static void validateHostsConfigurationOptions(Optional<String> masterHost, Optional<Integer> masterPort, List<String> multiHosts) throws ConfigurationException { if (masterHost.isPresent() != masterPort.isPresent()) { throw new ConfigurationException(ELASTICSEARCH_MASTER_HOST + " and " + ELASTICSEARCH_PORT + " should be specified together"); } if (!multiHosts.isEmpty() && masterHost.isPresent()) { throw new ConfigurationException("You should choose between mono host set up and " + ELASTICSEARCH_HOSTS); } if (multiHosts.isEmpty() && !masterHost.isPresent()) { throw new ConfigurationException("You should specify either (" + ELASTICSEARCH_MASTER_HOST + " and " + ELASTICSEARCH_PORT + ") or " + ELASTICSEARCH_HOSTS); } }
@Override public State convertToAcceptedState(@Nullable State state, @Nullable Item item) { if (state == null) { logger.error("A conversion of null was requested:", new IllegalArgumentException("State must not be null.")); return UnDefType.NULL; } if (item != null && !isAccepted(item, state)) { for (Class<? extends State> acceptedType : item.getAcceptedDataTypes()) { State convertedState = state.as(acceptedType); if (convertedState != null) { logger.debug("Converting {} '{}' to {} '{}' for item '{}'", state.getClass().getSimpleName(), state, convertedState.getClass().getSimpleName(), convertedState, item.getName()); return convertedState; } } } if (item instanceof NumberItem && state instanceof QuantityType) { NumberItem numberItem = (NumberItem) item; if (numberItem.getDimension() != null) { QuantityType<?> quantityState = (QuantityType<?>) state; Unit<?> itemUnit = parseItemUnit(numberItem); if (itemUnit != null) { if (!itemUnit.equals(quantityState.getUnit())) { return convertOrUndef(quantityState, itemUnit); } return quantityState; } Class<? extends Quantity<?>> dimension = numberItem.getDimension(); @SuppressWarnings({ "unchecked", "rawtypes" }) Unit<? extends Quantity<?>> conversionUnit = unitProvider .getUnit((Class<? extends Quantity>) dimension); if (conversionUnit != null && UnitUtils.isDifferentMeasurementSystem(conversionUnit, quantityState.getUnit())) { return convertOrUndef(quantityState, conversionUnit); } return state; } else { State convertedState = state.as(DecimalType.class); if (convertedState != null) { return convertedState; } } } return state; }
@Override public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof QuarterDateFormat)) { return false; } QuarterDateFormat that = (QuarterDateFormat) obj; if (!Arrays.equals(this.quarters, that.quarters)) { return false; } if (this.quarterFirst != that.quarterFirst) { return false; } return super.equals(obj); }
public static Object getValue(final ResultSet resultSet, final int columnIndex) throws SQLException { Object result = getValueByColumnType(resultSet, columnIndex); return resultSet.wasNull() ? null : result; }
public void inspect() throws JBakeException { ensureSource(); ensureTemplateFolder(); ensureContentFolder(); ensureDestination(); checkAssetFolder(); }
@Override public ResultModel preExecution(GfshParseResult parseResult) { String pooled = parseResult.getParamValueAsString(CreateDataSourceCommand.POOLED); if (pooled != null && pooled.equalsIgnoreCase("false")) { String poolProperties = parseResult.getParamValueAsString(CreateDataSourceCommand.POOL_PROPERTIES); if (poolProperties != null && poolProperties.length() > 0) { return ResultModel.createError(POOL_PROPERTIES_ONLY_VALID_ON_POOLED_DATA_SOURCE); } String pooledDataSourceFactoryClass = parseResult .getParamValueAsString(CreateDataSourceCommand.POOLED_DATA_SOURCE_FACTORY_CLASS); if (pooledDataSourceFactoryClass != null && pooledDataSourceFactoryClass.length() > 0) { return ResultModel.createError( POOLED_DATA_SOURCE_FACTORY_CLASS_ONLY_VALID_ON_POOLED_DATA_SOURCE); } } return super.preExecution(parseResult); }
@Override public void close() throws IOException { logger.atFine().log( "close(): Current tail file: %s final destination: %s", curGcsPath, finalGcsPath); if (!isOpen()) { logger.atFinest().log("close(): Ignoring; stream already closed."); return; } commitCurrentFile(); curGcsPath = null; curDelegate = null; logger.atFine().log("close(): Awaiting %s deletionFutures", deletionFutures.size()); for (Future<?> deletion : deletionFutures) { try { deletion.get(); } catch (ExecutionException | InterruptedException e) { if (e instanceof InterruptedException) { Thread.currentThread().interrupt(); } throw new IOException("Failed to delete files while closing stream", e); } } }
public void setProtocol( String protocol ) { this.protocol = protocol; }
public static ResolvedOvernightFutureTrade.Builder builder() { return new ResolvedOvernightFutureTrade.Builder(); }
@Override public byte[] decode(byte[] src, final int length) { if (length % BITS_4 != 0) throw new IllegalArgumentException( "Input is expected to be encoded in multiple of 4 bytes but found: " + length); int pads = 0; int last = length - 1; for (; pads < 2 && last > -1; last--, pads++) { if (src[last] != PAD) break; } final int fq; switch (pads) { case 0: fq = BITS_3; break; case 1: fq = 2; break; case 2: fq = 1; break; default: throw new Error("Impossible"); } final byte[] dest = new byte[length / BITS_4 * BITS_3 - (BITS_3 - fq)]; int s = 0, d = 0; for (; d < dest.length - fq % BITS_3; s += BITS_4, d += BITS_3) { decode4bytes(src, s, dest, d); } if (fq < BITS_3) { decode1to3bytes(fq, src, s, dest, d); } return dest; }
public void setVehicleType(int vehicleType) { this.vehicleType = vehicleType; }
public static <K, V> MapBuilder<K, V> mapBuilder() { return new MapBuilder<K, V>(); }
@VisibleForTesting public boolean isViewPermitted(final String repositoryName, final String repositoryFormat, final String action) { return securityHelper.anyPermitted(new RepositoryViewPermission(repositoryFormat, repositoryName, action)); }
@Override public void deleteGroupUsers(int gid) { groupDao.deleteGroupUsers(gid); }
@Override public Thread createThread(Runnable runnable) { return delegate.createThread(runnable); }
public static byte[] decode(byte[] inBytes) { if (null == inBytes) { throw new NullPointerException("Null input buffer"); } int len = inBytes.length; if (len % 4 != 0 && inBytes[len - 1] == '\0') { len -= 1; } if (len % 4 != 0) { throw new CryptoException("String not padded ie, input string not modulo 4 len = " + len + " len%4= " + len % 4); } byte[] out = new byte[y64decodeLen(len)]; int i = 0; int j = 0; int tlen; while (i < len) { tlen = (len - i); if (tlen > 4) { tlen = 4; } if (inBytes[i + 3] == '-') { tlen--; } if (inBytes[i + 2] == '-') { tlen--; } if (inBytes[i + 1] == '-') { throw new CryptoException("Too Many pad characters ( this should never happen )"); } byte a = decodeByte(inBytes[i++]); byte b = decodeByte(inBytes[i++]); byte c = decodeByte(inBytes[i++]); byte d = decodeByte(inBytes[i++]); if (a == (byte) 0xee || b == (byte) 0xee || c == (byte) 0xee || d == (byte) 0xee) { throw new CryptoException("Unrecognized characters in y64-encoded input starting at: " + (i - 4)); } if (tlen == 4) { out[j++] = decode1(a, b); out[j++] = decode2(b, c); out[j++] = decode3(c, d); } else if (tlen == 3) { if ((c & (byte) 0x03) != 0) { throw new CryptoException("Unknown decode error c & 0x03 failed, c-pos: " + (i - 2)); } out[j++] = decode1(a, b); out[j++] = decode2(b, c); } else { if ((b & (byte) 0x0F) != 0) { throw new CryptoException("Invalid decode. b & 0x0f failed, b-pos: " + (i - 3)); } out[j++] = decode1(a, b); } } return Arrays.copyOf(out, j); }
@Override public ExpandedQuery rewrite(final ExpandedQuery expandedQuery) { final QuerqyQuery<?> querqyQuery = expandedQuery.getUserQuery(); if (!(querqyQuery instanceof Query)) { return expandedQuery; } collectedTerms = new LinkedList<>(); visit((Query) querqyQuery); final List<ExactMatch<ReplaceInstruction>> exactMatches = sequenceLookup.findExactMatches(collectedTerms); if (!exactMatches.isEmpty()) { this.hasReplacement = true; final List<ExactMatch<ReplaceInstruction>> exactMatchesFiltered = LookupUtils.removeSubsetsAndSmallerOverlaps(exactMatches); exactMatchesFiltered.sort(LookupUtils.COMPARE_EXACT_MATCH_BY_LOOKUP_OFFSET_DESC); exactMatchesFiltered.forEach(exactMatch -> exactMatch.value.apply( collectedTerms, exactMatch.lookupStart, exactMatch.lookupExclusiveEnd - exactMatch.lookupStart ) ); } final List<SuffixMatch<ReplaceInstruction>> suffixMatches = sequenceLookup.findSingleTermSuffixMatches(collectedTerms); if (!suffixMatches.isEmpty()) { this.hasReplacement = true; suffixMatches.sort(LookupUtils.COMPARE_SUFFIX_MATCH_BY_LOOKUP_OFFSET_DESC); suffixMatches.forEach(suffixMatch -> suffixMatch.match.apply( collectedTerms, suffixMatch.getLookupOffset(), 1, suffixMatch.wildcardMatch )); } final List<PrefixMatch<ReplaceInstruction>> prefixMatches = sequenceLookup.findSingleTermPrefixMatches(collectedTerms); if (!prefixMatches.isEmpty()) { this.hasReplacement = true; prefixMatches.sort(LookupUtils.COMPARE_PREFIX_MATCH_BY_LOOKUP_OFFSET_DESC); prefixMatches.forEach(prefixMatch -> prefixMatch.match.apply( collectedTerms, prefixMatch.getLookupOffset(), 1, prefixMatch.wildcardMatch )); } return hasReplacement ? buildQueryFromSeqList(expandedQuery, collectedTerms) : expandedQuery; }
public T send() throws IOException { return neow3jService.send(this, responseType); }
@RequestMapping(value = "/employee/{empId}", method = RequestMethod.GET) @ResponseBody Employee getEmployee(@PathVariable("empId") int empId) throws Exception { LOG.info("Request to get employee by ID:" + empId); Employee emp = employeeService.getEmployee(empId); if(emp==null) throw new Exception("Employee does not exist"); return emp; }
public Object clone() throws CloneNotSupportedException { IndexDesc desc = (IndexDesc) super.clone(); desc.name = name; desc.tableId = tableId; desc.column = (Column) column.clone(); desc.indexMethod = indexMethod; desc.isUnique = isUnique; desc.isClustered = isClustered; desc.isAscending = isAscending; return desc; }
@Override public ProductInterface getProductBySku(String sku, String storeView) { if (sku == null) { return null; } try { ArrayKey key = toProductCacheKey(sku, storeView); return productCache.get(key, () -> getProductBySkuImpl(sku, storeView)).orElse(null); } catch (ExecutionException e) { throw new RuntimeException(e); } }
@Override public DataBag exec(Tuple input) throws IOException { if (input == null || input.size() < 2) { int errCode = 2107; String msg = "Over expected 2 or more inputs but received " + input.size(); throw new ExecException(msg, errCode, PigException.INPUT); } DataBag inbag = null; try { inbag = (DataBag)input.get(0); } catch (ClassCastException cce) { int errCode = 2107; String msg = "Over expected a bag for arg 1 but received " + DataType.findTypeName(input.get(0)); throw new ExecException(msg, errCode, PigException.INPUT); } if (!initialized) { init(input); } else { if (func instanceof ResetableEvalFunc) { ((ResetableEvalFunc)func).reset(); } } OverBag tmpbag = new OverBag(inbag, rowsBefore, rowsAfter); Tuple tmptuple = mTupleFactory.newTuple(1); tmptuple.set(0, tmpbag); DataBag outbag = BagFactory.getInstance().newDefaultBag(); for (int i = 0; i < inbag.size(); i++) { tmpbag.setCurrentRow(i); Tuple t = mTupleFactory.newTuple(1); t.set(0, func.exec(tmptuple)); outbag.add(t); } return outbag; }
public RuleModel visitRuleModel(RuleModel model) { RuleModel clone = new RuleModel(); clone.modelVersion = model.modelVersion; clone.name = model.name; clone.parentName = model.parentName; clone.setNegated(model.isNegated()); if (model.attributes != null) { clone.attributes = new RuleAttribute[model.attributes.length]; for (int i = 0; i < model.attributes.length; i++) { RuleAttribute attr = model.attributes[i]; clone.attributes[i] = (RuleAttribute) visit(attr); } } if (model.metadataList != null) { clone.metadataList = new RuleMetadata[model.metadataList.length]; for (int i = 0; i < model.metadataList.length; i++) { RuleMetadata md = model.metadataList[i]; clone.metadataList[i] = (RuleMetadata) visit(md); } } if (model.lhs != null) { clone.lhs = new IPattern[model.lhs.length]; for (int i = 0; i < model.lhs.length; i++) { IPattern pattern = model.lhs[i]; clone.lhs[i] = (IPattern) visit(pattern); } } if (model.rhs != null) { clone.rhs = new IAction[model.rhs.length]; for (int i = 0; i < model.rhs.length; i++) { IAction action = model.rhs[i]; clone.rhs[i] = (IAction) visit(action); } } return clone; }
public void loadedData(List<Note> notes) { items.addAll(notes); error.set(false); loaded = true; }
@Override public ValidationResult validate(Config config) { if (config.hasPath(ifPath)) { if (config.getAnyRef(ifPath).equals(hasValue)) { return thenValidation.validate(config); } else { return new ValidationResult(this, Validity.VALID, "Conditional configuration '" + ifPath + "' did not have value '" + hasValue + "', so it was not required that the validation (" + thenValidation + ") be checked"); } } else { return new ValidationResult(this, Validity.VALID, "Conditional configuration '" + ifPath + "' does not exist, so it was not required that the validation (" + thenValidation + ") be checked"); } }
public T readFrom(Class<T> type, Type genericType, Annotation[] anns, MediaType mt, MultivaluedMap<String, String> headers, InputStream is) throws IOException { if (isPayloadEmpty(headers)) { if (AnnotationUtils.getAnnotation(anns, Nullable.class) != null) { return null; } reportEmptyContentLength(); } XMLStreamReader reader = null; Unmarshaller unmarshaller = null; try { boolean isCollection = InjectionUtils.isSupportedCollectionOrArray(type); Class<?> theGenericType = isCollection ? InjectionUtils.getActualType(genericType) : type; Class<?> theType = getActualType(theGenericType, genericType, anns); unmarshaller = createUnmarshaller(theType, genericType, isCollection); addAttachmentUnmarshaller(unmarshaller); Object response = null; if (JAXBElement.class.isAssignableFrom(type) || !isCollection && (unmarshalAsJaxbElement || jaxbElementClassMap != null && jaxbElementClassMap.containsKey(theType.getName()))) { reader = getStreamReader(is, type, mt); reader = TransformUtils.createNewReaderIfNeeded(reader, is); if (JAXBElement.class.isAssignableFrom(type) && type == theType) { response = unmarshaller.unmarshal(reader); } else { response = unmarshaller.unmarshal(reader, theType); } } else { response = doUnmarshal(unmarshaller, type, is, anns, mt); } if (response instanceof JAXBElement && !JAXBElement.class.isAssignableFrom(type)) { response = ((JAXBElement<?>)response).getValue(); } if (isCollection) { response = ((CollectionWrapper)response).getCollectionOrArray( unmarshaller, theType, type, genericType, org.apache.cxf.jaxrs.utils.JAXBUtils.getAdapter(theGenericType, anns)); } else { response = checkAdapter(response, type, anns, false); } return type.cast(response); } catch (JAXBException e) { handleJAXBException(e, true); } catch (DepthExceededStaxException e) { throw ExceptionUtils.toWebApplicationException(null, JAXRSUtils.toResponse(413)); } catch (WebApplicationException e) { throw e; } catch (Exception e) { LOG.warning(ExceptionUtils.getStackTrace(e)); throw ExceptionUtils.toBadRequestException(e, null); } finally { try { StaxUtils.close(reader); } catch (XMLStreamException e) { } JAXBUtils.closeUnmarshaller(unmarshaller); } return null; }
public boolean hasMissingSignatures() { return this.getTransactionInfo().filter(info -> info.getHeight().equals(BigInteger.valueOf(0)) && !StringUtils .equalsIgnoreCase(info.getHash(), info.getMerkleComponentHash())).isPresent(); }
public static Builder builder() { return new AutoValue_StackdriverStatsConfiguration.Builder() .setProjectId(DEFAULT_PROJECT_ID) .setConstantLabels(DEFAULT_CONSTANT_LABELS) .setExportInterval(DEFAULT_INTERVAL) .setMonitoredResource(DEFAULT_RESOURCE) .setDeadline(DEFAULT_DEADLINE); }
public Object parse(InputStream inputStream, PDescriptor type) throws ParseException { return parse(new Utf8StreamReader(inputStream), type); }
public BigInteger calculateNetHashRate(Duration period) { return calculateHashRate(b -> true, period); }
@Override public boolean addRule(ACLRule rule) { if(checkRuleMatch(rule)){ return false; } rule.setId(lastRuleId++); this.ruleSet.add(rule); logger.info("No.{} ACL rule added.", rule.getId()); enforceAddedRule(rule); return true; }
public Double processDiscount(Double currentPrice, Double originItemsPrice) { if (!isEligible(originItemsPrice)){ return currentPrice; } switch (type) { case DISCOUNT_RATE: currentPrice = currentPrice - originItemsPrice * discountValue / 100; break; case ORDER_DISCOUNT_AMOUNT: currentPrice -= discountValue; break; case SHIPPING_FEE_DISCOUNT_AMOUNT: currentPrice -= discountValue; } return currentPrice; }
@Override public String getTypeName() { return "bigdecimal"; }
@Override public void checkCompatibility(Region incoming, String group, Region existing) { if (incoming.getType().equals(existing.getType())) { return; } if (!incoming.getType().name().contains("PROXY") && !existing.getType().name().contains("PROXY")) { raiseIncompatibilityError(incoming, group, existing); } String incomingType = incoming.getType().name().split("_")[0]; String existingType = existing.getType().name().split("_")[0]; if (!incomingType.equals(existingType)) { raiseIncompatibilityError(incoming, group, existing); } }
public void validate(Iterable<? extends ApiConfig> apiConfigs) throws ApiConfigInvalidException, ApiClassConfigInvalidException, ApiMethodConfigInvalidException, ApiParameterConfigInvalidException { if (Iterables.isEmpty(apiConfigs)) { return; } Map<String, ApiMethodConfig> restfulSignatures = Maps.newHashMap(); Iterator<? extends ApiConfig> i = apiConfigs.iterator(); ApiConfig first = i.next(); validate(first, restfulSignatures); while (i.hasNext()) { ApiConfig config = i.next(); Iterable<ApiConfigInconsistency<Object>> inconsistencies = config.getConfigurationInconsistencies(first); if (!Iterables.isEmpty(inconsistencies)) { throw new InconsistentApiConfigurationException(config, first, inconsistencies); } validate(config, restfulSignatures); } }
public String getPostingToResource( final String actionIdentifier, final String actionParams ) { return getString( "ActionInvoker.INFO_0003_POSTING_TO_RESOURCE", actionIdentifier, actionParams ); }
public String getCleCoul() { return this.cleCoul; }
public Optional<BuildResult> buildEmptyWalletTo(Address to) { return buildWithConfiguration((SendRequest sr) -> { sr.tx.addOutput(Coin.ZERO, to); sr.changeAddress = to; sr.emptyWallet = true; }, String.format("emptying wallet to %s", to)); }
public static LinkKey linkKey(ConnectPoint src, ConnectPoint dst) { return new LinkKey(src, dst); }
@Override protected boolean validateAction() { boolean actionValidated = true; MdxQueryAction queryAction = null; MdxConnectionAction connAction = null; try { if ( getActionDefinition() instanceof MdxQueryAction ) { queryAction = (MdxQueryAction) getActionDefinition(); actionValidated = isConnectionInfoSpecified( queryAction ); if ( actionValidated ) { if ( queryAction.getQuery() == ActionInputConstant.NULL_INPUT ) { error( Messages.getInstance().getErrorString( "MDXBaseComponent.ERROR_0001_QUERY_NOT_SPECIFIED", getActionName() ) ); actionValidated = false; } } if ( actionValidated ) { if ( ( queryAction.getOutputResultSet() == null ) && ( queryAction.getOutputPreparedStatement() == null ) ) { error( Messages.getInstance().getErrorString( "MDXBaseComponent.ERROR_0003_OUTPUT_NOT_SPECIFIED", getActionName() ) ); actionValidated = false; } } } else if ( getActionDefinition() instanceof MdxConnectionAction ) { connAction = (MdxConnectionAction) getActionDefinition(); actionValidated = isConnectionInfoSpecified( connAction ); if ( connAction.getOutputConnection() == null ) { error( Messages.getInstance().getErrorString( "MDXBaseComponent.ERROR_0003_OUTPUT_NOT_SPECIFIED", getActionName() ) ); actionValidated = false; } } } catch ( Exception e ) { actionValidated = false; error( Messages.getInstance().getErrorString( "MDXBaseComponent.ERROR_0004_VALIDATION_FAILED", getActionName() ), e ); } return actionValidated; }
public com.silanis.esl.sdk.AttachmentFile toSDKAttachmentFile() { if (apiAttachmentFile == null) { return sdkAttachmentFile; } com.silanis.esl.sdk.AttachmentFile result = new com.silanis.esl.sdk.AttachmentFile(); result.setId(apiAttachmentFile.getId()); result.setName(apiAttachmentFile.getName()); result.setInsertDate(apiAttachmentFile.getInsertDate()); result.setPreview(apiAttachmentFile.isPreview()); return result; }
@POST @Path("/{id}/code/{code}") @Produces(MediaType.APPLICATION_JSON) public Object codeChange(@PathParam("id") @AuditId String id, @AuditContent @PathParam("code") String code) throws ObjectNotFoundException { if ((id = SearchUtils.trimToNull(id)) == null) { throw new RequiredFieldException("id"); } if ((code = SearchUtils.trimToNull(code)) == null) { throw new RequiredFieldException("code"); } return contributorService.changeContributorCode(id, code); }
public int getValidationSkipGroups() { return skipGroups; }
@Override public AuthorizeResponse executeRequest(OktaHttpClient client) throws AuthorizationException { AuthorizationException exception = null; HttpResponse response = null; try { response = openConnection(client); if (response.getStatusCode() == HttpURLConnection.HTTP_UNAUTHORIZED) { exception = AuthorizationException.TokenRequestErrors.INVALID_CLIENT; } else if (response.getStatusCode() == HttpURLConnection.HTTP_OK || response.getStatusCode() == HttpURLConnection.HTTP_MOVED_TEMP) { Uri locationUri = Uri.parse(response.getHeaderField("Location")); return AuthorizeResponse.fromUri(locationUri); } } catch (IOException ex) { exception = new AuthorizationException(ex.getMessage(), ex); } catch (Exception e) { exception = new AuthorizationException(e.getMessage(), e); } finally { if (response != null) { response.disconnect(); } if (exception != null) { throw exception; } } return null; }
@RequestMapping(method = POST) public ResponseEntity<IdentityProvider> createIdentityProvider(@RequestBody IdentityProvider body, @RequestParam(required = false, defaultValue = "false") boolean rawConfig) throws MetadataProviderException{ body.setSerializeConfigRaw(rawConfig); String zoneId = identityZoneManager.getCurrentIdentityZoneId(); body.setIdentityZoneId(zoneId); try { configValidator.validate(body); } catch (IllegalArgumentException e) { logger.debug("IdentityProvider[origin="+body.getOriginKey()+"; zone="+body.getIdentityZoneId()+"] - Configuration validation error.", e); return new ResponseEntity<>(body, UNPROCESSABLE_ENTITY); } if (OriginKeys.SAML.equals(body.getType())) { SamlIdentityProviderDefinition definition = ObjectUtils.castInstance(body.getConfig(), SamlIdentityProviderDefinition.class); definition.setZoneId(zoneId); definition.setIdpEntityAlias(body.getOriginKey()); samlConfigurator.validateSamlIdentityProviderDefinition(definition); body.setConfig(definition); } try { IdentityProvider createdIdp = identityProviderProvisioning.create(body, zoneId); createdIdp.setSerializeConfigRaw(rawConfig); redactSensitiveData(createdIdp); return new ResponseEntity<>(createdIdp, CREATED); } catch (IdpAlreadyExistsException e) { return new ResponseEntity<>(body, CONFLICT); } catch (Exception x) { logger.debug("Unable to create IdentityProvider[origin="+body.getOriginKey()+"; zone="+body.getIdentityZoneId()+"]", x); return new ResponseEntity<>(body, INTERNAL_SERVER_ERROR); } }
public boolean hasSameCurrency(final Money money) { return currency.equals(money.currency); }
public static Stream<Path> iterPaths(Path path) { Deque<Path> parents = new ArrayDeque<>(path.getNameCount()); Path next = path; while (next != null) { parents.addFirst(next); next = next.getParent(); } return ImmutableList.copyOf(parents).stream(); }
public static File convert(File props, boolean backup) throws IOException { if (!props.isFile()) { throw new IllegalArgumentException("The given properties file does not exist : " + props.getAbsolutePath()); } Properties properties; try { properties = readFileAsProperties(props); } catch (IOException e) { throw new IllegalArgumentException("Cannot convert " + props.getName() + " to hocon - the file is not a " + "valid properties file", e); } if (properties == null || properties.isEmpty()) { throw new IllegalArgumentException("Cannot convert an empty file : " + props.getAbsolutePath()); } if (backup) { try { generateBackup(props); } catch (IOException e) { throw new IllegalStateException("Cannot generate the backup for " + props.getName(), e); } } String hocon = convertToHocon(props); File output = props; if (!props.getName().endsWith(".conf")) { output = new File(props.getParentFile(), props.getName().substring(0, props.getName().lastIndexOf(".")) + ".conf"); } FileUtils.write(output, hocon); return output; }
@Override public void beforeJob(JobParameters jobParameters) { for (JobListener listener : listeners) { listener.beforeJob(jobParameters); } }
@Override public ItemDocument withLabel(MonolingualTextValue newLabel) { return new ItemDocumentImpl(getItemId(), withTerm(labels, newLabel), descriptions, aliases, claims, sitelinks, revisionId); }
public static ServerListConfig namespaceUris(ServerListConfig config, String namespace) { Set<String> serversWithNamespaces = config .servers() .stream() .map(serverAddress -> serverAddress.replaceAll("/$", "") + "/" + namespace) .collect(Collectors.toSet()); return ImmutableServerListConfig.builder() .from(config) .servers(serversWithNamespaces) .build(); }
public byte[] toByteArray() { ByteArrayOutputStream stream = new ByteArrayOutputStream(); try { write(stream); } catch (IOException e) { throw new RuntimeException(e); } return stream.toByteArray(); }
@Override public void readFrom(ChannelBuffer channelBuffer) { while (channelBuffer.readableBytes() > 0) { MetricOfInternalReachability metricOfInternalReachability = new MetricOfInternalReachability(); metricOfInternalReachability.readFrom(channelBuffer); this.metricOfInternalReachability.add(metricOfInternalReachability); } }
public static byte[] encryptSHA224(byte[] data) { return hashTemplate(data, "SHA224"); }
@Override public void writeEvents(List<AuditEvent> auditEvents) { AuditEvent[] auditEventArray = auditEvents.toArray(new AuditEvent[0]); saveTask = new AuditEventSaveTask(file, isLocationEnabled, isTrackingChangesEnabled, isUserRequired, isTrackChangesReasonEnabled).execute(auditEventArray); }
public void run() { try { EntityContainerComparator comparator; EntityContainer entityContainer0 = null; EntityContainer entityContainer1 = null; comparator = new EntityContainerComparator(new EntityByTypeThenIdComparator()); postbox0.outputInitialize(); postbox1.outputInitialize(); sink.initialize(Collections.<String, Object>emptyMap()); entityContainer0 = nextOrNull(postbox0); entityContainer1 = nextOrNull(postbox1); if (entityContainer0 != null && entityContainer1 != null) { Bound bound0 = null; Bound bound1 = null; if (entityContainer0.getEntity().getType() == EntityType.Bound) { bound0 = (Bound) entityContainer0.getEntity(); entityContainer0 = nextOrNull(postbox0); } if (entityContainer1.getEntity().getType() == EntityType.Bound) { bound1 = (Bound) entityContainer1.getEntity(); entityContainer1 = nextOrNull(postbox1); } if (bound0 != null && bound1 != null) { sink.process(new BoundContainer(bound0.union(bound1))); } else if ((bound0 != null && bound1 == null) || (bound0 == null && bound1 != null)) { handleBoundRemoved(bound0 == null); } } while ( (entityContainer0 != null || postbox0.hasNext()) && (entityContainer1 != null || postbox1.hasNext())) { long comparisonResult; if (entityContainer0 == null) { entityContainer0 = postbox0.getNext(); } if (entityContainer1 == null) { entityContainer1 = postbox1.getNext(); } comparisonResult = comparator.compare(entityContainer0, entityContainer1); if (comparisonResult < 0) { sink.process(entityContainer0); entityContainer0 = null; } else if (comparisonResult > 0) { sink.process(entityContainer1); entityContainer1 = null; } else { if (conflictResolutionMethod.equals(ConflictResolutionMethod.Timestamp)) { int timestampComparisonResult; timestampComparisonResult = entityContainer0.getEntity().getTimestamp() .compareTo(entityContainer1.getEntity().getTimestamp()); if (timestampComparisonResult < 0) { sink.process(entityContainer1); } else if (timestampComparisonResult > 0) { sink.process(entityContainer0); } else { sink.process(entityContainer1); } } else if (conflictResolutionMethod.equals(ConflictResolutionMethod.LatestSource)) { sink.process(entityContainer1); } else if (conflictResolutionMethod.equals(ConflictResolutionMethod.Version)) { int version0 = entityContainer0.getEntity().getVersion(); int version1 = entityContainer1.getEntity().getVersion(); if (version0 < version1) { sink.process(entityContainer1); } else if (version0 > version1) { sink.process(entityContainer0); } else { sink.process(entityContainer1); } } else { throw new OsmosisRuntimeException( "Conflict resolution method " + conflictResolutionMethod + " is not recognized."); } entityContainer0 = null; entityContainer1 = null; } } while (entityContainer0 != null || postbox0.hasNext()) { if (entityContainer0 == null) { entityContainer0 = postbox0.getNext(); } sink.process(entityContainer0); entityContainer0 = null; } while (entityContainer1 != null || postbox1.hasNext()) { if (entityContainer1 == null) { entityContainer1 = postbox1.getNext(); } sink.process(entityContainer1); entityContainer1 = null; } sink.complete(); postbox0.outputComplete(); postbox1.outputComplete(); } finally { sink.close(); postbox0.outputRelease(); postbox1.outputRelease(); } }
public StartEventBuilder startEvent() { return startEvent(null); }
public static SetTintOperation tintTo(Tint to) { SetTintOperation operation = Operation.prepare(SetTintOperation.class); operation.get().set(to); return operation; }
public void delete(DeletionTask deletionTask) { if (debugDelay != -1) { if (LOG.isDebugEnabled()) { String msg = String.format("Scheduling DeletionTask (delay %d) : %s", debugDelay, deletionTask.toString()); LOG.debug(msg); } recordDeletionTaskInStateStore(deletionTask); sched.schedule(deletionTask, debugDelay, TimeUnit.SECONDS); } }
public String getBasePath() { return basePath; }
@Override public boolean acceptable(int maxStartOffset, int minEndOffset) { if (!updateSegmenter(maxStartOffset)) { return false; } minEndOffset -= lastStartOffset; if (minEndOffset > segmenter.length || inSegmenterStartOffset < 0) { return false; } return segmenter.segmenter.acceptable(inSegmenterStartOffset, minEndOffset); }
public static JobConfig readConfig(final String workingDir, final String configFileName) throws IOException { List<String> searchPaths = new ArrayList<>(); Path configFilePath = Paths.get(workingDir + "/" + configFileName); searchPaths.add(configFilePath.toString()); if (!Files.exists(configFilePath)) { configFilePath = Paths.get(configFileName); searchPaths.add(configFilePath.toString()); if (!Files.exists(configFilePath)) { configFilePath = Paths.get(LINEUP_CONFIG_DEFAULT_PATH); searchPaths.add(configFilePath.toString()); if (!Files.exists(configFilePath)) { String cwd = Paths.get(".").toAbsolutePath().normalize().toString(); throw new FileNotFoundException("JobConfig file not found. Search locations were: " + Arrays.toString(searchPaths.toArray()) + " - working dir: " + cwd); } } } BufferedReader br = new BufferedReader(new FileReader(configFilePath.toString())); return JacksonWrapper.deserializeConfig(br); }
@Override public void saveOrders(List<EncounterTransaction.Order> orders, Encounter encounter) { Set<OrderGroup> orderGroups = new LinkedHashSet<OrderGroup>(); for (EncounterTransaction.Order order : orders) { OrderGroup orderGroup = mapToOpenMRSOrderGroup(orderGroups, order.getOrderGroup(), encounter); Order omrsOrder = openMRSOrderMapper.map(order, encounter); omrsOrder.setOrderGroup(orderGroup); encounter.addOrder(omrsOrder); } encounterService.saveEncounter(encounter); }
public static boolean matchersFailFast() { return matchersFailFast; }
protected static void addConnection(final Element parentElement, ConnectionSchema connectionProperties, ParentGroupIdResolver parentGroupIdResolver) throws ConfigurationChangeException { try { final Document doc = parentElement.getOwnerDocument(); final Element element = doc.createElement("connection"); parentElement.appendChild(element); addTextElement(element, "id", connectionProperties.getId()); addTextElement(element, "name", connectionProperties.getName()); final Element bendPointsElement = doc.createElement("bendPoints"); element.appendChild(bendPointsElement); addTextElement(element, "labelIndex", "1"); addTextElement(element, "zIndex", "0"); addConnectionSourceOrDestination(element, "source", connectionProperties.getSourceId(), parentGroupIdResolver); addConnectionSourceOrDestination(element, "destination", connectionProperties.getDestinationId(), parentGroupIdResolver); List<String> sourceRelationshipNames = connectionProperties.getSourceRelationshipNames(); if (sourceRelationshipNames.isEmpty()) { addTextElement(element, "relationship", null); } else { for (String relationshipName : sourceRelationshipNames) { addTextElement(element, "relationship", relationshipName); } } addTextElement(element, "maxWorkQueueSize", String.valueOf(connectionProperties.getMaxWorkQueueSize())); addTextElement(element, "maxWorkQueueDataSize", connectionProperties.getMaxWorkQueueDataSize()); addTextElement(element, "flowFileExpiration", connectionProperties.getFlowfileExpiration()); addTextElementIfNotNullOrEmpty(element, "queuePrioritizerClass", connectionProperties.getQueuePrioritizerClass()); parentElement.appendChild(element); } catch (Exception e) { throw new ConfigurationChangeException("Failed to parse the config YAML while trying to add the connection from the Processor to the input port of the Remote Process Group", e); } }
public void step(Program aprogram) { steps(aprogram,1); }
public static <K, V> Builder<K, V> builder() { return new Builder<>(); }
@Nullable @Override public Authorizable getAuthorizableByPath(@NotNull String path) throws RepositoryException { String oakPath = namePathMapper.getOakPath(path); if (oakPath == null) { throw new RepositoryException("Invalid path " + path); } return getAuthorizableByOakPath(oakPath); }
public long getBorrowId() { return borrowId; }
@Override public boolean isThisSyntax(String message) throws ServiceException { initialise(); for (Pattern p : patternList) { Matcher m = p.matcher(message); if (!m.matches()) { return false; } } return true; }
Entity get(Key key) throws IOException { return call(() -> rw.get(key)); }
@NotNull @Override public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) { NodeBuilder builder = after.builder(); after.compareAgainstBaseState(before, new Diff(before, builder)); deletedCUGs.clear(); moveSources.clear(); return builder.getNodeState(); }
@Transactional(propagation = Propagation.NEVER) @Override public Bundle transaction(RequestDetails theRequestDetails, Bundle theRequest) { return myTransactionProcessor.transaction(theRequestDetails, theRequest); }
public static boolean contentEquals( @Nonnull final InputStream input1, @Nonnull final InputStream input2 ) throws IOException { final InputStream bufferedInput1 = new BufferedInputStream( input1 ); final InputStream bufferedInput2 = new BufferedInputStream( input2 ); int ch = bufferedInput1.read(); while ( -1 != ch ) { final int ch2 = bufferedInput2.read(); if ( ch != ch2 ) { return false; } ch = bufferedInput1.read(); } final int ch2 = bufferedInput2.read(); return -1 == ch2; }
@Override public synchronized MetadataSyncSummary doMetadataSync( MetadataSyncParams syncParams ) throws MetadataSyncServiceException, DhisVersionMismatchException { MetadataVersion version = getMetadataVersion( syncParams ); setMetadataImportMode( syncParams, version ); String metadataVersionSnapshot = getMetadataVersionSnapshot( version ); if ( metadataSyncDelegate.shouldStopSync( metadataVersionSnapshot ) ) { throw new DhisVersionMismatchException( "Metadata sync failed because your version of DHIS does not match the master version" ); } saveMetadataVersionSnapshotLocally( version, metadataVersionSnapshot ); MetadataSyncSummary metadataSyncSummary = metadataSyncImportHandler.importMetadata( syncParams, metadataVersionSnapshot ); log.info( "Metadata Sync Summary: " + metadataSyncSummary ); return metadataSyncSummary; }
public boolean revertToSnapshot(int snapshotId) { if (snapshotId <= 0 || snapshotId > this.snapshots.size()) { return false; } long newBestBlockNumber = this.snapshots.get(snapshotId - 1); this.snapshots = this.snapshots.stream().limit(snapshotId).collect(Collectors.toList()); long currentBestBlockNumber = blockchain.getBestBlock().getNumber(); if (newBestBlockNumber >= currentBestBlockNumber) { return true; } BlockStore store = blockchain.getBlockStore(); Block block = store.getChainBlockByNumber(newBestBlockNumber); BlockDifficulty difficulty = blockchain.getBlockStore().getTotalDifficultyForHash(block.getHash().getBytes()); blockchain.setStatus(block, difficulty); transactionPool.processBest(block); transactionPool.removeTransactions(transactionPool.getPendingTransactions()); transactionPool.removeTransactions(transactionPool.getQueuedTransactions()); for (long nb = blockchain.getBestBlock().getNumber() + 1; nb <= currentBestBlockNumber; nb++) { blockchain.removeBlocksByNumber(nb); } return true; }
@Override void addValueFromAxiom(Axiom<?> ax) { final Object val = ax.getValue().getValue(); if (!isValidRange(val)) { return; } verifyCardinalityConstraint(ax.getSubject()); if (IdentifierTransformer.isValidIdentifierType(attribute.getJavaType())) { this.value = IdentifierTransformer.transformToIdentifier(val, attribute.getJavaType()); } else { this.value = toAttributeValue(val); } }
@Override public boolean contains(Object o) { if (o instanceof JexlNode) { String nodeKey = buildKey((JexlNode) o); return nodeMap.containsKey(nodeKey); } return false; }
@Deprecated public static String massageSql(String sql, String project, int limit, int offset, String defaultSchema) { sql = sql.trim(); sql = sql.replace("\r", " ").replace("\n", System.getProperty("line.separator")); ProjectManager projectManager = ProjectManager.getInstance(KylinConfig.getInstanceFromEnv()); ProjectInstance projectInstance = projectManager.getProject(project); KylinConfig kylinConfig = projectInstance.getConfig(); sql = removeCommentInSql(sql); while (sql.endsWith(";")) sql = sql.substring(0, sql.length() - 1); String sql1 = sql; final String suffixPattern = "^.+?\\s(limit\\s\\d+)?\\s(offset\\s\\d+)?\\s*$"; sql = sql.replaceAll("\\s+", " "); Pattern pattern = Pattern.compile(suffixPattern); Matcher matcher = pattern.matcher(sql.toLowerCase(Locale.ROOT) + " "); int toAppendLimit = 0; int toAppendOffset = 0; if (matcher.find()) { if (limit > 0 && matcher.group(1) == null) { toAppendLimit = limit; } if (offset > 0 && matcher.group(2) == null) { toAppendOffset = offset; } } if (kylinConfig.getForceLimit() > 0 && limit <= 0 && matcher.group(1) == null && sql1.toLowerCase(Locale.ROOT).matches("^select\\s+\\*\\p{all}*")) { toAppendLimit = kylinConfig.getForceLimit(); } sql1 = appendLimitOffsetToSql(sql1, toAppendLimit, toAppendOffset); if (queryTransformers == null) { initQueryTransformers(); } for (IQueryTransformer t : queryTransformers) { sql1 = t.transform(sql1, project, defaultSchema); } return sql1; }
public String getStatus() { return status; }
public boolean execute(final RabbitMQConnectionInfo connectionInfo) { final RabbitManagementApiFacade api = rabbitManagementApiProvider.getApi(connectionInfo); final List<Queue> queueStates; try { queueStates = api.listQueues(); } catch (final Exception e) { throw new RuntimeException(e); } final List<String> nonEmptyQueues = queueStates.stream() .filter(queue -> queue.getMessages() > 0) .map(Queue::getName) .collect(Collectors.toList()); log.info("Non-empty queues: {}", nonEmptyQueues); return nonEmptyQueues.isEmpty(); }
@Override public ServletOutputStream getOutputStream() throws IOException{ if(returnedWriter != null){ throw new IllegalStateException("Method getWriter() has already been called."); } if(returnedStream == null){ returnedStream = new GzipServletOutputStream(super.getOutputStream()); } return returnedStream; }
public static ShortShortInt parse(ByteBuf buf) { return new ShortShortInt(buf.readByte()); }
public int getPower() { return power; }
public void setDataFlavor(DataFlavor flavor) { this.dataFlavor = flavor; }
@Override public boolean containsGene(Integer entrezGeneId) { return entrezIdToRowIndex.containsKey(entrezGeneId); }
@Override public URI transfer(PID binPid, URI sourceFileUri, boolean allowOverwrite) { URI binUri = super.transfer(binPid, sourceFileUri, allowOverwrite); HashedPosixStorageLocation posixLoc = (HashedPosixStorageLocation) destination; if (posixLoc.getPermissions() != null) { Path binPath = Paths.get(binUri); try { Files.setPosixFilePermissions(binPath, posixLoc.getPermissions()); } catch (IOException e) { log.debug("Failed to set permissions in destination {}", destination.getId()); } } return binUri; }
public long getDataStorageFrequency() { return dataStorageFrequency; }
@Override @Transactional(value = "transactionManager", readOnly = true) public Authentication authenticate(Authentication authentication) throws AuthenticationException { final String exceptionMessage = "User and password do not match."; String accountName = authentication.getName(); String rawPassword = (String) authentication.getCredentials(); LOG.debug("Trying to authenticate User '" + accountName + "'"); User user = userDao.findByAccountName(accountName); Set<GrantedAuthority> grantedAuthorities = new HashSet<GrantedAuthority>(); String encryptedPassword = null; if (user == null) { LOG.warn("No user for account name '" + accountName + "' could be found."); throw new UsernameNotFoundException(exceptionMessage); } else if (!user.isActive()) { LOG.warn("The user with the account name '" + accountName + "' is not active."); throw new DisabledException(exceptionMessage); } else { encryptedPassword = user.getPassword(); if (passwordEncoder.matches(rawPassword, encryptedPassword)) { Set<Role> allUserRoles = getAllUserRoles(user); for (Role role : allUserRoles) { grantedAuthorities.add(new SimpleGrantedAuthority(role.getName())); } } else { LOG.warn("The given password for user '" + accountName + "' does not match."); throw new BadCredentialsException(exceptionMessage); } } Authentication authResult = null; if (grantedAuthorities.isEmpty()) { LOG.warn("The user '" + accountName + "' has no authorities and will thereby NOT be authenticated."); authResult = new UsernamePasswordAuthenticationToken(user, encryptedPassword); } else { authResult = new UsernamePasswordAuthenticationToken(user, encryptedPassword, grantedAuthorities); LOG.debug("The user '" + accountName + "' got the following (explicit) roles: " + StringUtils.join(getRawRoleNames(grantedAuthorities), ", ")); } final boolean isAuthenticated = authResult.isAuthenticated(); final String authLog = isAuthenticated ? "has succesfully" : "has NOT"; LOG.info("The user '" + accountName + "' " + authLog + " been authenticated."); return authResult; }
public static StreamSpec getStreamSpec(String streamId, StreamConfig streamConfig) { String physicalName = streamConfig.getPhysicalName(streamId); String system = streamConfig.getSystem(streamId); Map<String, String> streamProperties = streamConfig.getStreamProperties(streamId); return new StreamSpec(streamId, physicalName, system, streamProperties); }
@Override public String compileFile(String inputFileName, String includeDirName) throws RubySassCompilerException { return compileFile(inputFileName, includeDirName, false, ""); }
public ResponseEntity<String> removeGroupFromServiceAccount(String token, ServiceAccountGroup serviceAccountGroup, UserDetails userDetails) { log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Remove Group from Service Account"). put(LogMessage.MESSAGE, String.format ("Trying to remove Group from Service Account")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); if (!userDetails.isAdmin()) { token = tokenUtils.getSelfServiceToken(); } if(!isSvcaccPermissionInputValid(serviceAccountGroup.getAccess())) { return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Invalid value specified for access. Valid values are read, reset, deny\"]}"); } if (serviceAccountGroup.getAccess().equalsIgnoreCase("reset")) { serviceAccountGroup.setAccess(TVaultConstants.WRITE_POLICY); } String groupName = serviceAccountGroup.getGroupname().toLowerCase(); String svcAccName = serviceAccountGroup.getSvcAccName(); String access = serviceAccountGroup.getAccess(); boolean isAuthorized = true; if (userDetails != null) { isAuthorized = hasAddOrRemovePermission(userDetails, svcAccName, token); } if(isAuthorized){ if (!ifInitialPwdReset(token, userDetails, serviceAccountGroup.getSvcAccName())) { log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Remove Group from ServiceAccount"). put(LogMessage.MESSAGE, "Failed to remove group permission from Service account. Initial password reset is pending for this Service Account."). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Failed to remove group permission from Service account. Initial password reset is pending for this Service Account. Please reset the password and try again.\"]}"); } String r_policy = new StringBuffer().append(TVaultConstants.SVC_ACC_POLICIES_PREFIXES.getKey(TVaultConstants.READ_POLICY)).append(TVaultConstants.SVC_ACC_PATH_PREFIX).append("_").append(svcAccName).toString(); String w_policy = new StringBuffer().append(TVaultConstants.SVC_ACC_POLICIES_PREFIXES.getKey(TVaultConstants.WRITE_POLICY)).append(TVaultConstants.SVC_ACC_PATH_PREFIX).append("_").append(svcAccName).toString(); String d_policy = new StringBuffer().append(TVaultConstants.SVC_ACC_POLICIES_PREFIXES.getKey(TVaultConstants.DENY_POLICY)).append(TVaultConstants.SVC_ACC_PATH_PREFIX).append("_").append(svcAccName).toString(); String o_policy = new StringBuffer().append(TVaultConstants.SVC_ACC_POLICIES_PREFIXES.getKey(TVaultConstants.SUDO_POLICY)).append(TVaultConstants.SVC_ACC_PATH_PREFIX).append("_").append(svcAccName).toString(); log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Remove group from Service Account"). put(LogMessage.MESSAGE, String.format ("Policies are, read - [%s], write - [%s], deny -[%s], owner - [%s]", r_policy, w_policy, d_policy, o_policy)). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); Response groupResp = reqProcessor.process("/auth/ldap/groups","{\"groupname\":\""+groupName+"\"}",token); log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Remove group from ServiceAccount"). put(LogMessage.MESSAGE, String.format ("userResponse status is [%s]", groupResp.getHttpstatus())). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); String responseJson=""; List<String> policies = new ArrayList<>(); List<String> currentpolicies = new ArrayList<>(); String policy = new StringBuffer().append(TVaultConstants.SVC_ACC_POLICIES_PREFIXES.getKey(access)).append(TVaultConstants.SVC_ACC_PATH_PREFIX).append("_").append(svcAccName).toString(); if(HttpStatus.OK.equals(groupResp.getHttpstatus())){ responseJson = groupResp.getResponse(); try { ObjectMapper objMapper = new ObjectMapper(); currentpolicies = ControllerUtil.getPoliciesAsListFromJson(objMapper, responseJson); } catch (IOException e) { log.error(e); log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Remove group from ServiceAccount"). put(LogMessage.MESSAGE, String.format ("Exception while creating currentpolicies or groups")). put(LogMessage.STACKTRACE, Arrays.toString(e.getStackTrace())). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); } policies.addAll(currentpolicies); policies.remove(r_policy); policies.remove(w_policy); policies.remove(d_policy); } String policiesString = org.apache.commons.lang3.StringUtils.join(policies, ","); String currentpoliciesString = org.apache.commons.lang3.StringUtils.join(currentpolicies, ","); Response ldapConfigresponse = ControllerUtil.configureLDAPGroup(groupName,policiesString,token); if(ldapConfigresponse.getHttpstatus().equals(HttpStatus.NO_CONTENT) || ldapConfigresponse.getHttpstatus().equals(HttpStatus.OK)){ String path = new StringBuffer(TVaultConstants.SVC_ACC_ROLES_PATH).append(svcAccName).toString(); Map<String,String> params = new HashMap<String,String>(); params.put("type", "groups"); params.put("name",groupName); params.put("path",path); params.put("access","delete"); Response metadataResponse = ControllerUtil.updateMetadata(params,token); if(metadataResponse !=null && (HttpStatus.NO_CONTENT.equals(metadataResponse.getHttpstatus()) || HttpStatus.OK.equals(metadataResponse.getHttpstatus()))){ log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Remove Group to Service Account"). put(LogMessage.MESSAGE, "Group configuration Success."). put(LogMessage.STATUS, metadataResponse.getHttpstatus().toString()). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.OK).body("{\"messages\":[\"Group is successfully removed from Service Account\"]}"); } ldapConfigresponse = ControllerUtil.configureLDAPGroup(groupName,currentpoliciesString,token); if(ldapConfigresponse.getHttpstatus().equals(HttpStatus.NO_CONTENT)){ log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Add Group to Service Account"). put(LogMessage.MESSAGE, "Reverting, group policy update success"). put(LogMessage.RESPONSE, (null!=metadataResponse)?metadataResponse.getResponse():TVaultConstants.EMPTY). put(LogMessage.STATUS, (null!=metadataResponse)?metadataResponse.getHttpstatus().toString():TVaultConstants.EMPTY). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("{\"errors\":[\"Group configuration failed. Please try again\"]}"); }else{ log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "Add Group to Service Account"). put(LogMessage.MESSAGE, "Reverting group policy update failed"). put(LogMessage.RESPONSE, (null!=metadataResponse)?metadataResponse.getResponse():TVaultConstants.EMPTY). put(LogMessage.STATUS, (null!=metadataResponse)?metadataResponse.getHttpstatus().toString():TVaultConstants.EMPTY). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("{\"errors\":[\"Group configuration failed. Contact Admin \"]}"); } } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("{\"errors\":[\"Failed to remove the group from the Service Account\"]}"); } } else { return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Access denied: No permission to remove groups from this service account\"]}"); } }
public void remove(String name) { metadata.remove(name); }
public long getHeight(String date) { SimpleDateFormat parser = new SimpleDateFormat("yyyy-MM-dd"); parser.setTimeZone(TimeZone.getTimeZone("UTC")); parser.setLenient(false); try { return getHeight(parser.parse(date)); } catch (ParseException ex) { throw new IllegalArgumentException(ex); } }
public static String getNormalizedConstraints(Constraints constraints) { if (constraints.isUnbounded()) { return UNBOUNDED_CONSTRAINT; } Map<String, String> orderedConstraints = constraints.toNormalizedQueryMap(); List<String> parts = new ArrayList<String>(); for (Map.Entry<String, String> entry : orderedConstraints.entrySet()) { StringBuilder builder = new StringBuilder(); String key = entry.getKey(); String value = entry.getValue(); builder.append(key); builder.append("="); if (value != null) { builder.append(value); } parts.add(builder.toString()); } return Joiner.on('&').join(parts); }
@Override public PiecewisePolynomialResult interpolate(double[] xValues, double[] yValues) { ArgChecker.notEmpty(xValues, "xValues"); ArgChecker.notEmpty(yValues, "yValues"); int nDataPts = xValues.length; ArgChecker.isTrue(nDataPts > 1, "at least two data points required"); ArgChecker.isTrue(nDataPts == yValues.length, "xValues length = yValues length"); for (int i = 0; i < nDataPts; ++i) { ArgChecker.isFalse(Double.isNaN(xValues[i]), "xData containing NaN"); ArgChecker.isFalse(Double.isInfinite(xValues[i]), "xData containing Infinity"); ArgChecker.isFalse(Double.isNaN(yValues[i]), "yData containing NaN"); ArgChecker.isFalse(Double.isInfinite(yValues[i]), "yData containing Infinity"); } if (nDataPts == 1) { return new PiecewisePolynomialResult(DoubleArray.copyOf(xValues), DoubleMatrix.filled(1, 1, yValues[0]), 1, 1); } double[] xValuesSrt = Arrays.copyOf(xValues, nDataPts); double[] yValuesSrt = Arrays.copyOf(yValues, nDataPts); DoubleArrayMath.sortPairs(xValuesSrt, yValuesSrt); ArgChecker.noDuplicatesSorted(xValuesSrt, "xValues"); DoubleMatrix coefMatrix = solve(xValuesSrt, yValuesSrt); for (int i = 0; i < coefMatrix.rowCount(); ++i) { for (int j = 0; j < coefMatrix.columnCount(); ++j) { ArgChecker.isFalse(Double.isNaN(coefMatrix.get(i, j)), "Too large input"); ArgChecker.isFalse(Double.isInfinite(coefMatrix.get(i, j)), "Too large input"); } double ref = 0.; double interval = xValuesSrt[i + 1] - xValuesSrt[i]; for (int j = 0; j < 2; ++j) { ref += coefMatrix.get(i, j) * Math.pow(interval, 1 - j); ArgChecker.isFalse(Double.isNaN(coefMatrix.get(i, j)), "Too large input"); ArgChecker.isFalse(Double.isInfinite(coefMatrix.get(i, j)), "Too large input"); } double bound = Math.max(Math.abs(ref) + Math.abs(yValuesSrt[i + 1]), 1.e-1); ArgChecker.isTrue(Math.abs(ref - yValuesSrt[i + 1]) < ERROR * bound, "Input is too large/small or data are not distinct enough"); } return new PiecewisePolynomialResult(DoubleArray.copyOf(xValuesSrt), coefMatrix, coefMatrix.columnCount(), 1); }
public Map<String, Collection<FailoverTaskInfo>> getAllFailoverTasks() { if (!regCenter.isExisted(FailoverNode.ROOT)) { return Collections.emptyMap(); } List<String> jobNames = regCenter.getChildrenKeys(FailoverNode.ROOT); Map<String, Collection<FailoverTaskInfo>> result = new HashMap<>(jobNames.size(), 1); for (String each : jobNames) { Collection<FailoverTaskInfo> failoverTasks = getFailoverTasks(each); if (!failoverTasks.isEmpty()) { result.put(each, failoverTasks); } } return result; }
public boolean containsKey( final long key ) { if ( size > 0 ) { if ( key > keys[size - 1] ) { return false; } } return findKeyInternal( key ) >= 0; }
@Override public void editTask() { if (null == mTaskId || mTaskId.isEmpty()) { mTaskDetailView.showMissingTask(); return; } mTaskDetailView.showEditTask(mTaskId); }
@Override public FieldType resolve(final TableType tableType) { if (tableType == null) { throw new IllegalArgumentException(); } for (FieldType fieldType : tableType.getFields()) { if (fieldType.getName().equals(fieldName)) { return fieldType; } } return null; }
public boolean isACollection(TypeMirror typeMirror) { TypeMirror collectionType = typeUtils.getDeclaredType( elementUtils.getTypeElement(Collection.class.getCanonicalName()), typeUtils.getWildcardType(null, null) ); final TypeElement typeElement = (TypeElement) typeUtils.asElement(typeMirror); final String qualifiedName = typeElement.getQualifiedName().toString(); final TypeMirror copy = elementUtils.getTypeElement(qualifiedName).asType(); return typeUtils.isAssignable(copy, collectionType); }
public HashMap<Object, Integer> putAttributeValues(String column, boolean ignoreBlanks) { HashMap<Object, Integer> valueToFreq = new HashMap<>(); frequencyMaps.put(column, valueToFreq); for (Attribute attr : dataset.getAttributesByColumn(column)) { if (attr.isAlive()) { Object value = attr.getValue(); if (value == null || (ignoreBlanks == true && "".equals(value.toString().trim()))) { continue; } if (valueToFreq.get(value) == null) { valueToFreq.put(value, 1); } else { valueToFreq.put(value, valueToFreq.get(value) + 1); } } } int max = 0; int second = 0; for (Entry<Object, Integer> entry : valueToFreq.entrySet()) { int freq = entry.getValue(); if (freq > max) { second = max; max = freq; } else if (freq < max && freq > second) { second = freq; } } maxOccurence.put(column, max); secondMaxOccurence.put(column, second); return valueToFreq; }
public Graph apply(final Graph g) { Graph h = new Graph(g.order()); for (int u = 0; u < g.order(); u++) { h.addAtom(g.atom(u)); h.addTopology(g.topologyOf(u)); } for (int u = 0; u < g.order(); u++) { for (final Edge e : g.edges(u)) { if (e.other(u) > u) h.addEdge(toExplicitEdge(g, e)); } } return h; }
public static String safeRemoveAllTags(String html) { html = removeNonTextTags(html); html = unsafeRemoveAllTags(html); return html; }
public static Sensor punctuateRatioSensor(final String threadId, final StreamsMetricsImpl streamsMetrics) { final Sensor sensor = streamsMetrics.threadLevelSensor(threadId, PUNCTUATE + RATIO_SUFFIX, Sensor.RecordingLevel.INFO); final Map<String, String> tagMap = streamsMetrics.threadLevelTagMap(threadId); addValueMetricToSensor( sensor, threadLevelGroup(streamsMetrics), tagMap, PUNCTUATE + RATIO_SUFFIX, PUNCTUATE_RATIO_DESCRIPTION ); return sensor; }
@Override public Iterator<PropertyValue> iterator() { return new PropertyValueListIterator(bytes); }
public void update(final Collection<InspectedType> updates) { final ArrayList<UUIDKey> originalItems = new ArrayList<>(map.keySet()); for (final InspectedType updatable : updates) { final InspectorType inspector = map.get(updatable.getUuidKey()); if (inspector != null) { originalItems.remove(updatable.getUuidKey()); continue; } else { final InspectorType newInspector = inspectorFactory.make(updatable); add(newInspector); map.put(updatable.getUuidKey(), newInspector); } } for (final UUIDKey originalItem : originalItems) { remove(map.remove(originalItem)); } }
public boolean isResponseCacheable(final String httpMethod, final HttpResponse response) { boolean cacheable = false; if (!HeaderConstants.GET_METHOD.equals(httpMethod) && !HeaderConstants.HEAD_METHOD.equals(httpMethod)) { if (LOG.isDebugEnabled()) { LOG.debug("{} method response is not cacheable", httpMethod); } return false; } final int status = response.getCode(); if (CACHEABLE_STATUS_CODES.contains(status)) { cacheable = true; } else if (uncacheableStatusCodes.contains(status)) { if (LOG.isDebugEnabled()) { LOG.debug("{} response is not cacheable", status); } return false; } else if (unknownStatusCode(status)) { if (LOG.isDebugEnabled()) { LOG.debug("{} response is unknown", status); } return false; } final Header contentLength = response.getFirstHeader(HttpHeaders.CONTENT_LENGTH); if (contentLength != null) { final long contentLengthValue = Long.parseLong(contentLength.getValue()); if (contentLengthValue > this.maxObjectSizeBytes) { if (LOG.isDebugEnabled()) { LOG.debug("Response content length exceeds {}", this.maxObjectSizeBytes); } return false; } } if (response.countHeaders(HeaderConstants.AGE) > 1) { LOG.debug("Multiple Age headers"); return false; } if (response.countHeaders(HeaderConstants.EXPIRES) > 1) { LOG.debug("Multiple Expires headers"); return false; } if (response.countHeaders(HttpHeaders.DATE) > 1) { LOG.debug("Multiple Date headers"); return false; } final Date date = DateUtils.parseDate(response, HttpHeaders.DATE); if (date == null) { LOG.debug("Invalid / missing Date header"); return false; } final Iterator<HeaderElement> it = MessageSupport.iterate(response, HeaderConstants.VARY); while (it.hasNext()) { final HeaderElement elem = it.next(); if ("*".equals(elem.getName())) { if (LOG.isDebugEnabled()) { LOG.debug("Vary * found"); } return false; } } if (isExplicitlyNonCacheable(response)) { LOG.debug("Response is explicitly non-cacheable"); return false; } return cacheable || isExplicitlyCacheable(response); }
public static <T extends Comparable<?>> IsLessThan<T> instance() { return new IsLessThan<T>(); }
public static final DataObjInp instanceForDeleteWithNoForce(final String fileAbsolutePath) throws JargonException { DataObjInp dataObjInp = new DataObjInp(fileAbsolutePath, ZERO_CREATE_MODE, OpenFlags.READ, 0L, 0L, "", null); dataObjInp.operationType = DEFAULT_OPERATION_TYPE; dataObjInp.setApiNumber(DELETE_FILE_API_NBR); return dataObjInp; }
@Override public Num calculate(BarSeries series, TradingRecord tradingRecord) { Returns returns = new Returns(series, tradingRecord, Returns.ReturnType.LOG); return calculateVaR(returns, confidence); }
public Num getK() { return k; }
public boolean hasValidCredentials() { String accessToken = storage.retrieveString(KEY_ACCESS_TOKEN); String refreshToken = storage.retrieveString(KEY_REFRESH_TOKEN); String idToken = storage.retrieveString(KEY_ID_TOKEN); Long expiresAt = storage.retrieveLong(KEY_EXPIRES_AT); return !(isEmpty(accessToken) && isEmpty(idToken) || expiresAt == null || expiresAt <= getCurrentTimeInMillis() && refreshToken == null); }
public static String camelCaseToUpperSnakeCase(String camelCase) { return camelCaseToSnakeCase(camelCase).toUpperCase(); }
@Nullable public File getTraceFile(Common.Session session) { return mySessionTraceFiles.get(session.getSessionId()); }
public Object resolveArgument(MethodParameter param, NativeWebRequest request) throws Exception { if (SitePreference.class.isAssignableFrom(param.getParameterType())) { return SitePreferenceUtils.getCurrentSitePreference(request); } else { return WebArgumentResolver.UNRESOLVED; } }
public void setFormalReturnType(DataType formalReturnType) { setParameterFormalDataType(returnInfo, formalReturnType); }
protected synchronized void checkRetryTask () { if (retryTask == null) { retryTask = new RetryTask(); new Thread(retryTask).start(); } }
@Override public ResponseEntity<UserResponse> user( String term, String pageToken, Integer size, String sortOrder) { UserResponse response = new UserResponse(); response.setUsers(Collections.emptyList()); response.setNextPageToken(""); if (null == term || term.isEmpty()) { return ResponseEntity.ok(response); } PaginationToken paginationToken; try { paginationToken = getPaginationTokenFromPageToken(pageToken); } catch (IllegalArgumentException | BadRequestException e) { return ResponseEntity.badRequest().body(response); } WorkbenchConfig config = configProvider.get(); if (!fireCloudService.isUserMemberOfGroup( userProvider.get().getUsername(), config.firecloud.registeredDomainName)) { throw new ForbiddenException("user search requires registered data access"); } Sort.Direction direction = Optional.ofNullable(Sort.Direction.fromStringOrNull(sortOrder)).orElse(Sort.Direction.ASC); Sort sort = new Sort(new Sort.Order(direction, DEFAULT_SORT_FIELD)); List<DbUser> users = userService.findUsersBySearchString(term, sort).stream() .filter(user -> user.getFirstSignInTime() != null) .collect(Collectors.toList()); int pageSize = Optional.ofNullable(size).orElse(DEFAULT_PAGE_SIZE); List<List<DbUser>> pagedUsers = Lists.partition(users, pageSize); int pageOffset = Long.valueOf(paginationToken.getOffset()).intValue(); if (pagedUsers.size() == 0) { return ResponseEntity.ok(response); } if (pageOffset < pagedUsers.size()) { boolean hasNext = pageOffset < pagedUsers.size() - 1; if (hasNext) { response.setNextPageToken(PaginationToken.of(pageOffset + 1).toBase64()); } List<org.pmiops.workbench.model.User> modelUsers = pagedUsers.get(pageOffset).stream() .map(TO_USER_RESPONSE_USER) .collect(Collectors.toList()); response.setUsers(modelUsers); } else { log.warning( String.format( "User attempted autocomplete for a paged result that doesn't exist. Term: %s. Page: %d", term, pageOffset)); return ResponseEntity.badRequest().body(response); } return ResponseEntity.ok(response); }
public static List<Properties> loadGenericJobConfigs(Properties sysProps, JobSpecResolver resolver) throws ConfigurationException, IOException { Path rootPath = new Path(sysProps.getProperty(ConfigurationKeys.JOB_CONFIG_FILE_GENERAL_PATH_KEY)); PullFileLoader loader = new PullFileLoader(rootPath, rootPath.getFileSystem(new Configuration()), getJobConfigurationFileExtensions(sysProps), PullFileLoader.DEFAULT_HOCON_PULL_FILE_EXTENSIONS); Config sysConfig = ConfigUtils.propertiesToConfig(sysProps); Collection<Config> configs = loader.loadPullFilesRecursively(rootPath, sysConfig, true); List<Properties> jobConfigs = Lists.newArrayList(); for (Config config : configs) { try { jobConfigs.add(resolveTemplate(ConfigUtils.configToProperties(config), resolver)); } catch (IOException ioe) { LOGGER.error("Could not parse job config at " + ConfigUtils.getString(config, ConfigurationKeys.JOB_CONFIG_FILE_PATH_KEY, "Unknown path"), ioe); } } return jobConfigs; }
@Override public Object execute() throws Exception { EventPrinter printer = new EventPrinter(session.getConsole(), verbose); collector.getEvents().filter(matchTopic(topicFilter)).forEach(printer); return null; }
@Override public Map<String, String> load() { final Map<String, String> preferences = new HashMap<String, String>(); addSystemProperty( preferences, ExamplesService.EXAMPLES_SYSTEM_PROPERTY ); return preferences; }
public boolean validateNotNull( final String input, final String label ) { return validateNotNull( input, label, STANDARD ); }
public void put(String path) { handleVoidResponse(client.put(path)); }
@Override public List<String> getResourceNames(ResourceIdentifier resourceIdentifier) { if (canHandle(resourceIdentifier)) { return applicationPersistenceService.getResourceTemplateNames(resourceIdentifier.webAppName, resourceIdentifier.jvmName); } else { return successor.getResourceNames(resourceIdentifier); } }
public static String expand(String ipStr, int nwords) throws IPStringConversionException { StringBuilder sb; String hex; int[] vals; int[] expanded_vals; int i; sb = new StringBuilder(); vals = splitvals(ipStr); if (vals == null) { throw new IPStringConversionException("Error converting hex to binary in IPv6 ip"); } expanded_vals = expand(vals, nwords); for (i = 0; i < nwords - 1; i++) { hex = String.format("%s:", IPUtils.int16bit2hex(expanded_vals[i])); sb.append(hex); } hex = String.format("%s", IPUtils.int16bit2hex(expanded_vals[nwords - 1])); sb.append(hex); return sb.toString(); }
@Override public float getMinimumQuality() { return minimumQuality; }
Double smoothOnePoint(final double x, final int left, final int right) { State state = computeNeighborhoodWeights(x, left, right); if (state == State.WEIGHTS_FAILED) return null; if (state == State.LINEAR_OK) updateWeights(x, left, right); double ys = 0.0; for (int i = left; i <= right; ++i) ys += fWeights[i] * fData[i]; return ys; }
public void expose(Map<String, ? extends ServerConfig> servers) throws InfrastructureException { Map<String, ServerConfig> internalServers = new HashMap<>(); Map<String, ServerConfig> externalServers = new HashMap<>(); Map<String, ServerConfig> secureServers = new HashMap<>(); Map<String, ServicePort> unsecuredPorts = new HashMap<>(); Map<String, ServicePort> securedPorts = new HashMap<>(); splitServersAndPortsByExposureType( servers, internalServers, externalServers, secureServers, unsecuredPorts, securedPorts); provisionServicesForDiscoverableServers(servers); Optional<Service> serviceOpt = createService(internalServers, unsecuredPorts); if (serviceOpt.isPresent()) { Service service = serviceOpt.get(); String serviceName = service.getMetadata().getName(); k8sEnv.getServices().put(serviceName, service); exposeNonSecureServers(serviceName, externalServers, unsecuredPorts); } exposeSecureServers(secureServers, securedPorts); }
@Override public boolean onStopJob(android.app.job.JobParameters params) { Connection connection = connections.get(params.getJobId()); if (connection != null) { JobService.Binder binder = connection.binder; boolean needsReschedule = binder != null && binder.stopJob(toLocalParameters(connection.params, connection.transientExtras)); stopJob(connection, needsReschedule); return needsReschedule; } else { return false; } }
@Override public long getStartTime() { return startTime; }
static void addMetaInfImplementations(Clazzes clazzes, Clazz clazz, Set<Clazz> compiled, Set<Clazz> compileQueue) throws IOException { String metaInfName = "META-INF/services/" + clazz.getClassName(); IOException throwLater = null; for (InputStream is : clazzes.loadResources(metaInfName)) { try (BufferedReader r = new BufferedReader(new InputStreamReader(is, "UTF8"))) { for (;;) { String line = r.readLine(); if (line == null) { break; } if (line.startsWith("#")) { continue; } String implClazzName = line.replace('.', '/'); Clazz implClazz = clazzes.load(implClazzName); if (implClazz != null && !compiled.contains(implClazz)) { compileQueue.add(implClazz); } } } catch (IOException ex) { throwLater = ex; } } if (throwLater != null) { throw throwLater; } }
@Override public boolean isEmpty() { return map.isEmpty(); }
@Override public void validate(Object obj, Errors errors) throws APIException, DuplicateConceptNameException { if (obj == null || !(obj instanceof Concept)) { throw new IllegalArgumentException("The parameter obj should not be null and must be of type" + Concept.class); } Concept conceptToValidate = (Concept) obj; if (conceptToValidate.getNames().isEmpty()) { errors.reject("Concept.name.atLeastOneRequired"); return; } ValidationUtils.rejectIfEmpty(errors, "datatype", "Concept.datatype.empty"); ValidationUtils.rejectIfEmpty(errors, "conceptClass", "Concept.conceptClass.empty"); boolean hasFullySpecifiedName = false; for (Locale conceptNameLocale : conceptToValidate.getAllConceptNameLocales()) { boolean fullySpecifiedNameForLocaleFound = false; boolean preferredNameForLocaleFound = false; boolean shortNameForLocaleFound = false; Set<String> validNamesFoundInLocale = new HashSet<>(); Collection<ConceptName> namesInLocale = conceptToValidate.getNames(conceptNameLocale); for (ConceptName nameInLocale : namesInLocale) { if (StringUtils.isBlank(nameInLocale.getName())) { log.debug("Name in locale '" + conceptNameLocale.toString() + "' cannot be an empty string or white space"); errors.reject("Concept.name.empty"); } if (nameInLocale.getLocalePreferred() != null) { if (nameInLocale.getLocalePreferred() && !preferredNameForLocaleFound) { if (nameInLocale.isIndexTerm()) { log.warn("Preferred name in locale '" + conceptNameLocale.toString() + "' shouldn't be an index term"); errors.reject("Concept.error.preferredName.is.indexTerm"); } else if (nameInLocale.isShort()) { log.warn("Preferred name in locale '" + conceptNameLocale.toString() + "' shouldn't be a short name"); errors.reject("Concept.error.preferredName.is.shortName"); } else if (nameInLocale.getVoided()) { log.warn("Preferred name in locale '" + conceptNameLocale.toString() + "' shouldn't be a voided name"); errors.reject("Concept.error.preferredName.is.voided"); } preferredNameForLocaleFound = true; } else if (nameInLocale.getLocalePreferred() && preferredNameForLocaleFound) { log.warn("Found multiple preferred names in locale '" + conceptNameLocale.toString() + "'"); errors.reject("Concept.error.multipleLocalePreferredNames"); } } if (nameInLocale.isFullySpecifiedName()) { if (!hasFullySpecifiedName) { hasFullySpecifiedName = true; } if (!fullySpecifiedNameForLocaleFound) { fullySpecifiedNameForLocaleFound = true; } else { log.warn("Found multiple fully specified names in locale '" + conceptNameLocale.toString() + "'"); errors.reject("Concept.error.multipleFullySpecifiedNames"); } if (nameInLocale.getVoided()) { log.warn("Fully Specified name in locale '" + conceptNameLocale.toString() + "' shouldn't be a voided name"); errors.reject("Concept.error.fullySpecifiedName.is.voided"); } } if (nameInLocale.isShort()) { if (!shortNameForLocaleFound) { shortNameForLocaleFound = true; } else { log.warn("Found multiple short names in locale '" + conceptNameLocale.toString() + "'"); errors.reject("Concept.error.multipleShortNames"); } } if (Context.getConceptService().isConceptNameDuplicate(nameInLocale)) { throw new DuplicateConceptNameException("'" + nameInLocale.getName() + "' is a duplicate name in locale '" + conceptNameLocale.toString() + "'"); } if (errors.hasErrors()) { log.debug("Concept name '" + nameInLocale.getName() + "' for locale '" + conceptNameLocale + "' is invalid"); return; } if (!nameInLocale.isShort() && !validNamesFoundInLocale.add(nameInLocale.getName().toLowerCase())) { throw new DuplicateConceptNameException("'" + nameInLocale.getName() + "' is a duplicate name in locale '" + conceptNameLocale.toString() + "' for the same concept"); } if (log.isDebugEnabled()) { log.debug("Valid name found: " + nameInLocale.getName()); } } } if (!hasFullySpecifiedName) { log.debug("Concept has no fully specified name"); errors.reject("Concept.error.no.FullySpecifiedName"); } if (CollectionUtils.isNotEmpty(conceptToValidate.getConceptMappings())) { int index = 0; Set<Integer> mappedTermIds = null; for (ConceptMap map : conceptToValidate.getConceptMappings()) { if (map.getConceptReferenceTerm().getConceptReferenceTermId() == null) { try { errors.pushNestedPath("conceptMappings[" + index + "].conceptReferenceTerm"); ValidationUtils.invokeValidator(new ConceptReferenceTermValidator(), map.getConceptReferenceTerm(), errors); } finally { errors.popNestedPath(); } } if (errors.hasErrors()) { return; } if (mappedTermIds == null) { mappedTermIds = new HashSet<>(); } if (map.getConceptReferenceTerm().getId() != null && !mappedTermIds.add(map.getConceptReferenceTerm().getId())) { errors.rejectValue("conceptMappings[" + index + "]", "ConceptReferenceTerm.term.alreadyMapped", "Cannot map a reference term multiple times to the same concept"); } index++; } } if (CollectionUtils.isNotEmpty(conceptToValidate.getAnswers())) { for (ConceptAnswer conceptAnswer : conceptToValidate.getAnswers()) { if (conceptAnswer.getAnswerConcept().equals(conceptToValidate)) { errors.reject("Concept.contains.itself.as.answer"); } } } ValidateUtil.validateFieldLengths(errors, obj.getClass(), "version", "retireReason"); super.validateAttributes(conceptToValidate, errors, Context.getConceptService().getAllConceptAttributeTypes()); }
public void setBackOffTime(long backOffTime) { this.backOffTime = backOffTime; }
@Override public PointForecast forecast(MetricData metricData) { notNull(metricData, "metricData can't be null"); val observed = metricData.getValue(); updateEstimates(observed); return new PointForecast(mean, false); }
public static long parseLong(String string) throws InvalidFormatException { return parseLong(string, 10); }
public static RegressionMetricsSummary getRegressionStatistics(Iterable<Row> rows) { RegressionMetricsSummary regressionSummary = new RegressionMetricsSummary(); for (Row row : rows) { if (checkRowFieldNotNull(row)) { double yVal = ((Number)row.getField(0)).doubleValue(); double predictVal = ((Number)row.getField(1)).doubleValue(); double diff = Math.abs(yVal - predictVal); regressionSummary.ySumLocal += yVal; regressionSummary.ySum2Local += yVal * yVal; regressionSummary.predSumLocal += predictVal; regressionSummary.predSum2Local += predictVal * predictVal; regressionSummary.maeLocal += diff; regressionSummary.sseLocal += diff * diff; regressionSummary.mapeLocal += Math.abs(diff / yVal); regressionSummary.total++; } } return regressionSummary.total == 0 ? null : regressionSummary; }
public static Object featureToObject(Feature f, Annotation a) { Object ret = null; switch (f.getRange().getName()) { case CAS.TYPE_NAME_STRING: ret = StringToObject.convertStringToObject(a.getStringValue(f)); break; case CAS.TYPE_NAME_INTEGER: ret = a.getIntValue(f); break; case CAS.TYPE_NAME_FLOAT: ret = a.getFloatValue(f); break; case CAS.TYPE_NAME_BOOLEAN: ret = a.getBooleanValue(f); break; case CAS.TYPE_NAME_BYTE: ret = a.getByteValue(f); break; case CAS.TYPE_NAME_SHORT: ret = a.getShortValue(f); break; case CAS.TYPE_NAME_LONG: ret = a.getLongValue(f); break; case CAS.TYPE_NAME_DOUBLE: ret = a.getDoubleValue(f); break; default: ret = null; } return ret; }
@Override public StatusResult startCollector(boolean isCommandLine, String folderToSaveTrace, VideoOption videoOption_old, String password) { return this.startCollector(isCommandLine, folderToSaveTrace, videoOption, true, null, null, password); }
public Map<String, Object> getKsqlFunctionsConfigProps(final String functionName) { final Map<String, Object> udfProps = originalsWithPrefix( KSQL_FUNCTIONS_PROPERTY_PREFIX + functionName.toLowerCase(), false); final Map<String, Object> globals = originalsWithPrefix( KSQ_FUNCTIONS_GLOBAL_PROPERTY_PREFIX, false); udfProps.putAll(globals); return udfProps; }
@Override public void validate(ValidityLevel level, ContentHandle content) throws InvalidContentException { if (level == ValidityLevel.SYNTAX_ONLY || level == ValidityLevel.FULL) { try { new SchemaParser().parse(content.content()); } catch (Exception e) { throw new InvalidContentException("Syntax violation for GraphQL artifact.", e); } } }
public void setPGN(String pgn) throws ChessParseError { { StringBuilder out = new StringBuilder(); Scanner sc = new Scanner(pgn); sc.useDelimiter(""); while (sc.hasNext()) { String c = sc.next(); if (c.equals("{")) { sc.skip("[^}]*}"); } else if (c.equals(";")) { sc.skip("[^\n]*\n"); } else { out.append(c); } } pgn = out.toString(); sc.close(); } Position pos = TextIO.readFEN(TextIO.startPosFEN); Scanner sc = new Scanner(pgn); sc.useDelimiter("\\s+"); while (sc.hasNext("\\[.*")) { String tagName = sc.next(); if (tagName.length() > 1) { tagName = tagName.substring(1); } else { tagName = sc.next(); } String tagValue = sc.findWithinHorizon(".*\\]", 0); tagValue = tagValue.trim(); if (tagValue.charAt(0) == '"') tagValue = tagValue.substring(1); if (tagValue.charAt(tagValue.length()-1) == ']') tagValue = tagValue.substring(0, tagValue.length() - 1); if (tagValue.charAt(tagValue.length()-1) == '"') tagValue = tagValue.substring(0, tagValue.length() - 1); if (tagName.equals("FEN")) { pos = TextIO.readFEN(tagValue); } } game.processString("new"); game.pos = pos; { StringBuilder out = new StringBuilder(); sc.useDelimiter(""); int level = 0; while (sc.hasNext()) { String c = sc.next(); if (c.equals("(")) { level++; } else if (c.equals(")")) { level--; } else if (level == 0) { out.append(c); } } pgn = out.toString(); } sc.close(); sc = new Scanner(pgn); sc.useDelimiter("\\s+"); while (sc.hasNext()) { String strMove = sc.next(); strMove = strMove.replaceFirst("\\$?[0-9]*\\.*([^?!]*)[?!]*", "$1"); if (strMove.length() == 0) continue; Move m = TextIO.stringToMove(game.pos, strMove); if (m == null) break; game.processString(strMove); } sc.close(); }
public static long adjustOffset(long oldCount, long calculatedOffset, int resolution) { if (oldCount + calculatedOffset < 0) { return -oldCount; } if (resolution <= 10 || oldCount < resolution * 10) { return calculatedOffset; } return RANDOM.nextInt(10) == 0 ? calculatedOffset * 10 : 0; }
protected boolean isInstallTypeVersion(String installpath) { String versionFile = getTypeProperty(VERSION_FILE); String installPathMatch = getTypeProperty(INSTALLPATH_MATCH); String installPathNoMatch = getTypeProperty(INSTALLPATH_NOMATCH); if (versionFile != null) { if (versionFile.startsWith("**/")) { versionFile=versionFile.substring(3); Pattern pattern=Pattern.compile(versionFile); File f=findVersionFile(new File(installpath),pattern); if (f==null) { return false; } getLog().debug(VERSION_FILE + "=" + versionFile + " matches -> " + f); Matcher m = pattern.matcher(f.getAbsolutePath()); m.find(); if(m.groupCount()!=0){ if(!getTypeInfo().getVersion().equals(m.group(1))){ getLog().debug(installpath + " not a match for version " + getTypeInfo().getVersion() + ", skipping"); return false; } } } else { File instPath = new File(installpath); if (instPath.isFile() && !instPath.isDirectory()) { instPath = instPath.getParentFile(); } File file = (instPath != null) ? new File(instPath, versionFile) : new File(versionFile); if (!file.exists()) { String[] expanded = PluginLoader.expand(file); if ((expanded == null) || (expanded.length == 0)) { getLog().debug(file + " does not exist, skipping"); return false; } else { getLog().debug(VERSION_FILE + "=" + versionFile + " matches -> " + expanded[0]); } } } } if (installPathMatch != null) { if (!(installpath.indexOf(installPathMatch) != -1)) { getLog().debug(installpath + " not a match for " + installPathMatch + ", skipping"); return false; } } if (installPathNoMatch != null) { if (installpath.indexOf(installPathNoMatch) != -1) { getLog().debug(installpath + " is a match for " + installPathNoMatch + ", skipping"); return false; } } return true; }
@Override public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { final RemotingCommand response = RemotingCommand.createResponseCommand(null); final EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class); LOGGER.info("Transaction request:{}", requestHeader); if (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) { response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE); LOGGER.warn("Message store is slave mode, so end transaction is forbidden. "); return response; } if (requestHeader.getFromTransactionCheck()) { switch (requestHeader.getCommitOrRollback()) { case MessageSysFlag.TRANSACTION_NOT_TYPE: { LOGGER.warn("Check producer[{}] transaction state, but it's pending status." + "RequestHeader: {} Remark: {}", RemotingHelper.parseChannelRemoteAddr(ctx.channel()), requestHeader.toString(), request.getRemark()); return null; } case MessageSysFlag.TRANSACTION_COMMIT_TYPE: { LOGGER.warn("Check producer[{}] transaction state, the producer commit the message." + "RequestHeader: {} Remark: {}", RemotingHelper.parseChannelRemoteAddr(ctx.channel()), requestHeader.toString(), request.getRemark()); break; } case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: { LOGGER.warn("Check producer[{}] transaction state, the producer rollback the message." + "RequestHeader: {} Remark: {}", RemotingHelper.parseChannelRemoteAddr(ctx.channel()), requestHeader.toString(), request.getRemark()); break; } default: return null; } } else { switch (requestHeader.getCommitOrRollback()) { case MessageSysFlag.TRANSACTION_NOT_TYPE: { LOGGER.warn("The producer[{}] end transaction in sending message, and it's pending status." + "RequestHeader: {} Remark: {}", RemotingHelper.parseChannelRemoteAddr(ctx.channel()), requestHeader.toString(), request.getRemark()); return null; } case MessageSysFlag.TRANSACTION_COMMIT_TYPE: { break; } case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: { LOGGER.warn("The producer[{}] end transaction in sending message, rollback the message." + "RequestHeader: {} Remark: {}", RemotingHelper.parseChannelRemoteAddr(ctx.channel()), requestHeader.toString(), request.getRemark()); break; } default: return null; } } OperationResult result = new OperationResult(); if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) { result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader); if (result.getResponseCode() == ResponseCode.SUCCESS) { RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader); if (res.getCode() == ResponseCode.SUCCESS) { MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage()); msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback())); msgInner.setQueueOffset(requestHeader.getTranStateTableOffset()); msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset()); msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp()); RemotingCommand sendResult = sendFinalMessage(msgInner); if (sendResult.getCode() == ResponseCode.SUCCESS) { this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage()); } return sendResult; } return res; } } else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) { result = this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader); if (result.getResponseCode() == ResponseCode.SUCCESS) { RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader); if (res.getCode() == ResponseCode.SUCCESS) { this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage()); } return res; } } response.setCode(result.getResponseCode()); response.setRemark(result.getResponseRemark()); return response; }
public static void validateTableObject(Table table, Configuration conf) throws InvalidObjectException { checkNotNull(table, "table cannot be null"); checkNotNull(table.getSd(), "Table#StorageDescriptor cannot be null"); if (!hiveShims.validateTableName(table.getTableName(), conf)) { throw new InvalidObjectException(table.getTableName() + " is not a valid object name"); } String validate = MetaStoreUtils.validateTblColumns(table.getSd().getCols()); if (validate != null) { throw new InvalidObjectException("Invalid column " + validate); } if (table.getPartitionKeys() != null) { validate = MetaStoreUtils.validateTblColumns(table.getPartitionKeys()); if (validate != null) { throw new InvalidObjectException("Invalid partition column " + validate); } } }
public static Set<Authorizations> mergeAuthorizations(String requestedAuths, Collection<? extends Collection<String>> userAuths) { HashSet<String> requested = null; if (!StringUtils.isEmpty(requestedAuths)) { requested = new HashSet<>(splitAuths(requestedAuths)); } if (null == userAuths) return Collections.singleton(new Authorizations()); HashSet<Authorizations> mergedAuths = new HashSet<>(); HashSet<String> missingAuths = (requested == null) ? new HashSet<>() : new HashSet<>(requested); for (Collection<String> auths : userAuths) { if (null != requested) { missingAuths.removeAll(auths); auths = new HashSet<>(auths); auths.retainAll(requested); } mergedAuths.add(new Authorizations(auths.toArray(new String[auths.size()]))); } if (!missingAuths.isEmpty()) { throw new IllegalArgumentException("User requested authorizations that they don't have. Missing: " + missingAuths + ", Requested: " + requested + ", User: " + userAuths); } return mergedAuths; }
public String process(String formatPattern) { ReplacementData data = ReplacementData.of(method, idx, Arrays.asList(parameters)); return super.process(data, formatPattern); }
DatasetMetadata merge( final List<DatasetMetadata> metadata ) { if ( metadata == null || metadata.isEmpty() ) return null; DatasetMetadata mergedMetadata = null; for ( DatasetMetadata datasetMetadata : metadata ) { if ( mergedMetadata == null ) mergedMetadata = datasetMetadata; else mergedMetadata = merge( mergedMetadata, datasetMetadata ); } return mergedMetadata; }
boolean isValid(Map<String, Object> preferences) { for (Map.Entry<String, Object> entry : defaults.entrySet()) { Object defaultValue = entry.getValue(); Object newValue = preferences.get(entry.getKey()); if (newValue != null) { if (!defaultValue.getClass().isAssignableFrom(newValue.getClass())) { return false; } } } return true; }
public static RollingThreadPoolMaxConcurrencyStream getInstance(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties properties) { final int counterMetricWindow = properties.metricsRollingStatisticalWindowInMilliseconds().get(); final int numCounterBuckets = properties.metricsRollingStatisticalWindowBuckets().get(); final int counterBucketSizeInMs = counterMetricWindow / numCounterBuckets; return getInstance(threadPoolKey, numCounterBuckets, counterBucketSizeInMs); }
public State currentState() { return lastState.get().state; }
public static String substitute(DownloadRequirement req, String basevalue) { return substitute(basevalue, getBasicSubstitutions(req)); }
public static void unzip(BeanByteSource source, Path path) { Path absolutePath = path.toAbsolutePath(); Set<ZipKey> deduplicate = new HashSet<>(); try (ZipInputStream in = new ZipInputStream(source.openStream())) { ZipEntry entry = in.getNextEntry(); while (entry != null) { Path resolved = validateZipPathName(absolutePath, entry); if (!entry.isDirectory()) { if (deduplicate.add(new ZipKey(entry, resolved))) { Files.createDirectories(resolved); Files.copy(in, resolved, StandardCopyOption.REPLACE_EXISTING); } } in.closeEntry(); entry = in.getNextEntry(); } } catch (IOException ex) { throw new UncheckedIOException(ex); } }
@Override public DataSet<EPGMGraphHead> getGraphHeadsByLabel(String label) { return graphHeads.filter(new ByLabel<>(label)); }
public Consumer consumer( KafkaConsumerInputMeta meta, Function<String, String> variablesFunction ) { return consumer( meta, variablesFunction, KafkaConsumerField.Type.String, KafkaConsumerField.Type.String ); }
@NonNull public static Predicate<String> isNotEmpty() { return TextUtils::isNotEmpty; }
public BrooklynProperties.Factory.Builder createPropertiesBuilder() { if (brooklynProperties == null) { BrooklynProperties.Factory.Builder builder = BrooklynProperties.Factory.builderDefault(); if (Strings.isNonEmpty(globalBrooklynPropertiesFile)) { File globalProperties = new File(Os.tidyPath(globalBrooklynPropertiesFile)); if (globalProperties.exists()) { globalProperties = resolveSymbolicLink(globalProperties); checkFileReadable(globalProperties); checkFilePermissionsX00(globalProperties); LOG.debug("Using global properties file " + globalProperties); } else { LOG.debug("Global properties file " + globalProperties + " does not exist, will ignore"); } builder.globalPropertiesFile(globalProperties.getAbsolutePath()); } else { LOG.debug("Global properties file disabled"); builder.globalPropertiesFile(null); } if (Strings.isNonEmpty(localBrooklynPropertiesFile)) { File localProperties = new File(Os.tidyPath(localBrooklynPropertiesFile)); localProperties = resolveSymbolicLink(localProperties); checkFileReadable(localProperties); checkFilePermissionsX00(localProperties); builder.localPropertiesFile(localProperties.getAbsolutePath()); } if (propertiesSupplier != null) { builder.propertiesSupplier(propertiesSupplier); } return builder; } else { if (globalBrooklynPropertiesFile != null) LOG.warn("Ignoring globalBrooklynPropertiesFile "+globalBrooklynPropertiesFile+" because explicit brooklynProperties supplied"); if (localBrooklynPropertiesFile != null) LOG.warn("Ignoring localBrooklynPropertiesFile "+localBrooklynPropertiesFile+" because explicit brooklynProperties supplied"); return Builder.fromProperties(brooklynProperties); } }
public String getMember() { if (isNotBlank(getMemberName())) { return getMemberName(); } if (isNotBlank(getMemberId())) { return getMemberId(); } return null; }
public static <T, U> RelaxedSubscriber<T> subscribe(Subscriber<? super U> s, Function<? super T, ? extends Publisher<? extends U>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { return new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize); }
public void copyCostValuesFromOperation(final ViewDefinitionState view, final ComponentState operationLookupState, final String[] args) { ComponentState operationLookup = view.getComponentByReference(OPERATION_FIELD); if (operationLookup.getFieldValue() == null) { if (!OPERATION_FIELD.equals(operationLookupState.getName())) { view.getComponentByReference("form").addMessage("costNormsForOperation.messages.info.missingOperationReference", INFO); } return; } Entity operation = dataDefinitionService.get(TechnologiesConstants.PLUGIN_IDENTIFIER, TechnologiesConstants.MODEL_OPERATION).get((Long) operationLookup.getFieldValue()); applyCostNormsFromGivenSource(view, operation); }
public static void main(String[] args) throws Exception { TikaCLI cli = new TikaCLI(); if (!isConfigured()) { PropertyConfigurator.configure(cli.getClass().getResourceAsStream("/log4j.properties")); } if (cli.testForHelp(args)) { cli.usage(); return; } else if (cli.testForBatch(args)) { String[] batchArgs = BatchCommandLineBuilder.build(args); BatchProcessDriverCLI batchDriver = new BatchProcessDriverCLI(batchArgs); batchDriver.execute(); return; } if (args.length > 0) { for (int i = 0; i < args.length; i++) { cli.process(args[i]); } if (cli.pipeMode) { cli.process("-"); } } else { if (System.in.available() == 0) { Thread.sleep(100); } if (System.in.available() > 0) { cli.process("-"); } else { cli.process("--gui"); } } }
@Override public Enumeration<String> getParameterNames() { if (request.getMultiValueQueryStringParameters() == null) { return Collections.emptyEnumeration(); } return Collections.enumeration(request.getMultiValueQueryStringParameters().keySet()); }
@Override public void initialize(Map<String, Object> config) { super.initialize(config); if(config.containsKey(INDICATOR_COLUMN_KEY)) { indicatorColumn = columnMap.get(config.get(INDICATOR_COLUMN_KEY).toString()); } if(config.containsKey(TYPE_KEY)) { type = config.get(TYPE_KEY).toString(); } else if(config.containsKey(TYPE_COLUMN_KEY)) { typeColumnIndex = columnMap.get(config.get(TYPE_COLUMN_KEY).toString()); } if(config.containsKey(LOOKUP_CONVERTER)) { converter = LookupConverters.getConverter((String) config.get(LOOKUP_CONVERTER)); } }
public CharFormatter with(final String string) { final int length = string.length(); final char[] value = ensureLength(length); lengths[encodedSoFar] = length; string.getChars(0, length, value, 0); encodedSoFar++; return this; }
public Object orderGetOrders(String orderId, String orderLinkId, String symbol, String order, BigDecimal page, BigDecimal limit, String orderStatus) throws ApiException { ApiResponse<Object> resp = orderGetOrdersWithHttpInfo(orderId, orderLinkId, symbol, order, page, limit, orderStatus); return resp.getData(); }
public GatewayConfigDocument parse(final File configFile) throws Exception { long time = 0; if (LOGGER.isDebugEnabled()) { time = System.currentTimeMillis(); } String configFileName = configFile.getName(); GatewayConfigDocument config = null; XmlOptions parseOptions = new XmlOptions(); parseOptions.setLoadLineNumbers(); parseOptions.setLoadLineNumbers(XmlOptions.LOAD_LINE_NUMBERS_END_ELEMENT); parseOptions.setLoadStripWhitespace(); parseOptions.setLoadStripComments(); File translatedConfigFile; try { translatedConfigFile = getTranslatedConfigFile(configFile); } catch (Exception e) { Throwable rootCause = getRootCause(e); if (rootCause == null) { rootCause = e; } if (LOGGER.isDebugEnabled()) { LOGGER.error("Error upgrading XML: " + rootCause, rootCause); } else { LOGGER.error("Error upgrading XML: " + rootCause); } if (e instanceof IllegalArgumentException) { throw e; } else { throw new GatewayConfigParserException(e.getMessage()); } } List<String> xmlParseErrors = new ArrayList<>(); try { config = GatewayConfigDocument.Factory.parse(new FileInputStream(translatedConfigFile), parseOptions); } catch (Exception e) { xmlParseErrors.add("Invalid XML: " + getRootCause(e).getMessage()); } if (xmlParseErrors.isEmpty()) { GatewayConfigDocument.GatewayConfig gatewayConfig = config.getGatewayConfig(); PropertiesType properties = gatewayConfig.getProperties(); Map<String, String> propertiesMap = new HashMap<>(); if (properties != null) { for (PropertyType propertyType : properties.getPropertyArray()) { propertiesMap.put(propertyType.getName(), propertyType.getValue()); } } InputStream xmlInjectedIn = new PipedInputStream(); OutputStream xmlInjectedOut = new PipedOutputStream((PipedInputStream) xmlInjectedIn); ExecutorService xmlInjectedExecutor = Executors.newSingleThreadExecutor(); Future<Boolean> xmlInjectedFuture = xmlInjectedExecutor.submit(new XMLParameterInjector(new FileInputStream( translatedConfigFile), xmlInjectedOut, propertiesMap, configuration, xmlParseErrors)); if (LOGGER.isTraceEnabled()) { xmlInjectedIn = bufferToTraceLog(xmlInjectedIn, "Gateway config file '" + configFileName + "' post parameter injection", LOGGER); } InputStream xmlTransformedIn = new PipedInputStream(); OutputStream xmlTransformedOut = new PipedOutputStream((PipedInputStream) xmlTransformedIn); ExecutorService xmlTransformedExecutor = Executors.newSingleThreadExecutor(); Future<Boolean> xmlTransformedFuture = xmlTransformedExecutor.submit( new XSLTransformer(xmlInjectedIn, xmlTransformedOut, GATEWAY_CONFIG_ANNOTATE_TYPES_XSL)); if (LOGGER.isTraceEnabled()) { xmlTransformedIn = bufferToTraceLog(xmlTransformedIn, "Gateway config file '" + configFileName + "' post XSL transformation", LOGGER); } try { config = GatewayConfigDocument.Factory.parse(xmlTransformedIn, parseOptions); } catch (Exception e) { try { if (xmlInjectedFuture.get()) { if (xmlTransformedFuture.get()) { throw e; } } } catch (Exception n) { xmlParseErrors.add("Invalid XML: " + getRootCause(n).getMessage()); } } finally { xmlInjectedFuture.cancel(true); xmlInjectedExecutor.shutdownNow(); xmlTransformedFuture.cancel(true); xmlTransformedExecutor.shutdownNow(); } } validateGatewayConfig(config, xmlParseErrors); if (LOGGER.isDebugEnabled()) { LOGGER.debug("parsed " + " gateway config file '" + configFileName + "' in [" + (System.currentTimeMillis() - time) + " ms]"); } return config; }
public String renderTemplateFile(File templateFile, Map<String, Object> contextMap) { for (Map.Entry<String, Object> entry : contextMap.entrySet()) { renderContext.put(entry.getKey(), entry.getValue()); } return renderTemplateFile(templateFile); }
public FontBuilder fontCourierNew() { return Styles.fontCourierNew(); }
@DELETE @Path("/{name}") @Produces(APPLICATION_JSON) @Timed @ExceptionMetered public Response removeDeploymentGroup(@PathParam("name") @Valid final String name) { try { model.removeDeploymentGroup(name); return Response.ok(new RemoveDeploymentGroupResponse( RemoveDeploymentGroupResponse.Status.REMOVED)).build(); } catch (final DeploymentGroupDoesNotExistException e) { return Response.ok(new RemoveDeploymentGroupResponse( RemoveDeploymentGroupResponse.Status.DEPLOYMENT_GROUP_NOT_FOUND)).build(); } }
public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step, NamedClusterService namedClusterService, NamedCluster namedCluster, LogChannelInterface logChannelInterface ) throws KettleException { String namedClusterName = namedCluster.getName(); String m_zookeeperHosts = namedCluster.getZooKeeperHost(); String m_zookeeperPort = namedCluster.getZooKeeperPort(); if ( !StringUtils.isEmpty( namedClusterName ) ) { rep.saveStepAttribute( id_transformation, id_step, CLUSTER_NAME, namedClusterName ); try { if ( namedClusterService.contains( namedClusterName, metaStore ) ) { NamedCluster nc = namedClusterService.read( namedClusterName, metaStore ); m_zookeeperHosts = nc.getZooKeeperHost(); m_zookeeperPort = nc.getZooKeeperPort(); } } catch ( MetaStoreException e ) { logChannelInterface.logDebug( e.getMessage(), e ); } } if ( !Utils.isEmpty( m_zookeeperHosts ) ) { rep.saveStepAttribute( id_transformation, id_step, 0, ZOOKEEPER_HOSTS, m_zookeeperHosts ); } if ( !Utils.isEmpty( m_zookeeperPort ) ) { rep.saveStepAttribute( id_transformation, id_step, 0, ZOOKEEPER_PORT, m_zookeeperPort ); } }
public ToolExecutionCheckStatus checkTool(Tool tool, String tag) { Optional<ToolVersionScanResult> versionScanOp = toolManager.loadToolVersionScan(tool.getId(), tag); int graceHours = preferenceManager.getPreference(SystemPreferences.DOCKER_SECURITY_TOOL_GRACE_HOURS); boolean isGracePeriodOrWhiteList = versionScanOp.isPresent() && (gracePeriodIsActive(versionScanOp.get(), graceHours) || versionScanOp.get().isFromWhiteList()); if (isGracePeriodOrWhiteList) { LOGGER.debug("Tool: " + tool.getId() + " version: " + tag + " is from White list or Grace period still active! Proceed with running!"); return ToolExecutionCheckStatus.success(); } boolean denyNotScanned = preferenceManager.getPreference( SystemPreferences.DOCKER_SECURITY_TOOL_POLICY_DENY_NOT_SCANNED); if (denyNotScanned && (!versionScanOp.isPresent() || versionScanOp.get().getStatus() == ToolScanStatus.NOT_SCANNED || versionScanOp.get().getSuccessScanDate() == null)) { return ToolExecutionCheckStatus.fail("Tool is not scanned."); } if (versionScanOp.isPresent()) { ToolVersionScanResult toolVersionScanResult = versionScanOp.get(); Map<VulnerabilitySeverity, Integer> severityCounters = toolVersionScanResult.getVulnerabilities().stream() .collect( HashMap::new, (map, v) -> { if (map.containsKey(v.getSeverity())) { map.put(v.getSeverity(), map.get(v.getSeverity()) + 1); } else { map.put(v.getSeverity(), 1); } }, (map1, map2) -> map1.keySet().forEach(k -> map1.merge(k, map2.get(k), (a, b) -> a + b))); int maxCriticalVulnerabilities = preferenceManager.getPreference( SystemPreferences.DOCKER_SECURITY_TOOL_POLICY_MAX_CRITICAL_VULNERABILITIES); if (maxCriticalVulnerabilities != DISABLED && maxCriticalVulnerabilities < severityCounters.getOrDefault(VulnerabilitySeverity.Critical, 0)) { return ToolExecutionCheckStatus.fail("Max number of CRITICAL vulnerabilities is reached"); } int maxHighVulnerabilities = preferenceManager.getPreference( SystemPreferences.DOCKER_SECURITY_TOOL_POLICY_MAX_HIGH_VULNERABILITIES); if (maxHighVulnerabilities != DISABLED && maxHighVulnerabilities < severityCounters.getOrDefault(VulnerabilitySeverity.High, 0)) { return ToolExecutionCheckStatus.fail("Max number of HIGH vulnerabilities is reached"); } int maxMediumVulnerabilities = preferenceManager.getPreference( SystemPreferences.DOCKER_SECURITY_TOOL_POLICY_MAX_MEDIUM_VULNERABILITIES); if (maxMediumVulnerabilities != DISABLED && maxMediumVulnerabilities < severityCounters.getOrDefault(VulnerabilitySeverity.Medium, 0)) { return ToolExecutionCheckStatus.fail("Max number of MEDIUM vulnerabilities is reached"); } LOGGER.debug("Tool: {} version: {} Check tool os version.", tool.getId(), tag); if (toolVersionScanResult.getToolOSVersion() != null && !toolManager.isToolOSVersionAllowed(toolVersionScanResult.getToolOSVersion())) { LOGGER.warn("Tool: {} version: {}. Tool os version isn't allowed, check preference {} ! Cancel run.", tool.getId(), tag, SystemPreferences.DOCKER_SECURITY_TOOL_OS.getKey()); return ToolExecutionCheckStatus.fail("This type of OS is not supported."); } } return ToolExecutionCheckStatus.success(); }
public static <T> CachedSupplier.Builder<T> builder(Supplier<RefreshResult<T>> valueSupplier) { return new CachedSupplier.Builder<>(valueSupplier); }
@VisibleForTesting static Instant getCreationTime(String configuredCreationTime, ProjectProperties projectProperties) throws DateTimeParseException, InvalidCreationTimeException { try { switch (configuredCreationTime) { case "EPOCH": return Instant.EPOCH; case "USE_CURRENT_TIMESTAMP": projectProperties.log( LogEvent.warn( "Setting image creation time to current time; your image may not be reproducible.")); return Instant.now(); default: DateTimeFormatter formatter = new DateTimeFormatterBuilder() .append(DateTimeFormatter.ISO_DATE_TIME) .optionalStart() .appendOffset("+HHmm", "+0000") .optionalEnd() .toFormatter(); return formatter.parse(configuredCreationTime, Instant::from); } } catch (DateTimeParseException ex) { throw new InvalidCreationTimeException(configuredCreationTime, configuredCreationTime, ex); } }
public static void createAndRegister(StackdriverStatsConfiguration configuration) throws IOException { checkNotNull(configuration, "configuration"); createInternal( configuration.getCredentials(), configuration.getProjectId(), configuration.getExportInterval(), configuration.getMonitoredResource(), configuration.getMetricNamePrefix(), configuration.getConstantLabels(), configuration.getDeadline(), configuration.getMetricServiceStub()); }
public static <I, O> Mapper<I, O> nullSafe(Mapper<I, O> mapper) { return input -> { if (input == null) { return null; } return mapper.map(input); }; }
@Override public FileStatus[] listStatus(JobConf job) throws IOException { List<String> incrementalTables = HoodieHiveUtils.getIncrementalTableNames(Job.getInstance(job)); InputPathHandler inputPathHandler = new InputPathHandler(conf, getInputPaths(job), incrementalTables); List<FileStatus> returns = new ArrayList<>(); Map<String, HoodieTableMetaClient> tableMetaClientMap = inputPathHandler.getTableMetaClientMap(); for (String table : incrementalTables) { HoodieTableMetaClient metaClient = tableMetaClientMap.get(table); if (metaClient == null) { continue; } List<Path> inputPaths = inputPathHandler.getGroupedIncrementalPaths().get(metaClient); List<FileStatus> result = listStatusForIncrementalMode(job, metaClient, inputPaths); if (result != null) { returns.addAll(result); } } List<Path> nonHoodiePaths = inputPathHandler.getNonHoodieInputPaths(); if (nonHoodiePaths.size() > 0) { setInputPaths(job, nonHoodiePaths.toArray(new Path[nonHoodiePaths.size()])); FileStatus[] fileStatuses = super.listStatus(job); returns.addAll(Arrays.asList(fileStatuses)); } List<Path> snapshotPaths = inputPathHandler.getSnapshotPaths(); if (snapshotPaths.size() > 0) { setInputPaths(job, snapshotPaths.toArray(new Path[snapshotPaths.size()])); FileStatus[] fileStatuses = super.listStatus(job); Map<HoodieTableMetaClient, List<FileStatus>> groupedFileStatus = HoodieInputFormatUtils.groupFileStatusForSnapshotPaths(fileStatuses, HoodieFileFormat.PARQUET.getFileExtension(), tableMetaClientMap.values()); LOG.info("Found a total of " + groupedFileStatus.size() + " groups"); for (Map.Entry<HoodieTableMetaClient, List<FileStatus>> entry : groupedFileStatus.entrySet()) { List<FileStatus> result = HoodieInputFormatUtils.filterFileStatusForSnapshotMode(job, entry.getKey(), entry.getValue()); if (result != null) { returns.addAll(result); } } } return returns.toArray(new FileStatus[returns.size()]); }
@Override public InputStream getContent() throws IOException { if( replayBuffer == null ) { return wrappedEntity.getContent(); } else if( finalStream != null ) { throw new IOException( "Existing stream already past replay buffer capacity." ); } else { if( wrappedStream == null ) { wrappedStream = wrappedEntity.getContent(); } return new ReplayStream(); } }
@Override public Boolean expireAt(byte[] key, long unixTime) { return helper.doInScope(RedisCommand.EXPIREAT, key, () -> connection.expireAt(key, unixTime)); }
long toMegabytes(final String unitAndUOM) { Preconditions.checkArgument(!Strings.isNullOrEmpty(unitAndUOM), "unitAndUOM should not be empty"); Preconditions.checkArgument(unitAndUOM.toUpperCase().endsWith("K") || unitAndUOM.toUpperCase().endsWith("M") || unitAndUOM.toUpperCase().endsWith("G") || Character.isDigit(unitAndUOM.charAt(unitAndUOM.length() -1)), "unitAndUOM should end with a proper UoM or with a digit"); try { final long bytesCount; if (unitAndUOM.toUpperCase().endsWith("K")) { bytesCount = getUnit(unitAndUOM) * ONE_KB; } else if (unitAndUOM.toUpperCase().endsWith("M")) { bytesCount = getUnit(unitAndUOM) * ONE_MB; } else if (unitAndUOM.toUpperCase().endsWith("G")) { bytesCount = getUnit(unitAndUOM) * ONE_GB; } else { bytesCount = Long.parseLong(unitAndUOM); } Preconditions.checkArgument(bytesCount > 0L, "unit should be positive"); return bytesCount / ONE_MB; } catch (final NumberFormatException e) { LOG.error("Cannot parse bytes and UoM {0}, cannot convert to megabytes."); throw e; } }
@Override public double measure(final SimpleFeature x, final SimpleFeature y) { double dist = Double.MAX_VALUE; final Coordinate[] coords = new DistanceOp(getGeometry(x), getGeometry(y)).nearestPoints(); for (int i = 0; i < coords.length; i++) { for (int j = i + 1; j < coords.length; j++) { dist = Math.min(dist, coordinateDistanceFunction.measure(coords[j], coords[i])); } } return dist; }
@Override public int complete( Session session, CommandLine commandLine, List<String> candidates ) { StringsCompleter delegate = new StringsCompleter( false ); for( Level level : LEVELS ) delegate.getStrings().add( level.toString()); return delegate.complete( session, commandLine, candidates ); }
@POST @Path("{from}/{to}") @Produces("text/plain") public String post(@PathParam("from") final String from, @PathParam("to") final String to, @FormParam("content") final String content) { REST.LOG.log(Level.INFO, "Converting from '" + from + "' to '" + to + "'..."); if ((null == content) || (0 == content.length())) { throw new ConverterWebApplicationException( Response.Status.NOT_ACCEPTABLE, "empty input"); } String result = ""; try { result = DeliveryMechanism.convert(from, to, content); } catch (MissingRspecElementException | InvalidRspecValueException | RiotException | MultipleNamespacesException | RequiredResourceNotFoundException | MultiplePropertyValuesException | DeprecatedRspecVersionException | UnsupportedException e) { throw new ConverterWebApplicationException( Response.Status.BAD_REQUEST, e); } catch (UnknownFormatConversionException e) { throw new ConverterWebApplicationException( Response.Status.NOT_ACCEPTABLE, e.getMessage()); } catch (XMLStreamException | JAXBException | InvalidModelException | IOException e) { throw new ConverterWebApplicationException( Response.Status.INTERNAL_SERVER_ERROR, e.getMessage()); } return result; }
public boolean isSpecified() { return (!this.isNasSelected()) && (!this.isUserNegotiated()); }
@Override public ResultSet getSchemas() { return null; }
@Override public String execute( final Context context, final String classname, final Map< String, String > params ) throws PluginException { if( !m_pluginsEnabled ) { return ""; } final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE ); final boolean debug = TextUtil.isPositive( params.get( PARAM_DEBUG ) ); try { final Plugin plugin = newWikiPlugin( classname, rb ); if( plugin == null ) { return "Plugin '" + classname + "' not compatible with this version of JSPWiki"; } try { return plugin.execute( context, params ); } catch( final PluginException e ) { if( debug ) { return stackTrace( params, e ); } throw ( PluginException )e.fillInStackTrace(); } catch( final Throwable t ) { log.info( "Plugin failed while executing:", t ); if( debug ) { return stackTrace( params, t ); } throw new PluginException( rb.getString( "plugin.error.failed" ), t ); } } catch( final ClassCastException e ) { throw new PluginException( MessageFormat.format( rb.getString( "plugin.error.notawikiplugin" ), classname ), e ); } }
void onResume() { if (seekPosition != 0) { videoView.seekTo(seekPosition); } if (isPlaying) { videoView.start(); videoControlView.update(); } }
@Override Trigger fromJSON(String data) { try { JSONObject d = new JSONObject(data); ssid.setValue(JsonHelper.safeGetString(d, "ssid")); lastRun = JsonHelper.safeGetLong(d, "lastRun"); comparator.setValue(Comparator.Compare.valueOf(JsonHelper.safeGetString(d, "comparator"))); } catch (Exception e) { log.error("Unhandled exception", e); } return this; }
@Duration public void setEntryExpiration(@Positive @Duration final long entryExpiration) { expires = Constraint.isGreaterThan(0, entryExpiration, "revocation cache entry expiration must be greater than 0"); }
CompletableFuture<IndexIndexingPlanExecutionReport<R>> execute() { CompletableFuture<IndexIndexingPlanExecutionReport<R>> reportFuture = CompletableFuture.allOf( futures ) .handle( (result, throwable) -> onAllWorksFinished() ); for ( int i = 0; i < works.size(); i++ ) { CompletableFuture<Long> future = futures[i]; SingleDocumentIndexingWork work = works.get( i ); orchestrator.submit( future, work ); } return reportFuture; }
public String renderTemplateFile(File templateFile, Map<String, Object> contextMap) { for (Map.Entry<String, Object> entry : contextMap.entrySet()) { renderContext.put(entry.getKey(), entry.getValue()); } return renderTemplateFile(templateFile); }
public static AddressHolder getAddressHolder(ConsumerBootstrap consumerBootstrap) { String addressHolder = null; try { addressHolder = consumerBootstrap.getConsumerConfig().getAddressHolder(); ExtensionClass<AddressHolder> ext = ExtensionLoaderFactory.getExtensionLoader(AddressHolder.class) .getExtensionClass(addressHolder); if (ext == null) { throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_LOAD_ADDRESS_HOLDER, addressHolder)); } return ext.getExtInstance(new Class[] { ConsumerBootstrap.class }, new Object[] { consumerBootstrap }); } catch (SofaRpcRuntimeException e) { throw e; } catch (Throwable e) { throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_LOAD_ADDRESS_HOLDER, addressHolder), e); } }
@Override public SQLStatement processTemplate(String template, Map<String, ?> parameters) { Map<String, Object> internalParameters = (parameters != null && !parameters.isEmpty()) ? new HashMap<>( parameters) : new HashMap<String, Object>(5); SimpleNode parsedTemplate = parse(template); return processTemplate(template, parsedTemplate, internalParameters); }
@VisibleForTesting static void validateTypes(List<Type> unresTypeList) { Preconditions.checkArgument(unresTypeList.size() % 2 == 0, "ETL Stages validation expects even number of types"); List<Type> resTypeList = Lists.newArrayListWithCapacity(unresTypeList.size()); resTypeList.add(unresTypeList.get(0)); try { Type nType = (new TypeResolver()).where(unresTypeList.get(1), resTypeList.get(0)).resolveType( unresTypeList.get(1)); resTypeList.add(nType); } catch (IllegalArgumentException e) { resTypeList.add(unresTypeList.get(1)); } for (int i = 2; i < unresTypeList.size(); i++) { Type actualType = resTypeList.get(i - 1); Type formalType = unresTypeList.get(i - 1); Type toResolveType = unresTypeList.get(i); try { Type newType; if ((toResolveType instanceof TypeVariable) || (toResolveType instanceof GenericArrayType)) { newType = (new TypeResolver()).where(toResolveType, actualType).resolveType(toResolveType); } else { newType = (new TypeResolver()).where(formalType, actualType).resolveType(toResolveType); } resTypeList.add(newType); } catch (IllegalArgumentException e) { resTypeList.add(toResolveType); } } for (int i = 0; i < resTypeList.size(); i += 2) { Type firstType = resTypeList.get(i); Type secondType = resTypeList.get(i + 1); Preconditions.checkArgument(TypeToken.of(secondType).isAssignableFrom(firstType), "Types between stages didn't match. Mismatch between %s -> %s", firstType, secondType); } }
@Override public void mutateRow(RowMutation rowMutation) { delegate.mutateRow(rowMutation); }
@Override public boolean isInUse() { return totalRuns >= 0; }
public void debug(String msg, Object... args) { if (logger.isDebugEnabled()) { logger.debug(msg, args); } }
public Sentence[] process(LanguageDirection language, String[] batch) throws ProcessingException, InterruptedException { return process(language, batch, null); }
public void selectedIndexChangeVetoed(org.apache.pivot.wtk.Accordion arg0, org.apache.pivot.util.Vote arg1) { if (selectedIndexChangeVetoed != null) { selectedIndexChangeVetoed.call(arg0, arg1); } }
@Override public String getAsString(FacesContext facesContext, UIComponent uiComponent, Object obj) { StringBuilder sb = new StringBuilder(); if (obj instanceof Collection) { @SuppressWarnings("unchecked") Collection<? extends Object> c = (Collection<? extends Object>) obj; for (Object o : c) { if (sb.length() != 0) { sb.append(", "); } sb.append(o.toString()); } } else { throw new IllegalArgumentException("Value must be a Collection type."); } return sb.toString(); }
public void updateForBlock(final BlockHeader header, final VoteTally voteTally) { if (epochManager.isEpochBlock(header.getNumber())) { voteTally.discardOutstandingVotes(); return; } final Optional<ValidatorVote> vote = blockInterface.extractVoteFromHeader(header); vote.ifPresent(voteTally::addVote); }
static int processCx(final String str, final CxSmilesState state) { final CharIter iter = new CharIter(str); if (!iter.nextIf('|')) return -1; while (iter.hasNext()) { switch (iter.next()) { case '$': Map<Integer, String> dest; if (iter.nextIf("_AV:")) dest = state.atomValues = new TreeMap<>(); else dest = state.atomLabels = new TreeMap<>(); if (!processAtomLabels(iter, dest)) return -1; break; case '(': if (!processCoords(iter, state)) return -1; break; case 'c': case 't': if (iter.nextIf(':')) { if (!skipIntList(iter, COMMA_SEPARATOR)) return -1; } else if (iter.nextIf("tu:")) { if (!skipIntList(iter, COMMA_SEPARATOR)) return -1; } break; case 'r': if (iter.nextIf(':')) { if (!skipIntList(iter, COMMA_SEPARATOR)) return -1; } else { if (!iter.nextIf(',') && iter.curr() != '|') return -1; } break; case 'l': if (!iter.nextIf("p:")) return -1; if (!skipIntMap(iter)) return -1; break; case 'f': if (!iter.nextIf(':')) return -1; if (!processFragmentGrouping(iter, state)) return -1; break; case 'S': if (iter.nextIf("g:")) { if (!processPolymerSgroups(iter, state)) return -1; } else if (iter.nextIf("gD:")) { if (!processDataSgroups(iter, state)) return -1; } else { return -1; } break; case 'm': if (!iter.nextIf(':')) return -1; if (!processPositionalVariation(iter, state)) return -1; break; case '^': if (!processRadicals(iter, state)) return -1; break; case 'C': case 'H': if (!iter.nextIf(':')) return -1; while (iter.hasNext() && isDigit(iter.curr())) { if (!skipIntList(iter, DOT_SEPARATOR)) return -1; iter.nextIf(','); } break; case '|': if (!iter.nextIf(' ')) iter.nextIf('\t'); return iter.pos; default: return -1; } } return -1; }
public String getUpdateTotalTasksStatement() { return QueryBuilder.update(keyspace, TABLE_WORKFLOWS) .with(set(TOTAL_TASKS_KEY, bindMarker())) .where(eq(WORKFLOW_ID_KEY, bindMarker())) .and(eq(SHARD_ID_KEY, bindMarker())) .getQueryString(); }
@Override public final void run() { if (!check.isEnabled()) { return; } try { Map<String, Optional<BigDecimal>> targetValues = targetChecker.check(check); DateTime now = new DateTime(); BigDecimal warn = check.getWarn(); BigDecimal error = check.getError(); AlertType worstState; if (check.isAllowNoData()) { worstState = AlertType.OK; } else { worstState = AlertType.UNKNOWN; } List<Alert> interestingAlerts = new ArrayList<Alert>(); for (Entry<String, Optional<BigDecimal>> entry : targetValues.entrySet()) { String target = entry.getKey(); Optional<BigDecimal> value = entry.getValue(); if (!value.isPresent()) { if (!check.isAllowNoData()) { LOGGER.warn("No value present for {} and check must have data", target); } continue; } BigDecimal currentValue = value.get(); Alert lastAlert = alertsStore.getLastAlertForTargetOfCheck(target, check.getId()); AlertType lastState; if (lastAlert == null) { lastState = AlertType.OK; } else { lastState = lastAlert.getToType(); } AlertType currentState = valueChecker.checkValue(currentValue, warn, error); if (currentState.isWorseThan(worstState)) { worstState = currentState; } if (isStillOk(lastState, currentState)) { continue; } Alert alert = createAlert(target, currentValue, warn, error, lastState, currentState, now); alertsStore.createAlert(check.getId(), alert); if (stateIsTheSame(lastState, currentState)) { continue; } interestingAlerts.add(alert); } Check updatedCheck = checksStore.updateStateAndLastCheck(check.getId(), worstState, DateTime.now()); if (interestingAlerts.isEmpty()) { return; } for (Subscription subscription : updatedCheck.getSubscriptions()) { if (!subscription.shouldNotify(now, worstState)) { continue; } for (NotificationService notificationService : notificationServices) { if (notificationService.canHandle(subscription.getType())) { try { notificationService.sendNotification(updatedCheck, subscription, interestingAlerts); } catch (Exception e) { LOGGER.warn("Notifying {} by {} failed.", subscription.getTarget(), subscription.getType(), e); } } } } } catch (Exception e) { LOGGER.warn("{} failed", check.getName(), e); } }
public boolean exitStandby(final String groupId) { try { asyncClient.exitStandby(new ExitStandbyRequest().withAutoScalingGroupName(groupId).withInstanceIds(instanceId)); return true; } catch (AmazonClientException e) { LOG.error(LogConstants.ERROR_EXECUTING_REQUEST, e); return false; } }
public static Asn parse(String text) { try { String asnString = Validate.notNull(text, "AS Number must not be null").trim().toUpperCase(); if (asnString.startsWith("AS")) { asnString = asnString.substring(2); } long low; long high = 0L; int indexOfDot = asnString.indexOf('.'); if (indexOfDot != -1) { low = Validate.checkRange(Long.valueOf(asnString.substring(indexOfDot + 1)), ASN_MIN_VALUE, ASN_16_BIT_MAX_VALUE); high = Validate.checkRange(Long.valueOf(asnString.substring(0, indexOfDot)), ASN_MIN_VALUE, ASN_16_BIT_MAX_VALUE); } else { low = Long.valueOf(asnString); } return new Asn((high << SIXTEEN) | low); } catch (Exception ex) { throw new IllegalArgumentException("Invalid AS number: '" + text + "'. Details: " + ex.getMessage(), ex); } }
public static String getSubsetString(Variable var, int beginInd, int endInd, int id) { if (var == null) return null; String subStr = ""; List<Dimension> dimList = var.getDimensions(); if (dimList.size() > 2 || dimList.size() < 1) { return null; } for (int i = 0; i < dimList.size(); i++) { Dimension dim = dimList.get(i); if (dim == null) continue; if (!CF.TIME.equalsIgnoreCase(dim.getShortName()) && !CF.TIME.equalsIgnoreCase(dim.getFullNameEscaped())) { subStr += id; } else { if (beginInd < 0 || endInd < 0) subStr += ":"; else subStr += (beginInd + ":" + endInd); } if (i < dimList.size() - 1) { subStr += ","; } } return subStr; }
@Override public synchronized <H extends Object, B extends Serializable> void put(H hash, B object, Blockchain blockchain, BlockchainUnitType type) throws IOException { boolean await = false; put(hash, object, blockchain, type, await); }
@Override public String renderHtml() { if (StringUtils.isEmpty(tagName)) { return ""; } final StringBuilder sb = new StringBuilder(16).append('<').append(tagName); for (HtmlAttribute attribute : attributes) { sb.append(' ').append(attribute.toHtml()); } return sb.append('>').toString(); }
public List<SingleScenario> getSingleScenariosFromFeature( final String featureContent, final String featureFilePath, final List<Integer> scenarioLineNumbers) throws CucablePluginException { String escapedFeatureContent = featureContent.replace("\\n", "\\\\n"); GherkinDocument gherkinDocument = getGherkinDocumentFromFeatureFileContent(escapedFeatureContent); Feature feature = gherkinDocument.getFeature(); if (feature == null) { return Collections.emptyList(); } String featureName = feature.getKeyword() + ": " + feature.getName(); String featureLanguage = feature.getLanguage(); String featureDescription = feature.getDescription(); List<String> featureTags = gherkinToCucableConverter.convertGherkinTagsToCucableTags(feature.getTags()); ArrayList<SingleScenario> singleScenarioFeatures = new ArrayList<>(); List<Step> backgroundSteps = new ArrayList<>(); List<ScenarioDefinition> scenarioDefinitions = feature.getChildren(); for (ScenarioDefinition scenarioDefinition : scenarioDefinitions) { String scenarioName = scenarioDefinition.getKeyword() + ": " + scenarioDefinition.getName(); String scenarioDescription = scenarioDefinition.getDescription(); if (scenarioDefinition instanceof Background) { Background background = (Background) scenarioDefinition; backgroundSteps = gherkinToCucableConverter.convertGherkinStepsToCucableSteps(background.getSteps()); continue; } if (scenarioDefinition instanceof Scenario) { Scenario scenario = (Scenario) scenarioDefinition; if (scenarioLineNumbers == null || scenarioLineNumbers.isEmpty() || scenarioLineNumbers.contains(scenario.getLocation().getLine())) { SingleScenario singleScenario = new SingleScenario( featureName, featureFilePath, featureLanguage, featureDescription, scenarioName, scenarioDescription, featureTags, backgroundSteps ); addGherkinScenarioInformationToSingleScenario(scenario, singleScenario); if (scenarioShouldBeIncluded(singleScenario)) { singleScenarioFeatures.add(singleScenario); } } continue; } if (scenarioDefinition instanceof ScenarioOutline) { ScenarioOutline scenarioOutline = (ScenarioOutline) scenarioDefinition; if (scenarioLineNumbers == null || scenarioLineNumbers.isEmpty() || scenarioLineNumbers.contains(scenarioOutline.getLocation().getLine())) { List<SingleScenario> outlineScenarios = getSingleScenariosFromOutline( scenarioOutline, featureName, featureFilePath, featureLanguage, featureDescription, featureTags, backgroundSteps ); for (SingleScenario singleScenario : outlineScenarios) { if (scenarioShouldBeIncluded(singleScenario)) { singleScenarioFeatures.add(singleScenario); } } } } } return singleScenarioFeatures; }
@Override public void updateUI() { super.updateUI(); if (tableModel != null) { CorrectedResultCollector crc = new CorrectedResultCollector(); crc.setProperty(JMeterPluginsUtils .tableModelRowsToCollectionPropertyEval(tableModel, DATA_PROPERTY)); } }
public SortedSet<NodeRef> findDeletes() { return inverse().findNewTrees(); }
static String getRedirectHtmlFilename(String artifactFileName, String artifactId) { String search = "-"; int nthElement = 0; if (artifactFileName.endsWith(XCodeOtaHtmlGeneratorMojo.OTA_CLASSIFIER_APPENDIX + "." + XCodeOtaHtmlGeneratorMojo.OTA_HTML_FILE_APPENDIX)) { nthElement = 3; } else if (artifactFileName.endsWith("-AppStoreMetaData.zip")) { nthElement = 1; } else if (artifactFileName.endsWith("-app.dSYM.zip")) { nthElement = 3; } else if (artifactFileName.endsWith("-app.zip")) { nthElement = 3; } else if (artifactFileName.endsWith(".ipa")) { nthElement = 2; } else if (artifactFileName.endsWith("versions.xml")) { nthElement = 1; } else if (artifactFileName.endsWith(".pom")) { nthElement = 1; search = "."; } else if (artifactFileName.endsWith("-fat-binary.a")) { nthElement = 3; } else if (artifactFileName.endsWith(".a")) { nthElement = 2; } else if (artifactFileName.endsWith(".headers.tar")) { nthElement = 2; } else if (artifactFileName.endsWith(".tar")) { nthElement = 1; search = "."; } int idx = getNthIndexFromBack(artifactFileName, search, nthElement); if (idx >= 0) { String name = artifactId + artifactFileName.substring(idx); if (!name.endsWith(".htm")) { name = name + ".htm"; } return name; } return artifactId + "-" + artifactFileName + ".htm"; }
@Override public ServiceResult<List<SpendProfileStatusResource>> getPendingSpendProfiles(long competitionId) { List<Object[]> pendingSpendProfiles = competitionRepository.getPendingSpendProfiles(competitionId); return serviceSuccess(simpleMap(pendingSpendProfiles, object -> new SpendProfileStatusResource(((BigInteger) object[0]).longValue(), ((BigInteger) object[1]).longValue(), (String) object[2]))); }
@Override @Nonnull public Iterator<EntryIndexItem> iterator() { if (isEmpty()) { return Collections.emptyIterator(); } return new EntryIndexIterator(entryIndexCount, minEntryIndex); }
@Override public boolean isApplicable(String username, String password, Principal localPrincipal) { return username != null && username.length() > 0 && password != null && password.length() > 0; }
@Override public void sendAmplitude(float amplitude) { amplitude = Math.min(amplitude, 1) * settings.amplitudeGain; doSetAmplitude(amplitude); if(monitor!=null) monitor.amplitudeChanged(amplitude); }
public static OspfRouterId ospfRouterId(IpAddress ipAddress) { return new OspfRouterId(ipAddress); }
public long cachedApproximateDataSize() { return nodeDataSize.get(); }
static TimedEvent create( long epochNanos, String name, Attributes attributes, int totalAttributeCount) { return new AutoValue_TimedEvent_RawTimedEvent( name, attributes, epochNanos, totalAttributeCount); }
public long getId(double longitude, double latitude) { return this.getId((long) (longitude * OSHDB.GEOM_PRECISION_TO_LONG), (long) (latitude * OSHDB.GEOM_PRECISION_TO_LONG)); }
public Message generateWorldFileResponse(byte[] worldFileBytes) { Message response = MessageRegistry.getInstance().createMessage("WorldFileResponse"); response.setArgument("fileBytes", worldFileBytes); return response; }
@Override public Orchestratable process(Orchestratable message) { if (message instanceof OutboundOrchestratable) { return process((OutboundOrchestratable) message); } return null; }
public boolean register( final String applicationScheme, final int applicationPort, final int adminPort) { final AgentClient agent = consul.agentClient(); if (agent.isRegistered(serviceId)) { LOGGER.info( "Service ({}) [{}] already registered", configuration.getServiceName(), serviceId); return false; } servicePort.compareAndSet(null, applicationPort); serviceAdminPort.compareAndSet(null, adminPort); LOGGER.info( "Registering service ({}) [{}] on port {} (admin port {}) with a health check of {}s", configuration.getServiceName(), serviceId, servicePort.get(), serviceAdminPort.get(), configuration.getCheckInterval().toSeconds()); final Registration.RegCheck check = ImmutableRegCheck.builder() .http(getHealthCheckUrl(applicationScheme)) .interval(String.format("%ds", configuration.getCheckInterval().toSeconds())) .deregisterCriticalServiceAfter( String.format("%dm", configuration.getDeregisterInterval().toMinutes())) .build(); final ImmutableRegistration.Builder builder = ImmutableRegistration.builder().port(servicePort.get()).check(check).id(serviceId); final String serviceName = configuration.getServiceName(); if (serviceName != null) { builder.name(serviceName); } if (serviceAddress.get() != null) { builder.address(serviceAddress.get()); } if (tags.get() != null) { builder.tags(tags.get()); } if (serviceMeta.get() != null) { builder.meta(serviceMeta.get()); } builder.putMeta("scheme", applicationScheme); consul.agentClient().register(builder.build()); return true; }
@Override public boolean accept() { return accept(operands, outputType); }
public AbstractFreeSqlBuilder setNullable(String name, Object value, int sqlType) { return set(value != null, name, value, sqlType); }
public Tutor createTutor(Tutor tutor) { SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession(); try { TutorMapper mapper = sqlSession.getMapper(TutorMapper.class); mapper.insertTutor(tutor); sqlSession.commit(); } finally { sqlSession.close(); } return tutor; }
public StartEventBuilder startEvent() { return startEvent(null); }
@Override protected BdfMessageContext validateMessage(Message m, Group g, BdfList body) throws FormatException { MessageType type = MessageType.fromValue(body.getLong(0).intValue()); switch (type) { case REQUEST: return validateRequestMessage(m, body); case ACCEPT: return validateAcceptMessage(m, body); case AUTH: return validateAuthMessage(m, body); case ACTIVATE: return validateActivateMessage(m, body); case DECLINE: case ABORT: return validateOtherMessage(type, m, body); default: throw new FormatException(); } }
@Deprecated public static List<String> trim(List<String> lines) { return Comment.trim(lines); }
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException, ServletException { Iterator<Filter> iterator = filters.descendingIterator(); NanoFilterChain chain = new NanoFilterChain(servlet); while (iterator.hasNext()) { Filter filter = iterator.next(); NanoFilterChain previousChain = chain; chain = new NanoFilterChain(filter, previousChain); } if (servletRequest.getServletContext() == null && servletRequest instanceof NanoRequest) { NanoRequest nanoRequest = (NanoRequest) servletRequest; nanoRequest.setWebApplication(webApplication); } if (servletResponse instanceof NanoResponse) { NanoResponse nanoResponse = (NanoResponse) servletResponse; nanoResponse.setWebApplication(webApplication); } chain.doFilter(servletRequest, servletResponse); servletResponse.flushBuffer(); }
public static void copy( @Nonnull final InputStream input, @Nonnull final OutputStream output ) throws IOException { copy( input, output, DEFAULT_BUFFER_SIZE ); }
@Override public void initialize(TransformContext context) throws Exception { super.initialize(context); FailureCollector collector = context.getFailureCollector(); init(null, collector); collector.getOrThrowException(); }
@Override public OutputStream getOutputStream() { try { return response.getOutputStream(); } catch (IOException e) { throw new RuntimeException("Unable to return response output stream", e); } }
public void delete(Connection connection, String tokenId) throws LDAPOperationFailedException, ErrorResultException { String dn = String.valueOf(conversion.generateTokenDN(tokenId)); try { processResult(connection.delete(dn)); } catch (ErrorResultException e) { Result result = e.getResult(); if (e.getResult() != null && ResultCode.NO_SUCH_OBJECT.equals(result.getResultCode())) { return; } throw e; } }
@Override public ServiceResult<Void> markAsIneligible(long applicationId, IneligibleOutcomeResource reason) { return applicationRestService.markAsIneligible(applicationId, reason).toServiceResult(); }
public String sendRequest(final String sessionId, Request request) throws SDKBadRequestException { if (request.getType() == null) { throw new SDKBadRequestException(SDKErrorEnum.badRequestError, "Request type (method) is missing!"); } URI uri = buildURI(request); LOGGER.debug("Using URL: " + uri.toString()); HttpRequestBase requestBase; switch (request.getType()) { case POST: HttpPost post = new HttpPost(uri); fillRequestEntity(post, request); requestBase = post; break; case GET: requestBase = new HttpGet(uri); break; case PATCH: HttpPatch patch = new HttpPatch(uri); fillRequestEntity(patch, request); requestBase = patch; break; case PUT: HttpPut put = new HttpPut(uri); fillRequestEntity(put, request); requestBase = put; break; case DELETE: requestBase = new HttpDelete(uri); break; default: LOGGER.error("Request type not supported."); throw new SDKBadRequestException(SDKErrorEnum.badRequestError, SdkConstants.APPLIANCE); } for (Header header : request.getHeaders()) { requestBase.addHeader(header); } if (StringUtils.isNotBlank(sessionId)) { requestBase.setHeader(SdkConstants.AUTH_HEADER, sessionId); } return getResponse(sessionId, requestBase, request.isForceReturnTask(), request.getDownloadPath()); }
@Override public Certificate getTrustedCertificate(String alias) throws KeystoreException { trustedKeyStoreLock.readLock().lock(); try { return trustedKeyStore.getCertificate( checkNotNull(alias, "'alias' cannot be null when looking up a trusted Certificate."), config.getTrustedKeyStorePassword()); } finally { trustedKeyStoreLock.readLock().unlock(); } }
public void writeTo(T src, Class<?> cls, Type genericType, Annotation[] annotations, MediaType type, MultivaluedMap<String, Object> headers, OutputStream os) throws IOException { DataSource ds = DataSource.class.isAssignableFrom(cls) ? (DataSource)src : ((DataHandler)src).getDataSource(); if (useDataSourceContentType) { setContentTypeIfNeeded(type, headers, ds.getContentType()); } IOUtils.copyAndCloseInput(ds.getInputStream(), os); }
@Override public void execSQLScript(String sql) { EntityManager em = emf.createEntityManager(); try{ em.createNativeQuery(sql); } catch (PersistenceException e) { logger.error("Class CommonDAO is method findByNativeSQL(String sql) error!",e); } finally{ em.close(); } }
public static final Path pathElementsToPath(List<String> pathElements) { return pathElementsToFile(pathElements).toPath(); }
@Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { checkClientTrusted(chain, authType, (Socket) null); }
public List<Node> childNodesCopy() { List<Node> children = new ArrayList<Node>(childNodes.size()); for (Node node : childNodes) { children.add((Node)node.clone()); } return children; }
@Override protected Node<View<AdHocSubprocess>, Edge> createNode(String id) { return factoryManager.newNode(id, AdHocSubprocess.class); }
@Override public CmsResponse<List<PsuIdData>> getPsuDataListByPaymentId(String encryptedPaymentId) { Optional<String> decryptIdOptional = securityDataService.decryptId(encryptedPaymentId); if (decryptIdOptional.isEmpty()) { log.info("Encrypted Payment ID: [{}]. Get PSU data list by payment ID failed, couldn't decrypt consent id", encryptedPaymentId); return CmsResponse.<List<PsuIdData>>builder() .error(TECHNICAL_ERROR) .build(); } return pisCommonPaymentService.getPsuDataListByPaymentId(decryptIdOptional.get()); }
public static String formatSolidDate(LocalDate date) { return String.format("%04d%02d%02d", date.getYear(), date.get(ChronoField.MONTH_OF_YEAR), date.getDayOfMonth()); }
@NonNull @Override public String getStyleRootPath() { return "tron-style/"; }
@Override public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof BoundNullaryFunction<?>)) { return false; } BoundNullaryFunction<?> that = (BoundNullaryFunction<?>) obj; if (!(that.function.equals(this.function))) { return false; } return that.arg == this.arg || that.arg != null && that.arg.equals(this.arg); }
public static String getWrapperFieldType(Field field) { FieldType type = field.getType(); if (type instanceof ScalarFieldType) { ScalarFieldType scalarFieldType = (ScalarFieldType) type; return ScalarFieldTypeUtil.getWrapperType(scalarFieldType); } if (type instanceof UserType) { UserType userType = (UserType) type; return UserTypeUtil.getCanonicalName(userType); } throw new IllegalArgumentException(field.toString()); }
public boolean isAlarmOn() { return alarmOn; }
@Nonnull @Override protected List<MethodSpec> buildMethods() { final MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC); final ImmutableList.Builder<MethodSpec> builder = ImmutableList.builder(); getProperties().entrySet().forEach(property -> { final String name = property.getKey(); final TypeName type = property.getValue(); final String fieldName = fieldNamePolicy.convert(name, type); final String methodName = methodNamePolicy.convert(name, type); builder.add(MethodSpec.methodBuilder(methodName) .addModifiers(Modifier.PUBLIC) .returns(type) .addStatement("return $L", fieldName) .build()); final String propertyName = parameterNamePolicy.convert(name, type); constructorBuilder.addParameter(ParameterSpec.builder(type, propertyName) .build()) .addStatement("this.$L = $L", fieldName, propertyName); }); builder.add(constructorBuilder.build()); return builder.build(); }
public String toSecureString() { final StringBuilder sb = new StringBuilder(); sb.append(getClass().getName()); sb.append("{_method=").append(_method); sb.append(", _baseUriTemplate=").append(_baseUriTemplate); sb.append(", _methodName=").append(_methodName); sb.append(", _requestOptions=").append(_requestOptions); sb.append('}'); return sb.toString(); }
@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; ClassDeployment that = (ClassDeployment) o; if (!consumers.equals(that.consumers)) return false; if (!services.equals(that.services)) return false; return coreServices.equals(that.coreServices); }
@Override public boolean validateConnectionCreation(final AMQPConnection<?> connection, final QueueManagingVirtualHost<?> virtualHost) { String connectionVersion = connection.getClientVersion(); if (connectionVersion == null) { connectionVersion = ""; } boolean valid = true; if (!connectionMatches(virtualHost, VIRTUALHOST_ALLOWED_CONNECTION_VERSION, connectionVersion)) { if (connectionMatches(virtualHost, VIRTUALHOST_LOGGED_CONNECTION_VERSION, connectionVersion)) { virtualHost.getBroker().getEventLogger().message(ConnectionMessages.CLIENT_VERSION_LOG(connection.getClientVersion())); } else if (connectionMatches(virtualHost, VIRTUALHOST_REJECTED_CONNECTION_VERSION, connectionVersion)) { virtualHost.getBroker().getEventLogger().message(ConnectionMessages.CLIENT_VERSION_REJECT(connection.getClientVersion())); valid = false; } } return valid; }
@Override public boolean seek( Mark mark, int untilChar ) throws IOException { if ( eof ) { return eof( mark ); } seekStartPos = bufferPos; int ch; int endOffset = 1; int skippedChars = 0; int quoteDepth = 0; int quoteStartLine = 0; boolean isQuoted = false; while ( !eof ) { ch = nextChar( skippedChars ); if ( quoteDepth == 0 ) { if ( ch == untilChar ) { return setMark( mark, endOffset, skippedChars, ch, isQuoted ); } else if ( trim && isWhitespace( ch ) ) { if ( seekStartPos == bufferPos - 1 ) { seekStartPos++; } } else if ( ch == quoteChar && seekStartPos == bufferPos - 1 ) { quoteDepth++; isQuoted = true; seekStartPos++; quoteStartLine = lineNumber; } else if ( isNewLine( ch ) ) { if ( bufferPos - 1 == lineStartPos ) { seekStartPos++; lineStartPos++; continue; } break; } else if ( isQuoted ) { throw new DataAfterQuoteException( this, new String( buffer, seekStartPos, bufferPos - seekStartPos ) ); } } else { if ( ch == quoteChar ) { int nextCh = peekChar( skippedChars ); if ( nextCh == quoteChar ) { repositionChar( bufferPos++, ++skippedChars ); } else { endOffset++; quoteDepth--; } } else if ( isNewLine( ch ) ) { if ( !multilineFields ) { throw new IllegalMultilineFieldException( this ); } if ( ch == EOL_CHAR ) { lineNumber++; } } else if ( ch == BACK_SLASH && legacyStyleQuoting ) { int nextCh = peekChar( skippedChars ); if ( nextCh == quoteChar || nextCh == BACK_SLASH ) { repositionChar( bufferPos++, ++skippedChars ); } } else if ( eof ) { throw new MissingEndQuoteException( this, quoteStartLine, quoteChar ); } } } int valueLength = bufferPos - seekStartPos - 1; if ( eof && valueLength == 0 && seekStartPos == lineStartPos ) { return eof( mark ); } lineNumber++; lineStartPos = bufferPos; return setMark( mark, endOffset, skippedChars, END_OF_LINE_CHARACTER, isQuoted ); }
String convertToString( byte[] bytes ) { if ( bytes == null || bytes.length != 16 ) { return Messages.getString( "InPlaceUuidValueEditor.InvalidUuid" ); } char[] hex = Hex.encodeHex( bytes ); StringBuffer sb = new StringBuffer(); sb.append( hex, 0, 8 ); sb.append( '-' ); sb.append( hex, 8, 4 ); sb.append( '-' ); sb.append( hex, 12, 4 ); sb.append( '-' ); sb.append( hex, 16, 4 ); sb.append( '-' ); sb.append( hex, 20, 12 ); return Strings.toLowerCase( sb.toString() ); }
DispatcherCommand wrap(LiteralCommandNode<CommandSender> command) { var aliases = new ArrayList<String>(); if (command instanceof Aliasable<?>) { for (var alias : ((Aliasable<?>) command).aliases()) { aliases.add(alias.getName()); } } return new DispatcherCommand(command.getName(), plugin, dispatcher, command.getUsageText(), aliases); }
protected void onCall(List<ClientMessage> messages) throws RepositoryException, ActiveMQException { for (ClientMessage message : messages) { processMessage(message); message.acknowledge(); } session.commit(); }
public Object generate(Object value) { if (value != null) { Class<?> clazz = value.getClass(); if (clazz.isPrimitive()) { return Defaults.defaultValue(clazz); } else { Object defaultValue = BoxedDefaults.defaultValue(clazz); if (defaultValue == null) { try { defaultValue = clazz.newInstance(); } catch (InstantiationException e) { return null; } catch (IllegalAccessException e) { return null; } } return defaultValue; } } return null; }
public List<AnalysisStep> check(List<AnalysisStep> analysisSteps) { if (analysisSteps.size() < 2) { return analysisSteps; } moveInheritanceModeDependentStepsAfterLastVariantFilter(analysisSteps); removePriorityScoreFiltersWithoutMatchingPrioritiser(analysisSteps); movePriorityScoreFiltersNextToMatchingPrioritiser(analysisSteps); analysisSteps.sort(new AnalysisStepComparator()); return analysisSteps; }
@Override protected boolean onBackPress() { return finishActionMode() || super.onBackPress(); }
public EnsemblEntryVO fetchEnsemblEntry(String geneId) throws ExternalDbUnavailableException { ParameterNameValue[] params = new ParameterNameValue[]{ new ParameterNameValue(CONTENT_TYPE, APPLICATION_JSON), new ParameterNameValue(ENSEMBL_EXPAND_TOOL, "1"), new ParameterNameValue("utr", "1")}; String location = ENSEMBL_SERVER + ENSEMBL_TOOL + "/" + geneId + "?"; String geneData = httpDataManager.fetchData(location, params); EnsemblEntryVO ensemblEntryVO; try { ensemblEntryVO = objectMapper.readValue(geneData, EnsemblEntryVO.class); } catch (IOException e) { throw new ExternalDbUnavailableException("Unexpected result format", e); } return ensemblEntryVO; }
public void forEachFeature(ForEachCallback<Double, NodeFeature> callback) { features.forEach(callback); }
public static SmartLock getSmartLock(Activity activity) { Application application = activity.getApplication(); if (!(application instanceof LockProvider)) { throw new IllegalStateException("Android Application object must implement LockProvider interface"); } LockProvider provider = (LockProvider) application; final Lock lock = provider.getLock(); if (!(lock instanceof SmartLock)) { throw new IllegalStateException("LockProvider must return an instance of SmartLock"); } return (SmartLock) lock; }
public static byte[] parseObjectId(String s) { if (s == null) { throw new IllegalArgumentException("Argument 's' cannot be null."); } return StringUtil.fromHex(s); }
@Override public Collection<LoanDescriptor> getMarketplace() { Stream<Loan> loans = tenant.call(zonky -> zonky.getAvailableLoans(getIncrementalFilter())) .filter(l -> l.getMyInvestment() .isEmpty()); if (getMaximumItemsToRead().isPresent()) { int limit = getMaximumItemsToRead().orElseThrow(); LOGGER.trace("Enforcing read limit of {} latest items.", limit); loans = loans.limit(limit); } return loans.map(LoanDescriptor::new) .collect(Collectors.toList()); }
@Override public void copyVariablesFrom( IVariables variables ) { this.variables.copyVariablesFrom( variables ); }
public static boolean isSubscribedToFeatureSet( List<Subscription> subscriptions, String projectName, String featureSetName) { for (Subscription sub : subscriptions) { if (sub.getProject().isEmpty() || sub.getName().isEmpty()) { throw new IllegalArgumentException( String.format("Subscription is missing arguments: %s", sub.toString())); } Pattern patternName = getNamePattern(sub); Pattern patternProject = getProjectPattern(sub); if (patternProject.matcher(projectName).matches() && patternName.matcher(featureSetName).matches() && sub.getExclude()) { return false; } } List<Subscription> filteredSubscriptions = subscriptions.stream().filter(sub -> !sub.getExclude()).collect(Collectors.toList()); for (Subscription filteredSub : filteredSubscriptions) { Pattern patternName = getNamePattern(filteredSub); Pattern patternProject = getProjectPattern(filteredSub); if (patternProject.matcher(projectName).matches() && patternName.matcher(featureSetName).matches()) { return true; } } return false; }
@Nonnull @ReturnsMutableObject ("The passed parameter") @CodingStyleguideUnaware public static <COLLTYPE extends Collection <String>> COLLTYPE getExploded (final char cSep, @Nullable final String sElements, final int nMaxItems, @Nonnull final COLLTYPE aCollection) { explode (cSep, sElements, nMaxItems, aCollection::add); return aCollection; }
public List<Item> findQuery(String title, String label, String identifier, String owner, String model, Collection<String> hasOwners) throws FedoraClientException, IOException { return findQuery(new Query().setTitle(title).setLabel(label) .setIdentifier(identifier).setOwner(owner).setModel(model) .setHasOwners(hasOwners), "active"); }
public static double max(double[][] matrix) { return Stream.of(matrix) .mapToDouble(MatrixUtils::max) .max().getAsDouble(); }
public static boolean existsResource(String resourceName) { InputStream is = null; try { try { is = new BufferedInputStream(FileUtil.class.getResource(resourceName).openStream()); } catch (Throwable e) { is = new BufferedInputStream( Thread.currentThread().getContextClassLoader().getResource(resourceName).openStream()); } return is != null; } catch (Throwable e) { return false; } finally { if (is != null) try { is.close(); } catch (IOException e) { } } }
public static IFilter createFilter(String where) { if (StringUtils.isEmpty(where)) { return null; } MySqlExprVisitor visitor = MySqlExprVisitor.parser(where); Object value = visitor.getColumnOrValue(); if (value instanceof IFilter) { return (IFilter) value; } else if (value instanceof ISelectable) { throw new IllegalArgumentException("illegal filter:" + where); } else { return visitor.buildConstanctFilter(value); } }
@Override public void close() { if (!open) { return; } try { dataSource.close(); } catch (OntoDriverException e) { throw new StorageAccessException("Error when closing the data source.", e); } finally { this.open = false; } }
@Override public void validate(final PreparedUpdate update, final UpdateContext updateContext) { final Subject subject = updateContext.getSubject(update); final RpslObject originalObject = update.getReferenceObject(); final RpslObject updatedObject = update.getUpdatedObject(); final boolean rsMaintained = maintainers.isRsMaintainer(originalObject.getValuesForAttribute(AttributeType.MNT_BY)); if (mntByChanged(originalObject, updatedObject) && rsMaintained && isAllocation(originalObject)) { if (subject.hasPrincipal(Principal.OVERRIDE_MAINTAINER) || subject.hasPrincipal(Principal.RS_MAINTAINER)) { return; } else { updateContext.addMessage(update, UpdateMessages.canOnlyBeChangedByRipeNCC(AttributeType.MNT_BY)); } } }
@Override public void doOnMessage(final Message message) throws Exception { LOG.debug("Entering " + getClass()); LOG.debug(message); MessageDataContainer dataContainer = getDataContainerFromMessage(message); LoadBalancer dbLoadBalancer; LoadBalancer errorMsgLB = new LoadBalancer(); errorMsgLB.setUserName(dataContainer.getUserName()); errorMsgLB.setId(dataContainer.getLoadBalancerId()); errorMsgLB.setAccountId(dataContainer.getAccountId()); try { dbLoadBalancer = loadBalancerService.getWithUserPages(errorMsgLB.getId(), errorMsgLB.getAccountId()); } catch (EntityNotFoundException enfe) { String alertDescription = String.format("Load balancer '%d' not found in database.", errorMsgLB.getId()); LOG.error(alertDescription, enfe); notificationService.saveAlert(errorMsgLB.getAccountId(), errorMsgLB.getId(), enfe, DATABASE_FAILURE.name(), alertDescription); sendErrorToEventResource(errorMsgLB); return; } List<SnmpUsage> usages = new ArrayList<SnmpUsage>(); Map<Integer, SnmpUsage> usagesMap = new HashMap<Integer, SnmpUsage>(); try { LOG.info(String.format("Collecting usage BEFORE ssl event for load balancer %s...", dbLoadBalancer.getId())); usages = usageEventCollection.getUsage(dbLoadBalancer); for (SnmpUsage usage : usages) { usagesMap.put(usage.getHostId(), usage); } LOG.info(String.format("Successfully collected usage BEFORE ssl event for load balancer %s", dbLoadBalancer.getId())); } catch (UsageEventCollectionException e) { LOG.error(String.format("Collection of the ssl usage event failed for " + "load balancer: %s :: Exception: %s", dbLoadBalancer.getId(), e)); } try { if (isRestAdapter()) { LOG.debug(String.format("Deleting load balancer '%d' ssl termination in STM...", dbLoadBalancer.getId())); reverseProxyLoadBalancerStmService.removeSslTermination(dbLoadBalancer); LOG.debug(String.format("Successfully deleted load balancer ssl termination '%d' in Zeus.", dbLoadBalancer.getId())); } else { LOG.debug(String.format("Deleting load balancer '%d' ssl termination in ZXTM...", dbLoadBalancer.getId())); reverseProxyLoadBalancerService.removeSslTermination(dbLoadBalancer); LOG.debug(String.format("Successfully deleted load balancer ssl termination '%d' in Zeus.", dbLoadBalancer.getId())); } } catch (Exception e) { loadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ERROR); LOG.error(String.format("LoadBalancer status before error was: '%s'", dbLoadBalancer.getStatus())); String alertDescription = String.format("Error deleting loadbalancer '%d' ssl termination in Zeus.", dbLoadBalancer.getId()); LOG.error(alertDescription, e); notificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), e, ZEUS_FAILURE.name(), alertDescription); sendErrorToEventResource(errorMsgLB); Calendar eventTime = Calendar.getInstance(); try { usageEventCollection.collectUsageAndProcessUsageRecords(dbLoadBalancer, UsageEvent.SSL_OFF, eventTime); } catch (UsageEventCollectionException uex) { LOG.error(String.format("Collection and processing of the usage event failed for load balancer: %s " + ":: Exception: %s", dbLoadBalancer.getId(), uex)); } catch (Exception exc) { String exceptionStackTrace = Debug.getExtendedStackTrace(exc); String usageAlertDescription = String.format("An error occurred while processing the usage for an event on loadbalancer %d: \n%s\n\n%s", dbLoadBalancer.getId(), exc.getMessage(), exceptionStackTrace); LOG.error(usageAlertDescription); notificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), exc, USAGE_FAILURE.name(), usageAlertDescription); } return; } List<SnmpUsage> usages2 = new ArrayList<SnmpUsage>(); Map<Integer, SnmpUsage> usagesMap2 = new HashMap<Integer, SnmpUsage>(); try { LOG.info(String.format("Collecting usage AFTER ssl event for load balancer %s...", dbLoadBalancer.getId())); usages2 = usageEventCollection.getUsage(dbLoadBalancer); for (SnmpUsage usage : usages2) { usagesMap2.put(usage.getHostId(), usage); } LOG.info(String.format("Successfully collected usage AFTER ssl event for load balancer %s", dbLoadBalancer.getId())); } catch (UsageEventCollectionException e) { LOG.error(String.format("Collection of the ssl usage event failed for " + "load balancer: %s :: Exception: %s", dbLoadBalancer.getId(), e)); } for (CertificateMapping certificateMapping : dbLoadBalancer.getCertificateMappings()) { try { LOG.info(String.format("Removing certificate '%s' for load balancer %d...", certificateMapping.getId(), dbLoadBalancer.getId())); certificateMappingService.deleteByIdAndLoadBalancerId(certificateMapping.getId(), dbLoadBalancer.getId()); LOG.info(String.format("Successfully removed certificate '%s' for load balancer %d.", certificateMapping.getId(), dbLoadBalancer.getId())); } catch (Exception odne) { LOG.info(String.format("Certificate for host '%s' does not exist for load balancer %d. Ignoring...", certificateMapping.getHostName(), dbLoadBalancer.getId())); } } sslTerminationService.deleteSslTermination(dbLoadBalancer.getId(), dbLoadBalancer.getAccountId()); Calendar eventTime = Calendar.getInstance(); SslTerminationUsage sslTermUsageHelper = new SslTerminationUsage(); SslTermination currentSslTerm = new SslTermination(); currentSslTerm.setEnabled(false); List<SnmpUsage> usagesToInsert = sslTermUsageHelper.getUsagesToInsert(dbLoadBalancer.getId(), dataContainer.getPreviousSslTermination(), currentSslTerm, usagesMap, usagesMap2); try { usageEventCollection.processUsageEvent(usagesToInsert, dbLoadBalancer, UsageEvent.SSL_OFF, eventTime); } catch (Exception exc) { String exceptionStackTrace = Debug.getExtendedStackTrace(exc); String usageAlertDescription = String.format("An error occurred while processing the usage for an event on loadbalancer %d: \n%s\n\n%s", dbLoadBalancer.getId(), exc.getMessage(), exceptionStackTrace); LOG.error(usageAlertDescription); notificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), exc, USAGE_FAILURE.name(), usageAlertDescription); } loadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ACTIVE); String atomTitle = "Load Balancer SSL Termination Successfully Deleted"; String atomSummary = "Load balancer ssl termination successfully deleted"; notificationService.saveLoadBalancerEvent(errorMsgLB.getUserName(), dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), atomTitle, atomSummary, DELETE_SSL_TERMINATION, DELETE, INFO); LOG.info(String.format("Load balancer ssl termination '%d' successfully deleted.", dbLoadBalancer.getId())); }
public static void validate(RegistrationData registrationData) { if (registrationData == null) { throw new ConstraintViolationException("registrationData must not be null"); } validate(registrationData.getAttestationObject()); if (registrationData.getAttestationObjectBytes() == null) { throw new ConstraintViolationException("attestationObjectBytes must not be null"); } validateAuthenticationExtensionsClientOutputs(registrationData.getClientExtensions()); validate(registrationData.getCollectedClientData()); if (registrationData.getCollectedClientDataBytes() == null) { throw new ConstraintViolationException("collectedClientDataBytes must not be null"); } }
public Observable<Void> deleteConnection(String userId, Type type) { return service.deleteConnection(userId, type); }
void execute(UploadRequest uploadRequest) throws IOException, InterruptedException { String sourceId = uploadRequest.sourceId; contentUploadService.startAsync().awaitRunning(); for (UploadRequest.AbstractRequest request : uploadRequest.requests) { GenericJson response = request.accept(getVisitor(sourceId)); System.out.println(response.toPrettyString()); } contentUploadService.stopAsync().awaitTerminated(); }
public void saveLastCloudbreakFlowChainId(SdxCluster sdxCluster, FlowIdentifier flowIdentifier) { if (flowIdentifier == null) { LOGGER.info("Cloudbreak not sent flow identifier for cluster falling back to flow API."); trySaveLastCbFlowIdOrFlowChainId(sdxCluster); } else { LOGGER.info("Received cloudbreak flow identifier {} for cluster {}", flowIdentifier, sdxCluster.getClusterName()); switch (flowIdentifier.getType()) { case FLOW: setFlowIdAndResetFlowChainId(sdxCluster, flowIdentifier.getPollableId()); break; case FLOW_CHAIN: setFlowChainIdAndResetFlowId(sdxCluster, flowIdentifier.getPollableId()); break; case NOT_TRIGGERED: resetFlowIdAndFlowChainId(sdxCluster); break; default: throw new IllegalArgumentException("Unsupported flow type " + flowIdentifier.getType()); } sdxClusterRepository.save(sdxCluster); } }
public static <T> int getRecommendedPartitions(PCollection<T> pcollection) { Configuration conf = pcollection.getPipeline().getConfiguration(); return getRecommendedPartitions(pcollection, conf); }
public static boolean isEven(final int value) { return (value & LAST_DIGIT_MASK) == 0; }
@Override public Serializer<Alert> serializer() { return new Ser(); }
public static String multipleCatch(Throwable throwable) { try { throw throwable; } catch (BaseException baseEx) { return baseEx.getMessage(); } catch (Exception ex) { return ex.getMessage(); } catch (Throwable th) { return th.getMessage(); } }
@SuppressWarnings("deprecation") public static boolean hasNewNetworkBufConf(final Configuration config) { return config.contains(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_FRACTION) || config.contains(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN) || config.contains(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX) || !config.contains(TaskManagerOptions.NETWORK_NUM_BUFFERS); }
@Override public boolean equals( Object that ) { if ( this == that ) { return true; } Rdn rdn; if ( that instanceof String ) { try { rdn = new Rdn( schemaManager, ( String ) that ); } catch ( LdapInvalidDnException e ) { return false; } } else if ( !( that instanceof Rdn ) ) { return false; } else { rdn = ( Rdn ) that; } if ( rdn.nbAvas != nbAvas ) { return false; } switch ( nbAvas ) { case 0: return true; case 1: return ava.equals( rdn.ava ); default: for ( Ava paramAva : rdn.avas ) { List<Ava> avaList = avaTypes.get( paramAva.getNormType() ); if ( ( avaList == null ) || !avaList.contains( paramAva ) ) { return false; } } return true; } }
@RequestMapping(value = "/findByForceGreaterThanAndRankIs/{force}/{rank}", method = RequestMethod.GET) public List<Jedi> findByForceGreaterThanAndRankIs(@PathVariable("force") Long force, @PathVariable("rank") Rank rank) { return jediService.findByForceGreaterThanAndRankIs(force, rank); }
@Override public ByteBuf readBytes(int length) { checkReadableBytes(length); if (length == 0) { return Unpooled.EMPTY_BUFFER; } ByteBuf buf = alloc().buffer(length, maxCapacity); buf.writeBytes(this, readerIndex, length); readerIndex += length; return buf; }
@Override public Iterable<Row> query(String query, Object... params) { if (this.iterable == null) { try { this.iterable = this.load(); } catch (ScriptException | IOException ex) { Logger.getLogger(ScriptableSource.class.getName()).log(Level.SEVERE, null, ex); } } return this.iterable; }
public SelectionSpecBuilder resume(List<Uri> uriList) { if (uriList == null) { return this; } mResumeList.addAll(uriList); return this; }
@Override public Value evaluate(ValueFactory vf, Value... args) throws ValueExprEvaluationException { if (args.length != 1) { throw new ValueExprEvaluationException("expect exactly 1 argument"); } if (!(args[0] instanceof Triple)) { throw new ValueExprEvaluationException("arg1 must be a Triple"); } return ((Triple) args[0]).getObject(); }
@GET public List<RoutingRuleXO> getRoutingRules(@QueryParam("includeRepositoryNames") boolean includeRepositoryNames) { routingRuleHelper.ensureUserHasPermissionToRead(); List<RoutingRuleXO> rules = routingRuleStore.list() .stream() .map(RoutingRulesResource::toXO) .collect(toList()); if (includeRepositoryNames) { setAssignedRepositories(rules); } return rules; }
public List<File> doCheck() throws SystemCheckException { File walFolderFile = SystemFileFactory.INSTANCE.getFile(walFolder); logger.info("Checking folder: {}", walFolderFile.getAbsolutePath()); if(!walFolderFile.exists() || !walFolderFile.isDirectory()) { throw new SystemCheckException(walFolder); } File[] storageWalFolders = walFolderFile.listFiles(); if (storageWalFolders == null || storageWalFolders.length == 0) { logger.info("No sub-directories under the given directory, check ends"); return Collections.emptyList(); } List<File> failedFiles = new ArrayList<>(); for (int dirIndex = 0; dirIndex < storageWalFolders.length; dirIndex++) { File storageWalFolder = storageWalFolders[dirIndex]; logger.info("Checking the No.{} directory {}", dirIndex, storageWalFolder.getName()); File walFile = SystemFileFactory.INSTANCE.getFile(storageWalFolder, WAL_FILE_NAME); if (!checkFile(walFile)) { failedFiles.add(walFile); } } return failedFiles; }
public int getScriptCount() { if (history.getSingleResults() == null) { return 0; } return history.getSingleResults().size(); }
@Override public void initChannel(SocketChannel ch) { ChannelPipeline p = ch.pipeline(); if (debugChannelLifecycleLoggingEnabled) { p.addLast(SERVER_WORKER_CHANNEL_DEBUG_LOGGING_HANDLER_NAME, new LoggingHandler(SERVER_WORKER_CHANNEL_DEBUG_SLF4J_LOGGER_NAME, LogLevel.DEBUG)); } if (sslCtx != null) p.addLast(SSL_HANDLER_NAME, sslCtx.newHandler(ch.alloc())); p.addLast(HTTP_SERVER_CODEC_HANDLER_NAME, new HttpServerCodec( httpRequestDecoderConfig.maxInitialLineLength(), httpRequestDecoderConfig.maxHeaderSize(), httpRequestDecoderConfig.maxChunkSize() ) ); p.addLast(PROCESS_FINAL_RESPONSE_OUTPUT_HANDLER_NAME, new ProcessFinalResponseOutputHandler()); p.addLast(REQUEST_STATE_CLEANER_HANDLER_NAME, new RequestStateCleanerHandler( metricsListener, incompleteHttpCallTimeoutMillis, distributedTracingConfig ) ); p.addLast(DTRACE_START_HANDLER_NAME, new DTraceStartHandler(userIdHeaderKeys, distributedTracingConfig)); p.addLast(ACCESS_LOG_START_HANDLER_NAME, new AccessLogStartHandler()); p.addLast(SMART_HTTP_CONTENT_COMPRESSOR_HANDLER_NAME, new SmartHttpContentCompressor(responseCompressionThresholdBytes)); if (beforeSecurityRequestFilterHandler != null) p.addLast(REQUEST_FILTER_BEFORE_SECURITY_HANDLER_NAME, beforeSecurityRequestFilterHandler); p.addLast(ROUTING_HANDLER_NAME, new RoutingHandler(endpoints, maxRequestSizeInBytes, distributedTracingConfig)); p.addLast(SMART_HTTP_CONTENT_DECOMPRESSOR_HANDLER_NAME, new SmartHttpContentDecompressor()); p.addLast(REQUEST_INFO_SETTER_HANDLER_NAME, new RequestInfoSetterHandler(maxRequestSizeInBytes)); if (maxOpenChannelsThreshold != -1) { p.addLast(OPEN_CHANNEL_LIMIT_HANDLER_NAME, new OpenChannelLimitHandler(openChannelsGroup, maxOpenChannelsThreshold)); } p.addLast(SECURITY_VALIDATION_HANDLER_NAME, new SecurityValidationHandler(requestSecurityValidator)); if (afterSecurityRequestFilterHandler != null) p.addLast(REQUEST_FILTER_AFTER_SECURITY_HANDLER_NAME, afterSecurityRequestFilterHandler); p.addLast(REQUEST_CONTENT_DESERIALIZER_HANDLER_NAME, new RequestContentDeserializerHandler(requestContentDeserializer)); if (validationService != null) p.addLast(REQUEST_CONTENT_VALIDATION_HANDLER_NAME, new RequestContentValidationHandler(validationService)); p.addLast( NONBLOCKING_ENDPOINT_EXECUTION_HANDLER_NAME, new NonblockingEndpointExecutionHandler( longRunningTaskExecutor, defaultCompletableFutureTimeoutMillis, distributedTracingConfig ) ); p.addLast(PROXY_ROUTER_ENDPOINT_EXECUTION_HANDLER_NAME, new ProxyRouterEndpointExecutionHandler(longRunningTaskExecutor, streamingAsyncHttpClientForProxyRouterEndpoints, defaultCompletableFutureTimeoutMillis, distributedTracingConfig )); p.addLast(REQUEST_HAS_BEEN_HANDLED_VERIFICATION_HANDLER_NAME, new RequestHasBeenHandledVerificationHandler()); ExceptionHandlingHandler exceptionHandlingHandler = new ExceptionHandlingHandler(riposteErrorHandler, riposteUnhandledErrorHandler, distributedTracingConfig); p.addLast(EXCEPTION_HANDLING_HANDLER_NAME, exceptionHandlingHandler); if (cachedResponseFilterHandler != null) p.addLast(RESPONSE_FILTER_HANDLER_NAME, cachedResponseFilterHandler); p.addLast(RESPONSE_SENDER_HANDLER_NAME, new ResponseSenderHandler(responseSender)); p.addLast(ACCESS_LOG_END_HANDLER_NAME, new AccessLogEndHandler(accessLogger)); p.addLast(DTRACE_END_HANDLER_NAME, new DTraceEndHandler()); p.addLast( CHANNEL_PIPELINE_FINALIZER_HANDLER_NAME, new ChannelPipelineFinalizerHandler( exceptionHandlingHandler, responseSender, metricsListener, accessLogger, workerChannelIdleTimeoutMillis ) ); if (pipelineCreateHooks != null) { for (PipelineCreateHook hook : pipelineCreateHooks) { hook.executePipelineCreateHook(p); } } }
@GET @Override @Path("/ids") public Response getActivities(@QueryParam("ids") ActivityIdList activityIdList) { List<String> idList; idList = activityIdList.getIdList(); if (idList == null || idList.isEmpty()) { String msg = "Activity Ids shouldn't be empty"; log.error(msg); return Response.status(400).entity( new ErrorResponse.ErrorResponseBuilder().setMessage(msg).build()).build(); } Response validationFailedResponse = validateAdminUser(); if (validationFailedResponse == null) { List<Activity> activities; ActivityList activityList = new ActivityList(); DeviceManagementProviderService dmService; try { for (String id : idList) { RequestValidationUtil.validateActivityId(id); } dmService = DeviceMgtAPIUtils.getDeviceManagementService(); activities = dmService.getOperationByActivityIds(idList); if (!activities.isEmpty()) { activityList.setList(activities); int count = activities.size(); if (log.isDebugEnabled()) { log.debug("Number of activities : " + count); } activityList.setCount(count); return Response.ok().entity(activityList).build(); } else { String msg = "No activity found with the given IDs."; log.error(msg); return Response.status(404).entity( new ErrorResponse.ErrorResponseBuilder().setMessage(msg).build()).build(); } } catch (OperationManagementException e) { String msg = "ErrorResponse occurred while fetching the activity list for the supplied ids."; log.error(msg, e); return Response.serverError().entity( new ErrorResponse.ErrorResponseBuilder().setMessage(msg).build()).build(); } } else { return validationFailedResponse; } }
public AstLiteralInteger integerNumber() { pushRange(); var token = consume(INTEGER); try { var radix = 10; var text = token.getLexeme(); if (text.startsWith("0x")) { text = text.substring(2); radix = 16; } return new AstLiteralInteger(popRange(), Integer.parseInt(text, radix)); } catch (NumberFormatException e) { throw createError(token, "The literal " + token.getLexeme() + " of type int is out of range"); } }
boolean isContainsMatch(String dataContent, String correspontingHeadline){ return ( this.dataContent.contains(dataContent.trim()) && this.correspontingHeadline.contains(correspontingHeadline.trim())); }
public NetworkInfo createNetwork(String cloudSiteId, String tenantId, NetworkType type, String networkName, String provider, List<Integer> vlans) throws MsoException { CloudSite cloudSite = cloudConfig.getCloudSite(cloudSiteId).orElseThrow(() -> new MsoCloudSiteNotFound(cloudSiteId)); Quantum neutronClient = getNeutronClient(cloudSite, tenantId); Network network = findNetworkByName(neutronClient, networkName); if (network != null) { logger.error("{} Network {} on Cloud site {} for tenant {} already exists {}", MessageEnum.RA_NETWORK_ALREADY_EXIST, networkName, cloudSiteId, tenantId, ErrorCode.DataError.getValue()); throw new MsoNetworkAlreadyExists(networkName, tenantId, cloudSiteId); } network = new Network(); network.setName(networkName); network.setAdminStateUp(true); if (type == NetworkType.PROVIDER) { if (provider != null && vlans != null && !vlans.isEmpty()) { network.setProviderPhysicalNetwork(provider); network.setProviderNetworkType("vlan"); network.setProviderSegmentationId(vlans.get(0)); } } else if (type == NetworkType.MULTI_PROVIDER) { if (provider != null && vlans != null && !vlans.isEmpty()) { List<Segment> segments = new ArrayList<>(vlans.size()); for (int vlan : vlans) { Segment segment = new Segment(); segment.setProviderPhysicalNetwork(provider); segment.setProviderNetworkType("vlan"); segment.setProviderSegmentationId(vlan); segments.add(segment); } network.setSegments(segments); } } try { OpenStackRequest<Network> request = neutronClient.networks().create(network); Network newNetwork = executeAndRecordOpenstackRequest(request); return new NetworkInfoMapper(newNetwork).map(); } catch (OpenStackBaseException e) { MsoException me = neutronExceptionToMsoException(e, "CreateNetwork"); throw me; } catch (RuntimeException e) { MsoException me = runtimeExceptionToMsoException(e, "CreateNetwork"); throw me; } }
public Configuration getConfiguration(final PersistenceUnitDescriptor descriptor) { for (final ConfigurationFactory factory : CONFIG_FACTORIES) { if (factory.isSupported(descriptor)) { return factory.createConfiguration(descriptor); } } throw new JpaUnitException("Unsupported JPA provider"); }
@Override public Date fromString(String s) { Date d; synchronized (DateFormatter.dateFormat) { String str = s; if (str.equals("+24Hours")) { d = new Date(new Date().getTime() + 86400000); log.debug("Param passed in was '+24Hours', setting value to now + 86400000ms"); } else { if (StringUtils.isNotBlank(this.defaultTime) && !str.contains(" ")) { str = str + " " + this.defaultTime; } if (StringUtils.isNotBlank(this.defaultMillisec) && !str.contains(".")) { str = str + "." + this.defaultMillisec; } try { d = DateFormatter.dateFormat.parse(str); if (DateUtils.getFragmentInMilliseconds(d, Calendar.HOUR_OF_DAY) > 0) { DateUtils.setMilliseconds(d, 999); } } catch (ParseException pe) { throw new RuntimeException("Unable to parse date " + str + " with format " + formatPattern, pe); } } } return d; }
public SSLContext build() throws NoSuchAlgorithmException, KeyManagementException { final SSLContext sslContext; final String protocolStr = this.protocol != null ? this.protocol : TLS; if (this.provider != null) { sslContext = SSLContext.getInstance(protocolStr, this.provider); } else { sslContext = SSLContext.getInstance(protocolStr); } initSSLContext(sslContext, keyManagers, trustManagers, secureRandom); return sslContext; }
@Bindable public String getName() { String innerJoinLabel = ModelerMessagesHolder.getMessages().getString( "multitable.INNER_JOIN" ); String leftTable = this.leftKeyFieldModel.getParentTable().getName(); String rightTable = this.rightKeyFieldModel.getParentTable().getName(); StringBuffer joinName = new StringBuffer(); joinName.append( leftTable ); joinName.append( "." ); joinName.append( this.leftKeyFieldModel.getName() ); joinName.append( " - " ); joinName.append( innerJoinLabel ); joinName.append( " - " ); joinName.append( rightTable ); joinName.append( "." ); joinName.append( this.rightKeyFieldModel.getName() ); return joinName.toString(); }
public String translate(Properties wikiProps, final String content) { boolean blogLineBreaks = false; String imagePlugin = wikiProps.getProperty("creole.imagePlugin.name"); String result = content; result = protectMarkup(result); result = translateLists(result, "*", "-", "Nothing"); result = translateElement(result, CREOLE_BOLD, JSPWIKI_BOLD); result = translateElement(result, CREOLE_ITALIC, JSPWIKI_ITALIC); result = translateElement(result, WWW_URL, HTTP_URL); if (imagePlugin != null && !imagePlugin.equals("")) { result = this.replaceImageArea(wikiProps, result, CREOLE_LINK_IMAG_X, JSPWIKI_LINK_IMAGE_X, 6, imagePlugin); result = this.replaceImageArea(wikiProps, result, CREOLE_IMAGE_X, JSPWIKI_IMAGE_X, 5, imagePlugin); } result = translateElement(result, CREOLE_IMAGE_LINK_DESC, JSPWIKI_IMAGE_LINK_DESC); result = translateElement(result, CREOLE_IMAGE_LINK, JSPWIKI_IMAGE_LINK); result = translateElement(result, CREOLE_LINK, JSPWIKI_LINK); result = translateElement(result, CREOLE_SIMPLELINK, JSPWIKI_SIMPLELINK); result = translateElement(result, CREOLE_HEADER_4, JSPWIKI_HEADER_4); result = translateElement(result, CREOLE_HEADER_3, JSPWIKI_HEADER_3); result = translateElement(result, CREOLE_HEADER_2, JSPWIKI_HEADER_2); result = translateElement(result, CREOLE_HEADER_1, JSPWIKI_HEADER_1); result = translateElement(result, CREOLE_HEADER_0, JSPWIKI_HEADER_0); result = translateElement(result, CREOLE_IMAGE, JSPWIKI_IMAGE); result = translateLists(result, "-", "*", "#"); result = translateElement(result, CREOLE_SIMPLEIMAGE, JSPWIKI_SIMPLEIMAGE); result = translateElement(result, CREOLE_TABLE, JSPWIKI_TABLE); result = replaceArea(result, TABLE_HEADER_PROTECTED, "\\|=([^\\|]*)=|\\|=([^\\|]*)", "||$1$2"); result = unprotectMarkup(result, true); result = translateVariables(result, blogLineBreaks); return result; }
@SuppressWarnings("unchecked") public static <T extends Enum<T>> T variantToEnum(final Object variant, final Class<T> enumClazz) { if (variant == null) { return null; } if (variant instanceof String) { return Enum.valueOf(enumClazz, ((String) variant).trim().toUpperCase()); } else if (variant instanceof Number) { final Integer index = variantToInteger(variant); final T[] enumConstants = enumClazz.getEnumConstants(); if (index < 0 || index >= enumConstants.length) { throw new IllegalArgumentException( String.format("Variant of type \"%s\", and value \"%s\" is out of range [, %d]", variant.getClass(), variant, enumConstants.length ) ); } return enumConstants[index]; } else if (variant instanceof Enum) { return (T) variant; } throw new IllegalArgumentException(String.format("\"%s\", and value \"%s\" is not one of %s", variant.getClass(), variant, Arrays.toString(SUPPORTED_VARIANT_TO_ENUM_TYPES))); }
@Override public boolean process(Telemetry telemetry) { if (telemetry == null) { return true; } if (telemetry instanceof MetricTelemetry) { MetricTelemetry mt = (MetricTelemetry) telemetry; if (notNeeded.contains(mt.getName())) { return false; } } return true; }
@Override public long getSize() { return size; }
public void setExecutable(@NotEmpty final List<@NotBlank @Size(max = 1024) String> executable) { this.executable.clear(); this.executable.addAll(executable); }
public Obs getDateOfDeathObs(Obs obsGroup) { return findMember(obsGroup, dateOfDeathConcept); }
public static Offset at(HorizontalOffset horizontal, VerticalOffset vertical) { return new InternalOffsets.OffsetImpl(horizontal, vertical); }
public void setRegionProvider(RegionProvider regionProvider) { this.regionProvider = regionProvider; }
public static GoogleGeocodeResponse parse(String originalQueryString, InputStream jsonInputStream) { Validate.notNull(jsonInputStream, "jsonInputStream is required"); try { JsonNode geocodeResponseRoot = new ObjectMapper().readValue(jsonInputStream, JsonNode.class); validateJsonFieldExists(geocodeResponseRoot, FIELD_STATUS); validateJsonFieldExists(geocodeResponseRoot, FIELD_RESULTS); return GoogleGeocodeResponse.newBuilder(originalQueryString) .setGeocodeStatus(parseGeocodeStatus(geocodeResponseRoot)) .addGeocodedAddresses(parseGeocodedAddresses(geocodeResponseRoot)) .build(); } catch (IOException e) { LOGGER.error("An I/O exception occured while parsing Google's geocode response"); throw new GeocodeException("An I/O exception occured while parsing Google's geocode response", e); } }
@Override public int hashCode() { int hash = 37; if ( name != null ) { hash = hash * 17 + name.hashCode(); } hash = hash * 17 + mods.size(); for ( int i = 0; i < mods.size(); i++ ) { hash = hash * 17 + ( ( DefaultModification ) mods.get( i ) ).hashCode(); } hash = hash * 17 + super.hashCode(); return hash; }
@Override public Void execute(Context context) { super.execute(context); final Task task = taskContext.getPersistenceContext().findTask(planningItem.getTaskId()); if (task == null) { throw new PlanningException(String.format(TASK_MODIFIED_ERROR_MSG_1, planningItem.getTaskId()), planningItem.getContainerId(), PlanningExecutionResult.ErrorCode.TASK_MODIFIED_SINCE_PLAN_CALCULATION_ERROR); } final org.kie.api.task.model.TaskData taskData = task.getTaskData(); final Status status = taskData.getStatus(); if (!(Ready == status || Reserved == status)) { throw new PlanningException(String.format(TASK_MODIFIED_ERROR_MSG, planningItem.getTaskId(), status, Arrays.toString(new Status[]{Ready, Reserved})), planningItem.getContainerId(), PlanningExecutionResult.ErrorCode.TASK_MODIFIED_SINCE_PLAN_CALCULATION_ERROR); } final OrganizationalEntity existingPotentialOwner = findPotentialOwner(task, planningItem.getPlanningTask().getAssignedUser()); DelegateTaskCommand delegateTaskCommand = createDelegateCommand(planningItem.getTaskId(), getUserId(), planningItem.getPlanningTask().getAssignedUser()); delegateTaskCommand.execute(context); if (existingPotentialOwner == null) { OrganizationalEntity addedPotentialOwner = findPotentialOwner(task, planningItem.getPlanningTask().getAssignedUser()); if (addedPotentialOwner != null) { task.getPeopleAssignments().getPotentialOwners().remove(addedPotentialOwner); } } saveOrUpdatePlanningTask(planningItem); return null; }
public <T> T query(String sql, OutputHandler<T> outputHandler, Object... params) throws SQLException { AssertUtils.assertNotNull(sql, nullException()); AssertUtils.assertNotNull(outputHandler, nullException()); return this.<T>query(this.getStatementHandler(), sql, outputHandler, new QueryParameters(params)); }
public void recordPageHistory(HttpServletRequest request, HttpServletResponse response, ModelAndView modelAndView, HandlerMethod handler) { Deque<PageHistory> history = getPageHistory(request).orElse(new LinkedList<>()); while (history.contains(new PageHistory(request.getRequestURI()))) { history.pop(); } if (handler.hasMethodAnnotation(NavigationRoot.class)) { history.clear(); } if (!history.isEmpty()) { modelAndView.getModel().put("cookieBackLinkUrl", history.peek().getUrl()); modelAndView.getModel().put("cookieBackLinkText", history.peek().getName()); } if (!ERROR.equals(request.getDispatcherType())) { history.push(new PageHistory(request.getRequestURI())); encodedCookieService.saveToCookie(response, PAGE_HISTORY_COOKIE_NAME, JsonUtil.getSerializedObject(history)); } }
public List<String> loadTextFileAndUpdate(String configFilePath, ServletContext context, Path appPath, BufferedReader reader) throws IOException { ServletResourceLoader loader = new ServletResourceLoader(context, appPath); try { String resource = lookupOverrideParameter(context, appPath); return loadFileAndUpdate(loader, resource, configFilePath, reader); } catch (JDOMException e) { return loadFileAndUpdate(loader, null, configFilePath, reader); } }
@Override public void messageReceived(IoSession session, Object in, ReadFilterChainController controller) { LOGGER.debug("Processing a MESSAGE_RECEIVED for session {}", session); CoapMessage coapMsg = (CoapMessage) in; String transmissionId = CoapTransmission.uniqueId(session, coapMsg); switch (coapMsg.getType()) { case NON_CONFIRMABLE: super.messageReceived(session, coapMsg, controller); break; case CONFIRMABLE: CoapMessage ack = processed.get(transmissionId); if (ack != null) { LOGGER.debug("Duplicated messages detected with ID {} in session {}", coapMsg.requestId(), session); controller.callWriteMessageForRead(ack); } else { super.messageReceived(session, coapMsg, controller); } break; case ACK: case RESET: CoapTransmission t = inFlight.get(transmissionId); if (t != null) { t.getRetryFuture().cancel(false); inFlight.remove(transmissionId); } super.messageReceived(session, coapMsg, controller); break; } }
@CachedGauge(absolute = true, name = "streams.count", timeout = 30, timeoutUnit = TimeUnit.SECONDS) public int getTotalStreams() { return streamStatusDao.getAll().size(); }
@Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } ObjectInfo rhs = (ObjectInfo) o; return new EqualsBuilder() .append(storageID, rhs.storageID) .append(objectFormat, rhs.objectFormat) .append(protectionStatus, rhs.protectionStatus) .append(objectCompressedSize, rhs.objectCompressedSize) .append(thumbFormat, rhs.thumbFormat) .append(thumbCompressedSize, rhs.thumbCompressedSize) .append(thumbPixWidth, rhs.thumbPixWidth) .append(thumbPixHeight, rhs.thumbPixHeight) .append(imagePixWidth, rhs.imagePixWidth) .append(imagePixHeight, rhs.imagePixHeight) .append(imageBitDepth, rhs.imageBitDepth) .append(parentObject, rhs.parentObject) .append(associationType, rhs.associationType) .append(associationDesc, rhs.associationDesc) .append(sequenceNumber, rhs.sequenceNumber) .append(fileName, rhs.fileName) .append(captureDate, rhs.captureDate) .append(modificationDate, rhs.modificationDate) .append(keywords, rhs.keywords) .isEquals(); }
public static UDDIClient getUDDIClient(ServletContext servletContext) throws ConfigurationException { if (servletContext.getAttribute(JUDDI_CLIENT_NAME) != null) { String clientName = String.valueOf(servletContext.getAttribute(JUDDI_CLIENT_NAME)); return UDDIClientContainer.getUDDIClient(clientName); } else { String clientName = servletContext.getInitParameter(UDDI_CLIENT_NAME); if (clientName != null) { try { UDDIClient client = UDDIClientContainer.getUDDIClient(clientName); logger.info("Client " + clientName + " was already started."); servletContext.setAttribute(JUDDI_CLIENT_NAME, clientName); return client; } catch (ConfigurationException ce) { logger.debug("Client " + clientName + " is not yet started."); } } String clientConfigFile = servletContext.getInitParameter(UDDI_CLIENT_CONFIG_FILE); if (clientConfigFile == null) { clientConfigFile = ClientConfig.DEFAULT_UDDI_CONFIG; } logger.info("Reading the clientName from the clientConfig file " + clientConfigFile); UDDIClient client = new UDDIClient(clientConfigFile); if (client.getName() == null) { logger.warn("Deprecated, client name set to 'default', however it should be provided in the uddi.xml"); clientName = "default"; } if (client.getName() != null) { logger.info("Starting Client " + client.getName() + "..."); clientName = client.getName(); } else { throw new ConfigurationException("A client name needs to be specified in the client config file."); } client.start(); servletContext.setAttribute(JUDDI_CLIENT_NAME, clientName); return client; } }
public synchronized void setProcessor (String processor) { this.processorClass = processor; setModified (true); }
public String getClientAddress() { if (null != peer.cnxnFactory) { return formatInetAddr(peer.cnxnFactory.getLocalAddress()); } else { return ""; } }
@Override public RuleResult execute(Map<String, String> ruleParam, Map<String, String> resourceAttributes) { logger.debug("========CheckForApiGatewayProtected started========="); Annotation annotation = null; String roleIdentifyingString = ruleParam .get(PacmanSdkConstants.Role_IDENTIFYING_STRING); String resourceId = ruleParam.get(PacmanSdkConstants.RESOURCE_ID); String authType = ruleParam.get(PacmanRuleConstants.AUTH_TYPE); String tagsSplitter = ruleParam.get(PacmanSdkConstants.SPLITTER_CHAR); String severity = ruleParam.get(PacmanRuleConstants.SEVERITY); String category = ruleParam.get(PacmanRuleConstants.CATEGORY); MDC.put("executionId", ruleParam.get("executionId")); MDC.put("ruleId", ruleParam.get(PacmanSdkConstants.RULE_ID)); Gson gson = new Gson(); List<LinkedHashMap<String, Object>> issueList = new ArrayList<>(); LinkedHashMap<String, Object> issue = new LinkedHashMap<>(); Map<String, Object> authTypeMap = new HashMap<>(); if (!PacmanUtils.doesAllHaveValue(authType, tagsSplitter, severity, category)) { logger.info(PacmanRuleConstants.MISSING_CONFIGURATION); throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION); } AmazonApiGatewayClient apiGatewayClient = getClient( roleIdentifyingString, ruleParam); List<String> authTypeList = PacmanUtils.splitStringToAList(authType, tagsSplitter); try { for (Resource resource : getResourceList(resourceId, apiGatewayClient)) { Map<String, Method> httpMethodMap = resource .getResourceMethods(); if (httpMethodMap != null) { for (Map.Entry<String, Method> httpMethod : httpMethodMap .entrySet()) { GetMethodResult methodResult = getGetMethodResult( resource, resourceId, httpMethod, apiGatewayClient); String authorisationType = methodResult .getAuthorizationType(); boolean isApiKeyRequired = methodResult .getApiKeyRequired(); boolean isAuthType = false; logger.info("========Checking is auth type true========="); for (String authorType : authTypeList) { if (authorisationType.equalsIgnoreCase(authorType)) { isAuthType = true; } else { authTypeMap.put(authorType, "Not found"); } } if (!(isAuthType || isApiKeyRequired)) { if (annotation == null) { annotation = Annotation.buildAnnotation( ruleParam, Annotation.Type.ISSUE); annotation.put(PacmanRuleConstants.SEVERITY, severity); annotation.put(PacmanRuleConstants.CATEGORY, category); } formateAPIMethodDetails(resource.getPath(), httpMethod.getKey(), String.valueOf(isApiKeyRequired)); } } } } } catch (Exception exception) { logger.error("error: ", exception); throw new RuleExecutionFailedExeption(exception.getMessage()); } if (annotation == null) { logger.debug("========CheckForApiGatewayProtected ended========="); return new RuleResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE); } else { annotation.put("APIMethods", apiMethodsDes); annotation.put(PacmanSdkConstants.DESCRIPTION, "API gateway is not protected.And the API methods description are " + apiMethodsDes); issue.put(PacmanRuleConstants.VIOLATION_REASON, "API gateway is not protected"); issue.put("apiMethods", apiMethodsDes); issue.put("authType", gson.toJson(authTypeMap)); issueList.add(issue); annotation.put("issueDetails", issueList.toString()); apiMethodsDes = null; logger.debug("========CheckForApiGatewayProtected ended with annotation : {}=========",annotation); return new RuleResult(PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation); } }
public ComplianceStatus getStatus(Consumer c) { return getStatus(c, null, false); }
public String getCucumberOptions() { return cucumberOptions; }
@Override public SdkRequest modifyRequest(Context.ModifyRequest context, ExecutionAttributes executionAttributes) { SdkRequest sdkRequest = context.request(); if (sdkRequest instanceof CreateBucketRequest) { CreateBucketRequest request = (CreateBucketRequest) sdkRequest; validateBucketNameIsS3Compatible(request.bucket()); if (request.createBucketConfiguration() == null || request.createBucketConfiguration().locationConstraint() == null) { Region region = executionAttributes.getAttribute(AwsExecutionAttribute.AWS_REGION); sdkRequest = request.toBuilder() .createBucketConfiguration(toLocationConstraint(region)) .build(); } } return sdkRequest; }
@Override public byte[] next() throws IOException { checkStop(); try { input.mark(avgSizeByte); int len = input.readInt(); if (len <= 0) { throw new IOException("failed to read next data."); } byte[] data = new byte[len]; input.readFully(data); position += (data.length + INTEGER_SIZE_BYTE); return data; } catch (IOException io) { try { input.reset(); } catch (IOException ignore) { } throw io; } }
void createBackends(Set<Optional<String>> backendNames) { if ( backendNames.remove( Optional.<String>empty() ) ) { backendNames.add( Optional.of( getDefaultBackendName() ) ); } for ( Optional<String> backendNameOptional : backendNames ) { String backendName = backendNameOptional.get(); BackendInitialBuildState backendBuildState; try { backendBuildState = createBackend( backendName ); } catch (RuntimeException e) { rootBuildContext.getFailureCollector() .withContext( EventContexts.fromBackendName( backendName ) ) .add( e ); continue; } backendBuildStateByName.put( backendName, backendBuildState ); } }
@NonNull public static Builder builder() { return new AutoValue_LogRequest.Builder(); }
@Override public List<String> listResourcesOfApp(String app) { List<String> results = new ArrayList<>(); if (StringUtil.isBlank(app)) { return results; } Map<String, LinkedHashMap<Long, MetricEntity>> resourceMap = allMetrics.get(app); if (resourceMap == null) { return results; } final long minTimeMs = System.currentTimeMillis() - 1000 * 60; Map<String, MetricEntity> resourceCount = new ConcurrentHashMap<>(32); readWriteLock.readLock().lock(); try { for (Entry<String, LinkedHashMap<Long, MetricEntity>> resourceMetrics : resourceMap.entrySet()) { for (Entry<Long, MetricEntity> metrics : resourceMetrics.getValue().entrySet()) { if (metrics.getKey() < minTimeMs) { continue; } MetricEntity newEntity = metrics.getValue(); if (resourceCount.containsKey(resourceMetrics.getKey())) { MetricEntity oldEntity = resourceCount.get(resourceMetrics.getKey()); oldEntity.addPassQps(newEntity.getPassQps()); oldEntity.addRtAndSuccessQps(newEntity.getRt(), newEntity.getSuccessQps()); oldEntity.addBlockQps(newEntity.getBlockQps()); oldEntity.addExceptionQps(newEntity.getExceptionQps()); oldEntity.addCount(1); } else { resourceCount.put(resourceMetrics.getKey(), MetricEntity.copyOf(newEntity)); } } } return resourceCount.entrySet() .stream() .sorted((o1, o2) -> { MetricEntity e1 = o1.getValue(); MetricEntity e2 = o2.getValue(); int t = e2.getBlockQps().compareTo(e1.getBlockQps()); if (t != 0) { return t; } return e2.getPassQps().compareTo(e1.getPassQps()); }) .map(Entry::getKey) .collect(Collectors.toList()); } finally { readWriteLock.readLock().unlock(); } }
public EvictResult tryEvict(final PeerId peer) { final Bytes id = peer.getId(); final int distance = distanceFrom(peer); if (distance == 0) { return EvictResult.self(); } distanceCache.remove(id); if (table[distance].getPeers().isEmpty()) { return EvictResult.absent(); } final boolean evicted = table[distance].evict(peer); if (evicted) { evictionCnt++; } else { return EvictResult.absent(); } if (evictionCnt >= BLOOM_FILTER_REGENERATION_THRESHOLD) { ForkJoinPool.commonPool().execute(this::buildBloomFilter); } return EvictResult.evicted(); }
public SimpleObject[] getMothers(@RequestParam("patientId") Patient patient,UiUtils ui) { List<Person> people = new ArrayList<Person>(); for (Relationship relationship : Context.getPersonService().getRelationshipsByPerson(patient)) { if (relationship.getRelationshipType().getbIsToA().equals("Parent")) { if (relationship.getPersonB().getGender().equals("F")) { people.add(relationship.getPersonB()); } } if (relationship.getRelationshipType().getaIsToB().equals("Parent")) { if (relationship.getPersonA().getGender().equals("F")) { people.add(relationship.getPersonA()); } } } return ui.simplifyCollection(people); }
public String getSubtreeId() { return subtreeId; }
@Override public SyntaxToken firstToken() { if (typeArguments() != null && methodSelect.is(Tree.Kind.MEMBER_SELECT)) { ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression(); SyntaxToken firstToken = expression.firstToken(); if (firstToken != null) { return firstToken; } } return super.firstToken(); }
public static Statement newInstance(boolean debug, BoltNeo4jConnectionImpl connection, int... rsParams) { Statement statement = new BoltNeo4jStatement(connection, rsParams); ((Neo4jStatement) statement).setDebug(debug); return (Statement) Proxy.newProxyInstance(BoltNeo4jStatement.class.getClassLoader(), new Class[] { Statement.class }, new Neo4jInvocationHandler(statement, debug)); }
public GeradorXml getGerador(Evento evento) throws GeracaoXmlException { GeradorXml geradorXml = getGeradores().get(evento.getTipoEvento()); if (geradorXml == null) { throw new GeracaoXmlException(evento, "Não foi possível encontrar um gerador de XML para o evento"); } return geradorXml; }
@Override public String getName() { return name; }
public void loadPropertyFile(File propertyFile, String propertyFileName) throws PropertyAccessException { PropertiesConfiguration properties = new PropertiesConfiguration(); try { properties.setReloadingStrategy(new FileChangedReloadingStrategy()); properties.load(propertyFile); properties.setFile(propertyFile); properties.setAutoSave(false); properties.refresh(); propertyFilesHashmap.put(propertyFileName, properties); } catch (ConfigurationException e) { String sMessage = "Failed to load property file. Error: " + e.getMessage(); throw new PropertyAccessException(sMessage, e); } }
@After("classAnnotatedWithRxLogSubscriber(joinPoint) && onRequestMethodCall(numberOfItems)") public void afterRequestMethodCall(JoinPoint joinPoint, long numberOfItems) { messageManager.printSubscriberRequestedItems(joinPoint.getTarget().getClass().getSimpleName(), numberOfItems); }
public static String getCommonName(X509Certificate cert) { try { return getValueByObjectIdentifier(cert, BCStyle.CN).replaceAll("\\\\", ""); } catch (CertificateEncodingException e) { LOGGER.error("Error extracting common name from certificate", e); return null; } }
public static String buildSpace(int spaces) { return repeated(spaces, " "); }
public static String extractTableName(final String sql) { String lowerCaseSql = sql.toLowerCase(); String from = " from "; int fromIndex = lowerCaseSql.indexOf(from); if (fromIndex < 0) { return null; } String tableString = sql.substring(fromIndex + from.length()); if (tableString.startsWith("(")) { return null; } int endTableIndex = -1; for (int i = 0; i < tableString.length(); i++) { char c = tableString.charAt(i); if (c == ' ' || c == ',' || c == ';') { endTableIndex = i; break; } } return endTableIndex < 0 ? tableString : tableString.substring(0, endTableIndex); }
public boolean isLocationSentence(){ return isGSA() || isGGA(); }
public static void setupProxy() { String proxyHost = Configuration.get(Parameter.PROXY_HOST); String proxyPort = Configuration.get(Parameter.PROXY_PORT); String noProxy = Configuration.get(Parameter.NO_PROXY); List<String> protocols = Arrays.asList(Configuration.get(Parameter.PROXY_PROTOCOLS).split("[\\s,]+")); if (proxyHost != null && !proxyHost.isEmpty() && proxyPort != null && !proxyPort.isEmpty() && Configuration.getBoolean(Parameter.PROXY_SET_TO_SYSTEM)) { if (protocols.contains("http")) { LOGGER.info(String.format("HTTP client will use http: %s:%s", proxyHost, proxyPort)); System.setProperty("http.proxyHost", proxyHost); System.setProperty("http.proxyPort", proxyPort); if (!noProxy.isEmpty()) { System.setProperty("http.nonProxyHosts", proxyPort); } } if (protocols.contains("https")) { LOGGER.info(String.format("HTTP client will use https proxies: %s:%s", proxyHost, proxyPort)); System.setProperty("https.proxyHost", proxyHost); System.setProperty("https.proxyPort", proxyPort); if (!noProxy.isEmpty()) { System.setProperty("https.nonProxyHosts", proxyPort); } } if (protocols.contains("ftp")) { LOGGER.info(String.format("HTTP client will use ftp proxies: %s:%s", proxyHost, proxyPort)); System.setProperty("ftp.proxyHost", proxyHost); System.setProperty("ftp.proxyPort", proxyPort); if (!noProxy.isEmpty()) { System.setProperty("ftp.nonProxyHosts", proxyPort); } } if (protocols.contains("socks")) { LOGGER.info(String.format("HTTP client will use socks proxies: %s:%s", proxyHost, proxyPort)); System.setProperty("socksProxyHost", proxyHost); System.setProperty("socksProxyPort", proxyPort); } } }
public static boolean hasVibrationPermission(Context context) { return (context.getPackageManager().checkPermission(Manifest.permission.VIBRATE, context.getPackageName()) == PackageManager.PERMISSION_GRANTED); }
public static int getJsonIntValue(String jsonStr, String keys) { try { Object rawValue = getJsonRawValue(jsonStr, keys); if (rawValue == null) { return 0; } else { if (rawValue instanceof Integer) { logger.debug("getJsonIntValue(): the raw value is an Integer Object={}", rawValue); return (Integer) rawValue; } else { logger.debug("getJsonIntValue(): the raw value is NOT an Integer Object={}", rawValue); return 0; } } } catch (Exception e) { logger.debug("getJsonIntValue(): unable to parse json to retrieve value for field={}. Exception was: {}", keys, e.toString(), e); } return 0; }
@Override public void storeOntologyEntries(List<OntologyEntryBean> entries) throws StorageEngineException { if (entries.isEmpty()) { LOGGER.debug("storeOntologyEntries called with empty list - ignoring"); } else { try { UpdateResponse response = server.addBeans(entries, config.getCommitWithinMs()); if (response.getStatus() != STATUS_OK) { LOGGER.error("Unexpected response: {}", response.getResponse()); throw new StorageEngineException("Could not store entries: " + response.getResponse()); } } catch (IOException e) { LOGGER.error("IO exception when calling server: {}", e.getMessage()); throw new StorageEngineException(e); } catch (SolrServerException e) { LOGGER.error("Server exception when storing entries: {}", e.getMessage()); throw new StorageEngineException(e); } } }
@Override public Set<String> supportedFileAttributeViews() { return ImmutableSet.of("basic", "posix"); }
public <T> T executeQuery(final Query query, final ResultSetCallback<T> callback) { return executeQuery(query.getSQL(), Collections.emptyList(), callback, getReadConnection()); }
public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, "next is null"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; }
long getFilePageId( long pageRef ) { long filePageId = UnsafeUtil.getLong( offPageBinding( pageRef ) ) >>> SHIFT_FILE_PAGE_ID; return filePageId == MAX_FILE_PAGE_ID ? PageCursor.UNBOUND_PAGE_ID : filePageId; }
@Override public boolean isAuthorized(AuthorizationContext context, String placeId, PlatformMessage message) { logger.debug("Authorized [{}] for message [{}]", context.getSubjectString(), message); return true; }
public ValidatorChain validatePermision(LoginUser user, Errors errors) throws SQLException { return ValidatorChain.newInstance().controllerValidate(errors) .addAssert(() -> permissionService.isManagerById(user.getId()), message.group_message_no_pemission); }
public List<R> scanForResourcesPath(Path resourcePath) { requireNonNull(resourcePath, "resourcePath must not be null"); List<R> resources = new ArrayList<>(); pathScanner.findResourcesForPath( resourcePath, canLoad, processResource(DEFAULT_PACKAGE_NAME, NULL_FILTER, createUriResource(), resources::add)); return resources; }
@Override public void validateConfiguration(String configuration) throws FragmentEntryConfigurationException { validateConfigurationValues(configuration, null); }
public String getDefaultTitleTypefacePath() { return builder.defaultTitleTypefacePath; }
public ClientServerNegotiationPolicy buildClientServerNegotiationPolicyFromJargonProperties() { JargonProperties jargonProperties = irodsSession.getJargonProperties(); ClientServerNegotiationPolicy clientServerNegotiationPolicy = new ClientServerNegotiationPolicy(); clientServerNegotiationPolicy.setSslNegotiationPolicy(jargonProperties.getNegotiationPolicy()); return clientServerNegotiationPolicy; }
public StubDescriptor parse(final Document document) { Element root = document.getDocumentElement(); StubDescriptorAttributes attributes = getStubDescriptorAttributes(root); List<DialogDescriptor> dialogDescriptors = getDialogDescriptors(document, root); List<InterceptorDescriptor> interceptorDescriptors = getInterceptorDescriptors(document, root); List<SequenceDescriptor> sequenceDescriptors = sequenceDescriptorParser.parse(document, root, dialogDescriptors); return new StubDescriptor(attributes, dialogDescriptors, interceptorDescriptors, sequenceDescriptors); }
public String getSelectQuery(ServiceConfigurationSearchCriteria serviceConfigurationSearchCriteria, List<Object> preparedStatementValues) { selectQuery = new StringBuilder(BASEQUERY); addWhereCluase(serviceConfigurationSearchCriteria, preparedStatementValues); log.debug("QueryForSearch: " + selectQuery.toString()); return selectQuery.toString(); }
public Location set(double latitude, double longitude) { this.latitude = latitude; this.longitude = longitude; return this; }
@Override public T integrate(Function<U, T> f, U[] lower, U[] upper) { ArgChecker.notNull(f, "function was null"); ArgChecker.notNull(lower, "lower bound array was null"); ArgChecker.notNull(upper, "upper bound array was null"); ArgChecker.notEmpty(lower, "lower bound array was empty"); ArgChecker.notEmpty(upper, "upper bound array was empty"); ArgChecker.notNull(lower[0], "lower bound was null"); ArgChecker.notNull(upper[0], "upper bound was null"); if (lower.length > 1) { log.info("Lower bound array had more than one element; only using the first"); } if (upper.length > 1) { log.info("Upper bound array had more than one element; only using the first"); } return integrate(f, lower[0], upper[0]); }
protected static int getHammingDistance(long a, long b) { long xor = a ^ b; int distance = Long.bitCount(xor); return distance; }
@Override public void saveWorkspace(Map<String, Map<String, String>> data, File destination) { requireNotNullArg(destination, "Destination file cannot be null"); LOG.debug(DefaultI18nContext.getInstance().i18n("Saving workspace data to {0}", destination.getAbsolutePath())); try { JSON.std.with(JSON.Feature.PRETTY_PRINT_OUTPUT).without(JSON.Feature.WRITE_NULL_PROPERTIES) .write(data, destination); LOG.info(DefaultI18nContext.getInstance().i18n("Workspace saved")); } catch (Exception e) { throw new RuntimeException(e); } }
public Date calculateBusinessTimeAsDate(String timeExpression) { timeExpression = adoptISOFormat(timeExpression); String trimmed = timeExpression.trim(); int weeks = 0; int days = 0; int hours = 0; int min = 0; int sec = 0; if( trimmed.length() > 0 ) { Matcher mat = PatternConstants.SIMPLE_TIME_DATE_MATCHER.matcher(trimmed ); if ( mat.matches() ) { weeks = (mat.group( SIM_WEEK ) != null) ? Integer.parseInt( mat.group( SIM_WEEK ) ) : 0; days = (mat.group( SIM_DAY ) != null) ? Integer.parseInt( mat.group( SIM_DAY ) ) : 0; hours = (mat.group( SIM_HOU ) != null) ? Integer.parseInt( mat.group( SIM_HOU ) ) : 0; min = (mat.group( SIM_MIN ) != null) ? Integer.parseInt( mat.group( SIM_MIN ) ) : 0; sec = (mat.group( SIM_SEC ) != null) ? Integer.parseInt( mat.group( SIM_SEC ) ) : 0; } } int time = 0; Calendar c = new GregorianCalendar(); if (timezone != null) { c.setTimeZone(TimeZone.getTimeZone(timezone)); } if (this.clock != null) { c.setTimeInMillis(this.clock.getCurrentTime()); } int numberOfWeeks = days/daysPerWeek + weeks; if (numberOfWeeks > 0) { c.add(Calendar.WEEK_OF_YEAR, numberOfWeeks); } handleWeekend(c, hours > 0 || min > 0); hours += (days - (numberOfWeeks * daysPerWeek)) * hoursInDay; int numberOfDays = hours/hoursInDay; if (numberOfDays > 0) { for (int i = 0; i < numberOfDays; i++) { c.add(Calendar.DAY_OF_YEAR, 1); handleWeekend(c, false); handleHoliday(c, hours > 0 || min > 0); } } int currentCalHour = c.get(Calendar.HOUR_OF_DAY); if (currentCalHour >= endHour) { c.add(Calendar.DAY_OF_YEAR, 1); c.add(Calendar.HOUR_OF_DAY, startHour-currentCalHour); c.set(Calendar.MINUTE, 0); c.set(Calendar.SECOND, 0); } else if (currentCalHour < startHour) { c.add(Calendar.HOUR_OF_DAY, startHour); } time = hours - (numberOfDays * hoursInDay); c.add(Calendar.HOUR, time); handleWeekend(c, true); handleHoliday(c, hours > 0 || min > 0); currentCalHour = c.get(Calendar.HOUR_OF_DAY); if (currentCalHour >= endHour) { c.add(Calendar.DAY_OF_YEAR, 1); c.set(Calendar.HOUR_OF_DAY, startHour); c.add(Calendar.HOUR_OF_DAY, currentCalHour - endHour); } else if (currentCalHour < startHour) { c.add(Calendar.HOUR_OF_DAY, startHour); } int numberOfHours = min/60; if (numberOfHours > 0) { c.add(Calendar.HOUR, numberOfHours); min = min-(numberOfHours * 60); } c.add(Calendar.MINUTE, min); int numberOfMinutes = sec/60; if (numberOfMinutes > 0) { c.add(Calendar.MINUTE, numberOfMinutes); sec = sec-(numberOfMinutes * 60); } c.add(Calendar.SECOND, sec); currentCalHour = c.get(Calendar.HOUR_OF_DAY); if (currentCalHour >= endHour) { c.add(Calendar.DAY_OF_YEAR, 1); c.set(Calendar.HOUR_OF_DAY, startHour); c.add(Calendar.HOUR_OF_DAY, currentCalHour - endHour); } else if (currentCalHour < startHour) { c.add(Calendar.HOUR_OF_DAY, startHour); } handleWeekend(c, false); handleHoliday(c, false); return c.getTime(); }
@PostMapping(value = "/invite", params = {"remove"}) public String removeInviteFromInviteView(Model model, @PathVariable("competitionId") long competitionId, @RequestParam(name = "remove") String email, @RequestParam(defaultValue = "0") int page, @SuppressWarnings("unused") @ModelAttribute(FORM_ATTR_NAME) InviteNewAssessorsForm form) { deleteInvite(email, competitionId).getSuccess(); return redirectToInvite(competitionId, page); }
@Override public boolean isApplicable(final RequestContext requestContext) { return containsHeader(requestContext, HttpHeader.X_DITTO_PRE_AUTH) || containsHeader(requestContext, HttpHeader.X_DITTO_DUMMY_AUTH); }
public Environment getEnvironment() { if (this.environment == null) { String msg = "Environment has not yet been set. This should be done before this broker filter is used."; throw new IllegalStateException(msg); } return environment; }
public static HeapBuffer allocate() { return allocate(DEFAULT_INITIAL_CAPACITY, MAX_SIZE); }
@Transactional @Override public CmsResponse<ScaStatus> getAuthorisationScaStatus(String authorisationId, AuthorisationParentHolder parentHolder) { String encryptedId = parentHolder.getParentId(); Optional<String> decryptedIdOptional = securityDataService.decryptId(encryptedId); if (decryptedIdOptional.isEmpty()) { log.info("Encrypted Parent ID: [{}]. Get SCA status has failed, couldn't decrypt parent id", encryptedId); return CmsResponse.<ScaStatus>builder() .error(TECHNICAL_ERROR) .build(); } return authorisationService.getAuthorisationScaStatus(authorisationId, new AuthorisationParentHolder(parentHolder.getAuthorisationType(), decryptedIdOptional.get())); }
public static Matcher<JsonNode> jsonNumber() { return new IsJsonNumber(is(anything()), n -> n); }
public String getLogContent(final String fileName) { Collection<File> files = getLogFiles(LOG_PATH); File file = findFile(fileName, files); return getContent(file); }
@Override public ProcessResult process(Doc doc) { if (!doc.hasField(field)) { return ProcessResult.failure(String.format("failed to process date, field in path [%s] is missing", field)); } Object dateTimeDocValue = doc.getField(field); ZonedDateTime dateTime = null; if (dateTimeDocValue instanceof Number && formats.contains("UNIX")) { long epocTimeInMilis = ((Number) (((Number) dateTimeDocValue).doubleValue() * 1000)).longValue(); dateTime = getEpochMillisDateTime(epocTimeInMilis); } else if (dateTimeDocValue instanceof Number && formats.contains("UNIX_MS")) { long epocTimeInMilis = ((Number) dateTimeDocValue).longValue(); dateTime = getEpochMillisDateTime(epocTimeInMilis); } else if (dateTimeDocValue instanceof String) { dateTime = getISODateTime((String) dateTimeDocValue); } if (dateTime == null) { return ProcessResult.failure(String.format("failed to parse date in path [%s], [%s] is not one of the formats [%s]", field, dateTimeDocValue, formats)); } doc.addField(targetField, dateTime.format(outputFormatter)); return ProcessResult.success(); }
@Override public boolean canHandle(ActionParameter actionParameter) { if (actionParameter.getExpression() == null) { return false; } ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName("javascript"); try { if (actionParameter.getInputData() != null && actionParameter.getInputData() instanceof Number) { return (Boolean) engine .eval(actionParameter.getInputData().toString() + actionParameter.getExpression()); } else if (actionParameter.getInputData() != null && actionParameter.getInputData() instanceof Date) { String varName = actionParameter.getColumn() + "Date"; engine.put(varName, actionParameter.getInputData()); return (Boolean) engine.eval("" + varName + actionParameter.getExpression()); } else { String varName = actionParameter.getColumn() + "String"; engine.put(varName, actionParameter.getInputData()); return (Boolean) engine.eval("" + varName + actionParameter.getExpression()); } } catch (ScriptException e) { LOGGER.error(e.getMessage(), e); } return false; }
public static Path serializeAsPath(GenericRecord record, boolean includeFieldNames, boolean replacePathSeparators) { if (record == null) { return new Path(""); } List<String> tokens = Lists.newArrayList(); for (Schema.Field field : record.getSchema().getFields()) { String sanitizedName = HadoopUtils.sanitizePath(field.name(), "_"); String sanitizedValue = HadoopUtils.sanitizePath(record.get(field.name()).toString(), "_"); if (replacePathSeparators) { sanitizedName = sanitizedName.replaceAll(Path.SEPARATOR, "_"); sanitizedValue = sanitizedValue.replaceAll(Path.SEPARATOR, "_"); } if (includeFieldNames) { tokens.add(String.format("%s=%s", sanitizedName, sanitizedValue)); } else if (!Strings.isNullOrEmpty(sanitizedValue)) { tokens.add(sanitizedValue); } } return new Path(Joiner.on(Path.SEPARATOR).join(tokens)); }
EncryptionService create(String alias, char[] password) { PublicKey pk = getPublicKey(alias); Key key; try { key = this.keyStore.getKey(alias, password); } catch (UnrecoverableKeyException e) { throw SeedException.wrap(e, CryptoErrorCode.UNRECOVERABLE_KEY); } catch (KeyStoreException e) { throw SeedException.wrap(e, CryptoErrorCode.UNEXPECTED_EXCEPTION); } catch (NoSuchAlgorithmException e) { throw SeedException.wrap(e, CryptoErrorCode.ALGORITHM_CANNOT_BE_FOUND); } return new EncryptionServiceImpl(alias, pk, key); }
@Override public Observable<UserEntity> loginUser(UserEntity user) { return this.restApi.doLogin(new UserWrapper(user)) .map(userEntityResponse -> { handleResponseError(userEntityResponse); return userEntityResponse.body(); }); }
@Override public void setRoot(RadixTreeNode root) { throw new UnsupportedOperationException(); }
public static <K, V> Builder<K, V> builder() { return new Builder<>(); }
public static void copyTo(ByteBuffer src, ByteBuffer dest) { if (src == null || dest == null) { return; } if (src.hasArray()) { byte[] array = src.array(); int offset = src.arrayOffset() + src.position(); int length = src.remaining(); dest.put(array, offset, length); } else { for (int i = src.position(); i < src.limit(); i++) { dest.put(src.get(i)); } } }
protected <T extends Model> Predicate constructQuery(CriteriaBuilder builder, Root<T> root) { path = getPath(root, name); return operator.constructCondition(builder, path, name); }
@Override public SearchResponse<Group> search(SearchRequest request) throws SecurityManagementException { List<Group> groups = getAll(); return groupsSearchEngine.search(groups, request); }
static Object callModuleMethod(final String instanceId, String moduleStr, String methodStr, JSONArray args) { ModuleFactory factory = sModuleFactoryMap.get(moduleStr); if(factory == null){ WXLogUtils.e("[WXModuleManager] module factory not found."); return null; } final WXModule wxModule = findModule(instanceId, moduleStr,factory); if (wxModule == null) { return null; } WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(instanceId); wxModule.mWXSDKInstance = instance; final Invoker invoker = factory.getMethodInvoker(methodStr); try { return instance .getNativeInvokeHelper() .invoke(wxModule,invoker,args); } catch (Exception e) { WXLogUtils.e("callModuleMethod >>> invoke module:" + moduleStr + ", method:" + methodStr + " failed. ", e); return null; } finally { if (wxModule instanceof WXDomModule || wxModule instanceof WXTimerModule) { wxModule.mWXSDKInstance = null; } } }
@Nonnull public static String toString( @Nonnull final InputStream input ) throws IOException { return toString( input, DEFAULT_BUFFER_SIZE ); }
public List<String> process(List<String> args) throws SoarException { arguments = new HashMap<String, String>(); List<String> nonOptionArgs = new ArrayList<String>(); if (args.isEmpty()) return nonOptionArgs; Iterator<String> iter = args.iterator(); iter.next(); boolean done = false; while (iter.hasNext()) { String arg = iter.next(); if (!done && arg.length() > 1 && arg.charAt(0) == '-') { if (arg.charAt(1) == '-') { if (arg.length() == 2) { done = true; } else { Option<E> option = resolveLongOption(arg.substring(2)); if (option == null) throw new SoarException("Unknown option: " + arg); processOption(option, arg, iter); } continue; } else { if (!isNumber(arg)) { for (int i = 1; i < arg.length(); ++i) { Option<E> option = resolveShortOption(arg.charAt(i)); if (option == null) throw new SoarException("Unknown option: " + arg); boolean consumedArg = processOption(option, arg, iter, i); if (consumedArg) break; } continue; } } } nonOptionArgs.add(arg); } return nonOptionArgs; }
public DirectoryStructure readDirectoryStructure( String rootDirectory, String include, String exclude ) throws IOException { FileFilter filter = FileFilter.of(rootDirectory, include, exclude); List<FileEntry> allFilesEntries = directoryLister.listFiles(rootDirectory, filter); DirectoryStructureBuilder structureBuilder = DirectoryStructure.builder(); for (FileEntry fileEntry : allFilesEntries) { FilePath filePath = fileEntry.getFilePath(); if (fileEntry.isDirectory()) { DirectoryMetadata directoryMetadata = metadataReader.readDirectoryMetadata(rootDirectory, filePath); structureBuilder.directory(directoryMetadata); } else { FileMetadata fileMetadata = metadataReader.readFileMetadata(rootDirectory, filePath); structureBuilder.file(fileMetadata); } } return structureBuilder.build(); }
public static DependencyRules allowAll() { return new DependencyRules(new ArrayList<>(), true, true, true); }
@Override public String getKeyFromMessage(AdaptrisMessage msg) throws CoreException { return getValueFromMessage(msg); }
public static void insertSubChannel( Tensor_F64 src , int srcStartIndex , int srcStride , Tensor_F64 dst , int dstStartIndex , int dstStride , int rows , int columns ) { int indexSrc = srcStartIndex; int indexDst = dstStartIndex;; for (int i = 0; i < rows; i++) { System.arraycopy(src.d,indexSrc,dst.d,indexDst,columns); indexSrc += srcStride; indexDst += dstStride; } }
public static char[][] split( final char[] inputArray, final char split ) { char[][] results = new char[ 16 ][]; int resultIndex = 0; int startCurrentLineIndex = 0; int currentLineLength = 1; char c = 0; int index = 0; for (; index < inputArray.length; index++, currentLineLength++ ) { c = inputArray[ index ]; if ( c == split ) { if ( resultIndex == results.length ) { results = _grow( results ); } results[ resultIndex ] = Chr.copy( inputArray, startCurrentLineIndex, currentLineLength - 1 ); startCurrentLineIndex = index + 1; currentLineLength = 0; resultIndex++; } } if (c!=split) { if ( resultIndex == results.length ) { results = _grow( results ); } results[resultIndex] = Chr.copy( inputArray, startCurrentLineIndex, currentLineLength - 1); resultIndex++; } else if (index == inputArray.length) { } else { if ( resultIndex == results.length ) { results = _grow( results ); } results[ resultIndex ] = Chr.copy( inputArray, startCurrentLineIndex, inputArray.length - index - 1); resultIndex++; } int actualLength = resultIndex; if ( actualLength < results.length ) { final int newSize = results.length - actualLength; results = __shrink( results, newSize ); } return results; }
static <T> Function<T, T> composeAllViaAndThen(List<Function<T, T>> list) { return foldRight(list, identity(), x -> y -> y.andThen(x)); }
String cleanLinkId(String url, String linkId, boolean image) { String ret = linkId.replace('\n', ' '); ret = LINK_MULTIPLE_SPACES.matcher(ret).replaceAll(" "); ret = LINK_SAFE_CHARS.matcher(ret).replaceAll(LINK_REPLACEMENT); ret = LINK_MULTIPLE_REPLACE.matcher(ret).replaceAll(LINK_REPLACEMENT); ret = LINK_EDGE_REPLACE.matcher(ret).replaceAll(""); ret = ret.trim(); if(ret.length() == 0 || ret.equals(LINK_REPLACEMENT)) { if(image) { if(url != null) { Matcher m = LINK_FILENAME.matcher(url); if(m.find()) { ret = cleanLinkId(null, m.group(1), true); } else { genericImageUrlCounter++; ret = "Image " + genericImageUrlCounter; } } else { genericImageUrlCounter++; ret = "Image " + genericImageUrlCounter; } } else { genericLinkUrlCounter++; ret = "Link " + genericLinkUrlCounter; } } return ret; }
@JsonProperty("streamsProperties") public Map<String, Object> getConfigOverrides() { return coerceTypes(configOverrides); }
public IAtomContainer kekuliseAromaticRings(IAtomContainer molecule) throws CDKException { IAtomContainer mNew = null; try { mNew = (IAtomContainer) molecule.clone(); } catch (Exception e) { throw new CDKException("Failed to clone source molecule"); } IRingSet ringSet; try { ringSet = removeExtraRings(mNew); } catch (CDKException x) { throw x; } catch (Exception x) { throw new CDKException("failure in SSSRFinder.findAllRings", x); } if (ringSet == null) { throw new CDKException("failure in SSSRFinder.findAllRings"); } List<Integer[]> rBondsArray = null; List<List<Integer>> ringGroups = null; rBondsArray = getRingSystem(mNew, ringSet); ringGroups = assignRingGroups(rBondsArray); for (int i = 0; i < ringGroups.size(); i++) { setAllRingBondsSingleOrder(ringGroups.get(i), ringSet); List<Integer> atomNos = null; atomNos = getAtomNosForRingGroup(mNew, ringGroups.get(i), ringSet); List<Integer> bondNos = null; bondNos = getBondNosForRingGroup(mNew, ringGroups.get(i), ringSet); List<Integer[]> atomNoPairs = null; atomNoPairs = getAtomNoPairsForRingGroup(mNew, bondNos); Matrix M = new Matrix(atomNos.size(), bondNos.size()); for (int x = 0; x < M.getRows(); x++) { for (int y = 0; y < M.getCols(); y++) { if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[0])) { M.set(x, y, 1); } else { if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[1])) { M.set(x, y, 1); } else { M.set(x, y, 0); } } } } List<Integer> freeValencies = null; freeValencies = getFreeValenciesForRingGroup(mNew, atomNos, M, ringSet); List<Integer> bondOrders = new ArrayList<Integer>(); for (int j = 0; j < bondNos.size(); j++) { bondOrders.add(0); } if (solveMatrix(M, atomNos, bondNos, freeValencies, atomNoPairs, bondOrders)) { for (int j = 0; j < bondOrders.size(); j++) { mNew.getBond(bondNos.get(j)).setOrder( bondOrders.get(j) == 1 ? IBond.Order.SINGLE : IBond.Order.DOUBLE); } } else { } } return mNew; }
public static <T> ToShort<T> minus(ToByte<T> first, byte second) { return MinusUtil.byteMinusByte(first, second); }
@Override public String getName() { return name; }
public boolean isNormal(final Throwable t) { if (t == null) { return false; } final Class<?> root = Throwable.class; final Class<?> error = Error.class; for (Class<?> c = t.getClass(); c != root; c = c.getSuperclass()) { if (error.isAssignableFrom(c)) { if (c.getName().equals("java.lang.ThreadDeath")) { return true; } } else { if (c.getName().contains("Interrupt")) { return true; } } } return false; }
@Override protected void reduce(TAKey taKey, Iterable<L3TemporalBinWithIndex> bins, Context context) throws IOException, InterruptedException { final DateFormat dateFormat = DateUtils.createDateFormat(DATE_PATTERN); LOGGER.info("handling bins for " + taKey + " ..."); final TAConfig.RegionConfiguration region = regions[taKey.getRegionId()]; FileSystem fs = new Path(outputDirPath).getFileSystem(conf); int numFeatures = outputFeatureNames.size(); PrintWriter[] writers = new PrintWriter[numFeatures + 1]; StringBuffer[] lines = new StringBuffer[numFeatures + 1]; ArrayList<float[]> lineValuesList = new ArrayList<>(); Map<Long,Integer> columnOfBinIndexMap = new HashMap<>(); L3TemporalBin outputBin = null; long currentTime = -1; for (L3TemporalBinWithIndex bin : bins) { if (currentTime == -1) { currentTime = bin.getTime(); LOGGER.info("Handling first time step " + dateFormat.format(new Date(currentTime))); outputBin = (L3TemporalBin) binManager.createTemporalBin(-1); initialiseCsvWriting(fs, region, numFeatures, writers, lines); } else if (bin.getTime() != currentTime) { writeAggregatedRecord(context, region, dateFormat, currentTime, outputBin); outputBin = (L3TemporalBin) binManager.createTemporalBin(-1); final String timeString = dateFormat.format(new Date(currentTime)); writeCurrentLines(timeString, numFeatures, writers, lineValuesList); currentTime = bin.getTime(); LOGGER.info("Handling time step " + dateFormat.format(new Date(currentTime))); } final float[] values = getValueContainerForBinIndex(columnOfBinIndexMap, lineValuesList, numFeatures, bin.getIndex()); for (int i = 0; i < numFeatures; ++i) { values[i] = bin.getFeatureValues()[i]; } values[numFeatures] = bin.getNumObs(); binManager.aggregateTemporalBin(bin, outputBin); } writeCurrentLines(dateFormat.format(currentTime), numFeatures, writers, lineValuesList); if (currentTime != -1) { writeAggregatedRecord(context, region, dateFormat, currentTime, outputBin); for (int i = 0; i < numFeatures + 1; ++i) { writers[i].flush(); writers[i].close(); } } }
public static List<String> validateSqlQueryTabularInputs(String dbServerName, String dbType, String username, String password, String instance, String dbPort, String database, String authenticationType, String command, String trustAllRoots, String trustStore, String trustStorePassword, String timeout, String resultSetType, String resultSetConcurrency, String authLibraryPath) { final List<String> validationList = validateCommonSqlInputs(dbServerName, dbType, username, password, instance, dbPort, database, authenticationType, trustAllRoots, trustStore, trustStorePassword, resultSetType, resultSetConcurrency, authLibraryPath); validateNoneEmpty(command, INVALID_COMMAND, validationList); validateTimeout(timeout, validationList); return validationList; }
private void parseProperties() throws IOException { String line; stream.seek(0); propertiesByteSize = 0; long posInStream = 0l; while ((line = stream.readLine()) != null) { if (!line.startsWith("#")) { stream.seek(posInStream); break; } propertiesByteSize += (stream.getStreamPosition() - posInStream); posInStream = stream.getStreamPosition(); line = line.substring(1); int pos = line.indexOf('='); if (pos == -1) { throw new IOException("Missing '=' in '" + line + "'"); } String name = line.substring(0, pos).trim(); if (name.isEmpty()) { throw new IOException("Empty property name in '" + line + "'"); } String value = line.substring(pos + 1).trim(); try { if (contains(Constants.CRS_IDENTIFIERS, name) && crs != null) { crs = CRS.parseWKT(value); } } catch (FactoryException e) { throw new IOException(e); } properties.put(name, value); } propertiesParsed = true; }
@Override public Map<String, ActionItemCustomization> getActionListCustomizations(String principalId, List<ActionItem> actionItems) throws RiceIllegalArgumentException { if (StringUtils.isBlank(principalId)) { throw new RiceIllegalArgumentException("invalid principalId: " + principalId); } if (actionItems == null) { actionItems = Collections.emptyList(); } Map<String, ActionItemCustomization> results = new HashMap<String, ActionItemCustomization>(); ListMultimap<String, ActionItem> itemsByApplicationId = ArrayListMultimap.create(); for (ActionItem actionItem : actionItems) { DocumentType docType = getDocumentTypeService().findByName(actionItem.getDocName()); if (docType == null) { LOG.error(String.format("Action item %s has an invalid document type name of %s", actionItem.getId(), actionItem.getDocName())); itemsByApplicationId.put(null, actionItem); } else { itemsByApplicationId.put(getActionListCustomizationApplicationId(docType), actionItem); } } for (String applicationId : itemsByApplicationId.keySet()) { ActionListCustomizationHandlerService actionListCustomizationHandler = getActionListCustomizationHandlerServiceChooser().getByApplicationId(applicationId); if (actionListCustomizationHandler == null) { actionListCustomizationHandler = getActionListCustomizationHandlerServiceChooser().getByApplicationId(null); } List<ActionItemCustomization> customizations = actionListCustomizationHandler.customizeActionList(principalId, itemsByApplicationId.get( applicationId)); if (customizations != null) for (ActionItemCustomization customization : customizations) { results.put(customization.getActionItemId(), customization); } } return results; }
public void checkMetadata( RepositorySystemSession session, UpdateCheck<Metadata, MetadataTransferException> check ) { if ( check.getLocalLastUpdated() != 0 && !isUpdatedRequired( session, check.getLocalLastUpdated(), check.getPolicy() ) ) { LOGGER.debug( "Skipped remote request for {} locally installed metadata up-to-date", check.getItem() ); check.setRequired( false ); return; } Metadata metadata = check.getItem(); RemoteRepository repository = check.getRepository(); File metadataFile = requireNonNull( check.getFile(), String.format( "The metadata '%s' has no file attached", metadata ) ); boolean fileExists = check.isFileValid() && metadataFile.exists(); File touchFile = getTouchFile( metadata, metadataFile ); Properties props = read( touchFile ); String updateKey = getUpdateKey( session, metadataFile, repository ); String dataKey = getDataKey( metadata, metadataFile, check.getAuthoritativeRepository() ); String error = getError( props, dataKey ); long lastUpdated; if ( error == null ) { if ( fileExists ) { lastUpdated = getLastUpdated( props, dataKey ); } else { lastUpdated = 0L; } } else if ( error.length() <= 0 ) { lastUpdated = getLastUpdated( props, dataKey ); } else { String transferKey = getTransferKey( session, metadata, metadataFile, repository ); lastUpdated = getLastUpdated( props, transferKey ); } if ( lastUpdated == 0L ) { check.setRequired( true ); } else if ( isAlreadyUpdated( session, updateKey ) ) { LOGGER.debug( "Skipped remote request for {}, already updated during this session", check.getItem() ); check.setRequired( false ); if ( error != null ) { check.setException( newException( error, metadata, repository ) ); } } else if ( isUpdatedRequired( session, lastUpdated, check.getPolicy() ) ) { check.setRequired( true ); } else if ( fileExists ) { LOGGER.debug( "Skipped remote request for {}, locally cached metadata up-to-date", check.getItem() ); check.setRequired( false ); } else { int errorPolicy = Utils.getPolicy( session, metadata, repository ); int cacheFlag = getCacheFlag( error ); if ( ( errorPolicy & cacheFlag ) != 0 ) { check.setRequired( false ); check.setException( newException( error, metadata, repository ) ); } else { check.setRequired( true ); } } }
public static String substVars(String val, Map props1, Map props2, List<String> propsToHide) throws IllegalArgumentException { StringBuffer sbuf = new StringBuffer(); int i = 0; int j, k; while (true) { j = val.indexOf(DELIM_START, i); if (j == -1) { if (i == 0) { return val; } else { sbuf.append(val.substring(i, val.length())); return sbuf.toString(); } } else { sbuf.append(val.substring(i, j)); k = indexOfDelimStop(val, j); if (k == -1) { throw new IllegalArgumentException('[' + val + "] has no closing brace. Opening brace at position [" + j + "]"); } else { String expression = val.substring(j, k + DELIM_STOP_LEN); j += DELIM_START_LEN; String key = val.substring(j, k); if (key.contains(DELIM_START)) { key = substVars(key, props1, props2); } String replacement = getSystemProperty(key, null); if (replacement == null && props1 != null) { if (props1 instanceof Properties) { replacement = ((Properties) props1).getProperty(key); } else { Object replacementSource = props1.get(key); if (replacementSource != null) { replacement = replacementSource.toString(); } } } if (replacement == null && props2 != null) { if (props2 instanceof Properties) { replacement = ((Properties) props2).getProperty(key); } else { Object replacementSource = props2.get(key); if (replacementSource != null) { replacement = replacementSource.toString(); } } } if (replacement != null) { if (propsToHide != null && propsToHide.contains(key)) { replacement = Misc.hide(replacement); } if (!replacement.equals(expression)) { String recursiveReplacement = substVars(replacement, props1, props2); sbuf.append(recursiveReplacement); } else { sbuf.append(replacement); } } i = k + DELIM_STOP_LEN; } } } }
public int getRegister(final int reg) { return this.getRegister(reg, false); }
@Override public boolean hasChanged(@Nullable final Object context) { final T resolved = getTransformer.apply(inputDependency.get(context)); final int resolvedHash = resolved == null ? 0 : resolved.hashCode(); return resolvedHash != lastResolvedHash; }
int score() { throw new UnsupportedOperationException("Delete this statement and write your own implementation."); }
public static void newExecution() { MDC.clear(); threadLocal.get().setHeader(new RequestHeader()); }
public void onFieldUpdated(Field field) { if(isMarked(field)) setField(field); else clearField(field); }
@Nullable public static EpoxyModel<?> getModelFromPayload(List<Object> payloads, long modelId) { if (payloads.isEmpty()) { return null; } for (Object payload : payloads) { DiffPayload diffPayload = (DiffPayload) payload; if (diffPayload.singleModel != null) { if (diffPayload.singleModel.id() == modelId) { return diffPayload.singleModel; } } else { EpoxyModel<?> modelForId = diffPayload.modelsById.get(modelId); if (modelForId != null) { return modelForId; } } } return null; }
public final static String fileType(File file) { return FileTypeImpl.getFileType(file); }
protected Assignment createAssignmentObject(Experiment experiment, User.ID userID, Context context, boolean selectBucket, BucketList bucketList, Date date, SegmentationProfile segmentationProfile) { Assignment.Builder builder = Assignment.newInstance(experiment.getID()) .withExperimentLabel(getExperimentLabel(experiment.getID())) .withApplicationName(experiment.getApplicationName()) .withUserID(userID) .withContext(context); if (selectBucket) { Bucket assignedBucket; BucketList bucketsExternal = getBucketList(experiment, userID, segmentationProfile, !Objects.isNull(bucketList) ); if (Objects.isNull(bucketsExternal) || bucketsExternal.getBuckets().isEmpty()) { assignedBucket = selectBucket(bucketList.getBuckets()); } else { assignedBucket = selectBucket(bucketsExternal.getBuckets()); } if (!Objects.isNull(assignedBucket)) { builder.withBucketLabel(assignedBucket.getLabel()); builder.withPayload(getBucketPayload(experiment.getID(), nonNull(assignedBucket.getLabel()) ? assignedBucket.getLabel().toString() : null)); } else { return nullAssignment(userID, experiment.getApplicationName(), experiment.getID(), Assignment.Status.NO_OPEN_BUCKETS); } } else { builder.withBucketLabel(null); } Assignment result = builder .withStatus(Assignment.Status.NEW_ASSIGNMENT) .withCreated(Optional.ofNullable(date).orElseGet(Date::new)) .withCacheable(false) .build(); LOGGER.debug("result => {}", result); return result; }
@Override public AlarmResult filter(AlarmContext context, AlarmState state, AlarmStrategy strategy) throws PumaAlarmFilterException { if (!(strategy instanceof ExponentialAlarmStrategy)) { throw new PumaAlarmFilterUnsupportedException("unsupported alarm strategy[%s]", strategy); } ExponentialAlarmStrategy exponentialAlarmStrategy = (ExponentialAlarmStrategy) strategy; AlarmResult result = new AlarmResult(); String mnemonic = generateMnemonic( context.getNamespace(), context.getName(), state.getClass().getSimpleName()); if (!state.isAlarm()) { lastAlarmTimeMap.remove(mnemonic); nextAlarmIntervalMap.remove(mnemonic); result.setAlarm(false); } else { if (!lastAlarmTimeMap.containsKey(mnemonic)) { lastAlarmTimeMap.put(mnemonic, clock.getTimestamp()); long minExponentialAlarmIntervalInSecond = exponentialAlarmStrategy.getMinExponentialAlarmIntervalInSecond(); nextAlarmIntervalMap.put(mnemonic, minExponentialAlarmIntervalInSecond); result.setAlarm(true); } else { long nextAlarmInterval = nextAlarmIntervalMap.get(mnemonic); long lastAlarmTime = lastAlarmTimeMap.get(mnemonic); long now = clock.getTimestamp(); long duration = now - lastAlarmTime; long maxExponentialAlarmIntervalInSecond = exponentialAlarmStrategy.getMaxExponentialAlarmIntervalInSecond(); if (duration < nextAlarmInterval) { result.setAlarm(false); } else { lastAlarmTimeMap.put(mnemonic, clock.getTimestamp()); nextAlarmInterval = nextAlarmInterval << 1; nextAlarmInterval = (nextAlarmInterval > maxExponentialAlarmIntervalInSecond) ? maxExponentialAlarmIntervalInSecond : nextAlarmInterval; nextAlarmIntervalMap.put(mnemonic, nextAlarmInterval); result.setAlarm(true); } } } return result; }
public ProjectFeatureFlags listProjectFeatureFlags(final Project project) { notNull(project, "project"); try { final ProjectFeatureFlags projectFeatureFlags = restTemplate .getForObject(PROJECT_FEATURE_FLAGS_TEMPLATE.expand(project.getId()), ProjectFeatureFlags.class); if (projectFeatureFlags == null) { throw new GoodDataException("empty response from API call"); } return projectFeatureFlags; } catch (GoodDataException | RestClientException e) { throw new GoodDataException("Unable to list project feature flags for project ID=" + project.getId(), e); } }
public static void setScriptsExecutable( File fileOrDir ) { List<File> files = new ArrayList<> (); if( fileOrDir.isDirectory()) files.addAll( Utils.listAllFiles( fileOrDir, true )); else files.add( fileOrDir ); for( File f : files ) f.setExecutable( true ); }
public static void notNull(Object object, String message) { if (object == null) { throw new IllegalArgumentException(message); } }
@PostMapping(path = "/edit") public String submitDeclaration(UserResource loggedInUser, @Valid @ModelAttribute(FORM_ATTR_NAME) AssessorProfileDeclarationForm form, BindingResult bindingResult, ValidationHandler validationHandler) { Supplier<String> failureView = () -> getEditDeclaration(loggedInUser, form, bindingResult); validateLists(form, bindingResult); return validationHandler.failNowOrSucceedWith(failureView, () -> { ServiceResult<Void> updateResult = affiliationRestService.updateUserAffiliations(loggedInUser.getId(), populateAffiliationsFromForm(form)).toServiceResult(); return validationHandler.addAnyErrors(updateResult, fieldErrorsToFieldErrors(), asGlobalErrors()) .failNowOrSucceedWith(failureView, () -> "redirect:/profile/declaration"); }); }
static String formatForUrl(LdapName ldapName) { StringBuilder sb = new StringBuilder(); ListIterator<Rdn> it = ldapName.getRdns().listIterator(ldapName.size()); while (it.hasPrevious()) { Rdn component = it.previous(); Attributes attributes = component.toAttributes(); NamingEnumeration<? extends Attribute> allAttributes = attributes.getAll(); while(allAttributes.hasMoreElements()) { Attribute oneAttribute = allAttributes.nextElement(); String encodedAttributeName = nameEncodeForUrl(oneAttribute.getID()); NamingEnumeration <?> allValues; try { allValues = oneAttribute.getAll(); } catch (NamingException e) { throw new UncategorizedLdapException("Unexpected error occurred formatting base URL", e); } while(allValues.hasMoreElements()) { sb.append(encodedAttributeName).append('='); Object oneValue = allValues.nextElement(); if (oneValue instanceof String) { String oneString = (String) oneValue; sb.append(nameEncodeForUrl(oneString)); } else { throw new IllegalArgumentException("Binary attributes not supported for base URL"); } if(allValues.hasMoreElements()) { sb.append('+'); } } if(allAttributes.hasMoreElements()) { sb.append('+'); } } if(it.hasPrevious()) { sb.append(','); } } return sb.toString(); }
@Override public String toString() { return compiledJavaccFile.getAbsolutePath(); }
public static String getQualifiedName( Function<String, String> quoteFunction, String catalogName, String schemaName, String simpleName) { assertNotNull(quoteFunction, simpleName); StringBuilder buf = new StringBuilder(); if (catalogName != null && !catalogName.isEmpty()) { buf.append(quoteFunction.apply(catalogName)).append("."); } if (schemaName != null && !schemaName.isEmpty()) { buf.append(quoteFunction.apply(schemaName)).append("."); } return buf.append(quoteFunction.apply(simpleName)).toString(); }
@Override public Object execute(Object[] arguments) { if (arguments == null) { throw new NativeContractIllegalArgumentException(String.format(INVALID_EXTENDED_PUBLIC_KEY, null)); } String xpub = (String) arguments[0]; NetworkParameters params = helper.validateAndExtractNetworkFromExtendedPublicKey(xpub); DeterministicKey key; try { key = DeterministicKey.deserializeB58(xpub, params); } catch (IllegalArgumentException e) { throw new NativeContractIllegalArgumentException(String.format(INVALID_EXTENDED_PUBLIC_KEY, xpub), e); } return key.getPubKeyPoint().getEncoded(true); }
@Override public DOMEntityOwnershipCandidateRegistration registerCandidate(final DOMEntity entity) throws CandidateAlreadyRegisteredException { synchronized (entities) { final DOMEntity prev = entities.get(entity.getType(), entity.getIdentifier()); if (prev != null) { throw new CandidateAlreadyRegisteredException(prev); } entities.put(entity.getType(), entity.getIdentifier(), entity); LOG.debug("{}: registered candidate {}", uuid, entity); } notifyListeners(entity, LOCAL_OWNERSHIP_GRANTED); return new EntityRegistration(entity); }
public FindEdgeResult findNearestEdge(PointD q) { final SubdivisionFace face = findFace(q); return face.findNearestEdge(q); }
@Override public long getLongLE(int index) { checkIndex(index, 8); return _getLongLE(index); }
public Product createProduct(ProductDTO dto, Owner owner) { if (dto == null) { throw new IllegalArgumentException("dto is null"); } if (owner == null) { throw new IllegalArgumentException("owner is null"); } if (dto.getId() == null || dto.getName() == null) { throw new IllegalArgumentException("dto is incomplete"); } if (this.ownerProductCurator.productExists(owner, dto.getId())) { throw new IllegalStateException("product has already been created: " + dto.getId()); } Product entity = new Product(dto.getId(), dto.getName()); this.applyProductChanges(entity, dto, owner); log.debug("Creating new product for org: {}, {}", entity, owner); List<Product> alternateVersions = this.ownerProductCurator.getProductsByVersions( owner, Collections.singletonMap(entity.getId(), entity.getEntityVersion())) .list(); for (Product alt : alternateVersions) { if (alt.equals(entity)) { this.ownerProductCurator.mapProductToOwner(alt, owner); return alt; } } entity = this.productCurator.create(entity); this.ownerProductCurator.mapProductToOwner(entity, owner); return entity; }
public void setZero(int index, int length) { if (length == 0) { return; } if (length < 0) { throw new IllegalArgumentException( "length must be 0 or greater than 0."); } int nLong = length >>> 3; int nBytes = length & 7; for (int i = nLong; i > 0; i --) { setLong(index, 0); index += 8; } if (nBytes == 4) { setInt(index, 0); } else if (nBytes < 4) { for (int i = nBytes; i > 0; i --) { setByte(index, (byte) 0); index ++; } } else { setInt(index, 0); index += 4; for (int i = nBytes - 4; i > 0; i --) { setByte(index, (byte) 0); index ++; } } }
@Override public MessageList displayMessages(MessageList messages) { MessageList messagesForProperty = getRelevantMessages(messages); componentWrapper.setValidationMessages(messagesForProperty); return messagesForProperty; }
public static <T> Optional<T> of(T object) { return new PresentOptional<T>(checkNotNull(object, "value must not be null")); }
@Override public void validate(final PreferenceScope scope) throws InvalidPreferenceScopeException { if (scope == null) { throw new InvalidPreferenceScopeException("A root scope must not be null."); } for (PreferenceScope currentScope = scope; currentScope != null; currentScope = currentScope.childScope()) { final String type = currentScope.type(); final String key = currentScope.key(); if (scopeTypes.typeRequiresKey(type) && isEmpty(key)) { throw new InvalidPreferenceScopeException("The type " + type + " must be associated with a non empty key."); } } if (!scopeResolutionStrategy.getInfo().order().contains(scope)) { throw new InvalidPreferenceScopeException("This scope is not defined in the scope hierarchy."); } }
@Override public void notify(BindingDescriptor bindingDescriptor) { if (bindingDescriptor.getServiceProtocol().underlyingTransportIsHttp()) { serviceBindingDescriptors.add((HttpServiceBindingDescriptor) bindingDescriptor); registerHandler((HttpServiceBindingDescriptor) bindingDescriptor); } }
public static DataGetter dataGetterForURI(VitroRequest vreq, Model displayModel, String dataGetterURI) throws InstantiationException, IllegalAccessException, ClassNotFoundException, IllegalArgumentException, InvocationTargetException, SecurityException { String dgClassName = getJClassForDataGetterURI(displayModel, dataGetterURI); Class<?> clz = Class.forName(dgClassName); if( ! DataGetter.class.isAssignableFrom(clz) ){ log.debug("Class doesn't implement DataGetter: '" + dgClassName + "'"); return null; } Object[][] argLists = new Object[][] { { vreq, displayModel, dataGetterURI }, { displayModel, dataGetterURI }, { vreq }, {} }; for (Object[] argList: argLists) { for (Constructor<?> ct: clz.getConstructors()) { if (isConstructorSuitableForArguments(ct, argList)) { log.debug("Using this constructor: " + ct); return (DataGetter) ct.newInstance(argList); } } } log.debug("Didn't find a suitable constructor for '" + dgClassName + "'"); return null; }
public static final GeometryDatatype get(RDFDatatype rdfDatatype) throws DatatypeFormatException { if (rdfDatatype instanceof GeometryDatatype) { return (GeometryDatatype) rdfDatatype; } else { throw new DatatypeFormatException("Unrecognised Geometry Datatype: " + rdfDatatype.getURI() + " Ensure that Datatype is extending GeometryDatatype."); } }
@Override public int hashCode() { int hashCode = 37; for (int i = 0; i < values.length; i++) { Datum d = get(i); if (d != null) { hashCode ^= (d.hashCode() * 41); } else { hashCode = hashCode ^ (i + 17); } } return hashCode; }
@Override public Multimap<String,String> flatten(JsonObject object) throws IllegalStateException { Multimap<String,String> map = HashMultimap.create(); flatten(object, map); return map; }
public Principal getPrincipal(HandshakeRequest handshakeRequest) { if (null != handshakeRequest && handshakeRequest.getUserPrincipal() != null) { return handshakeRequest.getUserPrincipal(); } else { return ANONYMOUS; } }
public static Row append(Row row, Object value) { Object[] appendedValues = ObjectArrays.concat(valuesFor(row), value); Row appendedRow = RowFactory.create(appendedValues); return appendedRow; }
public void setFilterBy(String[] list) { if (list != null) { for (String s : list) { filterBy.put(s, null); } } }
public static void removeEntities(Reader reader, Writer writer) throws IOException { int curChar = -1; StringBuffer ent = null; if (reader == null) { throw new IllegalArgumentException("null reader arg"); } else if (writer == null) { throw new IllegalArgumentException("null writer arg"); } ent = new StringBuffer(50); while ((curChar = reader.read()) != -1) { if (curChar == '&') { if (ent.length() > 0) { writer.write(ent.toString()); ent.setLength(0); } ent.append((char) curChar); } else if (curChar == ';' && ent.length() > 0) { int entLen = ent.length(); if (entLen > 1) { if (ent.charAt(1) == '#') { if (entLen > 2) { char char2 = ent.charAt(2); try { if (char2 == 'x' || char2 == 'X') { if (entLen > 3) { writer.write(Integer.parseInt(ent .substring(3), 16)); } else { writer.write(ent.toString()); writer.write(curChar); } } else { writer.write(Integer.parseInt(ent .substring(2))); } } catch (NumberFormatException nfe) { writer.write(ent.toString()); writer.write(curChar); } } else { writer.write("&#;"); } } else { Character character = HTMLEntityLookup .getCharacterCode(ent.substring(1)); if (character != null) { writer.write(character.charValue()); } else { writer.write(ent.toString()); writer.write(curChar); } } } else { writer.write("&;"); } ent.setLength(0); } else if (ent.length() > 0) { ent.append((char) curChar); } else { writer.write(curChar); } } if (ent.length() > 0) { writer.write(ent.toString()); } }
protected void drawSeries(Canvas canvas, RectF plotArea, XYSeries series, LineAndPointFormatter formatter) { PointF thisPoint; PointF lastPoint = null; PointF firstPoint = null; path.reset(); final List<PointF> points = getPointsCache(series); int iStart = 0; int iEnd = series.size(); if(SeriesUtils.getXYOrder(series) == OrderedXYSeries.XOrder.ASCENDING) { final Region iBounds = SeriesUtils.iBounds(series, getPlot().getBounds()); iStart = iBounds.getMin().intValue(); if(iStart > 0) { iStart--; } iEnd = iBounds.getMax().intValue() + 1; if(iEnd < series.size() - 1) { iEnd++; } } for (int i = iStart; i < iEnd; i++) { final Number y = series.getY(i); final Number x = series.getX(i); PointF iPoint = points.get(i); if (y != null && x != null) { if(iPoint == null) { iPoint = new PointF(); points.set(i, iPoint); } thisPoint = iPoint; getPlot().getBounds().transformScreen(thisPoint, x, y, plotArea); } else { thisPoint = null; iPoint = null; points.set(i, iPoint); } if(formatter.hasLinePaint() && formatter.getInterpolationParams() == null) { if (thisPoint != null) { if (firstPoint == null) { path.reset(); firstPoint = thisPoint; path.moveTo(firstPoint.x, firstPoint.y); } if (lastPoint != null) { appendToPath(path, thisPoint, lastPoint); } lastPoint = thisPoint; } else { if (lastPoint != null) { renderPath(canvas, plotArea, path, firstPoint, lastPoint, formatter); } firstPoint = null; lastPoint = null; } } } if(formatter.hasLinePaint()) { if(formatter.getInterpolationParams() != null) { List<XYCoords> interpolatedPoints = getInterpolator( formatter.getInterpolationParams()).interpolate(series, formatter.getInterpolationParams()); firstPoint = convertPoint(interpolatedPoints.get(ZERO), plotArea); lastPoint = convertPoint(interpolatedPoints.get(interpolatedPoints.size()-ONE), plotArea); path.reset(); path.moveTo(firstPoint.x, firstPoint.y); for(int i = 1; i < interpolatedPoints.size(); i++) { thisPoint = convertPoint(interpolatedPoints.get(i), plotArea); path.lineTo(thisPoint.x, thisPoint.y); } } if(firstPoint != null) { renderPath(canvas, plotArea, path, firstPoint, lastPoint, formatter); } } renderPoints(canvas, plotArea, series, iStart, iEnd, points, formatter); }
public GeneMatch getClosestPhenoMatchInNetwork(Integer entrezGeneId) { if (!dataMatrix.containsGene(entrezGeneId) || weightedHighQualityMatrixIndex.isEmpty()) { return GeneMatch.NO_HIT; } int rowIndex = dataMatrix.getRowIndexForGene(entrezGeneId); GeneColumnIndex topHighQualityGene = getGeneColumnIndexOfMostPhenotypicallySimilarGene(rowIndex, entrezGeneId); if (topHighQualityGene == null) { return GeneMatch.NO_HIT; } double walkerScore = 0.5 + weightedHighQualityMatrix.get(rowIndex, topHighQualityGene.columnIndex); Integer closestGeneId = topHighQualityGene.geneId; List<GeneModelPhenotypeMatch> models = bestGeneModels.get(closestGeneId); return GeneMatch.builder() .queryGeneId(entrezGeneId) .matchGeneId(closestGeneId) .score(walkerScore) .bestMatchModels(models) .build(); }
public boolean isDerivedFrom( String[] testTypeNames, String primaryTypeName, String[] mixinNames ) throws RepositoryException { CheckArg.isNotEmpty(testTypeNames, "testTypeNames"); CheckArg.isNotEmpty(primaryTypeName, "primaryTypeName"); NameFactory nameFactory = context().getValueFactories().getNameFactory(); Name[] typeNames = nameFactory.create(testTypeNames); for (Name typeName : typeNames) { JcrNodeType nodeType = getNodeType(typeName); if ((nodeType != null) && nodeType.isNodeType(primaryTypeName)) { return true; } } if (mixinNames != null) { for (String mixin : mixinNames) { for (Name typeName : typeNames) { JcrNodeType nodeType = getNodeType(typeName); if ((nodeType != null) && nodeType.isNodeType(mixin)) { return true; } } } } return false; }
Pool[] getPools() { return Arrays.copyOf(pools, pools.length); }
public List<XmlCalendar> getCalendars() { if (calendar == null) { calendar = new ArrayList<>(); } return this.calendar; }
public Converter<T> resolveConverter(Object object) { if(object == null) { return null; } Class<?> clazz; if(object instanceof Class) { clazz = (Class<?>) object; } else { clazz = object.getClass(); } synchronized(converterMap) { Converter<T> converter = converterMap.get(clazz); if(converter != null) { return converter; } for(Map.Entry<Class<?>, Converter<T>> current : converterMap.entrySet()) { Class<?> key = current.getKey(); if(key.isAssignableFrom(clazz)) { return current.getValue(); } } return null; } }
public void setIsOpaqueCapable(boolean isOpaqueCapable) { this.isOpaqueCapable = isOpaqueCapable; }
@Override public void focus(String componentId) { FacesContext context = FacesContext.getCurrentInstance(); if (context == null) { throw new IllegalStateException(FocusManager.class.getSimpleName() + " can't be used without FacesContext available"); } if (componentId == null) { setContextAttribute(context, null); } else { UIComponent currentComponent = UIComponent.getCurrentComponent(context); if (currentComponent == null) { currentComponent = context.getViewRoot(); } Pattern rowPattern = Pattern.compile(ROW_PATTERN); Matcher rowMatcher = rowPattern.matcher(componentId); String newId = componentId; if (rowMatcher.matches()) { newId = rowMatcher.group(2); newId = newId.replaceAll(ROW_ID, String.valueOf(SeparatorChar.SEPARATOR_CHAR)); } UIComponent component = RendererUtils.getInstance().findComponentFor(currentComponent, newId); if (component == null) { logNotFound(context, componentId); } else { String clientId = component.getClientId(context); if (rowMatcher.matches()) { int end = clientId.lastIndexOf(SeparatorChar.SEPARATOR_CHAR + newId); if (end != -1) { clientId = clientId.substring(0, end) + componentId; } else { logNotFound(context, componentId); return; } } setContextAttribute(context, clientId); JavaScriptService javaScriptService = ServiceTracker.getService(context, JavaScriptService.class); javaScriptService.addPageReadyScript(context, new JSLiteral(String.format(SCRIPT, clientId))); } } }
public static void createClusterwithAutoscaling() throws IOException, InterruptedException { String projectId = "your-project-id"; String region = "your-project-region"; String clusterName = "your-cluster-name"; String autoscalingPolicyName = "your-autoscaling-policy"; createClusterwithAutoscaling(projectId, region, clusterName, autoscalingPolicyName); }
@NotNull public SceneImpl visualizeDelta(ObjectDelta<? extends ObjectType> objectDelta, Task task, OperationResult parentResult) throws SchemaException, ExpressionEvaluationException { OperationResult result = parentResult.createSubresult(CLASS_DOT + "visualizeDelta"); try { resolver.resolve(objectDelta, task, result); return visualizeDelta(objectDelta, null, new VisualizationContext(), task, result); } catch (RuntimeException | Error | SchemaException | ExpressionEvaluationException e) { result.recordFatalError("Couldn't visualize the data structure: " + e.getMessage(), e); throw e; } finally { result.computeStatusIfUnknown(); } }
public FxRate forwardFxRate(ResolvedFxSingle fx, RatesProvider provider) { FxForwardRates fxForwardRates = provider.fxForwardRates(fx.getCurrencyPair()); Payment basePayment = fx.getBaseCurrencyPayment(); Payment counterPayment = fx.getCounterCurrencyPayment(); double forwardRate = fxForwardRates.rate(basePayment.getCurrency(), fx.getPaymentDate()); return FxRate.of(basePayment.getCurrency(), counterPayment.getCurrency(), forwardRate); }
public Iterable<T> iterable() { return new ResourceCollectionIterable<>(this); }
public static CardinalityPusher createFor(OperatorContainer container, Configuration configuration) { final CompositeOperator compositeOperator = container.toOperator(); final InputSlot<?>[] outerInputs = compositeOperator.getAllInputs(); final List<InputSlot<?>> innerInputs = Arrays.stream(outerInputs) .flatMap(inputSlot -> container.followInput(inputSlot).stream()) .collect(Collectors.toList()); final Collection<Operator> sourceOperators = compositeOperator.isSource() ? Collections.singleton(container.getSource()) : Collections.emptySet(); final CardinalityEstimationTraversal traversal = CardinalityEstimationTraversal.createPushTraversal( innerInputs, sourceOperators, configuration); return new SubplanCardinalityPusher(traversal, compositeOperator); }
public Integer totalRecordCount(Integer processTypeId) { Session session = sessionFactory.openSession(); session.beginTransaction(); Integer size; if (processTypeId == null) { Criteria parentProcessTypeCriteria = session.createCriteria(ProcessType.class).add(Restrictions.isNull(PARENTPROCESSTYPEID)); size = parentProcessTypeCriteria.list().size(); } else { Criteria processTypeCriteria = session.createCriteria(ProcessType.class).add(Restrictions.eq(PARENTPROCESSTYPEID, processTypeId)); size = processTypeCriteria.list().size(); } session.getTransaction().commit(); session.close(); return size; }
public long getSubqueryBitmap() { return subqueryBitmap; }
@VisibleForTesting protected static boolean isContentTypeCompatible( final MediaType responseContentType) { if (responseContentType == null || responseContentType.isWildcardType() || responseContentType.isWildcardSubtype()) { return true; } if (MediaType.TEXT_PLAIN_TYPE.isCompatible(responseContentType)) { return true; } Matcher matcher = VALID_TYPES_REGEX.matcher(responseContentType.toString()); return matcher.matches(); }
@GetMapping("/find") public String find(Model model, @ModelAttribute(name = SELECTION_FORM, binding = false) ReviewSelectionForm selectionForm, @SuppressWarnings("unused") BindingResult bindingResult, @PathVariable("competitionId") long competitionId, @RequestParam(defaultValue = "0") int page, HttpServletRequest request, HttpServletResponse response) { updateSelectionForm(request, response, competitionId, selectionForm); ReviewInviteAssessorsFindViewModel reviewInviteAssessorsFindViewModel = panelInviteAssessorsFindModelPopulator.populateModel(competitionId, page); model.addAttribute("model", reviewInviteAssessorsFindViewModel); return "assessors/panel-find"; }
@Override public String getDescription( Locale locale ) { return DESCRIPTION; }
@Override public Iterable<Tag> httpRequestTags(RequestEvent event) { ContainerResponse response = event.getContainerResponse(); return Tags.of(JerseyTags.method(event.getContainerRequest()), JerseyTags.uri(event), JerseyTags.exception(event), JerseyTags.status(response), JerseyTags.outcome(response)); }
public static double vomma( double spot, double strike, double timeToExpiry, double lognormalVol, double interestRate, double costOfCarry) { ArgChecker.isTrue(spot >= 0d, "negative/NaN spot; have {}", spot); ArgChecker.isTrue(strike >= 0d, "negative/NaN strike; have {}", strike); ArgChecker.isTrue(timeToExpiry >= 0d, "negative/NaN timeToExpiry; have {}", timeToExpiry); ArgChecker.isTrue(lognormalVol >= 0d, "negative/NaN lognormalVol; have {}", lognormalVol); ArgChecker.isFalse(Double.isNaN(interestRate), "interestRate is NaN"); ArgChecker.isFalse(Double.isNaN(costOfCarry), "costOfCarry is NaN"); double rootT = Math.sqrt(timeToExpiry); double sigmaRootT = lognormalVol * rootT; if (Double.isNaN(sigmaRootT)) { sigmaRootT = 1d; } if (spot > LARGE * strike || strike > LARGE * spot || rootT < SMALL) { return 0d; } double d1 = 0d; double d1d2Mod = 0d; if (Math.abs(spot - strike) < SMALL || (spot > LARGE && strike > LARGE) || rootT > LARGE) { double costOvVol = (Math.abs(costOfCarry) < SMALL && lognormalVol < SMALL) ? Math.signum(costOfCarry) : costOfCarry / lognormalVol; double coefD1 = costOvVol + 0.5 * lognormalVol; double coefD1D2Mod = costOvVol * costOvVol / lognormalVol - 0.25 * lognormalVol; double tmpD1 = coefD1 * rootT; double tmpD1d2Mod = coefD1D2Mod * rootT * timeToExpiry; d1 = Double.isNaN(tmpD1) ? 0d : tmpD1; d1d2Mod = Double.isNaN(tmpD1d2Mod) ? 1d : tmpD1d2Mod; } else { if (lognormalVol > LARGE) { d1 = 0.5 * sigmaRootT; d1d2Mod = -0.25 * sigmaRootT * timeToExpiry; } else { if (lognormalVol < SMALL) { double d1Tmp = (Math.log(spot / strike) / rootT + costOfCarry * rootT) / lognormalVol; d1 = Double.isNaN(d1Tmp) ? 1d : d1Tmp; d1d2Mod = d1 * d1 * rootT / lognormalVol; } else { double tmp = Math.log(spot / strike) / sigmaRootT + costOfCarry * rootT / lognormalVol; d1 = tmp + 0.5 * sigmaRootT; d1d2Mod = (tmp * tmp - 0.25 * sigmaRootT * sigmaRootT) * rootT / lognormalVol; } } } double coef = 0d; if ((interestRate > LARGE && costOfCarry > LARGE) || (-interestRate > LARGE && -costOfCarry > LARGE) || Math.abs(costOfCarry - interestRate) < SMALL) { coef = 1d; } else { double rate = costOfCarry - interestRate; if (rate > LARGE) { return costOfCarry > LARGE ? 0d : (d1d2Mod >= 0d ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY); } if (-rate > LARGE) { return 0d; } coef = Math.exp(rate * timeToExpiry); } double norm = NORMAL.getPDF(d1); double tmp = d1d2Mod * spot * coef; if (Double.isNaN(tmp)) { tmp = coef; } return norm < SMALL ? 0d : norm * tmp; }
public static Stream<BigFloat> rangeClosed(BigFloat startInclusive, BigFloat endInclusive, BigFloat step) { if (step.isZero()) { throw new IllegalArgumentException("invalid step: 0"); } if (endInclusive.subtract(startInclusive).signum() == -step.signum()) { return Stream.empty(); } return StreamSupport.stream(new BigFloatSpliterator(startInclusive, endInclusive, true, step), false); }
public void refresh() { logger.debug("Synchronization #{} started at {}", counter.incrementAndGet(), Instant.now().toString()); logger.debug("Refreshing gateway state..."); long nextLastRefreshAt = System.currentTimeMillis(); try { synchronizeApis(nextLastRefreshAt); } catch (Exception ex) { logger.error("An error occurs while synchronizing APIs", ex); } try { synchronizeDictionaries(nextLastRefreshAt); } catch (Exception ex) { logger.error("An error occurs while synchronizing dictionaries", ex); } lastRefreshAt = nextLastRefreshAt; logger.debug("Synchronization #{} ended at {}", counter.get(), Instant.now().toString()); }
public Optional<Template> template(String path) { return template(path, false); }
@Override public Short convert(String value) { if (isValid(value)) { try { return Short.valueOf(value); } catch (NumberFormatException e) { return null; } } return null; }
public static String getUrlFromArgs(String[] args) { if (args == null || args.length < 1) { throw new IllegalArgumentException("Collector URL is required"); } return args[0]; }
@Override <T> T loadEntity(LoadingParameters<T> loadingParameters) { final EntityTypeImpl<T> rootEt = metamodel.entity(loadingParameters.getEntityType()); try { final EntityType<? extends T> et = resolveEntityType(loadingParameters, rootEt); if (et == null) { return null; } return loadInstance(loadingParameters, et); } catch (OntoDriverException e) { throw new StorageAccessException(e); } }
@SuppressWarnings( { "unchecked", "rawtypes" } ) public static ObjectMapper createObjectMapper() { ObjectMapper mapper = new ObjectMapper(); mapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false ); SimpleModule module = new SimpleModule( "RoboconfModule", new Version( 1, 0, 0, null, null, null )); for( Map.Entry<Class<?>,? super JsonSerializer<?>> entry : SERIALIZERS.entrySet()) module.addSerializer((Class) entry.getKey(), (JsonSerializer) entry.getValue()); for( Map.Entry<Class<?>,? super JsonDeserializer<?>> entry : DESERIALIZERS.entrySet()) module.addDeserializer((Class) entry.getKey(), (JsonDeserializer) entry.getValue()); mapper.registerModule( module ); return mapper; }
public static Class<?> getGenericClass(Class<?> cls) { return getGenericClass(cls, 0); }
public static LegacyEndpointConverter env() { return new LegacyEndpointConverter(Endpoint.ENV, convertUsing(RESPONSE_TYPE_MAP, RESPONSE_TYPE_MAP, LegacyEndpointConverters::convertEnv)); }
protected void doHandleSimpleMultipartFileUpload(VaadinSession session, VaadinRequest request, VaadinResponse response, StreamVariable streamVariable, String variableName, ClientConnector owner, String boundary) throws IOException { final InputStream inputStream = request.getInputStream(); long contentLength = getContentLength(request); boolean atStart = false; boolean firstFileFieldFound = false; String rawfilename = "unknown"; String rawMimeType = "application/octet-stream"; while (!atStart) { String readLine = readLine(inputStream); contentLength -= (readLine.getBytes(UTF_8).length + CRLF.length()); if (readLine.startsWith("Content-Disposition:") && readLine.indexOf("filename=") > 0) { rawfilename = readLine.replaceAll(".*filename=", ""); char quote = rawfilename.charAt(0); rawfilename = rawfilename.substring(1); rawfilename = rawfilename.substring(0, rawfilename.indexOf(quote)); firstFileFieldFound = true; } else if (firstFileFieldFound && readLine.isEmpty()) { atStart = true; } else if (readLine.startsWith("Content-Type")) { rawMimeType = readLine.split(": ")[1]; } } contentLength -= (boundary.length() + CRLF.length() + 2 * DASHDASH.length() + CRLF.length()); InputStream simpleMultiPartReader = new SimpleMultiPartInputStream( inputStream, boundary); final String filename = removePath(rawfilename); final String mimeType = rawMimeType; try { handleFileUploadValidationAndData(session, simpleMultiPartReader, streamVariable, filename, mimeType, contentLength, owner, variableName); } catch (UploadException e) { session.getCommunicationManager() .handleConnectorRelatedException(owner, e); } sendUploadResponse(request, response); }
@Override public void check(String sourceContent, String targetContent) throws TrailingWhitespaceIntegrityCheckerException { logger.debug("Get trailing whitespaces of the target"); String sourceTrailingWhiteSpaces = getTrailingWhiteSpaces(sourceContent); logger.debug("Source trailing whitespaces: {}", sourceTrailingWhiteSpaces); logger.debug("Get trailing whitespaces of the source"); String targetTrailingWhiteSpaces = getTrailingWhiteSpaces(targetContent); logger.debug("Target trailing whitespaces: {}", targetTrailingWhiteSpaces); logger.debug("Make sure the target has the same trailing whitespaces as the source"); if (!StringUtils.equals(sourceTrailingWhiteSpaces, targetTrailingWhiteSpaces)) { throw new TrailingWhitespaceIntegrityCheckerException("Trailing whitespaces in source and target are different"); } }
@Override public Map<ApplicationId, ApplicationReport> getAllApplications() throws YarnException, IOException { TimelineEntities entities = timelineDataManager.getEntities( ApplicationMetricsConstants.ENTITY_TYPE, null, null, null, null, null, null, Long.MAX_VALUE, EnumSet.allOf(Field.class), UserGroupInformation.getLoginUser()); Map<ApplicationId, ApplicationReport> apps = new LinkedHashMap<ApplicationId, ApplicationReport>(); if (entities != null && entities.getEntities() != null) { for (TimelineEntity entity : entities.getEntities()) { try { ApplicationReportExt app = generateApplicationReport(entity, ApplicationReportField.ALL); apps.put(app.appReport.getApplicationId(), app.appReport); } catch (Exception e) { LOG.error("Error on generating application report for " + entity.getEntityId(), e); } } } return apps; }
@Override public Object invoke( MethodInvocation invocation) throws Throwable, ResultMessagesNotificationException { if (startingPoint.get() == null) { startingPoint.set(invocation); } try { return invocation.proceed(); } catch (ResultMessagesNotificationException e) { if (isStartingPoint(invocation)) { logResultMessagesNotificationException(e); } throw e; } finally { if (isStartingPoint(invocation)) { startingPoint.remove(); } } }
public ListenableFuture<BufferResult> getPages(long sequenceId, DataSize maxSize) { return getPages(sequenceId, maxSize, Optional.empty()); }
public static MediaType parse(String input) { checkNotNull(input); final MediaType wellKnown = KnownTypesByString.get(input); if (wellKnown != null) { return wellKnown; } Tokenizer tokenizer = new Tokenizer(input); try { String type = tokenizer.consumeToken(TOKEN_MATCHER); tokenizer.consumeCharacter('/'); String subtype = tokenizer.consumeToken(TOKEN_MATCHER); ImmutableListMultimap.Builder<String, String> parameters = ImmutableListMultimap.builder(); while (tokenizer.hasMore()) { tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE); tokenizer.consumeCharacter(';'); tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE); String attribute = tokenizer.consumeToken(TOKEN_MATCHER); tokenizer.consumeCharacter('='); final String value; if ('"' == tokenizer.previewChar()) { tokenizer.consumeCharacter('"'); StringBuilder valueBuilder = new StringBuilder(); while ('"' != tokenizer.previewChar()) { if ('\\' == tokenizer.previewChar()) { tokenizer.consumeCharacter('\\'); valueBuilder.append(tokenizer.consumeCharacter(ascii())); } else { valueBuilder.append(tokenizer.consumeToken(QUOTED_TEXT_MATCHER)); } } value = valueBuilder.toString(); tokenizer.consumeCharacter('"'); } else { value = tokenizer.consumeToken(TOKEN_MATCHER); } parameters.put(attribute, value); } return create(type, subtype, parameters.build()); } catch (IllegalStateException e) { throw new IllegalArgumentException("Could not parse '" + input + '\'', e); } }
private void registerService(ServiceReference<?> ref) { final String[] serviceInterfaceNames = (String[]) ref.getProperty(Constants.OBJECTCLASS); Arrays.stream(serviceInterfaceNames).forEach(serviceInterfaceName -> { try { final Class<?> serviceInterface = ref.getBundle().loadClass(serviceInterfaceName); if (serviceInterface.isAnnotationPresent(Path.class)) { final Long serviceId = serviceId(ref); final Object serviceImplementation = bundleContext.getService(ref); final DefaultServerDefinition definition = new DefaultServerDefinition(serviceId.toString(), serviceInterface, serviceImplementation); serverListeners.forEach(listener -> listener.registerServer(definition)); } } catch (ClassNotFoundException e) { LOGGER.error("Unable to load service interface from target bundle!", e); } }); }
@Override public ConstrainedAgEntity<T> apply(AgEntity<T> agEntity) { return op.apply(new ConstrainedAgEntity<T>(agEntity)); }
@Override public void createResource(Request request) throws InvalidPayloadException, ResourceAlreadyExistsException, ResourceNotFoundException { String entityId = String.valueOf(request.getQueryProperties().remove("id")); resourceDefinition.validateCreatePayload(request); Result termResult = getTermQueryResult(request.<String>getProperty("name")); Map<String, Object> termProperties = termResult.getPropertyMaps().iterator().next(); if (String.valueOf(termProperties.get("available_as_tag")).equals("false")) { throw new InvalidPayloadException( "Attempted to tag an entity with a term which is not available to be tagged"); } tagEntities(Collections.singleton(entityId), termProperties); }
public static void ensureIndexAndTypeForAnnotation(Annotation annotation, Boolean createIndexIfNotFound) throws Exception { String esUrl = getEsUrl(); if(Strings.isNullOrEmpty(esUrl)){ throw new Exception("ES host cannot be null"); } String indexName = buildIndexNameFromAnnotation(annotation); if (!Strings.isNullOrEmpty(indexName)) { indexName = indexName.toLowerCase(); } else throw new Exception("Index/datasource/pac_ds name cannot be null or blank"); if (!isValidIndex(esUrl, indexName)) { throw new Exception("Index is not yet ready to publish the data"); } String parentType, type; if (!Strings.isNullOrEmpty(annotation.get(PacmanSdkConstants.TARGET_TYPE)) && !Strings.isNullOrEmpty(annotation.get(PacmanSdkConstants.TYPE))) { parentType = annotation.get(PacmanSdkConstants.TARGET_TYPE); type = getIssueTypeFromAnnotation(annotation); } else throw new Exception("targetType name cannot be null or blank"); if (!isValidType(esUrl, indexName, type)) { throw new Exception("Index exists but unable to find type to publish the data"); } }
public ArrayList<Integer> maxone(ArrayList<Integer> a, int b) { ArrayList<Integer> result = new ArrayList<>(); if (a.size() == 0 || b < 0) { return result; } int start = 0; int count = 0; int globalStart = -1; int globalEnd = -1; int len = 0; for (int i = 0; i < a.size(); i++) { if (a.get(i) == 0) { count++; } if (count > b) { for (int j = start; j <= i; j++) { if (a.get(j) == 0) { count--; start = j + 1; break; } } } else { if (i - start + 1 > len) { len = i - start + 1; globalStart = start; globalEnd = i; } } } if (globalStart != -1) { for (int i = globalStart; i <= globalEnd; i++) { result.add(i); } } return result; }
public static J2735PathHistoryPoint genericPathHistoryPoint(JsonNode pathHistoryPoint) { J2735PathHistoryPoint php = new J2735PathHistoryPoint(); long latOffset = pathHistoryPoint.get("latOffset").asLong(); long lonOffset = pathHistoryPoint.get("lonOffset").asLong(); long elevationOffset = pathHistoryPoint.get("elevationOffset").asLong(); long timeOffset = pathHistoryPoint.get("timeOffset").asLong(); if (latOffset == -131072) { php.setLatOffset(null); } else if (latOffset < -131072) { php.setLatOffset(BigDecimal.valueOf(-0.0131071)); } else if (latOffset > 131071) { php.setLatOffset(BigDecimal.valueOf(0.0131071)); } else { php.setLatOffset(BigDecimal.valueOf(latOffset, 7)); } if (lonOffset == -131072) { php.setLonOffset(null); } else if (lonOffset < -131072) { php.setLonOffset(BigDecimal.valueOf(-0.0131071)); } else if (lonOffset > 131071) { php.setLonOffset(BigDecimal.valueOf(0.0131071)); } else { php.setLonOffset(BigDecimal.valueOf(lonOffset, 7)); } if (elevationOffset == -2048) { php.setElevationOffset(null); } else if (elevationOffset < -2048) { php.setElevationOffset(BigDecimal.valueOf(-204.7)); } else if (elevationOffset > 2047) { php.setElevationOffset(BigDecimal.valueOf(204.7)); } else { php.setElevationOffset(BigDecimal.valueOf(elevationOffset, 1)); } if (timeOffset == 65535) { php.setElevationOffset(null); } else if (timeOffset <= 0) { throw new IllegalArgumentException("timeOffset value out of bounds [below 0]"); } else if (timeOffset >= 65534) { php.setTimeOffset(BigDecimal.valueOf(655.34)); } else { php.setTimeOffset(BigDecimal.valueOf(timeOffset, 2)); } if (pathHistoryPoint.get(SPEED) != null) { php.setSpeed(SpeedOrVelocityBuilder.genericSpeed(pathHistoryPoint.get(SPEED))); } if (pathHistoryPoint.get(POS_ACCURACY) != null) { php.setPosAccuracy(PositionalAccuracyBuilder.genericPositionalAccuracy(pathHistoryPoint.get(POS_ACCURACY))); } if (pathHistoryPoint.get(HEADING) != null) { if (pathHistoryPoint.get(HEADING).asLong() == 240) { php.setHeading(null); } else if (pathHistoryPoint.get(HEADING).asLong() < 0) { throw new IllegalArgumentException("heading value out of bounds [below 0]"); } else if (pathHistoryPoint.get(HEADING).asLong() > 240) { throw new IllegalArgumentException("heading value out of bounds [above 240]"); } else { php.setHeading(BigDecimal.valueOf((pathHistoryPoint.get(HEADING).asDouble() * 1.5)).setScale(1)); } } return php; }
@Override public void encode(ChannelHandlerContext ctx, FixMessageBuilder msg, ByteBuf out) { final FixMessageHeader header = msg.getHeader(); validateRequiredFields(header); final int initialOffset = out.writerIndex(); final ByteBufAllocator byteBufAllocator = ctx.alloc(); final ByteBuf bodyBuf = byteBufAllocator.buffer(); final ByteBuf headBuf = byteBufAllocator.buffer(); int bodyLength = fillBodyBuf(bodyBuf, msg, header); writeField(8, header.getBeginString(), headBuf); writeField(9, Integer.toString(bodyLength), headBuf); out.writeBytes(headBuf); out.writeBytes(bodyBuf); int checksum = calculateChecksum(out, initialOffset); writeChecksumField(out, checksum); ctx.flush(); headBuf.release(); bodyBuf.release(); assert (headBuf.refCnt() == 0); assert (bodyBuf.refCnt() == 0); }
public void dispose() { tableHandler.dispose(); selection.dispose(); source.removeListEventListener(this); source.getPublisher().clearRelatedListener(selection.getSelectionList(), this); if (checkFilterList != null) { checkFilterList.dispose(); } if (originalSource != null) { originalSource.dispose(); } checkFilterList = null; tableHandler = null; selection = null; source = null; originalSource = null; }
public JacksonResponseFieldSnippet responseBodyAsType(Type responseBodyType) { return new JacksonResponseFieldSnippet(responseBodyType, failOnUndocumentedFields); }
@Override public void accept(String json, Context context) { logger.info("Function triggered by change to: " + context.resource()); JsonObject body = gson.fromJson(json, JsonObject.class); boolean isAdmin = false; if (body != null && body.has("auth")) { JsonObject authObj = body.getAsJsonObject("auth"); isAdmin = authObj.has("admin") && authObj.get("admin").getAsBoolean(); } logger.info("Admin?: " + isAdmin); if (body != null && body.has("delta")) { logger.info("Delta:"); logger.info(body.get("delta").toString()); } }
void moveCanvasTo(final double x, final double y) { final double deltaY = calculateDeltaY(y); final double deltaX = calculateDeltaX(x); final Transform newTransform = getTransform().copy().translate(deltaX, deltaY); getViewport().setTransform(newTransform); getDefaultGridLayer().batch(); getGridPanel().refreshScrollPosition(); }
@Override public void reportMetrics(final Map<MetricName, Gauge> gauges, final Map<MetricName, Counter> counters, final Map<MetricName, Histogram> histograms, final Map<MetricName, Meter> meters, final Map<MetricName, Timer> timers) { if (!corePlugin.isStagemonitorActive()) { return; } long timestamp = clock.getTime(); final Timer.Context time = registry.timer(reportingTimeMetricName).time(); final MetricsOutputStreamHandler metricsOutputStreamHandler = new MetricsOutputStreamHandler(gauges, counters, histograms, meters, timers, timestamp); if (!corePlugin.isOnlyLogElasticsearchMetricReports()) { if (!elasticsearchClient.isElasticsearchAvailable()) { return; } final String url = corePlugin.getElasticsearchUrl() + "/" + getTodaysIndexName() + "/" + METRICS_TYPE + "/_bulk"; httpClient.send("POST", url, CONTENT_TYPE_JSON, metricsOutputStreamHandler, NoopResponseHandler.INSTANCE); } else { try { final ByteArrayOutputStream os = new ByteArrayOutputStream(); metricsOutputStreamHandler.withHttpURLConnection(os); elasticsearchMetricsLogger.info(os.toString("UTF-8")); } catch (IOException e) { logger.warn(e.getMessage(), e); } } time.stop(); }
@Override public Result apply(PathData item) throws IOException { return expression.apply(item); }
public PluginSelector getPluginSelector(@Nullable ArtifactSelectorConfig config) { return config == null ? new PluginSelector() : getArtifactSelector(config); }
@Override public InviteeSession onJoinAction(Transaction txn, InviteeSession s) throws DbException { switch (s.getState()) { case START: case ACCEPTED: case JOINED: case LEFT: case DISSOLVED: case ERROR: throw new ProtocolStateException(); case INVITED: return onLocalAccept(txn, s); default: throw new AssertionError(); } }
public boolean isTrash() { if (isRoot()) return false; return getId().split("/")[0].equals(TRASH_FOLDER_ID); }
@Override @SuppressWarnings("unchecked") public <G extends Genotype> G newInstance() { try { return (G) this.getClass().newInstance(); } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } }
@Override public MimeBodyPart select(BodyPartIterator m) throws MessagingException { return m.getBodyPart(getPosition()); }
public static Set<String> fetchDataTypeKeys(String data) { Set<String> keys = Sets.newHashSet(); if (org.apache.commons.lang3.StringUtils.isNotBlank(data)) { String[] entries = StringUtils.split(data, ';'); for (String entry : entries) { String[] entrySplits = StringUtils.split(entry, ':'); if (2 != entrySplits.length) { log.warn("Skipping unparseable normalizer entry: '" + entry + "', from '" + data + "'"); } else { keys.add(entrySplits[0]); if (log.isTraceEnabled()) log.trace("Adding " + entrySplits[0] + " " + keys); } } } return keys; }
@Override public String toString() { return "HeroStat [strength=" + strength + ", intelligence=" + intelligence + ", luck=" + luck + "]"; }
Set<TaskId> assignedTasks() { return unmodifiableSet( union( () -> new HashSet<>(activeTasks.size() + standbyTasks.size()), activeTasks, standbyTasks ) ); }
@Override public boolean isEnabled() { return metaResource.isReadable() && metaResourceField.isInsertable(); }
public static Pair<String, List<FormatSpanInfo>> parseAndStripColorsFromMessage( final String line) { final FormatState state = new FormatState(); final int length = line.length(); final StringBuilder buffer = new StringBuilder(); int i = 0; while (i < length) { char c = line.charAt(i++); if (c == IRC_BOLD) { state.bold(buffer.length()); } else if (c == IRC_COLOR) { int firstFgDigit = digitValue(line, i); int secondFgDigit = digitValue(line, i + 1); if (firstFgDigit >= 0) { i++; } if (secondFgDigit >= 0) { i++; } FormatSpanInfo.Color fg = makeColor(firstFgDigit, secondFgDigit); FormatSpanInfo.Color bg = null; if ((i + 1) < line.length() && line.charAt(i) == ',') { i++; int firstBgDigit = digitValue(line, i); int secondBgDigit = digitValue(line, i + 1); if (firstBgDigit >= 0) { i++; if (secondBgDigit >= 0) { i++; } bg = makeColor(firstBgDigit, secondBgDigit); } else { i--; } } state.color(buffer.length(), fg, bg); } else if (c == IRC_ITALIC) { state.italic(buffer.length()); } else if (c == IRC_UNDERLINE) { state.underline(buffer.length()); } else if (c == IRC_RESET_FORMATTING) { state.applyAndReset(buffer.length()); } else { buffer.append(c); } } state.applyAndReset(buffer.length()); return Pair.create(buffer.toString(), state.mFormats); }
@Override public boolean supportsSetCharacterStream() { return false; }
public static void main(String[] args) throws Exception { File file = new File(args[0]); try (BufferedReader buffer = new BufferedReader(new FileReader(file))) { String line; while ((line = buffer.readLine()) != null) { line = line.trim(); boolean result = line.matches("^[a-zA-Z0-9]([\\+\\.\\-_][a-zA-Z0-9]|[a-zA-Z0-9])*@[a-zA-Z0-9]([\\.\\-][a-zA-Z0-9]|[a-zA-Z0-9])*?\\.[a-zA-Z0-9]+$"); System.out.println(result || line.matches("^\".*?\"@[a-zA-Z0-9]([\\.\\-][a-zA-Z0-9]|[a-zA-Z0-9])*?\\.[a-zA-Z0-9]+$")); } } }
public int getRegister(final int reg) { return this.getRegister(reg, false); }
@Override public String toString() { final Writer writer = new StringWriter(); try { toString(writer); return writer.toString(); } catch (IOException e) { throw new IllegalStateException("Should not occur", e); } }
protected HttpResponse handleTokenValidate(HttpRequest req) { HttpResponse response = null; QueryStringDecoder dec = new QueryStringDecoder(req.getUri()); Map<String, List<String>> params = dec.getParameters(); String tokenParam = QueryParameter.getFirstElement(params, QueryParameter.TOKEN); if (tokenParam == null || tokenParam.isEmpty()) { response = Response.createBadRequestResponse(); } else { AccessToken token = auth.isValidToken(tokenParam); if (token != null) { Gson gson = new Gson(); String json = gson.toJson(token); log.debug(json); response = Response.createOkResponse(json); } else { response = Response.createUnauthorizedResponse(); } } return response; }
@Override public Document parseDom(String source) throws GadgetException { return parseDomImpl(source); }
@Override public Multimap<String,NormalizedContentInterface> getEventFields(RawRecordContainer event) { if (null == flattener) { throw new IllegalStateException("JsonObjectFlattener was not initialized. Method 'setup' must be invoked first"); } HashMultimap<String,String> fields = HashMultimap.create(); String jsonString = new String(event.getRawData()); JsonParser parser = new JsonParser(); JsonElement jsonElement = parser.parse(jsonString); flattener.flatten(jsonElement.getAsJsonObject(), fields); return normalizeMap(getGroupNormalizedMap(fields)); }
@Override public SailImplConfig getConfig() { return new HBaseSailConfig(); }
public Single<DataType> createCustomDataType(@NonNull DataTypeCreateRequest dataTypeCreateRequest) { return createCustomDataTypeInternal(dataTypeCreateRequest, null, null); }
public void updateOrganisationUnits( Set<OrganisationUnit> updates ) { Set<OrganisationUnit> toRemove = Sets.difference( sources, updates ); Set<OrganisationUnit> toAdd = Sets.difference( updates, sources ); toRemove.forEach( u -> u.getDataSets().remove( this ) ); toAdd.forEach( u -> u.getDataSets().add( this ) ); sources.clear(); sources.addAll( updates ); }
protected static Object prepareObjectType( Object o ) { return ( o instanceof byte[] ) ? Arrays.hashCode( (byte[]) o ) : o; }
@Override public int compareTo(CrossVrfEdgeId o) { return Comparator.comparing(CrossVrfEdgeId::getFromVrf) .thenComparing(CrossVrfEdgeId::getToRib) .compare(this, o); }
@Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + argumentNames.hashCode(); result = prime * result + name.hashCode(); return result; }
@Override public void setValue(PreparedStatement st, int startIndex, ZonedDateTime value) throws SQLException { st.setTimestamp(startIndex, Timestamp.from(value.toInstant()), utc()); }
public String getId() { return id; }
@Override public boolean equals(Object o) { if (o instanceof Range) return equals((Range) o); return false; }
public Interval reportUsage(Interval usage, int minSize) { return null; }
@Override public FluentFuture<Optional<NormalizedNode<?, ?>>> read(final YangInstanceIdentifier path) { checkState(type != TransactionType.WRITE_ONLY, "Reads from write-only transactions are not allowed"); requireNonNull(path, "path should not be null"); LOG.trace("Tx {} read {}", getIdentifier(), path); return path.isEmpty() ? readAllData() : singleShardRead(shardNameFromIdentifier(path), path); }
@NonNull @Override public Long toSupported(@Nullable Date converted) { if (converted == null) { return DEFAULT_TIMESTAMP; } return converted.getTime(); }
public static String formateDate(Date date, String formate) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(formate); return simpleDateFormat.format(date); }
@Override public Boolean removeMs(String msCode) { hashOperations.delete(getMainKey(), msCode); return true; }
public void store(Owner owner, ConsumerDTO consumer, ConflictOverrides forcedConflicts, IdentityCertificate idcert) throws SyncDataFormatException { if (consumer.getUuid() == null) { throw new SyncDataFormatException( i18n.tr("No ID for upstream subscription management application.")); } Owner alreadyUsing = curator.getByUpstreamUuid(consumer.getUuid()); if (alreadyUsing != null && !alreadyUsing.getKey().equals(owner.getKey())) { log.error("Cannot import manifest for org: {}", owner.getKey()); log.error("Upstream distributor {} already in used by org: {}", consumer.getUuid(), alreadyUsing.getKey()); throw new SyncDataFormatException(i18n.tr( "This subscription management application has already been imported by another owner.")); } if (owner.getUpstreamUuid() != null && !owner.getUpstreamUuid().equals(consumer.getUuid())) { if (!forcedConflicts.isForced(Importer.Conflict.DISTRIBUTOR_CONFLICT)) { throw new ImportConflictException( i18n.tr("Owner has already imported from another subscription management application."), Importer.Conflict.DISTRIBUTOR_CONFLICT); } else { log.warn("Forcing import from a new distributor for org: {}", owner.getKey()); log.warn("Old distributor UUID: {}", owner.getUpstreamUuid()); log.warn("New distributor UUID: {}", consumer.getUuid()); } } if (idcert != null) { CertificateSerial cs = new CertificateSerial(); cs.setCollected(idcert.getSerial().isCollected()); cs.setExpiration(idcert.getSerial().getExpiration()); cs.setUpdated(idcert.getSerial().getUpdated()); cs.setCreated(idcert.getSerial().getCreated()); serialCurator.create(cs); idcert.setId(null); idcert.setSerial(cs); idCertCurator.create(idcert); } ConsumerType type = new ConsumerType(); populateEntity(type, consumer.getType()); Owner ownerToUse = new Owner(); if (consumer.getOwner() != null) { populateEntity(ownerToUse, consumer.getOwner()); } UpstreamConsumer uc = new UpstreamConsumer(consumer.getName(), ownerToUse, type, consumer.getUuid()); uc.setWebUrl(consumer.getUrlWeb()); uc.setApiUrl(consumer.getUrlApi()); uc.setIdCert(idcert); uc.setContentAccessMode(consumer.getContentAccessMode()); owner.setUpstreamConsumer(uc); curator.merge(owner); }
public T fromEntry(Entry entry, Class<? extends T> entityClass) { if (entry.getDn() == null) throw new LdapMappingException("LDAP Entry DN cannot be null"); try { final T bean = entityClass.newInstance(); Class<?> currentClass = entityClass; while (currentClass != null) { mapToProperties(entry, currentClass, bean); currentClass = currentClass.getSuperclass(); if (currentClass == Object.class) break; } return bean; } catch (InstantiationException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (IllegalAccessException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (InvocationTargetException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (LdapInvalidAttributeValueException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } catch (NoSuchMethodException e) { log.error("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); throw new LdapMappingException("Error mapping Entry " + entry.getDn() + " to " + entityClass.getName(), e); } }
public Provider getNext() { return next; }
public static AzureEnvironment getAzureEnvironment(String environment) { if (StringUtils.isEmpty(environment)) { return AzureEnvironment.AZURE; } switch (environment.toUpperCase(Locale.ENGLISH)) { case "AZURE_CHINA": case "AZURECHINACLOUD": return AzureEnvironment.AZURE_CHINA; case "AZURE_GERMANY": case "AZUREGERMANCLOUD": return AzureEnvironment.AZURE_GERMANY; case "AZURE_US_GOVERNMENT": case "AZUREUSGOVERNMENT": return AzureEnvironment.AZURE_US_GOVERNMENT; default: return AzureEnvironment.AZURE; } }
@Override public boolean retryRequest( final HttpRequest request, final IOException exception, final int execCount, final HttpContext context) { Args.notNull(request, "request"); Args.notNull(exception, "exception"); if (execCount > this.maxRetries) { return false; } if (this.nonRetriableIOExceptionClasses.contains(exception.getClass())) { return false; } else { for (final Class<? extends IOException> rejectException : this.nonRetriableIOExceptionClasses) { if (rejectException.isInstance(exception)) { return false; } } } if (request instanceof CancellableDependency && ((CancellableDependency) request).isCancelled()) { return false; } return handleAsIdempotent(request); }
@Override public String toString() { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("ColumnCombinationBitset "); int lastSetBitIndex = bitset.previousSetBit(bitset.length()); for (int i = 0; i <= lastSetBitIndex; i++) { stringBuilder.append(bitset.get(i) ? 1 : 0); } return stringBuilder.toString(); }
@Override public AppraisalStatus validatePlatformCredentialAttributes( final PlatformCredential platformCredential, final DeviceInfoReport deviceInfoReport, final EndorsementCredential endorsementCredential) { final String baseErrorMessage = "Can't validate platform credential attributes without "; String message; if (platformCredential == null) { message = baseErrorMessage + "a platform credential"; LOGGER.error(message); return new AppraisalStatus(FAIL, message); } if (deviceInfoReport == null) { message = baseErrorMessage + "a device info report"; LOGGER.error(message); return new AppraisalStatus(FAIL, message); } if (endorsementCredential == null) { message = baseErrorMessage + "an endorsement credential"; LOGGER.error(message); return new AppraisalStatus(FAIL, message); } if (!endorsementCredential.getSerialNumber() .equals(platformCredential.getHolderSerialNumber())) { message = "Platform Credential holder serial number does not match " + "the Endorsement Credential's serial number"; LOGGER.error(message); return new AppraisalStatus(FAIL, message); } String credentialType = platformCredential.getCredentialType(); if (PlatformCredential.CERTIFICATE_TYPE_2_0.equals(credentialType)) { return validatePlatformCredentialAttributesV2p0(platformCredential, deviceInfoReport); } return validatePlatformCredentialAttributesV1p2(platformCredential, deviceInfoReport); }
void fetchFeeds() { LOG.info("Updating RSS feeds..."); List<Feed> feeds; try { feeds = getFeeds(); } catch (DbException e) { logException(LOG, WARNING, e); return; } List<Feed> newFeeds = new ArrayList<>(feeds.size()); for (Feed feed : feeds) { try { newFeeds.add(fetchFeed(feed)); } catch (IOException | DbException e) { logException(LOG, WARNING, e); newFeeds.add(feed); } } try { storeFeeds(newFeeds); } catch (DbException e) { logException(LOG, WARNING, e); } LOG.info("Done updating RSS feeds"); }
public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputIndex) { int selectionMask = (int) inputMask; int combineMask = availableInputsMask & selectionMask; if (combineMask == 3) { return lastReadInputIndex == 0 ? 1 : 0; } else if (combineMask >= 0 && combineMask < 3) { return combineMask - 1; } throw new UnsupportedOperationException("Only two inputs are supported."); }
public static Ip4Address valueOf(int value) { byte[] bytes = ByteBuffer.allocate(INET_BYTE_LENGTH).putInt(value).array(); return new Ip4Address(bytes); }
@Override public List<IndexPlan> getPlans(Filter filter, List<OrderEntry> sortOrder, NodeState rootState) { Collection<String> indexPaths = new SolrIndexLookup(rootState).collectIndexNodePaths(filter); List<IndexPlan> plans = Lists.newArrayListWithCapacity(indexPaths.size()); log.debug("looking for plans for paths : {}", indexPaths); for (String path : indexPaths) { OakSolrConfiguration configuration = getConfiguration(path, rootState); SolrClient solrServer = getServer(path, rootState); log.debug("building plan for server {} and configuration {}", solrServer, configuration); if (configuration != null && solrServer != null) { LMSEstimator estimator = getEstimator(path); IndexPlan plan = getIndexPlan(filter, configuration, estimator, sortOrder, path); if (plan != null) { plans.add(plan); } } } return plans; }
@Override public DateTime create( String value ) { if (value == null) return null; try { return new ModeShapeDateTime(value.trim()); } catch (java.time.format.DateTimeParseException err) { try { Long longValue = Long.parseLong(value); return new ModeShapeDateTime(longValue); } catch (NumberFormatException e) { throw new ValueFormatException(value, getPropertyType(), GraphI18n.errorConvertingType.text(String.class.getSimpleName(), org.modeshape.jcr.api.value.DateTime.class.getSimpleName(), value), err); } } }
public DynamicType.Builder<? extends Annotation> makeAnnotation() { return new SubclassDynamicTypeBuilder<Annotation>(instrumentedTypeFactory.subclass(namingStrategy.subclass(TypeDescription.Generic.ANNOTATION), ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.ANNOTATION).resolve(), TypeDescription.Generic.OBJECT).withInterfaces(new TypeList.Generic.Explicit(TypeDescription.Generic.ANNOTATION)), classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classWriterStrategy, ignoredMethods, ConstructorStrategy.Default.NO_CONSTRUCTORS); }
@Override public StorageContainerRegistryImpl getRegistry() { return this.scRegistry; }
@Override public SqlQueryResult build(String query) throws IOException, ParserNotFoundException { Operation result = (Operation) super.parse(query); StringBuffer sql = new StringBuffer(result.getOperate()); sql.delete(sql.length() - 2, sql.length()); sql.delete(0, 2); return new SqlQueryResult(query, sql.toString(), (List<Object>) result.getValue()); }
public DependencyGraph parseYarnList(final List<String> yarnLockText, final List<String> yarnListAsList) { final MutableDependencyGraph graph = new MutableMapDependencyGraph(); final DependencyHistory history = new DependencyHistory(); final Map<String, String> yarnLockVersionMap = yarnLockParser.getYarnLockResolvedVersionMap(yarnLockText); for (final String line : yarnListAsList) { final String lowerCaseLine = line.toLowerCase().trim(); final String cleanedLine = line.replaceAll(NTH_DEPENDENCY_PREFIX, "").replaceAll(INNER_LEVEL_CHARACTER, "").replaceAll(LAST_DEPENDENCY_PREFIX, ""); if (!cleanedLine.contains("@") || lowerCaseLine.startsWith("yarn list") || lowerCaseLine.startsWith("done in") || lowerCaseLine.startsWith("warning")) { continue; } final Dependency dependency = parseDependencyFromLine(cleanedLine, yarnLockVersionMap); final int lineLevel = getLineLevel(cleanedLine); try { history.clearDependenciesDeeperThan(lineLevel); } catch (final IllegalStateException e) { logger.warn(String.format("Problem parsing line '%s': %s", line, e.getMessage())); } if (history.isEmpty()) { graph.addChildToRoot(dependency); } else { graph.addChildWithParents(dependency, history.getLastDependency()); } history.add(dependency); } return graph; }
public static <U> U valueOrElse(Versioned<U> versioned, U defaultValue) { return versioned == null ? defaultValue : versioned.value(); }
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return lowestCommonAncestorCurr(root, p, q); }
@Override public AsyncTriggerExecutionResult call() { if (asyncTrigger.getRetries() >= asyncTrigger.getMaxRetries()) { throw new IllegalStateException(); } return asyncTriggerExecutor.execute(asyncTrigger, retryStrategy, context, asyncTriggerStore); }
public void setIncludeParentsWhenFiltering( boolean includeParentsWhenFiltering) { this.includeParentsWhenFiltering = includeParentsWhenFiltering; if (filteredRoots != null) { doFilterContainer(true); } }
public static BaseParam getBaseParam(String type, String parameter) { try { switch (type) { case MR: return JsonUtil.parseObject(parameter, MrParam.class); case SHELL: return JsonUtil.parseObject(parameter, ShellParam.class); case HQL: return JsonUtil.parseObject(parameter, HqlParam.class); case VIRTUAL: return VirtualParam.getInstance(); case SPARK_STREAMING: return JsonUtil.parseObject(parameter, SparkParam.class); case SPARK: return JsonUtil.parseObject(parameter, SparkParam.class); case IMPEXP: return JsonUtil.parseObject(parameter,ImpExpBuilder.class).buildImpExp(); case STORM: return JsonUtil.parseObject(parameter, StormBuilder.class).buildStormParam(); default: return null; } } catch (Exception e) { logger.error("Get BaseParam object error", e); return null; } }
@Override protected boolean incomingMessage(Transaction txn, Message m, BdfList list, BdfDictionary meta) throws DbException, FormatException { GroupId groupId = m.getGroupId(); MessageType type = getMessageType(meta); if (type == POST || type == COMMENT) { BlogPostHeader h = getPostHeaderFromMetadata(txn, groupId, m.getId(), meta); if (type == COMMENT) { MessageId parentId = h.getParentId(); if (parentId == null) throw new FormatException(); BdfDictionary d = clientHelper .getMessageMetadataAsDictionary(txn, parentId); byte[] original1 = d.getRaw(KEY_ORIGINAL_MSG_ID); byte[] original2 = meta.getRaw(KEY_ORIGINAL_PARENT_MSG_ID); if (!Arrays.equals(original1, original2)) { throw new FormatException(); } } BlogPostAddedEvent event = new BlogPostAddedEvent(groupId, h, false); txn.attach(event); return true; } else if (type == WRAPPED_COMMENT) { MessageId dependencyId = new MessageId(meta.getRaw(KEY_PARENT_MSG_ID)); BdfDictionary d = clientHelper .getMessageMetadataAsDictionary(txn, dependencyId); byte[] original1 = d.getRaw(KEY_ORIGINAL_MSG_ID); byte[] original2 = meta.getRaw(KEY_ORIGINAL_PARENT_MSG_ID); if (!Arrays.equals(original1, original2)) { throw new FormatException(); } } return false; }
@Override public SessionMirror create(String id) throws SessionException, IOException { if (id == null) { throw new IllegalArgumentException("id must not be null"); } LOG.debug("Creating session: {}", id); return attach(id, true, false); }
public boolean contains(Geometry geometry) { return geometry.getDimension() > 2 ? !(geometry.contains(ll) || geometry.contains(ur)) : asEnvelop().contains(geometry.getEnvelopeInternal()); }
public StartEventBuilder startEvent() { return startEvent(null); }
public byte maximumAreaAddresses() { return maximumAreaAddresses; }
public List<String> getExcludedFieldKeyNames() { Collection<String> contextFieldsKeys = LogContext.getContextFieldsKeys(); List<String> result = new ArrayList<>(customFields.size()); for (CustomField customField : customFields) { if (!customField.isRetainOriginal() && !contextFieldsKeys.contains(customField.getKey())) { result.add(customField.getKey()); } } return result; }
public static ZContext shadow(ZContext ctx) { ZContext shadow = new ZContext(); shadow.setContext(ctx.getContext()); shadow.setMain(false); return shadow; }
public Fields rename( Fields from, Fields to ) { if( this.isSubstitution() || this.isUnknown() ) throw new TupleException( "cannot rename fields in a substitution or unknown Fields instance: " + this.print() ); if( from.size() != to.size() ) throw new TupleException( "from and to fields must be the same size" ); if( from.isSubstitution() || from.isUnknown() ) throw new TupleException( "from fields may not be a substitution or unknown" ); if( to.isSubstitution() || to.isUnknown() ) throw new TupleException( "to fields may not be a substitution or unknown" ); Comparable[] newFields = Arrays.copyOf( this.fields, this.fields.length ); int[] pos = getPos( from ); for( int i = 0; i < pos.length; i++ ) newFields[ pos[ i ] ] = to.fields[ i ]; Type[] newTypes = null; if( this.types != null && to.types != null ) { newTypes = copyTypes( this.types, this.size() ); for( int i = 0; i < pos.length; i++ ) newTypes[ pos[ i ] ] = to.types[ i ]; } return new Fields( newFields, newTypes ); }
@Override public AbstractResultSet executeAskQuery(Query query, cz.cvut.kbss.ontodriver.Statement.StatementOntology target) throws JenaDriverException { return connector.executeAskQuery(query, target); }
public static TaskExecutor create(TaskDefinition task) { switch (task.getType()) { case EXEC: return new ExecTaskExecutor(); case FETCH_MATERIAL: return FetchMaterialExecutorFactory.create(task); case FETCH_ARTIFACT: return new FetchArtifactExecutor(); case UPLOAD_ARTIFACT: return new UploadArtifactExecutor(); default: return null; } }
public void finalizeEstimate(EstimateForm form, Long userId) { this.save(form, userId); for (EstimateFormLineItem dto : ListUtil.emptyIfNull(form.getEstimateLineItems())) { for (AnnualDistrictEstimateEntry est : ListUtil.emptyIfNull(dto.getDistrictEstimates())) { est.setDistrictId(dto.getId()); if (est.getId() != null) { est.setModifiedBy(userId); est.setModifiedDate(new Date()); est.setIsFinal(true); repository.finalizeEstimate(est); } } } }
@Override public Relationship buildRelation(Node parent, Node child, DocumentRelationContext context) { String documentKey = context.getDocumentKey(); if(StringUtils.isBlank(documentKey)) { return null; } RelationshipType relationType = RelationshipType.withName( documentKey ); Iterable<Relationship> relationships = child.getRelationships(Direction.INCOMING,relationType); List<Relationship> rels = StreamSupport.stream(relationships.spliterator(), false) .filter(rel -> rel.getStartNode().getId() == parent.getId()) .collect(Collectors.toList()); Relationship relationship; if(rels.isEmpty()) { relationship = parent.createRelationshipTo(child, relationType); if(log.isDebugEnabled()) log.debug("Create new Relation "+relationship); }else { relationship = rels.get(0); if(log.isDebugEnabled()) log.debug("Update Relation "+relationship); } return relationship; }
@Override public void setReadOnly(boolean readOnly) { view.setReadOnly(readOnly); }
public Task<ShortDynamicLink> createShortDynamicLink(final Bundle builderParameters) { verifyDomainUriPrefix(builderParameters); return googleApi.doWrite(new CreateShortDynamicLinkImpl(builderParameters)); }
@Factory public static ValidationMatcher valid(final Object schemaSource) { return new ValidationMatcher(schemaSource); }
public static Criterion matchUdpDst(TpPort udpPort) { return new UdpPortCriterion(udpPort, Type.UDP_DST); }
public static boolean isCertCheckingDisabled() { return isPropertyEnabled(System.getProperty(DISABLE_CERT_CHECKING_SYSTEM_PROPERTY)); }
public DataType type(String name) throws AmbiguousNameException { NamedType nt = find(name); if (nt == null) { return null; } return nt.type(); }
@Override public ByteBuf setInt(int index, int value) { throw new ReadOnlyBufferException(); }
void acquire(Connection connection) { if (addConnection(connection)) { LOGGER.debug("Acquiring lock {} on database", uuid); addShutdownHook(); ensureLockUniqueness(connection); tryWriteLock(connection); } }
public void show(Path path, Validator validator, CommandWithFileNameAndCommitMessage command) { this.path = checkNotNull("path", path); this.validator = checkNotNull("validator", validator); this.command = checkNotNull("command", command); view.show(); }
String getMavenCommand(DeployApplicationRequest request) { if (!StringUtils.isBlank(request.getMainService())) { return String.format("maven:%s::%s", request.getModuleId(), request.getMainService()); } return String.format("maven:%s", request.getModuleId()); }
@Override public Class<?> getObjectType() { return DaleqSupport.class; }
public Uri getGadget(String version) { return gadgets.get(version); }
@Override public void onRefreshMenusEvent(final @Observes RefreshMenusEvent event) { super.onRefreshMenusEvent(event); }
@Transactional public InstrumentVoucher update(InstrumentVoucher instrumentVoucher) { InstrumentVoucherEntity entity = instrumentVoucherJdbcRepository .update(new InstrumentVoucherEntity().toEntity(instrumentVoucher)); return entity.toDomain(); }
boolean shouldBeComposite(final String path) { boolean supportMounts = false; if (mip.getNonDefaultMounts().stream().anyMatch(m -> m.isSupportFragmentUnder(path))) { supportMounts = true; } else if (!mip.getMountsPlacedUnder(path).isEmpty()) { supportMounts = true; } return supportMounts && mip.getMountByPath(path).isDefault(); }
@Subscribe @Guarded(by = STARTED) @AllowConcurrentEvents public void on(final AssetDeletedEvent deleted) { if (matchesRepository(deleted) && isEventRelevant(deleted)) { invalidateMetadata(deleted); } }
public void strip() { stripFiles(); stripTags(); }
@Override public void waitForLease() throws InterruptedException { hasLease.await(); }
public <T extends BaseRequest, R extends BaseResponse> R execute(BaseRequest<T, R> request) { return api.send(request); }
@UiThread public List<Fill> create(@NonNull String json) { return create(FeatureCollection.fromJson(json)); }
static void parseServerIpAndPort(MysqlConnection connection, Span span) { try { URI url = URI.create(connection.getURL().substring(5)); String remoteServiceName = connection.getProperties().getProperty("zipkinServiceName"); if (remoteServiceName == null || "".equals(remoteServiceName)) { String databaseName = getDatabaseName(connection); if (databaseName != null && !databaseName.isEmpty()) { remoteServiceName = "mysql-" + databaseName; } else { remoteServiceName = "mysql"; } } span.remoteServiceName(remoteServiceName); String host = getHost(connection); if (host != null) { span.remoteIpAndPort(host, url.getPort() == -1 ? 3306 : url.getPort()); } } catch (Exception e) { } }
@Override public String rewrite(String query, Configuration conf, HiveConf metastoreConf) throws LensException { this.query = query; String reWritten = rewrite(HQLParser.parseHQL(query, metastoreConf), conf, metastoreConf, true); log.info("Rewritten : {}", reWritten); String queryReplacedUdf = replaceUDFForDB(reWritten); log.info("Input Query : {}", query); log.info("Rewritten Query : {}", queryReplacedUdf); return queryReplacedUdf; }
public static CompressorFactory getInstance() { return new CompressorFactory(); }
public String getTitle() { return title; }
public URI firstTimeInit(String clientID, String clientSecret) { this.spotifyAPICalls.setClientID(clientID); this.spotifyAPICalls.setClientSecret(clientSecret); return this.spotifyAPICalls.authorizationCodeUri(); }
public static ConfigBuilder newConfigBuilder() { return new ConfigBuilder(); }
@Override public String getProjectType() { return MavenAttributes.MAVEN_ID; }
public ClassicHttpResponse execute( final ClassicHttpRequest request, final HttpClientConnection conn, final HttpResponseInformationCallback informationCallback, final HttpContext context) throws IOException, HttpException { Args.notNull(request, "HTTP request"); Args.notNull(conn, "Client connection"); Args.notNull(context, "HTTP context"); try { context.setAttribute(HttpCoreContext.SSL_SESSION, conn.getSSLSession()); context.setAttribute(HttpCoreContext.CONNECTION_ENDPOINT, conn.getEndpointDetails()); final ProtocolVersion transportVersion = request.getVersion(); if (transportVersion != null) { if (transportVersion.greaterEquals(HttpVersion.HTTP_2)) { throw new UnsupportedHttpVersionException(transportVersion); } context.setProtocolVersion(transportVersion); } conn.sendRequestHeader(request); if (streamListener != null) { streamListener.onRequestHead(conn, request); } boolean expectContinue = false; final HttpEntity entity = request.getEntity(); if (entity != null) { final Header expect = request.getFirstHeader(HttpHeaders.EXPECT); expectContinue = expect != null && HeaderElements.CONTINUE.equalsIgnoreCase(expect.getValue()); if (!expectContinue) { conn.sendRequestEntity(request); } } conn.flush(); ClassicHttpResponse response = null; while (response == null) { if (expectContinue) { if (conn.isDataAvailable(this.waitForContinue)) { response = conn.receiveResponseHeader(); if (streamListener != null) { streamListener.onResponseHead(conn, response); } final int status = response.getCode(); if (status == HttpStatus.SC_CONTINUE) { response = null; conn.sendRequestEntity(request); } else if (status < HttpStatus.SC_SUCCESS) { if (informationCallback != null) { informationCallback.execute(response, conn, context); } response = null; continue; } else if (status >= HttpStatus.SC_CLIENT_ERROR){ conn.terminateRequest(request); } else { conn.sendRequestEntity(request); } } else { conn.sendRequestEntity(request); } conn.flush(); expectContinue = false; } else { response = conn.receiveResponseHeader(); if (streamListener != null) { streamListener.onResponseHead(conn, response); } final int status = response.getCode(); if (status < HttpStatus.SC_INFORMATIONAL) { throw new ProtocolException("Invalid response: " + new StatusLine(response)); } if (status < HttpStatus.SC_SUCCESS) { if (informationCallback != null && status != HttpStatus.SC_CONTINUE) { informationCallback.execute(response, conn, context); } response = null; } } } if (MessageSupport.canResponseHaveBody(request.getMethod(), response)) { conn.receiveResponseEntity(response); } return response; } catch (final HttpException | IOException | RuntimeException ex) { Closer.closeQuietly(conn); throw ex; } }
protected boolean checkSignature(String signature) { return signature.length() >= 2 && signature.length() <= 5 && signature.matches("\\D+"); }
public static UpgradePostCheckPayload buildUpgradePostCheckPayload(DelegateExecution execution) { String requestPayload = String.valueOf(execution.getVariable(REQUEST_PAYLOAD)); UpgradePostCheckPayload upgradePostCheckPayload = new UpgradePostCheckPayload(); String ipaddressV4Oam = JsonUtils.getJsonValue(requestPayload, "ipaddressV4Oam"); upgradePostCheckPayload.setIpaddressV4Oam(ipaddressV4Oam); String oldSwVersion = JsonUtils.getJsonValue(requestPayload, "oldSwVersion"); upgradePostCheckPayload.setOldSwVersion(oldSwVersion); String targetSwVersion = String.valueOf(execution.getVariable(SoPropertyConstants.TARGET_SOFTWARE_VERSION)); if (targetSwVersion == null) { targetSwVersion = JsonUtils.getJsonValue(requestPayload, "targetSwVersion"); } upgradePostCheckPayload.setTargetSwVersion(targetSwVersion); String ruleName = JsonUtils.getJsonValue(requestPayload, "postCheckRuleName"); upgradePostCheckPayload.setRuleName(ruleName); String additionalData = JsonUtils.getJsonValue(requestPayload, "postCheckAdditionalData"); upgradePostCheckPayload.setAdditionalData(additionalData); String playbookName = JsonUtils.getJsonValue(requestPayload, "postCheckPlaybook"); if (playbookName != null) { upgradePostCheckPayload.setPlaybookName(playbookName); } return upgradePostCheckPayload; }
@Override public synchronized void parse(InputStream in, String baseURI) throws IOException, RDFParseException, RDFHandlerException { if (in == null) { throw new IllegalArgumentException("Input stream must not be 'null'"); } try { parse(new InputStreamReader(new BOMInputStream(in, false), StandardCharsets.UTF_8), baseURI); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }
public static PRPAIN201301UV02 copyNullFlavors(final PRPAIN201305UV02 from, final PRPAIN201301UV02 to) { if (!from.getNullFlavor().isEmpty()) { to.getNullFlavor().clear(); for (final String item : from.getNullFlavor()) { to.getNullFlavor().add(item); } } return to; }
@NonNull public static <T, F> Supplier<T> functionAsSupplier( @NonNull final Function<F, T> function, @NonNull final F from) { return new FunctionToSupplierConverter<>(function, from); }
public static void validateUserBulkUploadRequest(Map<String, Object> userMap) { validateUserType(userMap); validateOrganisationId(userMap); }
public static Map<PValue, ReplacementOutput> singleton( List<TaggedPValue> original, PValue replacement) { TaggedPValue taggedReplacement = Iterables.getOnlyElement(replacement.expand()); return ImmutableMap.<PValue, ReplacementOutput>builder() .put( taggedReplacement.getValue(), ReplacementOutput.of(Iterables.getOnlyElement(original), taggedReplacement)) .build(); }
@Override public double measure(Vector<Double> x, Vector<Double> y) { checkInput(x, y); double denom = x.pNorm(2) * y.pNorm(2); if (denom == 0) { return 2.0; } return 1 - x.dot(y) / denom; }
public void record(T value) { if (sampler == null || sampler.select()) { synchronized (samples) { samples.addLast(value); while (samples.size() > MAX_BUFFER_SIZE) samples.removeFirst(); } } }
@Override public ClientMessage transform(Map<String, Object> source) { String command = (String) source.get("command"); LegacyClientMessageType messageType = LegacyClientMessageType.fromString(command); Requests.verify(messageType != null, ErrorCode.INVALID_COMMAND, command); switch (messageType) { case HOST_GAME: return handleHostGame(source); case JOIN_GAME: return new JoinGameRequest(((Number) source.get("uid")).intValue(), (String) source.get("password")); case ASK_SESSION: String userAgent = (String) source.get("user_agent"); return LegacySessionRequest.forUserAgent(userAgent); case SOCIAL_ADD: return handleSocialAdd(source); case SOCIAL_REMOVE: return handleSocialRemove(source); case LOGIN: return handleLogin(source); case GAME_MATCH_MAKING: return handleMatchMaking(source); case AVATAR: return handleAvatar(source); case PING: return PingReport.INSTANCE; case GAME_STATE: return handleGameState(source); case GAME_OPTION: List<Object> args = getArgs(source); return new GameOptionReport((String) args.get(0), args.get(1)); case GAME_ENDED: return GameEndedReport.INSTANCE; case PLAYER_OPTION: args = getArgs(source); return new PlayerOptionReport(Integer.parseInt((String) args.get(0)), (String) args.get(1), args.get(2)); case VERIFY_PLAYER: args = getArgs(source); return new VerifyPlayerReport( (int) args.get(0), (String) args.get(1), (float) args.get(2), (float) args.get(3), (String) args.get(4), (String) args.get(5), (String) args.get(6) ); case CLEAR_SLOT: args = getArgs(source); return ClearSlotRequest.valueOf((int) args.get(0)); case DESYNC: return DesyncReport.INSTANCE; case GAME_MODS: return handleGameMods(source); case GAME_RESULT: return handleGameResult(source); case OPERATION_COMPLETE: return handleOperationComplete(source); case JSON_STATS: return handleJsonStats(source); case ENFORCE_RATING: return PlayerDefeatedReport.INSTANCE; case TEAMKILL_REPORT: return handleTeamKillReport(source); case MUTUAL_DRAW: return MutuallyAgreedDrawRequest.INSTANCE; case AI_OPTION: return handleAiOption(source); case INITIATE_TEST: throw new RequestException(ErrorCode.UNSUPPORTED_REQUEST, source); case ICE_SERVERS: return IceServersRequest.INSTANCE; case ICE_MESSAGE: args = getArgs(source); return new IceMessage((int) args.get(0), args.get(1)); case RESTORE_GAME_SESSION: return new RestoreGameSessionRequest((int) source.get("game_id")); case CREATE_ACCOUNT: throw new RequestException(ErrorCode.CREATE_ACCOUNT_IS_DEPRECATED); case ADMIN: return handleAdminAction(source); case DISCONNECTED: args = getArgs(source); return new PlayerDisconnectedReport((int) args.get(0)); case BOTTLENECK: return BottleneckReport.INSTANCE; case CHAT: return handleGameChatMessage((String) getArgs(source).get(0)); case BOTTLENECK_CLEARED: return BottleneckClearedReport.INSTANCE; default: throw new ProgrammingError("Uncovered message type: " + messageType); } }
public static Complex[] interleaved2Complex(double[] interleaved) { final int length = interleaved.length / 2; final Complex[] c = new Complex[length]; for (int n = 0; n < length; n++) { c[n] = Complex.ofCartesian(interleaved[n * 2], interleaved[n * 2 + 1]); } return c; }
public boolean dropTables(@Nonnull final String source, @Nonnull final String entity, @Nonnull final Set<TableType> tableTypes, @Nonnull final Set<String> additionalTables) { for (final TableType tableType : tableTypes) { final String identifier = tableType.deriveQualifiedName(source, entity); if (!dropTable(identifier)) { return false; } } for (final String identifier : additionalTables) { if (!dropTable(identifier)) { return false; } } return true; }
public boolean isValid(Class < T > javaClass, CobolContext cobolContext, byte[] hostData, int start) { int hostBytesLen = getBytesLen(charNum); if (hostData.length < start + hostBytesLen) { return false; } if (javaClass.equals(String.class)) { return isValidString(cobolContext, hostData, start); } else if (javaClass.equals(ByteBuffer.class)) { return true; } else { throw new IllegalArgumentException("Unsupported java type " + javaClass); } }
@SuppressWarnings("unused") public void onDecisionTablePinnedEvent(final @Observes DecisionTablePinnedEvent event) { final GuidedDecisionTableModellerView.Presenter modeller = event.getPresenter(); if (modeller == null) { return; } if (!modeller.equals(this.modeller)) { return; } view.enableDrag(!event.isPinned()); }
public int compareTo( Tuple other ) { if( other == null || other.elements == null ) return 1; if( other.elements.size() != this.elements.size() ) return this.elements.size() - other.elements.size(); for( int i = 0; i < this.elements.size(); i++ ) { Comparable lhs = (Comparable) this.elements.get( i ); Comparable rhs = (Comparable) other.elements.get( i ); if( lhs == null && rhs == null ) continue; if( lhs == null ) return -1; else if( rhs == null ) return 1; int c = lhs.compareTo( rhs ); if( c != 0 ) return c; } return 0; }
@Override public void configure(Map<String, String> parameters) throws IllegalStateException { super.configure(parameters); if (FILTER_USER.equals(parameters.get(INPUT_PARAM_FILTER))) { includingGroups = false; } else if (FILTER_GROUP.equals(parameters.get(INPUT_PARAM_FILTER))) { includingUsers = false; } this.parameters.put(PARAM_INCLUDE_GROUPS, includingGroups); this.parameters.put(PARAM_INCLUDE_USERS, includingUsers); }
public static <K, C, E, A> InputStreams<K, C> addTopology(TopologyContext<K, C, E, A> ctx, final StreamsBuilder builder) { final KStream<K, CommandRequest<K, C>> commandRequestStream = EventSourcedConsumer.commandRequestStream(ctx, builder); final KStream<K, CommandResponse<K>> commandResponseStream = EventSourcedConsumer.commandResponseStream(ctx, builder); final KTable<K, AggregateUpdate<A>> aggregateTable = EventSourcedConsumer.aggregateTable(ctx, builder); final DistributorContext<CommandId, CommandResponse<K>> distCtx = getDistributorContext(ctx); final KStream<CommandId, String> resultsTopicMapStream = ResultDistributor.resultTopicMapStream(distCtx, builder); Tuple2<KStream<K, CommandRequest<K, C>>, KStream<K, CommandResponse<K>>> reqResp = EventSourcedStreams.getProcessedCommands( ctx, commandRequestStream, commandResponseStream); final KStream<K, CommandRequest<K, C>> unprocessedRequests = reqResp.v1(); final KStream<K, CommandResponse<K>> processedResponses = reqResp.v2(); final KStream<K, CommandEvents<E, A>> commandEvents = EventSourcedStreams.getCommandEvents(ctx, unprocessedRequests, aggregateTable); final KStream<K, ValueWithSequence<E>> eventsWithSequence = EventSourcedStreams.getEventsWithSequence(commandEvents); final KStream<K, AggregateUpdateResult<A>> aggregateUpdateResults = EventSourcedStreams.getAggregateUpdateResults(ctx, commandEvents); final KStream<K, AggregateUpdate<A>> aggregateUpdates = EventSourcedStreams.getAggregateUpdates(aggregateUpdateResults); final KStream<K, CommandResponse<K>>commandResponses = EventSourcedStreams.getCommandResponses(aggregateUpdateResults); EventSourcedPublisher.publishEvents(ctx, eventsWithSequence); EventSourcedPublisher.publishAggregateUpdates(ctx, aggregateUpdates); EventSourcedPublisher.publishCommandResponses(ctx, processedResponses); EventSourcedPublisher.publishCommandResponses(ctx, commandResponses); ResultDistributor.distribute(distCtx, commandResponseStream, resultsTopicMapStream); return new InputStreams<>(commandRequestStream, commandResponseStream); }
@Override public void setThrottleValue(String uuid, int value) { getProfileInstanceManager(uuid).setThrottleValue(value); }
public void eval(Object... args) throws HiveException { if (isArgsSingleArray) { args = new Object[] {args}; } checkArgument(args.length == conversions.length); if (!allIdentityConverter) { for (int i = 0; i < args.length; i++) { args[i] = conversions[i].toHiveObject(args[i]); } } function.process(args); }
public Collection<NodeBase> getNodes() { return nodesByName.values(); }
@SuppressWarnings("PMD.PrematureDeclaration") @Override public String preProcess(String template) throws TemplateProcessingException { String newTemplate = super.preProcess(template); if (inSectionSymbol) { throw new TemplateProcessingException("The template is invalid since a section has not been closed"); } newTemplate = newTemplate.replaceAll(DOUBLE_OPEN_BRACE_PATTERN, MUSTACHE_OPEN_DELIMITER); newTemplate = newTemplate.replaceAll(DOUBLE_CLOSE_BRACE_PATTERN, MUSTACHE_CLOSE_DELIMITER); return newTemplate; }
@Override public boolean apply(SafeMap reportFields) { return CENTCHROMAN_FP_METHOD_VALUE.equalsIgnoreCase(reportFields.get(CURRENT_FP_METHOD_FIELD_NAME)); }
protected final void redef(String name, Parser parser) { if (!parsers.containsKey(name)) { throw new IllegalStateException("Undefined production: " + name); } parsers.put(Objects.requireNonNull(name), Objects.requireNonNull(parser)); }
@Override public CounterUpdate aggregate(List<CounterUpdate> counterUpdates) { if (counterUpdates == null || counterUpdates.isEmpty()) { return null; } if (counterUpdates.stream().anyMatch(c -> c.getDistribution() == null)) { throw new UnsupportedOperationException( "Aggregating DISTRIBUTION counter updates over non-distribution type is not implemented."); } CounterUpdate initial = counterUpdates.remove(0); return counterUpdates.stream() .reduce( initial, (first, second) -> first.setDistribution( new DistributionUpdate() .setCount( longToSplitInt( splitIntToLong(first.getDistribution().getCount()) + splitIntToLong(second.getDistribution().getCount()))) .setMax( longToSplitInt( Math.max( splitIntToLong(first.getDistribution().getMax()), splitIntToLong(second.getDistribution().getMax())))) .setMin( longToSplitInt( Math.min( splitIntToLong(first.getDistribution().getMin()), splitIntToLong(second.getDistribution().getMin())))) .setSum( longToSplitInt( splitIntToLong(first.getDistribution().getSum()) + splitIntToLong(second.getDistribution().getSum()))))); }
public static HiveStatusPatchBuilder patchBuilder() { return new HiveStatusPatchBuilder(); }
public static <T> T parseValue( Class<T> klass, Object objectValue ) { return parseValue( klass, null, objectValue ); }
public boolean validate( DriverDef driverDef ) { return hasValue( driverDef.getUuid( ) ) && hasValue( driverDef.getName( ) ) && hasValue( driverDef.getDriverClass( ) ) && hasValue( driverDef.getArtifactId( ) ) && hasValue( driverDef.getGroupId( ) ) && hasValue( driverDef.getVersion( ) ); }
public Order getOrderById(Long orderId) throws ApiException { Object localVarPostBody = null; if (orderId == null) { throw new ApiException(400, "Missing the required parameter 'orderId' when calling getOrderById"); } String localVarPath = "/store/order/{order_id}" .replaceAll("\\{" + "order_id" + "\\}", apiClient.escapeString(orderId.toString())); List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { "application/xml", "application/json" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }
static ParseCommandLineArgsResult parseCommandLineArgs(String[] args) { final ServerOptions opts = new ServerOptions(); final CommandLine cli = new CommandLine(opts); try { cli.parseArgs(args); if (cli.isUsageHelpRequested()) { cli.usage(cli.getOut()); return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnUsageHelp()); } else if (cli.isVersionHelpRequested()) { cli.printVersionHelp(cli.getOut()); return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnVersionHelp()); } } catch (ParameterException ex) { cli.getErr().println(ex.getMessage()); if (!UnmatchedArgumentException.printSuggestions(ex, cli.getErr())) { ex.getCommandLine().usage(cli.getErr()); } return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnInvalidInput()); } catch (Exception ex) { ex.printStackTrace(cli.getErr()); return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnExecutionException()); } return new ParseCommandLineArgsResult(opts); }
public String typeName() { return getTypeNameMatcher().group(3); }
public boolean addLibraryFiles(final Project project, final HatchejModel hatchejModel) { boolean added = false; File ideaLibrariesDir = new File(project.getRootDir(), ".idea/libraries"); if (!ideaLibrariesDir.isDirectory() || !ideaLibrariesDir.exists()) { return added; } for (String dependency : hatchejModel.getLibraryDependencies()) { added |= createLibraryFileIfNotExists(ideaLibrariesDir, dependency); } return added; }
public ByteBuf getData() { return data; }
public int getPartition(K key, V value, int numReduceTasks) { int h = SEED ^ key.hashCode(); h ^= (h >>> 20) ^ (h >>> 12); h = h ^ (h >>> 7) ^ (h >>> 4); return (h & Integer.MAX_VALUE) % numReduceTasks; }
@Override public <T> ScheduledCompletableFuture<T> schedule(SchedulerRunnable runnable, TemporalAdjuster temporalAdjuster) { final ScheduledCompletableFutureRecurring<T> schedule = new ScheduledCompletableFutureRecurring<>(); schedule(schedule, runnable, temporalAdjuster); return schedule; }
void fieldBindingWarningToggle(final boolean isFieldBindingValid) { if (!isFieldBindingValid) { view.showFieldBindingWarning(); } else { view.hideFieldBindingWarning(); } }
public final static List<ItemCollection> parse(final InputStream jsonDataStream) throws ParseException, UnsupportedEncodingException { boolean isarray = false; List<ItemCollection> result = null; if (jsonDataStream == null) { return null; } JsonParser parser = Json.createParser(jsonDataStream); Event event = null; while (true) { try { event = parser.next(); if (event == null) { return null; } if (event.name().equals(Event.START_ARRAY.toString())) { isarray = true; continue; } if (event.name().equals(Event.KEY_NAME.toString())) { String jsonkey = parser.getString(); if (DATA_ELEMENT.equals(jsonkey)) { if (result != null) { JsonLocation location = parser.getLocation(); throw new ParseException( "Invalid JSON Data Structure - element 'data' not expected (line: " + location.getLineNumber() + " column: " + location.getColumnNumber() + ")", (int) location.getStreamOffset()); } else { result = new ArrayList<ItemCollection>(); } } if (ITEM_ELEMENT.equals(jsonkey)) { ItemCollection document = new ItemCollection(); parseDocument(parser, document); if (result == null) { result = new ArrayList<ItemCollection>(); } result.add(document); } } if (isarray && event.name().equals(Event.END_ARRAY.toString())) { break; } if (!isarray && event.name().equals(Event.END_OBJECT.toString())) { break; } } catch (NoSuchElementException e) { return null; } } return result; }
@Override public double dot(DoubleVector vector) { Preconditions.checkArgument(this.vector.length == vector.getDimension(), "Dimensions of two vectors do not equal."); return this.dotUnsafe(vector); }
public FileCacheBuilder setUserHome(File d) { this.userHome = d; return this; }
public static <S> S load(Class<S> service, ClassLoader loader) throws EnhancedServiceNotFoundException { return InnerEnhancedServiceLoader.getServiceLoader(service).load(loader); }
@Override public void putAll(Map<? extends K, ? extends V> map) { map.forEach(this::put); }
protected File getOutputFile(final String path, final String baseFileName) throws IOException { makeDir(path); final String now = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date()); final String fileName = baseFileName + "." + now; final File file = Paths.get(path, fileName).toFile(); if (!file.exists() && !file.createNewFile()) { throw new IOException("Fail to create file: " + file); } return file; }
public boolean isValid() { return idHi != INVALID_ID || idLo != INVALID_ID; }
public static String lowerCase(final String str) { if (str == null) { return null; } return str.toLowerCase(Locale.ENGLISH); }
public List findMessageByCpa(MessageDVO data, int numberOfMessage) throws DAOException { List parameters = new ArrayList(); String sql = super.getFinder("find_message_by_cpa"); parameters.add(data.getCpaId()); parameters.add(data.getService()); parameters.add(data.getAction()); if (data.getConvId() != null) { sql += " AND " + getFilter("find_message_by_cpa_filter_conv_id"); parameters.add(data.getConvId()); } if (data.getFromPartyId() != null) { sql += " AND " + getFilter("find_message_by_cpa_filter_from_party_id"); parameters.add(data.getFromPartyId()); } if (data.getFromPartyRole() != null) { sql += " AND " + getFilter("find_message_by_cpa_filter_from_party_role"); parameters.add(data.getFromPartyRole()); } if (data.getToPartyId() != null) { sql += " AND " + getFilter("find_message_by_cpa_filter_to_party_id"); parameters.add(data.getToPartyId()); } if (data.getToPartyRole() != null) { sql += " AND " + getFilter("find_message_by_cpa_filter_to_party_role"); parameters.add(data.getToPartyRole()); } sql += " " + getOrder("find_message_by_cpa_order"); parameters.add(new Integer(numberOfMessage)); return executeQuery(sql, parameters.toArray()); }
public String getDomainName(String environmentName, String accountName) { if (StringUtils.isEmpty(environmentName)) { LOGGER.error("The required parameters hasn't been specified, environment name: {}, account name: {}", environmentName, accountName); throw new IllegalStateException(ENV_NAME_SHOULD_BE_SPECIFIED_MSG); } if (StringUtils.isEmpty(accountName)) { LOGGER.error("The required parameters hasn't been specified, environment name: {}, account name: {}", environmentName, accountName); throw new IllegalStateException(String.format(ACCOUNT_NAME_IS_EMTPY_FORMAT, environmentName)); } LOGGER.info("Generating domain with environment name: '{}', account name: '{}' and root domain: '{}'", environmentName, accountName, rootDomain); StringBuilder sb = new StringBuilder() .append(truncateEnvironment(environmentName)) .append(DOMAIN_PART_DELIMITER) .append(accountName); if (!rootDomain.startsWith(DOMAIN_PART_DELIMITER)) { sb = sb.append(DOMAIN_PART_DELIMITER); } String result = sb.append(rootDomain).toString(); validateDomainPattern(result); LOGGER.info("Generated domain: '{}'", result); return result; }
public String getProxyHost() { if (proxyHost != null) { return proxyHost; } else if (getProxyHostProperty() != null) { return getProxyHostProperty(); } else { return getProxyHostEnvironment(); } }
public static long addClamped(long a, long b) { long sum = a + b; return sumHadOverflow(a, b, sum) ? (a >= 0 ? Long.MAX_VALUE : Long.MIN_VALUE) : sum; }
@Override public final Policy getPolicy(final String name) throws PolicyManagerException { LOGGER.debug("getting policy by name: {}", name); try { return super.get(name); } catch (DBManagerException e) { throw new PolicyManagerException(e); } }
@Override public void validate(Object target, Errors errors) { LOG.debug("Start validation for: {}", target); SecHubConfiguration configuration = (SecHubConfiguration) target; validateAPI(configuration, errors); validateAtLeastOneScanConfiguration(configuration, errors); validateWebScan(configuration, errors); validateInfraScan(configuration, errors); if (errors.hasErrors()) { List<ObjectError> objectErrors = errors.getAllErrors(); for (ObjectError error : objectErrors) { LOG.info("Rejected sechub configuration from user:{}. Reason: {}", userContextService.getUserId(), error.getDefaultMessage()); } } }
@Override public Set<QueryContext> selectQueries(final FinishedLensQuery finishedQuery, final EstimatedImmutableQueryCollection waitingQueries) { String user = finishedQuery.getSubmitter(); return waitingQueries.getQueries(user); }
@Override public void close() throws FileSystemException { fileContent.close(); }
@Override protected void setReadOnly(boolean readOnly) { widget.setReadOnly(readOnly); }
public Map<InstanceGroupType, String> buildUserData(Platform cloudPlatform, byte[] cbSshKeyDer, String sshUser, PlatformParameters parameters, String saltBootPassword, String cbCert, CcmParameters ccmParameters, ProxyConfig proxyConfig) { Map<InstanceGroupType, String> result = new EnumMap<>(InstanceGroupType.class); for (InstanceGroupType type : InstanceGroupType.values()) { String userData = build(type, cloudPlatform, cbSshKeyDer, sshUser, parameters, saltBootPassword, cbCert, ccmParameters, proxyConfig); result.put(type, userData); LOGGER.debug("User data for {}, content; {}", type, userData); } return result; }
public String getMimeType() { return mimeType; }
@Override public int hashCode() { return _observer.hashCode(); }
public void setClassToId(final Map<Class<?>, String> classToId) { Map<String, Class<?>> reverseMap = new HashMap<String, Class<?>>(); for (Map.Entry<Class<?>, String> entry : classToId.entrySet()) { Assert.notNull(entry.getKey(), "Class cannot be null: " + entry); Assert.hasText(entry.getValue(), "Alias (id) cannot be null or contain only whitespaces" + entry); if (reverseMap.put(entry.getValue(), entry.getKey()) != null) { throw new IllegalArgumentException("Two or more classes with the same alias (id): " + entry.getValue()); } } this.classToId = classToId; this.idToClass = reverseMap; }
public void addParameter(String key, String val) { Parameter p = new Parameter(key, val); this.parameters.add(p); this.paramLookup.put(p.getParameterName(), p); }
@Override public boolean add(Workflow element) { if (element == null) { throw new IllegalArgumentException("Null workflow element"); } return workflows.add(register(element)); }
public List<? extends TextEdit> format(TextDocument textDocument, Range range, SharedSettings sharedSettings) { try { XMLFormatterDocument formatterDocument = new XMLFormatterDocument(textDocument, range, sharedSettings); return formatterDocument.format(); } catch (BadLocationException e) { LOGGER.log(Level.SEVERE, "Formatting failed due to BadLocation", e); } return null; }
public <T extends Enum<T> & LogMessage> Destination<T> configureDestination() throws UncheckedIOException { try { StackTraceProcessor stackTraceProcessor = this.configureStackTraceProcessor(); if (logfilePath.isPresent()) { if (!Files.isSymbolicLink(logfilePath.get().getParent())) { Files.createDirectories(logfilePath.get().getParent()); } FileChannelProvider provider = new FileChannelProvider(logfilePath.get()); ActiveRotationRegistry registry = ActiveRotationRegistry.getSingletonInstance(); return registry.add(new PathDestination<>(provider, stackTraceProcessor, registry)); } return new OutputStreamDestination<>(loggerOutput.orElse(System.out), stackTraceProcessor); } catch (IOException e) { throw new UncheckedIOException(e); } }
@Override public void setMessageCompression(boolean enable) { delegate().setMessageCompression(enable); }
public boolean isProcessedChangeSet(long changeSetId) { return changeSetId <= lastProcessedChangeSetId; }
public Class<?> findNearestAssignableFrom(Class<?> clazz) { if ((clazz == Object.class) || (clazz == null)) { return null; } if (classes.contains(clazz)) { return clazz; } for (Class<?> interfaceClass : clazz.getInterfaces()) { Class<?> classFound = findNearestAssignableFrom(interfaceClass); if (classFound != null) { return classFound; } } return findNearestAssignableFrom(clazz.getSuperclass()); }
public static Product create(String json) throws JSONException { return create(new JSONObject(json)); }
@Override public Optional<OrganisationResource> getOrganisationForUser(long userId, List<ProcessRoleResource> userApplicationRoles) { return userApplicationRoles.stream() .filter(uar -> uar.getUser().equals(userId)) .filter(uar -> uar.getOrganisationId() != null) .map(uar -> organisationRestService.getOrganisationById(uar.getOrganisationId()).getOptionalSuccessObject()) .filter(Optional::isPresent) .map(Optional::get) .findFirst(); }
@Override public String getString(int variableIndex) { ensureState(); return getString(getVariableAt(variableIndex)); }
public void deleteSdxClustersForEnvironment(PollingConfig pollingConfig, Environment environment, boolean force) { Set<String> sdxCrnsOrDatalakeName = environmentResourceDeletionService.getAttachedSdxClusterCrns(environment); boolean legacySdxEndpoint = false; if (sdxCrnsOrDatalakeName.isEmpty()) { sdxCrnsOrDatalakeName = environmentResourceDeletionService.getDatalakeClusterNames(environment); legacySdxEndpoint = true; } LOGGER.info("Found {} Data Lake clusters for environment {}.", sdxCrnsOrDatalakeName.size(), environment.getName()); if (sdxCrnsOrDatalakeName.isEmpty()) { LOGGER.info("No Data Lake clusters found for environment."); } else { waitSdxClustersDeletion(pollingConfig, environment, sdxCrnsOrDatalakeName, legacySdxEndpoint, force); LOGGER.info("Data Lake deletion finished."); } }
public void setMappings(List<Map<Integer, Integer>> mappings) { this.mappings = mappings; }
@Override @WorkerThread public void findBestPackage(@NonNull PackageFoundCallback packageFoundCallback, Context context) { Runnable findBestPackageTask = findBestPackageTask(packageFoundCallback, context); executor.execute(findBestPackageTask); }
public int[] getArray() { return this.array.clone(); }
@Override public boolean equals(final Object obj) { if (obj instanceof MessageNumberSet) { final MessageNumberSet o = (MessageNumberSet) obj; return (o.seqType == seqType) && (start == o.start) && (end == o.end); } return false; }
@Override public boolean isValidForFieldType(Type fieldType) { return IntegerType.TYPE.equals(fieldType) || DoubleType.TYPE.equals(fieldType) || BigDecimalType.TYPE.equals(fieldType) || BigIntegerType.TYPE.equals(fieldType); }
public boolean matchHivePolicy(String resourceName, List<XXResource> xResourceList, Long xUserId, int permission) { return matchHivePolicy(resourceName, xResourceList, xUserId, permission, 0, 0, true); }
@Override public void handleEvent( ManagedApplication ma, MsgNotifAutonomic event ) { try { this.logger.fine( "Autonomic event '" + event.getEventName() + "' is about to be recorded." ); AutonomicApplicationContext ctx = this.appNameToContext.get( ma.getName()); if( ctx == null ) { this.logger.fine( "No autonomic context was found for application " + ma.getApplication() + "." ); } else { ctx.registerEvent( event.getEventName()); List<Rule> rulesToExecute = ctx.findRulesToExecute(); if( rulesToExecute.isEmpty()) { this.logger.fine( "No rule was found after the event '" + event.getEventName() + "' occurred." ); } else { String strictMaxVmAS = this.preferencesMngr.get( IPreferencesMngr.AUTONOMIC_STRICT_MAX_VM_NUMBER, "true" ); boolean strictMaxVm = Boolean.parseBoolean( strictMaxVmAS ); String maxVmCountAS = this.preferencesMngr.get( IPreferencesMngr.AUTONOMIC_MAX_VM_NUMBER, "" + Integer.MAX_VALUE ); int maxVmCount = Integer.parseInt( maxVmCountAS ); if( maxVmCount < 0 ) maxVmCount = Integer.MAX_VALUE; if( maxVmCount <= this.autonomicVmCount.get()) strictMaxVm = true; CommandExecutionContext execCtx = new CommandExecutionContext( this.autonomicVmCount, ctx.getVmCount(), maxVmCount, strictMaxVm, AUTONOMIC_MARKER, "" ); for( Rule rule : rulesToExecute ) { this.logger.fine( "Applying rule '" + rule.getRuleName() + "' for event '" + event.getEventName() + "'." ); ctx.recordPreExecution( rule.getRuleName()); for( String commandName : rule.getCommandsToInvoke()) this.commandsMngr.execute( ma.getApplication(), commandName, execCtx, CommandHistoryItem.ORIGIN_AUTONOMIC, rule.getRuleName()); } } } } catch( Exception e ) { this.logger.warning( "An autonomic event could not be handled. " + e.getMessage()); Utils.logException( this.logger, e ); } }
public static <T> Set<T> symmetricDifference(Set<? extends T> s1, Set<? extends T> s2) { Set<T> s3 = new HashSet<>() ; s1.forEach(x -> { if ( !s2.contains(x) ) s3.add(x) ; }) ; s2.forEach(x -> { if ( !s1.contains(x) ) s3.add(x) ; }) ; return s3 ; }
@Override public synchronized void start() { if (scheduler != null) { throw new IllegalStateException("already started"); } scheduler = new Thread(delayedCommand, "Timeout"); scheduler.start(); }
@Override public List<Study> findByCriteria(String criteria, boolean isCaseSens) { return studyDAO.findByCriteria(criteria, isCaseSens); }
@Override public void onKeyDown(final KeyDownEvent event) { final GridWidget selectedGridWidget = getSelectedGridWidget(); if (selectedGridWidget == null) { return; } final KeyboardOperation operation = getOperation(event); if (operation == null) { return; } if (!operation.isExecutable(selectedGridWidget)) { return; } flushDOMElements(selectedGridWidget); final boolean redraw = operation.perform(selectedGridWidget, event.isShiftKeyDown(), event.isControlKeyDown()); event.preventDefault(); event.stopPropagation(); if (redraw) { gridLayer.draw(); } }
@Override public String toString() { return MoreObjects.toStringHelper(this) .add("deadline", deadline) .add("authority", authority) .add("callCredentials", credentials) .add("executor", executor != null ? executor.getClass() : null) .add("compressorName", compressorName) .add("customOptions", Arrays.deepToString(customOptions)) .add("waitForReady", isWaitForReady()) .add("maxInboundMessageSize", maxInboundMessageSize) .add("maxOutboundMessageSize", maxOutboundMessageSize) .add("streamTracerFactories", streamTracerFactories) .toString(); }
public static boolean isNodeType(Tree tree, String typeName, Tree typeRoot) { String primaryName = TreeUtil.getName(tree, JCR_PRIMARYTYPE); if (typeName.equals(primaryName)) { return true; } else if (primaryName != null) { Tree type = typeRoot.getChild(primaryName); if (contains(getNames(type, REP_SUPERTYPES), typeName)) { return true; } } for (String mixinName : getNames(tree, JCR_MIXINTYPES)) { if (typeName.equals(mixinName)) { return true; } else { Tree type = typeRoot.getChild(mixinName); if (contains(getNames(type, REP_SUPERTYPES), typeName)) { return true; } } } return false; }
public ResponseEntity<String> onboardServiceAccount(String token, ServiceAccount serviceAccount, UserDetails userDetails) { List<String> onboardedList = getOnboardedServiceAccountList(token, userDetails); if (onboardedList.contains(serviceAccount.getName())) { log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, "Failed to onboard Service Account. Service account is already onboarded"). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Failed to onboard Service Account. Service account is already onboarded\"]}"); } List<ADServiceAccount> allServiceAccounts = getADServiceAccount(serviceAccount.getName()); if (allServiceAccounts == null || allServiceAccounts.isEmpty()) { return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Failed to onboard Service Account. Unable to read Service account details\"]}"); } if (TVaultConstants.EXPIRED.toLowerCase().equals(allServiceAccounts.get(0).getAccountStatus().toLowerCase())) { return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Failed to onboard Service Account. Service account expired\"]}"); } int maxPwdAge = allServiceAccounts.get(0).getMaxPwdAge(); serviceAccount.setOwner(allServiceAccounts.get(0).getOwner()); if (serviceAccount.isAutoRotate()) { log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Auto-Rotate of password has been turned on")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); if (null == serviceAccount.getMax_ttl()) { return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Invalid or no value has been provided for MAX_TTL\"]}"); } if (null == serviceAccount.getTtl()) { serviceAccount.setTtl(maxPwdAge - 1L); } if (serviceAccount.getTtl() > maxPwdAge) { log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Password Expiration Time [%s] is greater the Maximum expiration time (MAX_TTL) [%s]", serviceAccount.getTtl(), maxPwdAge)). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Invalid value provided for Password Expiration Time. This can't be more than "+maxPwdAge+" for this Service Account\"]}"); } if (serviceAccount.getTtl() > serviceAccount.getMax_ttl()) { log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Password Expiration Time [%s] is greater the Maximum expiration time (MAX_TTL) [%s]", serviceAccount.getTtl(), serviceAccount.getMax_ttl())). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Password Expiration Time can't be more than Maximum expiration time (MAX_TTL) for this Service Account\"]}"); } } else { log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Auto-Rotate of password has been turned off")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); serviceAccount.setTtl(TVaultConstants.MAX_TTL); } ResponseEntity<String> accountRoleCreationResponse = createAccountRole(token, serviceAccount); if(accountRoleCreationResponse.getStatusCode().equals(HttpStatus.OK)) { ResponseEntity<String> metadataCreationResponse = createMetadata(token, serviceAccount); if (HttpStatus.OK.equals(metadataCreationResponse.getStatusCode())) { log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Successfully created Metadata for the Service Account")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); } else { log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Successfully created Service Account Role. However creation of Metadata failed.")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.MULTI_STATUS).body("{\"errors\":[\"Successfully created Service Account Role. However creation of Metadata failed.\"]}"); } String svcAccName = serviceAccount.getName(); ResponseEntity<String> svcAccPolicyCreationResponse = createServiceAccountPolicies(token, svcAccName); if (HttpStatus.OK.equals(svcAccPolicyCreationResponse.getStatusCode())) { ServiceAccountUser serviceAccountUser = new ServiceAccountUser(svcAccName, serviceAccount.getOwner(), TVaultConstants.SUDO_POLICY); ResponseEntity<String> addUserToServiceAccountResponse = addUserToServiceAccount(token, serviceAccountUser, userDetails, true); if (HttpStatus.OK.equals(addUserToServiceAccountResponse.getStatusCode())) { log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Successfully completed onboarding of AD service account into TVault for password rotation.")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); String filterQuery = "(&(objectclass=user)(|(cn=" + serviceAccount.getOwner() + ")))"; List<ADUserAccount> managerDetails = getServiceAccountManagerDetails(filterQuery); if (!managerDetails.isEmpty() && !StringUtils.isEmpty(managerDetails.get(0).getUserEmail())) { String from = supportEmail; List<String> to = new ArrayList<>(); to.add(managerDetails.get(0).getUserEmail()); String mailSubject = String.format(subject, svcAccName); String groupContent = TVaultConstants.EMPTY; Map<String, String> mailTemplateVariables = new Hashtable<>(); mailTemplateVariables.put("name", managerDetails.get(0).getDisplayName()); mailTemplateVariables.put("svcAccName", svcAccName); if (serviceAccount.getAdGroup() != null && serviceAccount.getAdGroup() != "") { groupContent = String.format(mailAdGroupContent, serviceAccount.getAdGroup()); } mailTemplateVariables.put("groupContent", groupContent); mailTemplateVariables.put("contactLink", supportEmail); emailUtils.sendHtmlEmalFromTemplate(from, to, mailSubject, mailTemplateVariables); } return ResponseEntity.status(HttpStatus.OK).body("{\"messages\":[\"Successfully completed onboarding of AD service account into TVault for password rotation.\"]}"); } else { log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Successfully created Service Account Role and policies. However the association of owner information failed.")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.MULTI_STATUS).body("{\"messages\":[\"Successfully created Service Account Role and policies. However the association of owner information failed.\"]}"); } } else { log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Failed to onboard AD service account into TVault for password rotation.")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); OnboardedServiceAccount serviceAccountToRevert = new OnboardedServiceAccount(serviceAccount.getName(),serviceAccount.getOwner()); ResponseEntity<String> accountRoleDeletionResponse = deleteAccountRole(token, serviceAccountToRevert); if (accountRoleDeletionResponse!=null && HttpStatus.OK.equals(accountRoleDeletionResponse.getStatusCode())) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("{\"errors\":[\"Failed to onboard AD service account into TVault for password rotation.\"]}"); } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("{\"errors\":[\"Failed to create Service Account policies. Revert service account role creation failed.\"]}"); } } } else { log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "onboardServiceAccount"). put(LogMessage.MESSAGE, String.format ("Failed to onboard AD service account into TVault for password rotation.")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Failed to onboard AD service account into TVault for password rotation.\"]}"); } }
String convertRangeUnit(APIEnums.Units unitsIn) throws ParameterValueException { DistanceUnit units; try { units = DistanceUnitUtil.getFromString(unitsIn.toString(), DistanceUnit.UNKNOWN); if (units == DistanceUnit.UNKNOWN) throw new ParameterValueException(IsochronesErrorCodes.INVALID_PARAMETER_VALUE, IsochronesRequest.PARAM_RANGE_UNITS, unitsIn.toString()); } catch (Exception e) { throw new ParameterValueException(IsochronesErrorCodes.INVALID_PARAMETER_VALUE, IsochronesRequest.PARAM_RANGE_UNITS, unitsIn.toString()); } return DistanceUnitUtil.toString(units); }
@Override public List filterResults(List results) { if (results.size() > 0 && results.get(0).getClass().isArray()) { List<AttachmentReference> attachmentReferences = new ArrayList<>(); for (Object result : results) { Object[] actualResult = (Object[]) result; String documentFullName = String.valueOf(actualResult[0]); String attachmentFileName = String.valueOf(actualResult[1]); DocumentReference documentReference = this.documentReferenceResolver.resolve(documentFullName); attachmentReferences.add(new AttachmentReference(attachmentFileName, documentReference)); } return attachmentReferences; } return results; }
@JsonIgnore @Override public String getEntityType() { return EntityIdValue.ET_SENSE; }
public String removeString(int size, String encoding) throws NotEnoughDataInByteBufferException, UnsupportedEncodingException { int len = length(); if (len < size) { throw new NotEnoughDataInByteBufferException(len, size); } UnsupportedEncodingException encodingException = null; String result = null; if (len > 0) { try { if (encoding != null) { result = new String(buffer, 0, size, encoding); } else { result = new String(buffer, 0, size); } } catch (UnsupportedEncodingException e) { debug.write("Unsupported encoding exception " + e); event.write(e, null); encodingException = e; } removeBytes0(size); } else { result = new String(""); } if (encodingException != null) { throw encodingException; } return result; }
@Override public void processNotification(@Nonnull final Long notificationId, @Nonnull final Map<String, String> secureProperties) { Assert.notNull(notificationId, "Notification id should not be null"); Assert.notNull(secureProperties, "Secure properties map should not be null"); LOGGER.debug("Processing notification with id - {}", notificationId); final Notification notification = notificationService.getNotificationById(notificationId); final NotificationProcessor notificationProcessor = getNotificationProcessorForType(notification.getType()); notificationProcessor.processNotification(notification.getId(), secureProperties); LOGGER.debug("Successfully processed notification with id - {}, notification - {}", notificationId, notification); }
@Override public void validate(Object target, Errors errors) { @SuppressWarnings("unchecked") T attributeType = (T) target; if (attributeType == null) { errors.reject("error.general"); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, "name", "error.name"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, "minOccurs", "error.null"); Integer minOccurs = attributeType.getMinOccurs(); Integer maxOccurs = attributeType.getMaxOccurs(); if (minOccurs != null && minOccurs < 0) { errors.rejectValue("minOccurs", "AttributeType.minOccursShouldNotBeLessThanZero"); } if (maxOccurs != null) { if (maxOccurs < 1) { errors.rejectValue("maxOccurs", "AttributeType.maxOccursShouldNotBeLessThanOne"); } else if (maxOccurs < minOccurs) { errors.rejectValue("maxOccurs", "AttributeType.maxOccursShouldNotBeLessThanMinOccurs"); } } if (StringUtils.isBlank(attributeType.getDatatypeClassname())) { errors.rejectValue("datatypeClassname", "error.null"); } else { try { CustomDatatype<?> datatype = CustomDatatypeUtil.getDatatype(attributeType); if (datatype instanceof RegexValidatedTextDatatype && StringUtils.isBlank(attributeType.getDatatypeConfig())) { errors.rejectValue("datatypeConfig", "error.null"); } } catch (Exception ex) { errors.rejectValue("datatypeConfig", "AttributeType.datatypeConfig.invalid", new Object[] { ex .getMessage() }, "Invalid"); } } if (StringUtils.isNotEmpty(attributeType.getPreferredHandlerClassname())) { try { CustomDatatype<?> datatype = CustomDatatypeUtil.getDatatype(attributeType); CustomDatatypeHandler<?, ?> handler = CustomDatatypeUtil.getHandler(attributeType); if (!CustomDatatypeUtil.isCompatibleHandler(handler, datatype)) { errors.rejectValue("preferredHandlerClassname", "AttributeType.preferredHandlerClassname.wrongDatatype"); } } catch (Exception ex) { errors.rejectValue("handlerConfig", "AttributeType.handlerConfig.invalid", new Object[] { ex .getMessage() }, "Invalid"); } } ValidateUtil.validateFieldLengths(errors, target.getClass(), "datatypeConfig", "handlerConfig"); } }
@Nonnull public static String capitalizeFirstLetter( @Nonnull String data ) { char firstChar = data.charAt( 0 ); char titleCase = Character.toTitleCase( firstChar ); if ( firstChar == titleCase ) { return data; } StringBuilder result = new StringBuilder( data.length() ); result.append( titleCase ); result.append( data, 1, data.length() ); return result.toString(); }
public static boolean test(TransposeDataList transposeDataList, boolean is_twoTailed, double aLevel) { if(transposeDataList.isEmpty()) { return false; } double SpearmanCorrelation= calculateCorrelation(transposeDataList); Object firstKey = transposeDataList.keySet().iterator().next(); int n=transposeDataList.get(firstKey).size(); double pvalue = scoreToPvalue(SpearmanCorrelation,n); boolean rejectH0=false; double a=aLevel; if(is_twoTailed) { a=aLevel/2; } if(pvalue<=a || pvalue>=(1-a)) { rejectH0=true; } return rejectH0; }
public static void validate(String name) { Preconditions.checkArgument( VALID_PACKAGE.matcher(name).matches(), "Conjure package names must match pattern %s: %s", VALID_PACKAGE.pattern(), name); }
public static UVariableDecl create( CharSequence identifier, UExpression type, @Nullable UExpression initializer) { return new AutoValue_UVariableDecl(StringName.of(identifier), type, initializer); }
static int indexOfHetro(int[] cycle, int[] contribution) { int index = -1; for (int i = 0; i < cycle.length - 1; i++) { if (contribution[cycle[i]] == 2) index = index == -1 ? i : -2; } return index; }
@Override public String convertValue(String value) { if (valid) { try { if (inputFormatter == null) { if (isInputUnixTimestamp(value)) { long lValue = Long.parseLong(value); lValue *= 1000; return outputFormatter.print(lValue); } else { long lValue = Long.parseLong(value); return outputFormatter.print(lValue); } } DateTime dt = inputFormatter.parseDateTime(value); return outputFormatter.print(dt); } catch (IllegalInstantException e) { if ((inputTimezone == null && !JodaUtils.formatContainsTime(this.inputDateFormat)) && outputFormat == OutputFormats.DATE_ONLY) { DateTime dt = LocalDate.parse(value, inputFormatter).toDateTimeAtStartOfDay(); return outputFormatter.print(dt); } else { throw e; } } catch (IllegalArgumentException e) { log.debug("Failed to convert string [{}] to date pattern [{}], value, inputDateFormat"); } } return value; }
public void generateReport(final AllScenariosPageCollection allScenariosPageCollection) throws CluecumberPluginException { String reportDirectory = propertyManager.getGeneratedHtmlReportDirectory(); createDirectories(reportDirectory); copyStaticReportAssets(reportDirectory); copyCustomCss(reportDirectory); boolean redirectToFirstScenarioPage = propertyManager.getStartPage() == PluginSettings.StartPage.ALL_SCENARIOS && allScenariosPageCollection.getTotalNumberOfScenarios() == 1; generateStartPage(redirectToFirstScenarioPage); for (PageVisitor visitor : visitors) { allScenariosPageCollection.accept(visitor); } }
@Override public final ListenableFuture<Boolean> render(OutputStream stream, RESPONSE response, Execution execution, Request request) { if (beforeHandoverMode) { beforeHandoverMode = false; if ( ! dataListListenerStack.isEmpty() && dataListListenerStack.getFirst().list.incoming().isComplete()) { getExecutor().execute(dataListListenerStack.getFirst()); } return success; } else { return startRender(stream, response, execution, request); } }
@Override public Optional<String> getStringSecret(final SecretIdentifier secretIdentifier) { return asString(secretsGroup.getLatestActiveVersion(secretIdentifier)); }
public String getName() { if (mainModule != null) { final String moduleName = mainModule.getModuleName(); if (moduleName != null && !mainModule.getModuleName().trim().isEmpty()) { return mainModule.getModuleName(); } else { return repository.getAlias(); } } else { return repository.getAlias(); } }
@Override public CompletableFuture<Optional<ConsumerAssignment>> getConsumerAssignment( String clusterId, String consumerGroupId, String consumerId, String topicName, int partitionId ) { return listConsumerAssignments(clusterId, consumerGroupId, consumerId) .thenApply( assignments -> assignments.stream() .filter(assignment -> assignment.getTopicName().equals(topicName)) .filter(assignment -> assignment.getPartitionId() == partitionId) .findAny()); }
public <T extends Enum<T>> TableLineBuilder withEnumCount( String statName, Map<T, Integer> countByEnum, Class<T> clazz) { for (T enumValue : clazz.getEnumConstants()) { withInt( enumValue.toString() + "_" + statName, countByEnum.getOrDefault(enumValue, 0)); } return this; }
public boolean configure( final PreviewPane reportPane ) { reportPane.setClosed( true ); return true; }
protected String registerProcessingNode(final String protocol, final String host, final int servicePort, final int adminPort, final SPQRResourceManagerClient client) throws RequiredInputMissingException, RemoteClientConnectionFailedException, IOException { if(StringUtils.isBlank(protocol)) throw new RequiredInputMissingException("Missing require communication protocol used by resource manager for accessing this node. See 'protocol' property in config file."); if(StringUtils.isBlank(host)) throw new RequiredInputMissingException("Missing required host name used by resource manager for accessing this node. See 'host' property in config file."); if(servicePort < 1) throw new RequiredInputMissingException("Missing required service port used by resource manager for accessing this node. See 'servicePort' property in config file."); if(adminPort < 1) throw new RequiredInputMissingException("Missing required admin port used by resource manager for accessing this node. See 'adminPort' property in config file."); final NodeRegistrationResponse registrationResponse = client.registerNode(protocol, host, servicePort, adminPort); if(registrationResponse == null) throw new RemoteClientConnectionFailedException("Failed to connect with resource manager. Error: no response received"); if(registrationResponse.getState() != NodeRegistrationState.OK) throw new RemoteClientConnectionFailedException("Failed to register processing node with resource manage. Reason: " + registrationResponse.getState() + ". Message: " + registrationResponse.getMessage()); return registrationResponse.getId(); }
public int[][] intMatrix() { return intMatrix(table.numericColumns()); }
public static HashMap<String, Integer> retrieveTags (Note note) { HashMap<String, Integer> tagsMap = new HashMap<>(); String[] words = (note.getTitle() + " " + note.getContent()).replaceAll("\n", " ").trim().split(" "); for (String word : words) { String parsedHashtag = UrlCompleter.parseHashtag(word); if (StringUtils.isNotEmpty(parsedHashtag)) { int count = tagsMap.get(parsedHashtag) == null ? 0 : tagsMap.get(parsedHashtag); tagsMap.put(parsedHashtag, ++count); } } return tagsMap; }
public static Response updateMetadataOnSvcaccPwdReset(Map<String,String> params,String token){ log.debug(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "updateMetadata"). put(LogMessage.MESSAGE, String.format ("Trying to upate metadata on Service account password reset")). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); String _type = params.get("type"); String value = params.get("value"); String path = params.get("path"); path = "metadata/"+path; ObjectMapper objMapper = new ObjectMapper(); String pathjson ="{\"path\":\""+path+"\"}"; Response metadataResponse = reqProcessor.process("/read",pathjson,token); Map<String,Object> _metadataMap = null; if(HttpStatus.OK.equals(metadataResponse.getHttpstatus())){ try { _metadataMap = objMapper.readValue(metadataResponse.getResponse(), new TypeReference<Map<String,Object>>() {}); } catch (IOException e) { log.error(e); log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "updateMetadata"). put(LogMessage.MESSAGE, String.format ("Error creating _metadataMap for type [%s] and path [%s] message [%s]", _type, path, e.getMessage())). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); } @SuppressWarnings("unchecked") Map<String,Object> metadataMap = (Map<String,Object>) _metadataMap.get("data"); @SuppressWarnings("unchecked") boolean initialPasswwordReset = (boolean) metadataMap.get(_type); if(StringUtils.isEmpty(initialPasswwordReset) || !initialPasswwordReset) { metadataMap.put(_type, true); String metadataJson = ""; try { metadataJson = objMapper.writeValueAsString(metadataMap); } catch (JsonProcessingException e) { log.error(e); log.error(JSONUtil.getJSON(ImmutableMap.<String, String>builder(). put(LogMessage.USER, ThreadLocalContext.getCurrentMap().get(LogMessage.USER).toString()). put(LogMessage.ACTION, "updateMetadata"). put(LogMessage.MESSAGE, String.format ("Error in creating metadataJson for type [%s] and path [%s] with message [%s]", _type, path, e.getMessage())). put(LogMessage.APIURL, ThreadLocalContext.getCurrentMap().get(LogMessage.APIURL).toString()). build())); } String writeJson = "{\"path\":\""+path+"\",\"data\":"+ metadataJson +"}"; metadataResponse = reqProcessor.process("/write",writeJson,token); return metadataResponse; } return metadataResponse; } return null; }
@Override public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(final DataSourceAnalysis analysis) { final TableDataSource tableDataSource = analysis.getBaseTableDataSource() .orElseThrow(() -> new ISE("Cannot handle datasource: %s", analysis.getDataSource())); synchronized (lock) { return Optional.ofNullable(timelines.get(tableDataSource.getName())); } }
public void release() { if (pooledByteBuffer != null) { LOGGER.trace("Releasing pooledBuffer {}", pooledByteBuffer); pooledByteBuffer.release(); pooledByteBuffer = null; } }
public double probability(double theta, double[] iparam, int category, double D){ double t = numer(theta, iparam, category, D); double b = denom(theta, iparam, D); return t/b; }
@Override public String toString(Type type, T value, Map<String, String> attributes) { requireNonNull(type, "type cannot be null"); if (value == null) { return null; } try { ObjectWriter objectWriter = objectMapper.writer(); return objectWriter.writeValueAsString(value); } catch (JsonProcessingException e) { throw new UncheckedIOException("Unable to process JSON.", e); } }
public String name() { return name; }
@Override public DeleteConsumerGroupOffsetsResult deleteConsumerGroupOffsets( String groupId, Set<TopicPartition> partitions, DeleteConsumerGroupOffsetsOptions options) { final KafkaFutureImpl<Map<TopicPartition, Errors>> future = new KafkaFutureImpl<>(); if (groupIdIsUnrepresentable(groupId)) { future.completeExceptionally(new InvalidGroupIdException("The given group id '" + groupId + "' cannot be represented in a request.")); return new DeleteConsumerGroupOffsetsResult(future, partitions); } final long startFindCoordinatorMs = time.milliseconds(); final long deadline = calcDeadlineMs(startFindCoordinatorMs, options.timeoutMs()); ConsumerGroupOperationContext<Map<TopicPartition, Errors>, DeleteConsumerGroupOffsetsOptions> context = new ConsumerGroupOperationContext<>(groupId, options, deadline, future); Call findCoordinatorCall = getFindCoordinatorCall(context, () -> getDeleteConsumerGroupOffsetsCall(context, partitions)); runnable.call(findCoordinatorCall, startFindCoordinatorMs); return new DeleteConsumerGroupOffsetsResult(future, partitions); }
public String getQuery() { return query; }
public Mono<Optional<SchemaVersion>> getCurrentSchemaVersion() { return cassandraAsyncExecutor.executeRows(readVersionStatement.bind()) .map(row -> row.getInt(VALUE)) .reduce(Math::max) .map(SchemaVersion::new) .map(Optional::of) .defaultIfEmpty(Optional.empty()); }
@Override public List<FileFilter> getFileFilters() { return Collections.unmodifiableList(this.fileFilters); }
@Override public boolean matches(IAtom atom) { return invariants(atom).connectivity() == connectivity; }
public void init(int apiVersion) { if (apiVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) { setupLifecycleCallbacks(); } }
public Object dequeue() { synchronized (mutex) { Object first = null; if (size() > 0) { first = queueData.removeFirst(); } return first; } }
@RequestMapping(path = "/v1/patching/detail", method = RequestMethod.POST) public ResponseEntity<Object> getPatchingDetails(@RequestBody(required = true) Request request) { ResponseWithCount response = null; String assetGroup = request.getAg(); if (Strings.isNullOrEmpty(assetGroup)) { return ResponseUtils.buildFailureResponse(new Exception(ASSET_MANDATORY)); } int from = request.getFrom(); int size = request.getSize(); if (from < 0) { return ResponseUtils.buildFailureResponse(new Exception("From should not be a negative number")); } String searchText = request.getSearchtext(); Map<String, String> filter = request.getFilter(); try { List<Map<String, Object>> masterDetailList = patchingService.getPatchingDetails(assetGroup, filter); masterDetailList = (List<Map<String, Object>>) patchingService.filterMatchingCollectionElements( masterDetailList, searchText, true); if (masterDetailList.isEmpty()) { return ResponseUtils.buildSucessResponse(new ArrayList<Map<String, Object>>()); } if (from >= masterDetailList.size()) { return ResponseUtils.buildFailureResponse(new ServiceException("From exceeds the size of list")); } int endIndex = 0; if ((from + size) > masterDetailList.size()) { endIndex = masterDetailList.size(); } else { endIndex = from + size; } if (endIndex == 0) { endIndex = masterDetailList.size(); } List<Map<String, Object>> subDetailList = masterDetailList.subList(from, endIndex); response = new ResponseWithCount(subDetailList, masterDetailList.size()); } catch (ServiceException e) { LOGGER.error(PATCHING_EXCEPTION, e.getMessage()); return complianceService.formatException(e); } return ResponseUtils.buildSucessResponse(response); }
@Override public void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response) throws IOException, ServletException { ResourceResolver rr = request.getResourceResolver(); Parameters params = new Parameters(request); if (params.containsPath()) { Writer writer = response.getWriter(); response.setContentType("text/csv"); response.setCharacterEncoding("UTF-8"); if (params.isLocalized()) { writer.write(tagsExportService.exportLocalizedTagsForPath(params.getPath(), rr, params.getDefaultLocalization())); } else { writer.write(tagsExportService.exportNonLocalizedTagsForPath(params.getPath(), rr)); } } else { log.warn("Cannot generate tag CSV file, missing 'path' parameter in request."); } }
public Object getAsJavaType( String valueName, Class<?> destinationType, InjectionTypeConverter converter ) throws HopValueException { int idx = rowMeta.indexOfValue( valueName ); if ( idx < 0 ) { throw new HopValueException( "Unknown column '" + valueName + "'" ); } IValueMeta metaType = rowMeta.getValueMeta( idx ); switch ( metaType.getType() ) { case IValueMeta.TYPE_STRING: String vs = rowMeta.getString( data, idx ); return getStringAsJavaType( vs, destinationType, converter ); case IValueMeta.TYPE_BOOLEAN: Boolean vb = rowMeta.getBoolean( data, idx ); if ( String.class.isAssignableFrom( destinationType ) ) { return converter.boolean2string( vb ); } else if ( int.class.isAssignableFrom( destinationType ) ) { return converter.boolean2intPrimitive( vb ); } else if ( Integer.class.isAssignableFrom( destinationType ) ) { return converter.boolean2integer( vb ); } else if ( long.class.isAssignableFrom( destinationType ) ) { return converter.boolean2longPrimitive( vb ); } else if ( Long.class.isAssignableFrom( destinationType ) ) { return converter.boolean2long( vb ); } else if ( boolean.class.isAssignableFrom( destinationType ) ) { return converter.boolean2booleanPrimitive( vb ); } else if ( Boolean.class.isAssignableFrom( destinationType ) ) { return converter.boolean2boolean( vb ); } else if ( destinationType.isEnum() ) { return converter.boolean2enum( destinationType, vb ); } else { throw new RuntimeException( "Wrong value conversion to " + destinationType ); } case IValueMeta.TYPE_INTEGER: Long vi = rowMeta.getInteger( data, idx ); if ( String.class.isAssignableFrom( destinationType ) ) { return converter.integer2string( vi ); } else if ( int.class.isAssignableFrom( destinationType ) ) { return converter.integer2intPrimitive( vi ); } else if ( Integer.class.isAssignableFrom( destinationType ) ) { return converter.integer2integer( vi ); } else if ( long.class.isAssignableFrom( destinationType ) ) { return converter.integer2longPrimitive( vi ); } else if ( Long.class.isAssignableFrom( destinationType ) ) { return converter.integer2long( vi ); } else if ( boolean.class.isAssignableFrom( destinationType ) ) { return converter.integer2booleanPrimitive( vi ); } else if ( Boolean.class.isAssignableFrom( destinationType ) ) { return converter.integer2boolean( vi ); } else if ( destinationType.isEnum() ) { return converter.integer2enum( destinationType, vi ); } else { throw new RuntimeException( "Wrong value conversion to " + destinationType ); } case IValueMeta.TYPE_NUMBER: Double vn = rowMeta.getNumber( data, idx ); if ( String.class.isAssignableFrom( destinationType ) ) { return converter.number2string( vn ); } else if ( int.class.isAssignableFrom( destinationType ) ) { return converter.number2intPrimitive( vn ); } else if ( Integer.class.isAssignableFrom( destinationType ) ) { return converter.number2integer( vn ); } else if ( long.class.isAssignableFrom( destinationType ) ) { return converter.number2longPrimitive( vn ); } else if ( Long.class.isAssignableFrom( destinationType ) ) { return converter.number2long( vn ); } else if ( boolean.class.isAssignableFrom( destinationType ) ) { return converter.number2booleanPrimitive( vn ); } else if ( Boolean.class.isAssignableFrom( destinationType ) ) { return converter.number2boolean( vn ); } else if ( destinationType.isEnum() ) { return converter.number2enum( destinationType, vn ); } else { throw new RuntimeException( "Wrong value conversion to " + destinationType ); } } throw new HopValueException( "Unknown conversion from " + metaType.getTypeDesc() + " into " + destinationType ); }
@Override public PlanNode optimize( QueryContext context, PlanNode plan ) { LinkedList<OptimizerRule> rules = new LinkedList<OptimizerRule>(); populateRuleStack(rules, context.getHints()); Problems problems = context.getProblems(); while (rules.peek() != null && !problems.hasErrors()) { OptimizerRule nextRule = rules.poll(); LOGGER.trace("Running query optimizer rule {0}", nextRule); plan = nextRule.execute(context, plan, rules); LOGGER.trace("Plan after running query optimizer rule {0}: \n{1}", nextRule, plan); } return plan; }
public final int getAndIncrement() { int next; do { next = this.values.incrementAndGet(VALUE_OFFSET); if (next > endValue && this.values.compareAndSet(VALUE_OFFSET, next, startValue)) { return endValue; } } while (next > endValue); return next - 1; }
public void setMediaEntity(MediaEntity entity) { if (TweetMediaUtils.GIF_TYPE.equals(entity.type)) { setBadge(getResources().getDrawable(R.drawable.tw__gif_badge)); } else if (TweetMediaUtils.VIDEO_TYPE.equals(entity.type)) { final long duration = entity.videoInfo == null ? 0 : entity.videoInfo.durationMillis; setText(duration); } else { setEmpty(); } }
public Boolean isOverwriteUserBundles() { if( !contains( ServiceConstants.CONFIG_OVERWRITE_USER_BUNDLES ) ) { return set( ServiceConstants.CONFIG_OVERWRITE_USER_BUNDLES, Boolean.valueOf( m_propertyResolver.get( ServiceConstants.CONFIG_OVERWRITE_USER_BUNDLES ) ) ); } return get( ServiceConstants.CONFIG_OVERWRITE_USER_BUNDLES ); }
@Override protected BaseQueryBuilder build(final PersonList context, final BaseQueryBuilder builder) { Function<Object, String> docNumFunction = value -> { return "LOWER(e.docNum) LIKE LOWER('%" + value + "%') "; }; return builder .where() .openBracket() .addAndCondition(PERSON_TYPES_CONDITION, context.getPersonTypes()) .addAndCondition(GENDERTYPES_CONDITION, context.getGenderTypes()) .addAndCondition(MARRIEDTYPES_CONDITION, context.getMarriedTypes()) .addAndCondition(PARENTS_CONDITION, context.getParents()) .addAndCondition(CITIZEN_COUNTRIES_CONDITION, context.getCitizenCountries()) .addAndConditionForLoop(value -> MessageFormat.format(NAMES_CONDITIOIN_PLACEHOLDER, value), context.getNames()) .addAndConditionForLoop(value -> MessageFormat.format(FIRSTNAMES_CONDITIOIN_PLACEHOLDER, value), context.getFirstNames()) .addAndConditionForLoop(value -> MessageFormat.format(SURNNAMES_CONDITIOIN_PLACEHOLDER, value), context.getSurnames()) .addAndConditionForLoop(value -> MessageFormat.format(FATHERNAMES_CONDITIOIN_PLACEHOLDER, value), context.getFatherNames()) .addAndConditionForLoop(value -> MessageFormat.format(PHOTOS_CONDITIOIN_PLACEHOLDER, value), context.getPhotos()) .addAndConditionForLoop(value -> MessageFormat.format(DOCSERIES_CONDITIOIN_PLACEHOLDER, value), context.getDocSeries()) .addAndConditionForLoop(docNumFunction, context.getDocNums()) .addAndConditionForLoop(value -> MessageFormat.format(IDENTIFIERS_CONDITIOIN_PLACEHOLDER, value), context.getIdentifiers()) .addAndConditionForLoop(value -> MessageFormat.format(BIRTHPLACES_CONDITIOIN_PLACEHOLDER, value), context.getBirthPlaces()) .addAndCondition(RESIDENT_CONDITION, context.getResident()) .addAndCondition(BEGDATE_CONDITION, context.getBegDate()) .addAndCondition(ENDDATE_CONDITION, context.getEndDate()) .addAndCondition(ISMILITARY_CONDITION, context.getIsMilitary()) .addAndCondition(ISHOSTEL_CONDITION, context.getIsHostel()) .closeBracket(); }
public GenericYumCommand upgrade(YumPackageName... packages) { return new GenericYumCommand(terminal, "upgrade", List.of(packages), UPGRADE_NOOP_PATTERN); }
@Nullable protected Credentials getCredentials() { Set<Class> supported = getSupportedCredentials(); if (callbackHandler != null) { log.debug("Login: retrieving Credentials using callback."); try { CredentialsCallback callback = new CredentialsCallback(); callbackHandler.handle(new Callback[]{callback}); Credentials creds = callback.getCredentials(); if (creds != null && supported.contains(creds.getClass())) { log.debug("Login: Credentials '{}' obtained from callback", creds); return creds; } else { log.debug("Login: No supported credentials obtained from callback; trying shared state."); } } catch (UnsupportedCallbackException | IOException e) { onError(); log.error(e.getMessage(), e); } } Credentials creds = getSharedCredentials(); if (creds != null && supported.contains(creds.getClass())) { log.debug("Login: Credentials obtained from shared state."); return creds; } else { log.debug("Login: No supported credentials found in shared state; looking for credentials in subject."); for (Class clz : getSupportedCredentials()) { Set<Credentials> cds = subject.getPublicCredentials(clz); if (!cds.isEmpty()) { log.debug("Login: Credentials found in subject."); return cds.iterator().next(); } } } log.debug("No credentials found."); return null; }
public void validateAllowedTypes(AptUtils aptUtils, TypeName parentType, TypeName type) { if (type.isPrimitive()) { return; } else if (type instanceof ParameterizedTypeName) { final ParameterizedTypeName parameterizedTypeName = (ParameterizedTypeName) type; validateAllowedTypes(aptUtils, parentType, parameterizedTypeName.rawType); for (TypeName x : parameterizedTypeName.typeArguments) { validateAllowedTypes(aptUtils, parentType, x); } } else if (type instanceof WildcardTypeName) { final WildcardTypeName wildcardTypeName = (WildcardTypeName) type; for (TypeName x : wildcardTypeName.upperBounds) { validateAllowedTypes(aptUtils, parentType, x); } } else if (type instanceof ClassName || type instanceof ArrayTypeName) { final boolean isValidType = getAllowedTypes().contains(type); aptUtils.validateTrue(isValidType, "Type '%s' in '%s' is not a valid type for CQL", type.toString(), parentType.toString()); } else { aptUtils.printError("Type '%s' in '%s' is not a valid type for CQL", type.toString(), parentType.toString()); } }
@Override public ResultSetMetaData getMetaData() throws SQLException { notClosed(); return metadata; }
public static CreatePolicyResponse of(final PolicyId policyId, @Nullable final Policy policy, final DittoHeaders dittoHeaders) { return new CreatePolicyResponse(policyId, HttpStatusCode.CREATED, policy, dittoHeaders); }
@Override public void inject(String cssText) { cssText = cssText.replace("\r\n", "").replace("\n", ""); cssText = StringEscapeUtils.escapeEcmaScript(cssText); executeScriptRetry("cssText = \"" + cssText + "\";\n" + getContentOf(INJECTOR_JS_PATH)); }
private static BiConsumer<OccurrenceHdfsRecord, SpecificRecordBase> temporalMapper() { return (hr, sr) -> { TemporalRecord tr = (TemporalRecord)sr; Optional.ofNullable(tr.getDateIdentified()).map(STRING_TO_DATE).ifPresent(date -> hr.setDateidentified(date.getTime())); Optional.ofNullable(tr.getModified()).map(STRING_TO_DATE).ifPresent(date -> hr.setModified(date.getTime())); hr.setDay(tr.getDay()); hr.setMonth(tr.getMonth()); hr.setYear(tr.getYear()); if (Objects.nonNull(tr.getStartDayOfYear())) { hr.setStartdayofyear(tr.getStartDayOfYear().toString()); } else { hr.setStartdayofyear(null); } if (Objects.nonNull(tr.getEndDayOfYear())) { hr.setEnddayofyear(tr.getEndDayOfYear().toString()); } else { hr.setEnddayofyear(null); } if (tr.getEventDate() != null && tr.getEventDate().getGte() != null) { Optional.ofNullable(tr.getEventDate().getGte()) .map(STRING_TO_DATE) .ifPresent(eventDate -> hr.setEventdate(eventDate.getTime())); } else { TemporalUtils.getTemporal(tr.getYear(), tr.getMonth(), tr.getDay()) .map(TEMPORAL_TO_DATE) .ifPresent(eventDate -> hr.setEventdate(eventDate.getTime())); } setCreatedIfGreater(hr, tr.getCreated()); addIssues(tr.getIssues(), hr); }; }
ArtifactClasses inspectArtifact(Id.Artifact artifactId, File artifactFile, @Nullable ClassLoader parentClassLoader, Set<PluginClass> additionalPlugins) throws IOException, InvalidArtifactException { Path tmpDir = Paths.get(cConf.get(Constants.CFG_LOCAL_DATA_DIR), cConf.get(Constants.AppFabric.TEMP_DIR)).toAbsolutePath(); Files.createDirectories(tmpDir); Location artifactLocation = Locations.toLocation(artifactFile); Path stageDir = Files.createTempDirectory(tmpDir, artifactFile.getName()); try { File unpackedDir = BundleJarUtil.unJar(artifactLocation, Files.createTempDirectory(stageDir, "unpacked-").toFile()); try ( CloseableClassLoader artifactClassLoader = artifactClassLoaderFactory.createClassLoader(unpackedDir); PluginInstantiator pluginInstantiator = new PluginInstantiator(cConf, parentClassLoader == null ? artifactClassLoader : parentClassLoader, Files.createTempDirectory(stageDir, "plugins-").toFile(), false)) { pluginInstantiator.addArtifact(artifactLocation, artifactId.toArtifactId()); ArtifactClasses.Builder builder = inspectApplications(artifactId, ArtifactClasses.builder(), artifactLocation, artifactClassLoader); return inspectPlugins(builder, artifactFile, artifactId.toArtifactId(), pluginInstantiator, additionalPlugins).build(); } } catch (EOFException | ZipException e) { throw new InvalidArtifactException("Artifact " + artifactId + " is not a valid zip file.", e); } finally { try { DirUtils.deleteDirectoryContents(stageDir.toFile()); } catch (IOException e) { LOG.warn("Exception raised while deleting directory {}", stageDir, e); } } }
public static BacnetDate parse(String date) { date = date.toLowerCase(); if (date.equals("any") || date.equals("*")) { return new BacnetDate(ANY, (byte) ANY, (byte) ANY, (byte) ANY); } String[] a = date.split("-"); if (a.length == 0) { throw new IllegalArgumentException(date); } int year; if (a[0].equals("any") || a[0].equals("*")) { year = ANY; } else { try { year = Integer.parseInt(a[0]); if (year > 1900 + 255) { throw new IllegalArgumentException("year out of range in " + date); } if (year == 1900 + 255) { year = ANY; } else { year -= 1900; } } catch (NumberFormatException nfe) { throw new IllegalArgumentException("no year in " + date); } } if (a.length == 1) { return new BacnetDate(year, (byte) ANY, (byte) ANY, (byte) ANY); } byte month; switch (a[1]) { case "any": case "*": month = (byte) ANY; break; case "even": month = MONTH_EVEN; break; case "odd": month = MONTH_ODD; break; default: try { month = (byte) Integer.parseInt(a[1]); } catch (NumberFormatException nfe) { throw new IllegalArgumentException("no month in " + date); } if (month > 14) { throw new IllegalArgumentException("month out of range in " + date); } break; } if (a.length == 3) { return new BacnetDate(year, month, (byte) ANY, (byte) ANY); } byte dayOfMonth; switch (a[2]) { case "any": case "*": dayOfMonth = (byte) ANY; break; case "even": dayOfMonth = DAY_OF_MONTH_EVEN; break; case "last": dayOfMonth = DAY_OF_MONTH_LAST; break; case "odd": dayOfMonth = DAY_OF_MONTH_ODD; break; default: try { dayOfMonth = (byte) Integer.parseInt(a[2]); } catch (NumberFormatException nfe) { throw new IllegalArgumentException("no day of month in " + date); } if (dayOfMonth > 34) { throw new IllegalArgumentException("day of month out of range in " + date); } break; } if (a.length == 3) { return new BacnetDate(year, month, dayOfMonth, (byte) ANY); } byte dayOfWeek; if (a[3].equals("any") || a[3].equals("*")) { dayOfWeek = (byte) ANY; } else { try { dayOfWeek = (byte) Integer.parseInt(a[3]); } catch (NumberFormatException nfe) { throw new IllegalArgumentException("no day of week in " + date); } if (dayOfWeek > 7) { throw new IllegalArgumentException("day of week out of range in " + date); } } return new BacnetDate(year, month, dayOfMonth, dayOfWeek); }
public synchronized T find(String name) throws AmbiguousNameException { return find(new HierarchicalName(false, name)); }
@Override public InvocationDataPublisher create(String name, AgentConfig config) { if (name.equals(NoOpInvocationDataPublisherImpl.NAME)) { return new NoOpInvocationDataPublisherImpl(config); } if (name.equals(HttpInvocationDataPublisherImpl.NAME)) { return new HttpInvocationDataPublisherImpl(config); } logger.warning( String.format( "Unrecognized invocation data publisher name: '%s', will use %s", name, NoOpInvocationDataPublisherImpl.NAME)); return new NoOpInvocationDataPublisherImpl(config); }
@Override public DemangledObject demangle(String mangled, boolean demangleOnlyKnownPatterns) throws DemangledException { try { DemangledObject demangled = demangleMS(mangled, demangleOnlyKnownPatterns); return demangled; } catch (GenericDemangledException e) { throw new DemangledException(true); } }
private boolean contains(long timeInMillis) { return CalendarUtil.getInstance().calcTsPeriodId(m_freq, timeInMillis) == m_id; }
public static DateAndTime parseRfc3339String(String rfc3339String) { try { return new DateAndTime(rfc3339String); } catch (NumberFormatException e) { throw new IllegalArgumentException( "DateAndTime string is not valid RFC3339: " + rfc3339String, e); } }
public boolean isValid(String name) { if (this.entityNameValidationConfiguration.useValidation() && this.entityNameValidationManager.getEntityReferenceNameStrategy() != null) { return this.entityNameValidationManager.getEntityReferenceNameStrategy().isValid(name); } else { return true; } }
public static PrivilegeBits getInstance() { return new PrivilegeBits(new ModifiableData()); }
public static MisoServiceManager buildWithDefaults(JdbcTemplate jdbcTemplate, SessionFactory sessionFactory, String username) throws IOException { MisoServiceManager m = new MisoServiceManager(jdbcTemplate, sessionFactory); m.setAllDefaults(); User migrationUser = m.getUserByLoginNameInTransaction(m.getSecurityStore(), username); if (migrationUser == null) throw new IllegalArgumentException("User '" + username + "' not found"); m.setUpSecurityContext(migrationUser); m.setAuthorizationManagerWithUser(migrationUser); return m; }
@Override public boolean recordEvent(@NotNull EventBO event) { return consentRestTemplate.postForEntity(eventRemoteUrls.createEvent(), event, Boolean.class).getBody(); }
boolean validateTenancyObject(Tenancy tenant, final String tenantDomain, final String providerService) { if (!tenant.getDomain().equals(tenantDomain)) { return false; } return tenant.getService().equals(providerService); }
@Nonnull public static <KEYTYPE, DATATYPE extends IHasID <KEYTYPE>> DefaultTreeWithID <KEYTYPE, DATATYPE> buildTree (@Nonnull final Collection <? extends DATATYPE> aAll, @Nonnull final IParentProvider <DATATYPE> aParentResolver) { ValueEnforcer.notNull (aAll, "All"); ValueEnforcer.notNull (aParentResolver, "ParentResolver"); return _buildTree (new CommonsArrayList <> (aAll), aParentResolver); }
static String addColumnString(String tableName, String columnName, String type) { return addColumnString(tableName, columnName, type, null); }
@Override public DataSet<Embedding> evaluate() { return input .flatMap(new FilterAndProjectEdge<>(predicates, projectionPropertyKeys, isLoop)) .name(getName()); }
@Handler @Override public void onNodeDisconnected(NodeDisconnectMessage message) { ActivityItem item = ActivityItem.create() .setTitle("Node disconnected.") .setDescription("Node disconnected from thet network."); getActivityLogger().addActivityItem(item); }
public static double dualDelta( double forward, double strike, double timeToExpiry, double lognormalVol, boolean isCall) { ArgChecker.isTrue(forward >= 0d, "negative/NaN forward; have {}", forward); ArgChecker.isTrue(strike >= 0d, "negative/NaN strike; have {}", strike); ArgChecker.isTrue(timeToExpiry >= 0d, "negative/NaN timeToExpiry; have {}", timeToExpiry); ArgChecker.isTrue(lognormalVol >= 0d, "negative/NaN lognormalVol; have {}", lognormalVol); double sigmaRootT = lognormalVol * Math.sqrt(timeToExpiry); if (Double.isNaN(sigmaRootT)) { log.info("lognormalVol * Math.sqrt(timeToExpiry) ambiguous"); sigmaRootT = 1d; } int sign = isCall ? 1 : -1; double d2 = 0d; boolean bFwd = (forward > LARGE); boolean bStr = (strike > LARGE); boolean bSigRt = (sigmaRootT > LARGE); if (bSigRt) { return isCall ? 0d : 1d; } if (sigmaRootT < SMALL) { if (Math.abs(forward - strike) >= SMALL && !(bFwd && bStr)) { return (isCall ? (forward > strike ? -1d : 0d) : (forward > strike ? 0d : 1d)); } log.info("(log 1d)/0., ambiguous value"); return isCall ? -0.5 : 0.5; } if (Math.abs(forward - strike) < SMALL | (bFwd && bStr)) { d2 = -0.5 * sigmaRootT; } else { d2 = Math.log(forward / strike) / sigmaRootT - 0.5 * sigmaRootT; } return -sign * NORMAL.getCDF(sign * d2); }
public long calculateNewDuration(ViscosityInterpolator viscosity, long timesAnimationViewed, long currentDuration) { if (currentDuration == 0) { Log.e("duration was zero"); return 0; } if (timesAnimationViewed == 0) { Log.v("first time viewing so no duration change"); return currentDuration; } return viscosity.calculateDuration(currentDuration, timesAnimationViewed); }
@Override public FraudServiceResponse recognizeSymptom(final FraudServiceResponse fraudServiceResponse, final AbstractOrderModel abstractOrderModel) { final List<PaymentTransactionModel> paymentTransactions = abstractOrderModel.getPaymentTransactions(); final double scoreLimit = getScoreLimit(); paymentTransactions.stream().filter(Objects::nonNull).forEach(paymentTransaction -> { final WorldpayRiskScoreModel riskScore = paymentTransaction.getRiskScore(); if (riskScore == null) { LOG.warn(format("We did not get a risk score back, skipping risk check for: {0}", paymentTransaction)); return; } final String riskScoreValue = riskScore.getValue(); try { if (riskScoreValue != null && Double.compare(Double.valueOf(riskScoreValue), scoreLimit) > 0) { setIncrement(Double.valueOf(riskScoreValue)); fraudServiceResponse.addSymptom(createSymptom("RiskValue", true)); } } catch (final NumberFormatException e) { LOG.error(format("riskScoreValue for order with code [{0}] was not a number: [{1}]. The RiskScore was not checked for fraud.", abstractOrderModel.getCode(), riskScoreValue)); } }); return fraudServiceResponse; }
public synchronized int getUniqueHandler() { return factory.getUniqueHandler(); }
@SuppressWarnings("unchecked") <T extends TSDRRecord> List<T> search(RecordType type, String key, long start, long end, int size) { checkNotNull(type); checkNotNull(key); checkState(isRunning(), "The service is not running"); if (end < start) { return Collections.emptyList(); } String query = buildELKQuery(type, key, start, end); SearchResult result = execute(new Search.Builder(query) .addIndex(INDEX) .addType(type.name) .setParameter(Parameters.SIZE, size) .build()); if (result == null || !result.isSucceeded() || result.getTotal() == 0) { return Collections.emptyList(); } return result.getHits(TsdrRecordPayload.class).stream() .map(hit -> (T) hit.source.toRecord(type)) .collect(Collectors.toList()); }
@Override public JpaPageTemplate convert(PageTemplate source) { if (source != null) { source.setPageType(source.getPageType() == null ? null : source.getPageType().toUpperCase()); return source instanceof JpaPageTemplate ? (JpaPageTemplate) source : createEntity(source); } return null; }
@VisibleForTesting static boolean getIsPassive(@Nonnull BgpPeerConfig peer) { if (peer instanceof BgpActivePeerConfig || peer instanceof BgpUnnumberedPeerConfig) { return false; } if (peer instanceof BgpPassivePeerConfig) { return true; } throw new IllegalArgumentException(String.format("Unrecognized peer type: %s", peer)); }
@Override public MappeableContainer iand(final MappeableArrayContainer b2) { if (-1 == cardinality) { BufferUtil.intersectArrayIntoBitmap(bitmap, b2.content, b2.cardinality); return this; } else { return b2.and(this); } }
@Override public Object getVertex() { return vertex; }
public Object get(T bean, String name) { validate(bean, name); Function<T, Object> getter = getters.get(name); if (getter == null) { throw new IllegalArgumentException("No getter specified for property '" + name + "' on bean class '" + bean.getClass() + "'"); } return getter.apply(bean); }
ServiceResult<Void> sendUserVerificationEmail(final UserResource user, final Optional<Long> competitionId, final Optional<Long> organisationId) { final Token token = createEmailVerificationToken(user, competitionId, organisationId); final Notification notification = getEmailVerificationNotification(user, token); return notificationService.sendNotificationWithFlush(notification, EMAIL); }
@Override public void send(final Message message, final TestContext context) { Assert.notNull(message, "Message is empty - unable to send empty message"); String topic = Optional.ofNullable(message.getHeader(KafkaMessageHeaders.TOPIC)) .map(Object::toString) .map(context::replaceDynamicContentInString) .orElse(context.replaceDynamicContentInString(endpointConfiguration.getTopic())); if (!StringUtils.hasText(topic)) { throw new CitrusRuntimeException(String.format("Invalid Kafka stream topic header %s - must not be empty or null", KafkaMessageHeaders.TOPIC)); } if (log.isDebugEnabled()) { log.debug("Sending Kafka stream message to topic: '" + topic + "'"); } try { ProducerRecord<Object, Object> producerRecord = endpointConfiguration.getMessageConverter().convertOutbound(message, endpointConfiguration, context); producer.send(producerRecord).get(endpointConfiguration.getTimeout(), TimeUnit.MILLISECONDS); log.info("Message was sent to Kafka stream topic: '" + topic + "'"); } catch (InterruptedException | ExecutionException e) { throw new CitrusRuntimeException(String.format("Failed to send message to Kafka topic '%s'", topic), e); } catch (TimeoutException e) { throw new ActionTimeoutException(String.format("Failed to send message to Kafka topic '%s' - timeout after %s milliseconds", topic, endpointConfiguration.getTimeout()), e); } context.onOutboundMessage(message); }
@Override public final APISummary info(final ConnectorTemplate connectorTemplate, final ConnectorSettings connectorSettings) { final OpenApiModelInfo modelInfo = parseSpecification(connectorSettings, APIValidationContext.CONSUMED_API); final OasDocument model = modelInfo.getModel(); if (model == null) { final APISummary.Builder summaryBuilder = new APISummary.Builder() .errors(modelInfo.getErrors()) .warnings(modelInfo.getWarnings()); if (modelInfo.getResolvedSpecification() != null) { summaryBuilder.putConfiguredProperty(SPECIFICATION, modelInfo.getResolvedSpecification()); } return summaryBuilder.build(); } final Connector connector = basicConnector(connectorTemplate, connectorSettings); final OasPaths paths = model.paths; final AtomicInteger total = new AtomicInteger(0); final Map<String, Integer> tagCounts; if (paths == null) { tagCounts = Collections.emptyMap(); } else { tagCounts = OasModelHelper.getPathItems(paths) .stream() .flatMap(p -> OasModelHelper.getOperationMap(p).values().stream()) .peek(o -> total.incrementAndGet()) .flatMap(o -> OasModelHelper.sanitizeTags(o.tags).distinct()) .collect( Collectors.groupingBy( Function.identity(), Collectors.reducing(0, (e) -> 1, Integer::sum))); } final ActionsSummary actionsSummary = new ActionsSummary.Builder() .totalActions(total.intValue()) .actionCountByTags(tagCounts) .build(); return APISummary.Builder.createFrom(connector) .actionsSummary(actionsSummary) .errors(modelInfo.getErrors()) .warnings(modelInfo.getWarnings()) .putAllConfiguredProperties(connectorSettings.getConfiguredProperties()) .putConfiguredProperty(SPECIFICATION, modelInfo.getResolvedSpecification()) .build(); }
public void close() { try { zkClient.close(); } catch (ZkInterruptedException e) { LOG.warn("Interrupted when closing zkClient. Clearing the interrupted status and retrying.", e); Thread.interrupted(); zkClient.close(); Thread.currentThread().interrupt(); } }
@Override public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) { int total = targetVM.getRunningTasks().size() + targetVM.getTasksCurrentlyAssigned().size(); int max = Math.max(1, configuration.getMaxTasksPerMachine()); return total < max ? VALID : TOO_MANY_CONTAINERS; }
public boolean verifySignature(String body, String timestamp, String signature) { return signedPayloadValidator.validateSignedPayload( emptyIfNull(body) + emptyIfNull(timestamp), signature); }
@Override public void rewind() throws IOException { _inputStream.close(); init(); }
@Override public SpaceReference resolve(String documentReferenceRepresentation, Object... parameters) { return new SpaceReference(this.entityReferenceResolver.resolve(documentReferenceRepresentation, EntityType.SPACE, parameters)); }
@Override public String render(DDMFormFieldValue ddmFormFieldValue, Locale locale) { Number number = getNumber(ddmFormFieldValue); if (number != null) { NumberFormat numberFormat = NumericDDMFormFieldUtil.getNumberFormat( locale); return numberFormat.format(number); } return StringPool.BLANK; }
@Override public @Nullable Boolean trySample(@Nullable M method) { if (method == null) return null; Sampler sampler = methodToSamplers.get(method); if (sampler == NULL_SENTINEL) return null; if (sampler != null) return sampler.isSampled(0L); sampler = samplerOfMethod(method); if (sampler == null) { methodToSamplers.put(method, NULL_SENTINEL); return null; } Sampler previousSampler = methodToSamplers.putIfAbsent(method, sampler); if (previousSampler != null) sampler = previousSampler; return sampler.isSampled(0L); }
@Override public void remove( String nodeKey, String propertyName, T value ) { for (UniqueKey<T> key : Fun.filter(valuesByKey, nodeKey)) { if (key.actualKey.equals(value)) { logger.trace("Removing node '{0}' from '{1}' index with value '{2}'", nodeKey, name, key.actualKey); keysByValue.remove(key); } } }
@Override public void removeDestination(MessageLocation destination) { if (destination.channel().equals(this.primaryDestination)) { throw new InvalidDestinationException("Can't remove default destination"); } if (this.destinations.containsKey(destination.channel())) { this.destinations.remove(destination.channel()); } else { throw new InvalidDestinationException("User don't have the given destination"); } }
T getFunction(final List<SqlType> arguments) { final List<Node> candidates = new ArrayList<>(); getCandidates(arguments, 0, root, candidates, new HashMap<>(), false); final Optional<T> fun = candidates .stream() .max(Node::compare) .map(node -> node.value); if (fun.isPresent()) { return fun.get(); } else if (!supportsImplicitCasts) { throw createNoMatchingFunctionException(arguments); } getCandidates(arguments, 0, root, candidates, new HashMap<>(), true); return candidates .stream() .max(Node::compare) .map(node -> node.value) .orElseThrow(() -> createNoMatchingFunctionException(arguments)); }
@Override public ResponseEntity getBalances(String accountId, UUID xRequestID, String consentID, String digest, String signature, byte[] tpPSignatureCertificate, String psUIPAddress, String psUIPPort, String psUAccept, String psUAcceptCharset, String psUAcceptEncoding, String psUAcceptLanguage, String psUUserAgent, String psUHttpMethod, UUID psUDeviceID, String psUGeoLocation) { ResponseObject<Xs2aBalancesReport> balancesReport = balanceService.getBalancesReport(consentID, accountId, trimEndingSlash(request.getRequestURI())); return balancesReport.hasError() ? responseErrorMapper.generateErrorResponse(balancesReport.getError()) : responseMapper.ok(balancesReport, accountModelMapper::mapToBalance); }
@Override public ProcessSummary apply(final ProcessDefinition definition) { if (definition == null) { return null; } final ProcessSummary summary = new ProcessSummary(definition.getId(), definition.getName(), definition.getContainerId(), definition.getVersion(), definition.isDynamic()); summary.setAssociatedEntities(definition.getAssociatedEntities()); summary.setProcessVariables(definition.getProcessVariables()); summary.setReusableSubProcesses(definition.getReusableSubProcesses()); summary.setServiceTasks(definition.getServiceTasks()); summary.setDynamicFormsEnabled(KieServerUtils.isKieServerRendererEnabled()); summary.setNodes(definition.getNodes() == null ? emptyList() : definition.getNodes().stream().map(node -> new ProcessNodeSummary(node.getId(), node.getName(), node.getType(), node.getUniqueId())).collect(toList())); summary.setTimers(definition.getTimers() == null ? emptyList() : definition.getTimers().stream().map(timer -> new TimerSummary(timer.getId(), timer.getNodeId(), timer.getNodeName(), timer.getUniqueId())).collect(toList())); return summary; }
public static final AndroidChannelBuilder forTarget(String target) { return new AndroidChannelBuilder(target); }
public List<Designation> getAllDesignations() { return designationRepository.findAll(); }
public static BigInteger decodeToBigInteger(String input) throws AddressFormatException { return new BigInteger(1, decode(input)); }
public static double standardDeviation(final double[] t) { return Math.sqrt(variance(t)); }
public void assignRolesToUser( String userName, String roleNames ) throws NotFoundException, UncategorizedUserRoleDaoException, SecurityException { if ( canAdminister() ) { StringTokenizer tokenizer = new StringTokenizer( roleNames, "\t" ); Set<String> assignedRoles = new HashSet<>(); ITenant tenant = TenantUtils.getCurrentTenant(); for ( IPentahoRole pentahoRole : getRoleDao().getUserRoles( tenant, userName ) ) { assignedRoles.add( pentahoRole.getName() ); } while ( tokenizer.hasMoreTokens() ) { assignedRoles.add( tokenizer.nextToken() ); } getRoleDao().setUserRoles( tenant, userName, assignedRoles.toArray( new String[assignedRoles.size()] ) ); } else { throw new SecurityException(); } }
public static Credentials checkValidForProvider(Credentials creds, denominator.Provider provider) { checkNotNull(provider, "provider cannot be null"); if (isAnonymous(creds) && provider.credentialTypeToParameterNames().isEmpty()) { return AnonymousCredentials.INSTANCE; } else if (creds instanceof Map) { if (credentialConfigurationHasKeys(provider, Map.class.cast(creds).keySet())) { return creds; } } else if (creds instanceof List) { if (credentialConfigurationHasPartCount(provider, List.class.cast(creds).size())) { return creds; } } throw new IllegalArgumentException(exceptionMessage(creds, provider)); }
public TableMetaDataView getTableMetaDataView(Connection connection, RegionMapping regionMapping) { return JavaWorkarounds.computeIfAbsent(tableToMetaDataMap, computeTableName(regionMapping), k -> computeTableMetaDataView(connection, k, regionMapping)); }
public static int sumInts(Iterable<Integer> values) { int total = 0; for (Integer value : values) { total += value; } return total; }
public Table read(CsvReadOptions options) throws IOException { return read(options, false); }
public List<Map<String, Object>> getDistributionSummaryByEnv(String assetGroup, String severity) throws ServiceException { List<Map<String, Object>> distributionList = new ArrayList<>(); if (StringUtils.isBlank(severity)) { severity = SEVERITY_LEVELS; } long totalVulnCount = 0; Map<String, Object> prodInfo = new HashMap<>(); prodInfo.put(TOTAL_VULN_ASSETS, 0); prodInfo.put(VULNEREBILITIES, 0); prodInfo.put(UNIQUE_VULN_COUNT, 0); Map<String, Object> nonProdInfo = new HashMap<>(); nonProdInfo.put(TOTAL_VULN_ASSETS, 0); nonProdInfo.put(VULNEREBILITIES, 0); nonProdInfo.put(UNIQUE_VULN_COUNT, 0); try { Map<String, Long> prodInfoTemp = vulnerabilityRepository.getProdInfoByEnv(assetGroup, severity); Map<String, Long> nonProdInfoTemp = vulnerabilityRepository.getNonProdInfoByEnv(assetGroup, severity); totalVulnCount += prodInfoTemp.get(VULNEREBILITIES) + nonProdInfoTemp.get(VULNEREBILITIES); for (Entry<String, Object> entry : prodInfo.entrySet()) { prodInfo.put(entry.getKey(), Long.valueOf(entry.getValue().toString()) + prodInfoTemp.get(entry.getKey())); } for (Entry<String, Object> entry : nonProdInfo.entrySet()) { nonProdInfo.put(entry.getKey(), Long.valueOf(entry.getValue().toString()) + nonProdInfoTemp.get(entry.getKey())); } } catch (Exception e) { throw new ServiceException(e); } prodInfo.put(CATEGORY, "Prod"); distributionList.add(prodInfo); nonProdInfo.put(CATEGORY, "Non-Prod"); distributionList.add(nonProdInfo); double contribution = HUNDRED; for (int i = 0; i < distributionList.size(); i++) { Map<String, Object> info = distributionList.get(i); if (totalVulnCount > 0) { double contributionPercent = Math .floor((Double.valueOf(info.get(VULNEREBILITIES).toString()) / totalVulnCount) * HUNDRED); if (i == distributionList.size() - 1) { info.put(CONTRIBUTION, contribution); } else { info.put(CONTRIBUTION, contributionPercent); contribution = contribution - contributionPercent; } } else { info.put(CONTRIBUTION, 0); } } return distributionList; }
public EmailBean organizationRenamed(String oldName, String newName) throws ServerException { Map<String, Object> attributes = new HashMap<>(); attributes.put("orgOldName", oldName); attributes.put("orgNewName", newName); return doBuildEmail(orgRenamedSubject, orgRenamedTemplate, attributes); }
public boolean tryJoin(ITabularFormula formula, ITier tier) { ITier existingTier = formula.findTierFor(tier); if (existingTier != null) { formula.unionOrAdd(existingTier); return true; } return false; }
public static String getConfigParamMessage(CommandLineConfigParam configParam) { return cmdProperties.getProperty(configParam.name().toLowerCase()); }
public static String byteToHexString(byte value) { final StringBuilder hex = new StringBuilder(2); byte b = value; hex.append(HEXES.charAt((b & 0xF0) >> 4)) .append(HEXES.charAt((b & 0x0F))); return hex.toString(); }
public ApplicationBuilder addRegistry(RegistryConfig registry) { if (this.registries == null) { this.registries = new ArrayList<>(); } this.registries.add(registry); return getThis(); }
@Override public Iterator<Trait> iterator() { return traits.iterator(); }
@Override public Object invoke(MethodInvocation invocation) throws Throwable { findAnnotation(invocation).ifPresent(rpAnnotation -> { checkPermissions(invocation.getMethod(), rpAnnotation.value(), rpAnnotation.logical()); }); return invocation.proceed(); }
public static <S, I> Iterable<TransRef<S, I, ?>> allDefinedInputs(Automaton<S, I, ?> automaton, Iterable<? extends I> inputs) { return allDefinedInputs(automaton, automaton, inputs); }
public List<T> calculateCriticalPath(ICriticalPathCalculable<T> graph) { this.graph = graph; dependencies = new HashMap<T, Map<T, DependencyType>>(); initDate = calculateInitDate(); bop = createBeginningOfProjectNode(); eop = createEndOfProjectNode(); nodes = createGraphNodes(); forward(bop, null, new VisitorTracker()); eop.updateLatestValues(); backward(eop, null, new VisitorTracker()); return getTasksOnCriticalPath(); }
@Override public FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException { checkNotNull("file", file); checkNotNull("attrs", attrs); return FileVisitResult.CONTINUE; }
public static int[] bytesToInts(byte[] bytes) { final int[] ints = new int[bytes.length >> 2]; for (int i = 0; i < ints.length; ++i) { final byte b4 = bytes[i * 4]; final byte b3 = bytes[i * 4 + 1]; final byte b2 = bytes[i * 4 + 2]; final byte b1 = bytes[i * 4 + 3]; ints[i] = (b1 & 0xFF) | (b2 & 0xFF) << 8 | (b3 & 0xFF) << 16 | (b4 & 0xFF) << 24; } return ints; }
public int getStatus() { return status; }
TrieMap<Boolean> getReverseCompoundTriggerWords() { return reverseCompoundTriggerWords; }
@Override public <T> boolean validate(T obj) { boolean retVal = false; File file = (File) obj; if (fileAgeValidator.validate(file)) { results.addFile(file.getPath()); checkFile(file); retVal = true; } return retVal; }
@Override public String eth_getBalance(String address, String block) throws Exception { AccountInformationProvider accountInformationProvider = getAccountInformationProvider(block); if (accountInformationProvider == null) { throw new NullPointerException(); } UscAddress addr = new UscAddress(address); BigInteger balance = accountInformationProvider.getBalance(addr).asBigInteger(); return toJsonHex(balance); }
@Override public boolean hasRight(MailboxPath mailboxPath, Right right, MailboxSession session) throws MailboxException { return myRights(mailboxPath, session).contains(right); }
public String getFieldName() { return fieldName; }
@Override @Nullable public OIDCMetadataContext apply(@Nullable final ProfileRequestContext input) { if (input == null || input.getInboundMessageContext() == null) { return null; } return input.getInboundMessageContext().getSubcontext(OIDCMetadataContext.class, false); }
public boolean isShowDisabledSubmitButton() { if (!projectManager) { return false; } if (isSubmitted()) { return false; } return !isOfferSigned(); }
public List<Disposal> search(final DisposalCriteria disposalCriteria) { final List<Object> preparedStatementValues = new ArrayList<>(); final String queryStr = disposalQueryBuilder.getQuery(disposalCriteria, preparedStatementValues); List<Disposal> disposals = null; try { log.info("queryStr::" + queryStr + "preparedStatementValues::" + preparedStatementValues.toString()); disposals = jdbcTemplate.query(queryStr, preparedStatementValues.toArray(), disposalRowMapper); log.info("DisposalRepository::" + disposals); } catch (final Exception ex) { log.info("the exception from findforcriteria : " + ex); throw new RuntimeException("the exception from find for disposal criteria : " + ex.getMessage()); } return disposals; }
public static List<String> allTokens(String input, String startDelimiter, String endDelimiter) { final List<String> tokens = new ArrayList<>(); Optional<String> token = firstToken(input, startDelimiter, endDelimiter); while(token.isPresent()) { final String tokenValue = token.get(); tokens.add(tokenValue); input = input.substring(input.indexOf(tokenValue) + tokenValue.length() + endDelimiter.length()); token = firstToken(input, startDelimiter, endDelimiter); } return tokens; }
public Single<InputStream> getInputStream(@NonNull com.google.android.gms.wearable.Channel channel) { return getInputStreamInternal(channel, null, null); }
@Override public String name() { return name; }
boolean isCacheableResourceRequest(HttpServletRequest request) { String requestPath = request.getPathInfo(); if (requestPath == null) { return false; } for (String resourcePrefix : resourcePrefixes) { if (requestPath.startsWith(resourcePrefix)) { return true; } } return false; }
public static JSONObject winLevel(JSONObject json) { LevelProgress progress = new LevelProgress(json); JSONObject clone = new JSONObject(json.toString()); progress.change(progress.current + 1, Math.max(progress.passed, progress.current)); if (progress.isValid()) { return progress.saveTo(clone); } else { return null; } }
void update(@NonNull CameraPosition cameraPosition) { clockwiseBearing = -cameraPosition.bearing; if (compassView != null) { compassView.update(clockwiseBearing); } }
@Override public void process(final HttpRequest request, final EntityDetails entity, final HttpContext context) throws HttpException, IOException { Args.notNull(request, "HTTP request"); if (!request.containsHeader(HttpHeaders.EXPECT)) { final ProtocolVersion version = request.getVersion() != null ? request.getVersion() : HttpVersion.HTTP_1_1; if (entity != null && entity.getContentLength() != 0 && !version.lessEquals(HttpVersion.HTTP_1_0)) { final HttpClientContext clientContext = HttpClientContext.adapt(context); final RequestConfig config = clientContext.getRequestConfig(); if (config.isExpectContinueEnabled()) { request.addHeader(HttpHeaders.EXPECT, HeaderElements.CONTINUE); } } } }
@Override public String getDINTER() { return "dinter"; }
@Override public String getLabel() { return getCategorization().getDrug().getLabel() + (!getName().isEmpty() ? " " + getName() : ""); }
@Override public Object apply(Collection<?> context, Options options) { if (context == null || context.isEmpty()) { return ""; } String separator = options.hash("sep", ","); String format = options.hash("format", null); Function<Object, String> formatter = format != null ? each -> String.format(format, each) : Object::toString; return context.stream() .map(formatter) .collect(joining(separator)); }
public void fetchItems() { int restoreOffset = restoreIfNeeded(); items.addAll( itemProvider.fetchItems( getOldest(), getFetchCount() + restoreOffset ) ); storeTopItem(); }
public static QueryRunnerService getQueryRunner(DataSource ds) { return (QueryRunnerService) ProfilerFactory.newInstance(new QueryRunner(ds)); }
@Override public void cdpDatahubClusterRequested(long timestamp, UsageProto.CDPDatahubClusterRequested details) { checkNotNull(details); log(eventBuilder() .setTimestamp(timestamp) .setCdpDatahubClusterRequested(details) .build()); }
public void saveAnmLocation(LocationTree anmLocation) { String amnLocationString = AssetHandler.javaToJsonString(anmLocation); saveANMLocationTask.save(amnLocationString); }
public static Competition initialiseProjectSetupColumns(Competition competition) { if (competition.getFundingType() == null) { return competition; } switch (competition.getFundingType()) { case LOAN: addLoanProjectSetupColumns(competition); break; case PROCUREMENT: addProcurementProjectSetupColumns(competition); break; case GRANT: case KTP: case INVESTOR_PARTNERSHIPS: addDefaultProjectSetupColumns(competition); break; default: break; } return competition; }
@SuppressLint("JavascriptInterface") public void addJavascriptInterface(Object object, String name) { if (TextUtils.equals(name, JAVASCRIPT_INTERFACE_NAME)) { throw new IllegalArgumentException(JAVASCRIPT_INTERFACE_NAME + " is a reserved Javascript Interface name."); } if (javascriptInterfaces.get(name) == null) { javascriptInterfaces.put(name, object); webView.addJavascriptInterface(object, name); TurbolinksLog.d("Adding JavascriptInterface: " + name + " for " + object.getClass().toString()); } }
@Override public void fromHL7(String hl7Data, PatientInfo patientInfo) { notNull(patientInfo, "patientInfo cannot be null"); patientInfo.setName(Hl7v2Based.parse(hl7Data, XpnName.class)); }
public void setValue(EV value) { this.f2 = value; }
@Override public Parameter getParameter(NamedObjectId paraId) throws InvalidIdentification { Parameter p; if (paraId.hasNamespace()) { p = outParamIndex.get(paraId.getNamespace(), paraId.getName()); } else { p = outParamIndex.get(paraId.getName()); } if (p != null) { return p; } else { throw new InvalidIdentification(); } }
@Override public List<Piirhind> findPiirhinnadDetailandmed(List<String> items) throws XRoadServiceConsumptionException { PiirhinnadByIDArray request = PiirhinnadByIDArray.Factory.newInstance(); request.setKeha(createDetailsRequest(items)); return ravimiregisterXRoadDatabase.piirhinnadByIDArrayV1(request).getKeha().getItemList(); }
@Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } final DoubleName that = (DoubleName) o; return Objects.equals(this.nameWithAliases, that.nameWithAliases); }
public void execute() { OpenAPIGenerator openApiGenerator = new OpenAPIGenerator( asList(modelPackages), asList(controllerBasePackages), createInfoFromParameters(), parseInputInterceptors(schemaInterceptors, SchemaInterceptor.class), parseInputInterceptors(schemaFieldInterceptors, SchemaFieldInterceptor.class), parseInputInterceptors(operationParameterInterceptors, OperationParameterInterceptor.class), parseInputInterceptors(operationInterceptors, OperationInterceptor.class), parseInputInterceptors(requestBodyInterceptors, RequestBodyInterceptor.class), parseInputFilter(operationFilter, OperationFilter.class), parseInputFilter(operationParameterFilter, OperationParameterFilter.class), parseInputFilter(schemaFieldFilter, SchemaFieldFilter.class) ); OpenApiGeneratorConfig openApiGeneratorConfig = OpenApiGeneratorConfigBuilder.defaultConfig().build(); if (BooleanUtils.isTrue(generateExamples)) { openApiGeneratorConfig.setGenerateExamples(true); if (StringUtils.isNotBlank(openApiExamplesResolver)) { openApiGeneratorConfig.setOpenApiExampleResolver(instantiateClass(openApiExamplesResolver, OpenApiExampleResolver.class)); } } OpenAPI openAPI = openApiGenerator.generate(openApiGeneratorConfig); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); try { if (!new File(outputDirectory).mkdirs()) { getLog().error(String.format("Error creating directories for path [%s]", outputDirectory)); return; } objectMapper.writeValue(new File(outputDirectory + "/swagger.json"), openAPI); } catch (IOException e) { getLog().error("Cannot serialize generated OpenAPI spec", e); } }
@Override public RestRequest<List<RecommendationTrends>> build() { return RestRequestBuilder.<List<RecommendationTrends>>builder() .withPath("/stock/{symbol}/recommendation-trends") .addPathParam(SYMBOL_PARAM_NAME, getSymbol()).get() .withResponse(new GenericType<List<RecommendationTrends>>() {}) .build(); }
public GatewayContext resolve(GatewayConfigDocument gatewayConfigDoc) throws Exception { return resolve(gatewayConfigDoc, System.getProperties()); }
public static String combine(Collection<Share> shares) throws IncompatibleSharesException, NotEnoughSharesException, InvalidContentTypeException { if (shares.size() == 0) { throw new NotEnoughSharesException(1); } Iterator<Share> it = shares.iterator(); Share firstShare = it.next(); while (it.hasNext()) { Share share = it.next(); if (!share.isCompatible(firstShare)) { throw new IncompatibleSharesException(); } } if (firstShare.contentType != TYPE_BASE_58_STRING) { throw new InvalidContentTypeException(); } Collection<Share> unique = Share.removeDuplicateIndexes(shares); int threshold = unique.iterator().next().threshold; if (threshold > unique.size()) { throw new NotEnoughSharesException(threshold - unique.size()); } List<Share> selection = new ArrayList<Share>(); it = unique.iterator(); while (it.hasNext()) { selection.add(it.next()); if (selection.size() == threshold) { break; } } Gf256 gf = new Gf256(); List<Gf256.Share> gfShares = new ArrayList<Gf256.Share>(); for (Share s : selection) { gfShares.add(new Gf256.Share((byte) s.shareNumber, s.shareData)); } byte[] content = gf.combineShares(gfShares); return Base58.encodeWithChecksum(content); }
public static String buildPackageName( String basePackageName, String packageName, String... subPackageNames) { StringBuilder stringBuilder = new StringBuilder(basePackageName + "." + packageName); if (subPackageNames != null) { for (String subPackageName : subPackageNames) { stringBuilder.append("."); stringBuilder.append(subPackageName); } } return stringBuilder.toString(); }
public void add(CommonPersonObject common) { SQLiteDatabase database = masterRepository.getWritableDatabase(); database.insert(TABLE_NAME, null, createValuesFor(common)); }
public void move(Direction direction) { switch (direction) { case RIGHT : merge(this.new _XY()); break; case UP : merge(this.new Y_X()); break; case LEFT : merge(this.new XY()); break; case DOWN : merge(this.new YX()); break; } }
public CurrencyAmount presentValue( ResolvedCapitalIndexedBondTrade trade, RatesProvider ratesProvider, LegalEntityDiscountingProvider discountingProvider) { validate(ratesProvider, discountingProvider); LocalDate settlementDate = settlementDate(trade, ratesProvider.getValuationDate()); CurrencyAmount pvProduct = productPricer.presentValue(trade.getProduct(), ratesProvider, discountingProvider, settlementDate); return presentValueFromProductPresentValue(trade, ratesProvider, discountingProvider, pvProduct); }
@Override public List<ExportField> listRequiredFields() { List<ExportField> fields = new ArrayList<>(); fields.add(new ExportField(PROJECT_NAME, "Targeted project's name", "string", "The name of targeted project in SquashTM. Note that the project must be created before doing the import.")); fields.add(new ExportField(USER, "Targeted User's name", "string", "The name of the user whom will act as the creator of the requirements in SquashTM. Note that the user must exist before doing the import.")); return fields; }
public void ensureXWikiNotificationsAreEnabled(DocumentReference user) throws NotificationException { if (isNotificationDisabled(user)) { TargetableNotificationPreferenceBuilder builder = targetableNotificationPreferenceBuilderProvider.get(); List<NotificationPreference> preferencesToCreate = new ArrayList<>(); Date now = new Date(); for (String eventType : XWIKI_EVENT_TYPES) { for (NotificationFormat format : NotificationFormat.values()) { preferencesToCreate.add(createNotificationPreference(user, builder, eventType, format, now)); } } notificationPreferenceManager.savePreferences(preferencesToCreate); } }
DataType createSubDataType(final ItemDefinition itemDefinition) { return anotherManager() .newDataType(getDataType().isReadOnly()) .withUUID() .withParentUUID(getDataTypeUUID().orElseThrow(() -> new UnsupportedOperationException("A parent data type must have an UUID."))) .withItemDefinition(itemDefinition) .withItemDefinitionName() .withItemDefinitionType() .withItemDefinitionConstraint() .withItemDefinitionCollection() .withTypeStack(getSubDataTypeStack()) .withItemDefinitionSubDataTypes() .withIndexedItemDefinition() .get(); }
@Override protected boolean shouldNotFilter(HttpServletRequest request) { return EXCLUDED_URLS.stream() .anyMatch(p -> matcher.match(p, request.getServletPath())); }
public static Boolean choose(Boolean parent, Boolean child) { if (parent == Boolean.TRUE || child == Boolean.TRUE) { return true; } return parent == null ? child : parent; }
static RenderedImage create(RenderedImage... sourceImages) { double[][] sourceThresholds = new double[sourceImages.length][1]; sourceThresholds[0][0] = determineSourceThreshold(sourceImages[0]); int t = 0; for (int i = 1; i < sourceImages.length; i++) { t += sourceImages[i - 1].getWidth(); sourceImages[i] = TranslateDescriptor.create(sourceImages[i], (float) t, 0.0f, INTERPOLATION, null); sourceThresholds[i][0] = determineSourceThreshold(sourceImages[i]); } return MosaicDescriptor.create(sourceImages, MosaicDescriptor.MOSAIC_TYPE_OVERLAY, null, null, sourceThresholds, null, null); }
@Override public ComparisonResult evaluate(String testText, String... param) { return testText != null && testText.trim().matches(NUMBER_PATTERN) ? EQUAL : DIFFERENT; }
public X509Certificate createX509Certificate(Consumer consumer, Owner owner, Pool pool, Entitlement ent, Product product, Set<Product> products, List<org.candlepin.model.dto.Product> productModels, BigInteger serialNumber, KeyPair keyPair, boolean useContentPrefix) throws GeneralSecurityException, IOException { Set<X509ExtensionWrapper> extensions; Set<X509ByteExtensionWrapper> byteExtensions = new LinkedHashSet<>(); products.add(product); Map<String, EnvironmentContent> promotedContent = getPromotedContent(consumer); String contentPrefix = getContentPrefix(consumer, owner, useContentPrefix); if (shouldGenerateV3(consumer)) { extensions = prepareV3Extensions(); byteExtensions = prepareV3ByteExtensions(product, productModels, contentPrefix, promotedContent); } else { extensions = prepareV1Extensions(products, pool, consumer, ent.getQuantity(), contentPrefix, promotedContent); } Date endDate = setupEntitlementEndDate(pool, consumer); ent.setEndDateOverride(endDate); Calendar calNow = Calendar.getInstance(); Calendar calMinusHour = Calendar.getInstance(); calMinusHour.add(Calendar.HOUR, -1); Date startDate = pool.getStartDate(); if (pool.getStartDate().getTime() > calMinusHour.getTime().getTime() && pool.getStartDate().getTime() < calNow.getTime().getTime()) { startDate = calMinusHour.getTime(); } X509Certificate x509Cert = this.pki.createX509Certificate( createDN(ent, owner), extensions, byteExtensions, startDate, endDate, keyPair, serialNumber, null); return x509Cert; }
public int completeName(String buffer, int cursor, List<InterpreterCompletion> candidates, Map<String, String> aliases) { CursorArgument cursorArgument = parseCursorArgument(buffer, cursor); String schema; String table; String column; if (cursorArgument.getSchema() == null) { List<CharSequence> keywordsCandidates = new ArrayList(); List<CharSequence> schemaCandidates = new ArrayList<>(); int keywordsRes = completeKeyword(buffer, cursor, keywordsCandidates); int schemaRes = completeSchema(buffer, cursor, schemaCandidates); addCompletions(candidates, keywordsCandidates, CompletionType.keyword.name()); addCompletions(candidates, schemaCandidates, CompletionType.schema.name()); return NumberUtils.max(new int[]{keywordsRes, schemaRes}); } else { schema = cursorArgument.getSchema(); if (aliases.containsKey(schema)) { String alias = aliases.get(schema); int pointPos = alias.indexOf('.'); schema = alias.substring(0, pointPos); table = alias.substring(pointPos + 1); column = cursorArgument.getColumn(); List<CharSequence> columnCandidates = new ArrayList(); int columnRes = completeColumn(schema, table, column, cursorArgument.getCursorPosition(), columnCandidates); addCompletions(candidates, columnCandidates, CompletionType.column.name()); } else if (cursorArgument.getTable() != null && cursorArgument.getColumn() == null) { List<CharSequence> tableCandidates = new ArrayList(); table = cursorArgument.getTable(); int tableRes = completeTable(schema, table, cursorArgument.getCursorPosition(), tableCandidates); addCompletions(candidates, tableCandidates, CompletionType.table.name()); return tableRes; } else { List<CharSequence> columnCandidates = new ArrayList(); table = cursorArgument.getTable(); column = cursorArgument.getColumn(); int columnRes = completeColumn(schema, table, column, cursorArgument.getCursorPosition(), columnCandidates); addCompletions(candidates, columnCandidates, CompletionType.column.name()); } } return -1; }
@Override public boolean create(DocumentReference documentReference) { XWikiContext xcontext = this.xcontextProvider.get(); try { XWikiDocument newDocument = xcontext.getWiki().getDocument(documentReference, xcontext); xcontext.getWiki().saveDocument(newDocument, xcontext); this.logger.info("Document [{}] has been created.", documentReference); return true; } catch (Exception e) { this.logger.error("Failed to create document [{}].", documentReference, e); return false; } }
public void putAttributeValues(String column) { Date latest = null; Date earliest = null; Date secondLatest = null; Date secondEarliest = null; for (Attribute attr : dataset.getAttributesByColumn(column)) { if (attr.isAlive()) { Date value = (Date) attr.getValue(); if (value == null) { continue; } if (latest == null || earliest == null || secondLatest == null || secondEarliest == null) { latest = value; earliest = value; secondLatest = value; secondEarliest = value; } else { if (value.after(latest)) { secondLatest = latest; latest = value; if (secondLatest.equals(earliest)) { secondEarliest = latest; } } else if (value.before(earliest)) { secondEarliest = earliest; earliest = value; if (secondEarliest.equals(latest)) { secondLatest = earliest; } } if (value.before(latest) && value.after(secondLatest)) { secondLatest = value; } if (value.after(earliest) && value.before(secondEarliest)) { secondEarliest = value; } } } } latestValueMap.put(column, latest); earliestValueMap.put(column, earliest); secondLatestValueMap.put(column, secondLatest); secondEarliestValueMap.put(column, secondEarliest); }
public boolean eval(DataFile file) { return visitor().eval(file); }
public static void saveHeapDumpToFile(@NotNull ProfilerClient client, @NotNull Common.Session session, @NotNull HeapDumpInfo info, @NotNull OutputStream outputStream, @NotNull FeatureTracker featureTracker) { Transport.BytesResponse response = client.getTransportClient() .getBytes(Transport.BytesRequest.newBuilder().setStreamId(session.getStreamId()).setId(Long.toString(info.getStartTime())).build()); if (response.getContents() != ByteString.EMPTY) { try { response.getContents().writeTo(outputStream); featureTracker.trackExportHeap(); } catch (IOException exception) { getLogger().warn("Failed to export heap dump file:\n" + exception); } } }
@Override public String login(String userId, String password) throws ZaasClientException { if (userId == null || password == null || userId.isEmpty() || password.isEmpty()) { log.error(ZaasClientErrorCodes.EMPTY_NULL_USERNAME_PASSWORD.toString()); throw new ZaasClientException(ZaasClientErrorCodes.EMPTY_NULL_USERNAME_PASSWORD); } try { return tokens.login(userId, password); } catch (ZaasClientException e) { log.error(e.getErrorCode().toString()); throw e; } }
public static double glucoseToA1C(double mgDl) { return round((mgDl + 46.7) / 28.7, 2); }
public static MarkovNetwork ex(BufferedReader rd_net) { try { return new MarkovUaiReader().go(rd_net); } catch (IOException e) { logExp(log, e); } return null; }
public static boolean isActivated() { String color = System.getProperty("maven.color"); if (color != null) { return Boolean.valueOf(color); } String activation = System.getProperty("style.color"); if ("always".equals(activation)) { return true; } if ("never".equals(activation)) { return false; } Set<String> args = split(System.getenv("MAVEN_CMD_LINE_ARGS")); return !isBatchMode(args) && !isLogFile(args) && !isDumbTerminal(); }
public String mavenGav() { return this.groupId + COLON + this.artifactId + COLON + (this.type == null ? JAR_PACKAGING : this.type) + COLON + (this.classifier == null ? "" : this.classifier + COLON) + this.version; }
@Override public String toString() { String result = Integer.toString(this.maskBits, 8); int len = result.length(); if (len == 1) { result = "000" + result; } else if (len == 2) { result = "00" + result; } else if (len == 3) { result = "0" + result; } return result; }
public void executeActionsOnHBase(Configuration hbaseConf) throws IOException { HBaseLogin.loginIfNeeded(mainConfig.loginFlags); try (Connection conn = ConnectionFactory.createConnection(hbaseConf); Admin hBaseAdmin = conn.getAdmin()) { byte[][] tableFamilies; byte[][] splitKeys = new byte[0][0]; String tableName; LOG.info("----------------------------------------------------------------------------------------------"); switch (commandLine.getParsedCommand()) { case COMMIT_TABLE_COMMAND_NAME: LOG.info("Performing actions related to COMMIT TABLE"); tableName = commitTableCommand.tableName; tableFamilies = commitTableFamilies; if (commitTableCommand.numRegions > 1) { splitKeys = splitInUniformRegions(hbaseConf, commitTableCommand.numRegions); } break; case TIMESTAMP_TABLE_COMMAND_NAME: LOG.info("Performing actions related to TIMESTAMP TABLE"); tableName = timestampTableCommand.tableName; tableFamilies = timestampTableFamilies; break; default: LOG.error("Unknown command: {}", commandLine.getParsedCommand()); commandLine.usage(); return; } createTable(hBaseAdmin, tableName, tableFamilies, splitKeys, 1); LOG.info("----------------------------------------------------------------------------------------------"); } }
@RequestMapping(value = {"", "/", "/add"}, method = RequestMethod.POST) public ServiceResult<String> add(@Validated(AddDalGroup.class) @RequestBody DasGroup group, @CurrentUser LoginUser user, Errors errors) throws Exception { group.setUpdate_user_no(user.getUserNo()); ValidateResult validateRes = groupService.validatePermision(user, errors) .addAssert(() -> groupService.isNotExistInProjectAndGroup(group.getGroup_name()), "已存在!且组名和项目名不能重复！") .addAssert(() -> groupService.addDalGroup(user, group), message.db_message_add_operation_failed).validate(); if (!validateRes.isValid()) { return ServiceResult.fail(validateRes.getSummarize()); } return ServiceResult.success(); }
public static TagElement tbody() { return TagElement.of("tbody"); }
@Override public ExecutionState execute(IConversationMemory memory, List<BehaviorRule> trace) { List<IData<Context>> contextData = memory.getCurrentStep().getAllData(CONTEXT); ExecutionState state; boolean success = false; for (IData<Context> contextDatum : contextData) { Context context = contextDatum.getResult(); if (contextDatum.getKey().equals(CONTEXT + ":" + contextKey)) { switch (context.getType()) { case expressions: Expressions contextExpressions = expressionProvider. parseExpressions(context.getValue().toString()); success = Collections.indexOfSubList(contextExpressions, expressions) != -1; break; case object: try { if (object.getObjectKeyPath() != null) { final String contextObjectAsJson = jsonSerialization.serialize(context.getValue()); Object foundObjectValue = findObjectValue(contextObjectAsJson); if (foundObjectValue != null) { success = object.getObjectValue() == null || object.getObjectValue().equals(foundObjectValue.toString()); } } } catch (IOException e) { log.error(e.getLocalizedMessage(), e); success = false; } break; default: case string: success = string.equals(context.getValue().toString()); break; } } } state = success ? ExecutionState.SUCCESS : ExecutionState.FAIL; return state; }
public RevisionScope<ObjectId> resolve(String fromRev, String toRev) throws SourceControlException { ObjectId from = resolve(fromRev); ObjectId to = resolve(toRev); validate(from, to); return new SCMRevisionScope(from, to); }
boolean acceptBrotliEncoding(HttpServletRequest httpRequest) { return acceptBrotliEncoding(httpRequest.getHeader(HTTP_HEADER_ACCEPT_ENCODING)); }
public static int partition(int[] a, int p, int r) { int x = a[r]; int i = p - 1; for (int j = p; j < r; j++) { if (a[j] <= x) { i = i + 1; swap(a, i, j); System.out.println("交换=" + "i=" + i + Arrays.toString(a)); }else{ System.out.println("未交换=" + "i=" + i + Arrays.toString(a)); } } swap(a, i + 1, r); System.out.println("结果=" + "i=" + i + Arrays.toString(a)); return i + 1; }
public int getResponseCode(ToShapeId shapeOrId) { ShapeId id = shapeOrId.toShapeId(); Shape shape = model.getShape(id).orElseThrow(() -> new IllegalArgumentException("Shape not found " + id)); if (shape.isOperationShape()) { return getHttpTrait(id).getCode(); } else if (shape.getTrait(HttpErrorTrait.class).isPresent()) { return shape.getTrait(HttpErrorTrait.class).get().getCode(); } else if (shape.getTrait(ErrorTrait.class).isPresent()) { return shape.getTrait(ErrorTrait.class).get().getDefaultHttpStatusCode(); } throw new IllegalStateException(shape + " must be an operation or error structure"); }
@Override protected BaseQueryBuilder build(final MarkScaleValue context, final BaseQueryBuilder builder) { return builder .where() .openBracket() .addAndCondition(MARKSCALE_CONDITION, context.getMarkScale()) .addAndCondition(STRVALUE_CONDITION, context.getStrValue()) .closeBracket(); }
static double variance(double[] data) { int n = 0; double mean = 0.0; double m2 = 0.0; for (final double value : data) { if (!Double.isNaN(value)) { final double delta = value - mean; n++; mean = mean + delta / n; m2 = m2 + delta * (value - mean); } } if (n < 2) { return 0.0; } return m2 / (n - 1); }
public static char[] compact( char[] array ) { int nullCount = 0; for ( char ch : array ) { if ( ch == '\0' ) { nullCount++; } } char[] newArray = new char[ array.length - nullCount ]; int j = 0; for ( char ch : array ) { if ( ch == '\0' ) { continue; } newArray[ j ] = ch; j++; } return newArray; }
void curateActionList(@NotNull ActionStore.PendingAction added, @NotNull List<ActionStore.PendingAction> actions) { final ListIterator<ActionStore.PendingAction> iter = actions.listIterator(actions.size()); while (iter.hasPrevious()) { final ActionStore.PendingAction existingAction = iter.previous(); PendingActionCurator.CurateResult result = curate(added, existingAction); added = result.replacedAdded(added); if (result.removeExisting) { iter.remove(); } else { iter.set(result.replacedExisting(existingAction)); } if (result.removeAdded) { return; } if (result.stopSearch) { break; } } actions.add(added); }
@Override public Map<MetricName, Metric> getMetrics() { final Map<MetricName, Metric> gauges = new HashMap<>(); gauges.put(MetricName.build("name"), (Gauge<String>) runtime::getName); gauges.put(MetricName.build("vendor"), (Gauge<String>) () -> String.format(Locale.US, "%s %s %s (%s)", runtime.getVmVendor(), runtime.getVmName(), runtime.getVmVersion(), runtime.getSpecVersion())); gauges.put(MetricName.build("uptime"), (Gauge<Long>) runtime::getUptime); return Collections.unmodifiableMap(gauges); }
@SuppressWarnings("deprecation") protected void checkRebuildHasRun(boolean firstRun) throws Exception { Connection conn = null; ConnectionPool cpm = SQLUtility.getConnectionPool(getConfig()); try { conn = cpm.getReadWriteConnection(); long mostRecentRebuildDate = SQLUtility.getMostRecentRebuild(conn); if (firstRun && mostRecentRebuildDate == -1) { SQLUtility.recordSuccessfulRebuild(conn, System.currentTimeMillis()); } else { boolean rebuildFinished = SQLUtility.getRebuildStatus(conn, mostRecentRebuildDate); if (!rebuildFinished) { throw new ServerInitializationException( "The SQL Rebuild attempted on " + new Date(mostRecentRebuildDate).toGMTString() + " did not finish successfully, which may compromise" + " the repo. Please re-run the SQL rebuild."); } } } finally { if (conn != null) cpm.free(conn); } }
@Override public double activate(double input) { return Math.exp(-(input * input)); }
@Override public PartitionStatus combine( DoubleArray curPar, DoubleArray newPar) { double[] arr1 = curPar.get(); int size1 = curPar.size(); double[] arr2 = newPar.get(); int size2 = newPar.size(); if (size1 != size2) { return PartitionStatus.COMBINE_FAILED; } switch (operation) { case SUM: for (int i = 0; i < size2; i++) { arr1[i] += arr2[i]; } break; case MINUS: for (int i = 0; i < size2; i++) { arr1[i] -= arr2[i]; } break; case MAX: for (int i = 0; i < size2; i++) { if (arr1[i] < arr2[i]) { arr1[i] = arr2[i]; } } break; case MIN: for (int i = 0; i < size2; i++) { if (arr1[i] > arr2[i]) { arr1[i] = arr2[i]; } } break; case MULTIPLY: for (int i = 0; i < size2; i++) { arr1[i] *= arr2[i]; } break; } return PartitionStatus.COMBINED; }
void validate(final Connection connection, final DittoHeaders dittoHeaders, final ActorSystem actorSystem) { final AbstractProtocolValidator spec = specMap.get(connection.getConnectionType()); validateSourceAndTargetAddressesAreNonempty(connection, dittoHeaders); checkMappingNumberOfSourcesAndTargets(dittoHeaders, connection); validateFormatOfCertificates(connection, dittoHeaders); hostValidator.validateHostname(connection.getHostname(), dittoHeaders); if (spec != null) { spec.validate(connection, dittoHeaders, actorSystem); } else { throw new IllegalStateException("Unknown connection type: " + connection); } }
List<String> getRegionsThatUseDataSource(CacheConfig cacheConfig, String dataSourceName) { return cacheConfig.getRegions() .stream() .filter(regionConfig -> hasJdbcMappingThatUsesDataSource(regionConfig, dataSourceName)) .map(RegionConfig::getName) .collect(Collectors.toList()); }
@Procedure(value = "gds.alpha.node2vec.stream", mode = READ) @Description(NODE2VEC_DESCRIPTION) public Stream<StreamResult> stream( @Name(value = "graphName") Object graphNameOrConfig, @Name(value = "configuration", defaultValue = "{}") Map<String, Object> configuration ) { ComputationResult<Node2Vec, HugeObjectArray<Vector>, Node2VecStreamConfig> computationResult = compute( graphNameOrConfig, configuration ); if (computationResult.isGraphEmpty()) { return Stream.empty(); } Graph graph = computationResult.graph(); var result = computationResult.result(); return LongStream .range(0, graph.nodeCount()) .mapToObj(nodeId -> new StreamResult(graph.toOriginalNodeId(nodeId), result.get(nodeId).data())); }
@VisibleForTesting static Optional<DoubleRange> calculateRangeForPartitioningKey(HiveColumnHandle column, Type type, List<HivePartition> partitions) { List<OptionalDouble> convertedValues = partitions.stream() .map(HivePartition::getKeys) .map(keys -> keys.get(column)) .filter(value -> !value.isNull()) .map(NullableValue::getValue) .map(value -> convertPartitionValueToDouble(type, value)) .collect(toImmutableList()); if (convertedValues.stream().noneMatch(OptionalDouble::isPresent)) { return Optional.empty(); } List<Double> values = convertedValues.stream() .peek(convertedValue -> checkState(convertedValue.isPresent(), "convertedValue is missing")) .map(OptionalDouble::getAsDouble) .collect(toImmutableList()); verify(!values.isEmpty()); double min = values.get(0); double max = values.get(0); for (Double value : values) { if (value > max) { max = value; } if (value < min) { min = value; } } return Optional.of(new DoubleRange(min, max)); }
public static ExponentialFamilyMixture fit(double[] x, Component... components) { return fit(x, components, 0.0, 500, 1E-4); }
@Override public Characters createCData(String content) { return new SimpleXMLEventAllocator.CharactersEvent(XMLStreamConstants.CDATA, location, content, false); }
@Override public void initialize(@NotNull NodeBuilder builder) { if (!builder.hasChildNode(JcrConstants.JCR_SYSTEM)) { throw new IllegalStateException("Missing " + JcrConstants.JCR_SYSTEM + " node, NodeStore not initialized."); } NodeBuilder system = builder.getChildNode(JcrConstants.JCR_SYSTEM); if (!system.hasChildNode(REP_PRIVILEGES)) { NodeBuilder privileges = system.child(REP_PRIVILEGES); privileges.setProperty(JcrConstants.JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, Type.NAME); NodeState base = squeeze(builder.getNodeState()); NodeStore store = new MemoryNodeStore(base); try { Root systemRoot = rootProvider.createSystemRoot(store, null); new PrivilegeDefinitionWriter(systemRoot).writeBuiltInDefinitions(); } catch (RepositoryException e) { log.error("Failed to register built-in privileges", e); throw new RuntimeException(e); } NodeState target = store.getRoot(); target.compareAgainstBaseState(base, new ApplyDiff(builder)); } }
public Item getTemplateItem() throws SQLException { return template; }
public static StaffAssignment generateTestStaffAssignment() { StaffAssignment staffAssignment = new StaffAssignment(); staffAssignment.setRefId(TEST_STAFFASSIGNMENT_REFID); staffAssignment.setSchoolInfoRefId(TEST_SCHOOLINFO_REFID); staffAssignment.setStaffPersonalRefId(TEST_STAFFPERSONAL_REFID); staffAssignment.setEmployeePersonalRefId(TEST_EMPLOYEEPERSONAL_REFID); staffAssignment.setSchoolYear(new Integer(2013)); staffAssignment.setDescription("Twelfth grade computer science teacher"); staffAssignment.setPrimaryAssignment(YesNo.YES); staffAssignment.setJobStartDate(new GregorianCalendar(2010, 7, 1)); staffAssignment.setJobEndDate(new GregorianCalendar(2013, 6, 31)); staffAssignment.setJobFTE(new BigDecimal(1.00)); staffAssignment.setJobFunction(new JobFunction(JobFunctionCode.INSTRUCTION)); staffAssignment.setTeachingAssignment(new TeachingAssignment(TeachingArea.COMPUTER_SCIENCE)); staffAssignment.setGradeLevels(new GradeLevels(new GradeLevel(GradeLevelCode._12))); staffAssignment.setItinerantTeacher(YesNo.NO); InstructionalLevel instructionalLevel = new InstructionalLevel(); instructionalLevel.setCode(InstructionalLevelCode.COLLEGE_LEVEL); staffAssignment.setInstructionalLevel(instructionalLevel); return staffAssignment; }
@Override public void onAfterDraw(Plot source, Canvas canvas) { lastLatency = System.currentTimeMillis() - lastStart; if(lastLatency < shortestRenderMs) { shortestRenderMs = lastLatency; } if(lastLatency > longestRenderMs) { longestRenderMs = lastLatency; } latencySum += lastLatency; latencySamples++; annotatePlot(source, canvas); }
@Override public int read(ByteBuffer buffer) throws IOException { throwIfNotOpen(); if (buffer.remaining() == 0) { return 0; } logger.atFine().log( "Reading %s bytes at %s position from '%s'", buffer.remaining(), currentPosition, resourceId); if (currentPosition == size) { return -1; } int totalBytesRead = 0; int retriesAttempted = 0; do { int remainingBeforeRead = buffer.remaining(); performLazySeek(remainingBeforeRead); checkState( contentChannelPosition == currentPosition, "contentChannelPosition (%s) should be equal to currentPosition (%s) after lazy seek", contentChannelPosition, currentPosition); try { int numBytesRead = contentChannel.read(buffer); checkIOPrecondition(numBytesRead != 0, "Read 0 bytes without blocking"); if (numBytesRead < 0) { if (gzipEncoded) { size = currentPosition; contentChannelEnd = currentPosition; } checkIOPrecondition( currentPosition == contentChannelEnd || currentPosition == size, String.format( "Received end of stream result before all the file data has been received; " + "totalBytesRead: %d, currentPosition: %d," + " contentChannelEnd %d, size: %d, object: '%s'", totalBytesRead, currentPosition, contentChannelEnd, size, resourceId)); if (contentChannelEnd != size && currentPosition == contentChannelEnd) { closeContentChannel(); } else { break; } } if (numBytesRead > 0) { totalBytesRead += numBytesRead; currentPosition += numBytesRead; contentChannelPosition += numBytesRead; checkState( contentChannelPosition == currentPosition, "contentChannelPosition (%s) should be equal to currentPosition (%s)" + " after successful read", contentChannelPosition, currentPosition); } if (retriesAttempted != 0) { logger.atInfo().log( "Success after %s retries on reading '%s'", retriesAttempted, resourceId); } retriesAttempted = 0; } catch (IOException ioe) { logger.atFine().log( "Closing contentChannel after %s exception for '%s'.", ioe.getMessage(), resourceId); closeContentChannel(); if (buffer.remaining() != remainingBeforeRead) { int partialRead = remainingBeforeRead - buffer.remaining(); logger.atInfo().log( "Despite exception, had partial read of %s bytes from '%s'; resetting retry count.", partialRead, resourceId); retriesAttempted = 0; totalBytesRead += partialRead; currentPosition += partialRead; } if (retriesAttempted == maxRetries) { logger.atSevere().log( "Throwing exception after reaching max read retries (%s) for '%s'.", maxRetries, resourceId); throw ioe; } if (retriesAttempted == 0) { readBackOff.get().reset(); } ++retriesAttempted; logger.atWarning().withCause(ioe).log( "Failed read retry #%s/%s for '%s'. Sleeping...", retriesAttempted, maxRetries, resourceId); try { boolean backOffSuccessful = BackOffUtils.next(sleeper, readBackOff.get()); if (!backOffSuccessful) { logger.atSevere().log( "BackOff returned false; maximum total elapsed time exhausted." + " Giving up after %s/%s retries for '%s'", retriesAttempted, maxRetries, resourceId); throw ioe; } } catch (InterruptedException ie) { Thread.currentThread().interrupt(); logger.atSevere().log( "Interrupted while sleeping before retry. Giving up after %s/%s retries for '%s'", retriesAttempted, maxRetries, resourceId); ioe.addSuppressed(ie); throw ioe; } logger.atInfo().log( "Done sleeping before retry #%s/%s for '%s'", retriesAttempted, maxRetries, resourceId); } catch (RuntimeException r) { closeContentChannel(); throw r; } } while (buffer.remaining() > 0 && currentPosition < size); boolean isEndOfStream = (totalBytesRead == 0); if (isEndOfStream) { checkIOPrecondition( currentPosition == size, String.format( "Failed to read any data before all the file data has been received;" + " currentPosition: %d, size: %d, object '%s'", currentPosition, size, resourceId)); return -1; } return totalBytesRead; }
public void clear() { nodeClear(myTopNode); myTopNode.setRange(null); }
@Override public String convert(final String name) { return converter.convert(entity.getBody(), name); }
public static byte[] parseMAC(String value) { final byte[] machineId; final char separator; switch (value.length()) { case 17: separator = value.charAt(2); validateMacSeparator(separator); machineId = new byte[EUI48_MAC_ADDRESS_LENGTH]; break; case 23: separator = value.charAt(2); validateMacSeparator(separator); machineId = new byte[EUI64_MAC_ADDRESS_LENGTH]; break; default: throw new IllegalArgumentException("value is not supported [MAC-48, EUI-48, EUI-64]"); } final int end = machineId.length - 1; int j = 0; for (int i = 0; i < end; ++i, j += 3) { final int sIndex = j + 2; machineId[i] = StringUtil.decodeHexByte(value, j); if (value.charAt(sIndex) != separator) { throw new IllegalArgumentException("expected separator '" + separator + " but got '" + value.charAt(sIndex) + "' at index: " + sIndex); } } machineId[end] = StringUtil.decodeHexByte(value, j); return machineId; }
@Override @Nullable public Object getSemanticModel() { if (!semanticEnabled) { return null; } return tree.sema; }
@Override public boolean evaluate(FeatureFilterEvaluationContext context) { if (context == null) { throw new IllegalArgumentException("Targeting Context not configured."); } TargetingContext targetingContext = contextAccessor.getContextAsync().block(); if (targetingContext == null) { LOGGER.warn("No targeting context available for targeting evaluation."); return false; } TargetingFilterSettings settings = new TargetingFilterSettings(); LinkedHashMap<String, Object> parameters = context.getParameters(); if (parameters != null) { Object audienceObject = parameters.get(AUDIENCE); if (audienceObject != null) { parameters = (LinkedHashMap<String, Object>) audienceObject; } this.<String>updateValueFromMapToList(parameters, USERS); updateValueFromMapToList(parameters, GROUPS); settings.setAudience(mapper.convertValue(parameters, Audience.class)); } tryValidateSettings(settings); Audience audience = settings.getAudience(); if (targetingContext.getUserId() != null && audience.getUsers() != null && audience.getUsers().stream() .anyMatch(user -> compairStrings(targetingContext.getUserId(), user))) { return true; } if (targetingContext.getGroups() != null && audience.getGroups() != null) { for (String group : targetingContext.getGroups()) { Optional<GroupRollout> groupRollout = audience.getGroups().stream() .filter(g -> compairStrings(g.getName(), group)).findFirst(); if (groupRollout.isPresent()) { String audienceContextId = targetingContext.getUserId() + "\n" + context.getName() + "\n" + group; if (isTargeted(audienceContextId, groupRollout.get().getRolloutPercentage())) { return true; } } } } String defaultContextId = targetingContext.getUserId() + "\n" + context.getFeatureName(); return isTargeted(defaultContextId, settings.getAudience().getDefaultRolloutPercentage()); }
@Override public Storeable put(String key, Storeable value) throws ColumnFormatException { if (key == null || value == null) { throw new IllegalArgumentException("put: null arguments"); } try { lock.readLock().lock(); checkActuality(); Storeable oldValue; if (!difference.get().containsKey(key)) { DataFile expectedDataFile = tableMap.get(new Coordinates(key, TableManager.NUMBER_OF_PARTITIONS)); if (expectedDataFile == null) { oldValue = null; } else { oldValue = expectedDataFile.get(key); } } else { oldValue = difference.get().get(key); } difference.get().put(key, value); return oldValue; } finally { lock.readLock().unlock(); } }
@Override public boolean isEnable() { return null != config && config.isEventBusEnable(); }
static String stripLtrMarker(String tweetText) { if (tweetText.endsWith(Character.toString('\u200E'))) { return tweetText.substring(0, tweetText.length() - 1); } return tweetText; }
@Override public void onCloseItemClicked(@Nonnull Notification notification) { removeNotification(notification); onCloseClicked(notification); }
@JsonProperty("server") public Server server() { return server; }
@NonNull public List<String> getImpressionTrackers() { final Set<String> allImpressionTrackers = new HashSet<String>(); allImpressionTrackers.addAll(mMoPubImpressionTrackers); allImpressionTrackers.addAll(mNativeAd.getImpressionTrackers()); return new ArrayList<String>(allImpressionTrackers); }
public static ContentTypeField contentType(String contentType) { return parse(ContentTypeFieldImpl.PARSER, FieldName.CONTENT_TYPE, contentType); }
@Override public ImmutableListPathCore subpath(int beginIndex, int endIndex) { checkPositionIndex(endIndex, getNameCount(), "endIndex"); checkElementIndex(beginIndex, endIndex, "beginIndex"); return new ImmutableListPathCore(null, path.subList(beginIndex, endIndex)); }
public static <E> List<E> listOf(Class<E> elementClass) { return new ListBuilder<E>().build(); }
public static Class<?> getWrappedClass(Class<?> clazz) { if (!clazz.isPrimitive()) { return clazz; } return PRIMITIVES_TO_WRAPPERS.getOrDefault(clazz, clazz); }
public static boolean isContentProvider(CtClass clazz) throws NotFoundException { return isSubClass(clazz.getClassPool(), clazz, ContentProvider.class); }
void removeDrgElementsWithoutShape(final List<org.kie.dmn.model.api.DRGElement> drgElements, final List<DMNShape> dmnShapes) { if (dmnShapes.isEmpty()) { return; } drgElements.removeIf(element -> dmnShapes.stream().noneMatch(s -> s.getDmnElementRef().getLocalPart().endsWith(element.getId()))); }
@Pure public static double clampToNearestBounds(double value, double minBounds, double maxBounds) { assert minBounds <= maxBounds : AssertMessages.lowerEqualParameters(1, minBounds, 2, maxBounds); final double center = (minBounds + maxBounds) / 2; if (value <= center) { return minBounds; } return maxBounds; }
@Override public void closed(CommandContext commandContext) { List<CloudRuntimeEvent<?, ?>> events = commandContext.getGenericAttribute(PROCESS_ENGINE_EVENTS); if (events != null && !events.isEmpty()) { CloudRuntimeEvent<?, ?>[] payload = events.stream() .filter(CloudRuntimeEventImpl.class::isInstance) .map(CloudRuntimeEventImpl.class::cast) .map(runtimeBundleInfoAppender::appendRuntimeBundleInfoTo) .toArray(CloudRuntimeEvent<?, ?>[]::new); Message<CloudRuntimeEvent<?, ?>[]> message = messageBuilderChainFactory.create(null) .withPayload(payload) .build(); producer.auditProducer().send(message); } }
@Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } return compareTo((IntegerPartitionChunk<T>) o) == 0; }
static TimePeriod nextUp(TimePeriod period) { switch(period.fieldId) { case GregorianCalendar.MILLISECOND: if (period.amount < 2) { return new TimePeriod(GregorianCalendar.MILLISECOND, 2); } if (period.amount < 5) { return new TimePeriod(GregorianCalendar.MILLISECOND, 5); } if (period.amount < 10) { return new TimePeriod(GregorianCalendar.MILLISECOND, 10); } if (period.amount < 20) { return new TimePeriod(GregorianCalendar.MILLISECOND, 20); } if (period.amount < 50) { return new TimePeriod(GregorianCalendar.MILLISECOND, 50); } if (period.amount < 100) { return new TimePeriod(GregorianCalendar.MILLISECOND, 100); } if (period.amount < 200) { return new TimePeriod(GregorianCalendar.MILLISECOND, 200); } if (period.amount < 500) { return new TimePeriod(GregorianCalendar.MILLISECOND, 500); } return new TimePeriod(GregorianCalendar.SECOND, 1); case GregorianCalendar.SECOND: if (period.amount < 2) { return new TimePeriod(GregorianCalendar.SECOND, 2); } if (period.amount < 5) { return new TimePeriod(GregorianCalendar.SECOND, 5); } if (period.amount < 10) { return new TimePeriod(GregorianCalendar.SECOND, 10); } if (period.amount < 15) { return new TimePeriod(GregorianCalendar.SECOND, 15); } if (period.amount < 30) { return new TimePeriod(GregorianCalendar.SECOND, 30); } return new TimePeriod(GregorianCalendar.MINUTE, 1); case GregorianCalendar.MINUTE: if ( period.amount < 2 ) { return new TimePeriod( GregorianCalendar.MINUTE , 2 ); } if ( period.amount < 5 ) { return new TimePeriod( GregorianCalendar.MINUTE , 5 ); } if ( period.amount < 10 ) { return new TimePeriod( GregorianCalendar.MINUTE , 10 ); } if ( period.amount < 15 ) { return new TimePeriod( GregorianCalendar.MINUTE , 15 ); } if ( period.amount < 30 ) { return new TimePeriod( GregorianCalendar.MINUTE , 30 ); } return new TimePeriod( HOUR_FIELD_ID, 1 ); case HOUR_FIELD_ID: if ( period.amount < 2 ) { return new TimePeriod( HOUR_FIELD_ID , 2 ); } if ( period.amount < 3 ) { return new TimePeriod( HOUR_FIELD_ID , 3 ); } if ( period.amount < 6 ) { return new TimePeriod( HOUR_FIELD_ID , 6 ); } if ( period.amount < 12 ) { return new TimePeriod( HOUR_FIELD_ID , 12 ); } if ( period.amount < 24 ) { return new TimePeriod( HOUR_FIELD_ID , 24 ); } return new TimePeriod( DAY_FIELD_ID , 1 ); case DAY_FIELD_ID: if ( period.amount < 2 ) { return new TimePeriod( DAY_FIELD_ID , 2 ); } if ( period.amount < 4 ) { return new TimePeriod( DAY_FIELD_ID , 4 ); } return new TimePeriod( WEEK_FIELD_ID , 1 ); case WEEK_FIELD_ID: if ( period.amount < 2 ) { return new TimePeriod( WEEK_FIELD_ID , 2 ); } return new TimePeriod( GregorianCalendar.MONTH , 1 ); case GregorianCalendar.MONTH: if ( period.amount < 2 ) { return new TimePeriod( GregorianCalendar.MONTH , 2 ); } if ( period.amount < 4 ) { return new TimePeriod( GregorianCalendar.MONTH , 4 ); } if ( period.amount < 8 ) { return new TimePeriod( GregorianCalendar.MONTH , 8 ); } return new TimePeriod( GregorianCalendar.YEAR , 1 ); case GregorianCalendar.YEAR: return new TimePeriod( GregorianCalendar.YEAR , period.amount/4+1 ); } return null; }
public List<Right> getRightsForUserAndWarehouse(Long userId, Long warehouseId) { return roleRightsMapper.getRightsForUserAndWarehouse(userId, warehouseId); }
public synchronized X509TrustManager getX509TrustManager() { return x509TrustManager; }
@Override public ResourceList<Image> getImages() throws IOException { ResourceList<Image> imageResourceList = new ResourceList<>(); ResourceList<Image> resourceList = getImageResourceList(getBasePath()); imageResourceList.setItems(resourceList.getItems()); while (resourceList.getNextPageLink() != null && !resourceList.getNextPageLink().isEmpty()) { resourceList = getImageResourceList(resourceList.getNextPageLink()); imageResourceList.getItems().addAll(resourceList.getItems()); } return imageResourceList; }
@Override public String toQueryString() { if (value == null || value.isEmpty()) { return "1 > 1"; } return getPropNameWithAlias() + " in " + getParamNameWithColon(); }
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; String contextPath = request.getContextPath(); String requestURI = request.getRequestURI(); String path = requestURI.substring(contextPath.length()); if (endpointMatcher.match(request)) { DEBUG.message("Path: " + path + " Method: " + request.getMethod() + " Added as exception. Not protected."); filterChain.doFilter(servletRequest, servletResponse); } else { DEBUG.message("Path: " + path + " Method: " + request.getMethod() + " Protected resource."); super.doFilter(servletRequest, servletResponse, filterChain); } }
@Override public CompetitionSetupForm populateForm(CompetitionResource competitionResource, Optional<Long> objectId) { QuestionForm competitionSetupForm = new QuestionForm(); if (objectId.isPresent()) { CompetitionSetupQuestionResource questionResource = questionSetupCompetitionRestService.getByQuestionId( (objectId.get())).getSuccess(); competitionSetupForm.setQuestion(questionResource); if (sectionContainsMoreThanOneQuestion(objectId.get())) { competitionSetupForm.setRemovable(true); } if (questionResource.getNumberOfUploads() == 0) { competitionSetupForm.setNumberOfUploads(0); questionResource.setAppendix(false); } else { competitionSetupForm.setNumberOfUploads(questionResource.getNumberOfUploads()); questionResource.setAppendix(true); } competitionSetupForm.getQuestion().getGuidanceRows().forEach(guidanceRowResource -> { GuidanceRowForm grvm = new GuidanceRowForm(guidanceRowResource); competitionSetupForm.getGuidanceRows().add(grvm); }); } else { throw new ObjectNotFoundException(); } return competitionSetupForm; }
public static <A, B, C> Function<Pair<A, B>, Pair<A, C>> mapB(Function<B, C> f) { return p -> Pair.of(p.a, f.apply(p.b)); }
@Override public Collection<MailAddress> match(Mail mail) throws MessagingException { return AttributeUtils .getAttributeValueFromMail(mail, attributeName) .filter(obj -> pattern.matcher(obj.toString()).matches()) .map(any -> mail.getRecipients()) .orElse(null); }
@Override public void doOnMessage(Message message) throws Exception { LOG.debug("Entering " + getClass()); LOG.debug(message); LoadBalancer queLb = getLoadbalancerFromMessage(message); LoadBalancer dbLoadBalancer; try { dbLoadBalancer = loadBalancerService.getWithUserPages(queLb.getId(), queLb.getAccountId()); } catch (EntityNotFoundException enfe) { String alertDescription = String.format("Load balancer '%d' not found in database.", queLb.getId()); LOG.error(alertDescription, enfe); notificationService.saveAlert(queLb.getAccountId(), queLb.getId(), enfe, DATABASE_FAILURE.name(), alertDescription); sendErrorToEventResource(queLb); return; } try { if (isRestAdapter()) { LOG.debug(String.format("Updating content caching for load balancer '%d' in STM...", dbLoadBalancer.getId())); reverseProxyLoadBalancerStmService.updateLoadBalancer(dbLoadBalancer, queLb); LOG.debug(String.format("Successfully updated content caching for load balancer '%d' in Zeus.", dbLoadBalancer.getId())); } else { LOG.debug(String.format("Updating connection throttle for load balancer '%d' in ZXTM...", dbLoadBalancer.getId())); reverseProxyLoadBalancerService.updateContentCaching(dbLoadBalancer); LOG.debug(String.format("Successfully updated connection throttle for load balancer '%d' in Zeus.", dbLoadBalancer.getId())); } } catch (Exception e) { loadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ERROR); String alertDescription = String.format("Error updating content caching for load balancer '%d' in Zeus.", dbLoadBalancer.getId()); LOG.error(alertDescription, e); notificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), e, ZEUS_FAILURE.name(), alertDescription); sendErrorToEventResource(queLb); return; } String desc = "Content caching successully set to " + dbLoadBalancer.isContentCaching().toString(); notificationService.saveLoadBalancerEvent(queLb.getUserName(), dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), UPDATE_CCACHING_TITLE, desc, EventType.UPDATE_CONTENT_CACHING, UPDATE, EventSeverity.INFO); loadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ACTIVE); LOG.info("Update content caching operation complete."); }
public static Optional<IntCollection> intersection(Collection<IntCollection> clusters) { List<IntCollection> sorted = sort(clusters, CLUSTER_COMPARATOR); return createIntersector(sorted).map(HeadAndTailIntersector::intersect); }
public void validate(Long workspaceId, NameOrCrn nameOrCrn, String location, String backupId) { Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId); ValidationResult validationResult = requestValidator.validate(stack, location, backupId); if (validationResult.hasError()) { throw new BadRequestException(validationResult.getFormattedErrors()); } }
public static Set<String> realLocation(final String location) { final boolean initialized = SystemInstance.isInitialized(); if (!initialized) { if (DEFAULT_PROVISIONING_RESOLVER == null) { synchronized (ProvisioningUtil.class) { if (DEFAULT_PROVISIONING_RESOLVER == null) { DEFAULT_PROVISIONING_RESOLVER = new ProvisioningResolver(); } } } return DEFAULT_PROVISIONING_RESOLVER.realLocation(location); } return SystemInstance.get().getComponent(ProvisioningResolver.class).realLocation(location); }
public static int parseInteger(final String parameter) throws NumberFormatException { return Integer.parseInt(parameter); }
public String toAgentArg() { StringBuilder arg = new StringBuilder(); for (Map.Entry<String,String> entry : options.entrySet()) { String key = entry.getKey(); if (!key.equals("quiet") && !key.equals("verbose")) { arg.append(key).append("=").append(EscapeUtil.escape(entry.getValue(),EscapeUtil.CSV_ESCAPE,",")).append(","); } } return arg.length() > 0 ? arg.substring(0,arg.length() - 1) : ""; }
@Override public void setConf(Configuration conf) { super.setConf(conf); getRawMapping().setConf(conf); }
public static Region parseRegion(String value) { if (StringUtils.isEmpty(value)) { throw new IllegalArgumentException(String.format(ExceptionMsgs.INVALID_VALUE_FOR_INPUT, value, InputNames.REGION)); } String[] coords = value.split("[,]"); if (coords.length != 4) { throw new IllegalArgumentException(ExceptionMsgs.INVALID_NR_OF_COORDS); } int left = Integer.parseInt(coords[0]); int top = Integer.parseInt(coords[1]); int right = Integer.parseInt(coords[2]); int bottom = Integer.parseInt(coords[3]); return new Region(left, top, right, bottom); }
public AggregationResponse readAggregationResponse(KSIRequestContext context, ServiceCredentials credentials, TLVElement input) throws KSIException { return this.aggregatorPduV2Factory.readAggregationResponse(context, credentials, input); }
public void putInt(long index, int value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addInt(getPageOffset(index), value); numProperties += page.getSize() - n; }
public String getScope() { return this.scope; }
@Override public String isPurchaseValid(String sku, UserData userData, Receipt receipt) { Log.d(TAG, "calling validateReceipt"); String requestId = createRandomString(receipt.getReceiptId(), 10); mReceiptVerifier.validateReceipt(mContext, requestId, sku, userData, receipt, mPurchaseListener); return requestId; }
public static FEEL_1_1Parser parse(FEELEventListenersManager eventsManager, String source, Map<String, Type> inputVariableTypes, Map<String, Object> inputVariables, Collection<FEELFunction> additionalFunctions, List<FEELProfile> profiles, FEELTypeRegistry typeRegistry) { CharStream input = CharStreams.fromString(source); FEEL_1_1Lexer lexer = new FEEL_1_1Lexer( input ); CommonTokenStream tokens = new CommonTokenStream( lexer ); FEEL_1_1Parser parser = new FEEL_1_1Parser( tokens ); ParserHelper parserHelper = new ParserHelper(eventsManager); additionalFunctions.forEach(f -> parserHelper.getSymbolTable().getBuiltInScope().define(f.getSymbol())); parser.setHelper(parserHelper); parser.setErrorHandler( new FEELErrorHandler() ); parser.removeErrorListeners(); parser.addErrorListener( new FEELParserErrorListener( eventsManager ) ); defineVariables( inputVariableTypes, inputVariables, parser ); if (typeRegistry != null) { parserHelper.setTypeRegistry(typeRegistry); } return parser; }
public double getSpeedAtTime(double time) { if (DoubleMath.fuzzyEquals(time, totalDuration, totalDuration * ROUNDING_ERROR_FRACTION)) { TraversalSection lastSection = Iterables.getLast(sections); return lastSection.getSpeedAtTime(lastSection.getDuration()); } if (time > totalDuration) { return 0; } if (time < 0) { throw new TraversalCalculationException("Negative time provided"); } return SegmentGraphUtilities.getValueAt( sections, TraversalSection::getDuration, TraversalSection::getSpeedAtTime, time); }
@Override public ConsumerGroupDeleteResponse deleteConsumerGroup(long consumerGroupId, boolean checkOnline) { CacheUpdateHelper.updateCache(); Map<String, ConsumerGroupEntity> consumerGroupMap = getCache(); ConsumerGroupEntity consumerGroupEntity = get(consumerGroupId); if (consumerGroupEntity.getMode() == 2 && consumerGroupEntity.getOriginName().equals(consumerGroupEntity.getName())) { for (String key : consumerGroupMap.keySet()) { if (consumerGroupMap.get(key) != null) { if (consumerGroupMap.get(key).getOriginName().equals(consumerGroupEntity.getName()) && consumerGroupMap.get(key).getId() != consumerGroupEntity.getId()) { return new ConsumerGroupDeleteResponse("1","存在镜像组时，不能删除原始组。"); } } } } return doDelete(consumerGroupEntity, checkOnline); }
public static long getPID() { if (isUnix()) { try { final Process process = new ProcessBuilder() .command("/bin/sh", "-c", "echo $PPID") .start(); final int exitCode = process.waitFor(); if (exitCode != 0) { LOG.log(Level.SEVERE, "Unable to determine PID. Exit code = {0}", exitCode); final StringBuilder errorMsg = new StringBuilder(); try (BufferedReader reader = new BufferedReader( new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8))) { for (int i = 0; i < 10 && reader.ready(); ++i) { errorMsg.append(reader.readLine()).append('\n'); } } LOG.log(Level.SEVERE, "Error:\n{0}", errorMsg); return -1; } final byte[] returnBytes = new byte[128]; if (process.getInputStream().read(returnBytes) == -1) { LOG.log(Level.FINE, "No data read because end of stream was reached"); } process.destroy(); return Long.parseLong(new String(returnBytes, StandardCharsets.UTF_8).trim()); } catch (final IOException | InterruptedException e) { LOG.log(Level.SEVERE, "Unable to determine PID", e); return -1; } } else if (isWindows()) { final String name = ManagementFactory.getRuntimeMXBean().getName(); try { return Long.parseLong(name.split("@")[0]); } catch (final NumberFormatException e) { LOG.log(Level.SEVERE, "Unable to parse PID from string " + name, e); return -1; } } else { return -1; } }
@Override public ExitStatus call() throws Exception { final List<byte[]> sequences = binaryInput.readBinarySequences(input, (byte) '\n'); Collections.sort(sequences, FSABuilder.LEXICAL_ORDERING); FSA fsa = FSABuilder.build(sequences); FSASerializer serializer = format.getSerializer(); try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(output))) { serializer.serialize(fsa, os); } return ExitStatus.SUCCESS; }
@Before("execution(* com.agiletec.apsadmin.portal.PageSettingsAction.updateSystemParamsForAjax())") public void executeUpdateSystemParams(JoinPoint joinPoint) { HttpServletRequest request = ServletActionContext.getRequest(); PageSettingsAction action = (PageSettingsAction) joinPoint.getTarget(); try { String robotContent = request.getParameter(PARAM_ROBOT_CONTENT_CODE); String alternativePath = request.getParameter(PARAM_ROBOT_ALTERNATIVE_PATH_CODE); InputStream is = (!StringUtils.isBlank(robotContent)) ? new ByteArrayInputStream(robotContent.getBytes("UTF-8")) : null; if (StringUtils.isBlank(alternativePath)) { if (null != is) { this.getStorageManager().saveFile(ROBOT_FILENAME, false, is); } else { this.getStorageManager().deleteFile(ROBOT_FILENAME, false); } } else if (!PageSettingsUtils.isRightPath(alternativePath)) { action.addFieldError(PARAM_ROBOT_ALTERNATIVE_PATH_CODE, action.getText("jpseo.error.robotFilePath.invalid", new String[]{alternativePath})); } else if (this.checkPath(alternativePath, action)) { if (null != is) { this.saveFile(alternativePath, is, action); } else { File file = new File(alternativePath); try { if (file.exists()) { file.delete(); } } catch (Exception e) { logger.error("error deleting file {}", alternativePath); } } } String xmlParams = this.getConfigManager().getConfigItem(SystemConstants.CONFIG_ITEM_PARAMS); Map<String, String> systemParams = SystemParamsUtils.getParams(xmlParams); if (!StringUtils.isEmpty(alternativePath)) { systemParams.put(JpseoSystemConstants.ROBOT_ALTERNATIVE_PATH_PARAM_NAME, alternativePath); } else { systemParams.remove(JpseoSystemConstants.ROBOT_ALTERNATIVE_PATH_PARAM_NAME); } String newXmlParams = SystemParamsUtils.getNewXmlParams(xmlParams, systemParams, true); this.getConfigManager().updateConfigItem(SystemConstants.CONFIG_ITEM_PARAMS, newXmlParams); } catch (Throwable t) { logger.error("error updating page settings for seo", t); action.addActionError("error updating page settings for seo"); } }
@Override public T pollLast() { if (_tail == null) { return null; } return removeNode(_tail); }
public static <T> Global<T> globally() { return new Global<>(); }
@Override public PluggableIAction unmarshal(final String iActionString) throws RuleModelDRLPersistenceException { List<String> parameters = StringUtils.splitArgumentsList(PersistenceExtensionUtils.unwrapParenthesis(iActionString)); if (!parameters.isEmpty() && "kcontext".equals(parameters.get(0))) { if (parameters.size() == 2) { return new ActionHardConstraintMatch(PersistenceExtensionUtils.extractConstraintMatchValue(parameters.get(1))); } if (parameters.size() == 3) { try { int bendableScoreLevel = Integer.parseInt(parameters.get(1)); return new ActionBendableHardConstraintMatch(bendableScoreLevel, PersistenceExtensionUtils.extractConstraintMatchValue(parameters.get(2))); } catch (NumberFormatException e) { LOGGER.error("Could not parse bendable score level parameter " + parameters.get(1) + " as an Integer"); } } } throw new RuleModelDRLPersistenceException(PersistenceExtensionUtils.EXCEPTION_MESSAGE_BASE + iActionString); }
@Nullable static TraceContext parseBytes(byte[] bytes, @Nullable TagsBin tags) { if (bytes == null) throw new NullPointerException("bytes == null"); if (bytes.length == 0) return null; if (bytes[0] != VERSION) { Platform.get().log("Invalid input: unsupported version {0}", bytes[0], null); return null; } if (bytes.length < FORMAT_LENGTH - 2 ) { Platform.get().log("Invalid input: truncated", null); return null; } long traceIdHigh, traceId, spanId; int pos = 1; if (bytes[pos] == TRACE_ID_FIELD_ID) { pos++; traceIdHigh = readLong(bytes, pos); traceId = readLong(bytes, pos + 8); pos += 16; } else { Platform.get().log("Invalid input: expected trace ID at offset {0}", pos, null); return null; } if (bytes[pos] == SPAN_ID_FIELD_ID) { pos++; spanId = readLong(bytes, pos); pos += 8; } else { Platform.get().log("Invalid input: expected span ID at offset {0}", pos, null); return null; } Boolean sampled = null; if (bytes.length > pos && bytes[pos] == TRACE_OPTION_FIELD_ID) { pos++; if (bytes.length < pos + 1) { Platform.get().log("Invalid input: truncated", null); return null; } sampled = bytes[pos] == 1; } TraceContext.Builder builder = TraceContext.newBuilder() .traceIdHigh(traceIdHigh) .traceId(traceId) .spanId(spanId); if (sampled != null) builder.sampled(sampled.booleanValue()); if (tags != null) builder.extra(Collections.singletonList(tags)); return builder.build(); }
public void setViewState(@Nullable final State state) { mState = state; if (state == null) { setVisibility(GONE); return; } setVisibility(View.VISIBLE); if (State.NO_DATA.equals(mState)) { populateDefaultState(); } else if (State.UPDATING.equals(mState)) { populateBusyProgressBarView(); } else { populate(state.mGuidanceManeuverData); } }
public IAtomContainer parseSmiles(String smiles) throws InvalidSmilesException { return parseSmiles(smiles, false); }
@Override public void onInboundMessage(JmsInboundMessageDispatch envelope) { listener.onInboundMessage(envelope); }
public List<Map<String, Object>> getCerticatesDetails(String assetGroup, String searchText, Map<String, String> filter) throws ServiceException { try { return certificateRepository.getCertificatesDetails(assetGroup, searchText, filter); } catch (DataException e) { throw new ServiceException(e); } }
@Override public boolean hasPermission(Authentication authentication, Widget widget, Permission permission) { return hasPermission(authentication, widget, permission, false); }
public static Stream<Node<Bytes>> breadthFirstDecoder( final NodeLoader nodeLoader, final Bytes32 rootHash, final int maxDepth) { checkArgument(maxDepth >= 0); return Streams.stream(new BreadthFirstIterator(nodeLoader, rootHash, maxDepth)); }
@Override public String filter(final String path) { int filterIndex = 0; int previousIndex = 0; do { if (filter[filterIndex] != null) { if (!path.regionMatches(previousIndex, filter[filterIndex], 0, filter[filterIndex].length())) { return path; } previousIndex += filter[filterIndex].length(); filterIndex++; } else { final int nextIndex = path.indexOf('/', previousIndex); if (nextIndex != -1) { previousIndex = nextIndex; } else { previousIndex = path.length(); break; } filterIndex++; } } while (filterIndex < filter.length); if (previousIndex == path.length()) { return substitute; } return substitute + path.substring(previousIndex); }
@Override public void update(@NotNull Runner runner) { this.runner = runner; this.runnerStatus = runner.getStatus(); changeRunnerStatusIcon(); itemWidget.setName(runner.getTitle()); itemWidget.setDescription(runner.getRAM() + "MB"); itemWidget.setStartTime(runner.getCreationTime()); }
public Distribution create(Distribution distribution) { distribution.setStatus(DistributionStatus.INITIATED); mapper.insert(distribution); return distribution; }
@NonNull @CheckResult public static Single<DataSnapshot> data(@NonNull DatabaseReference ref) { return Single.create(new DataOnSubscribe(ref)); }
@Override public Double create( String value ) { if (value == null) return null; try { return Double.valueOf(value.trim()); } catch (NumberFormatException err) { throw new ValueFormatException(value, getPropertyType(), GraphI18n.errorConvertingType.text(String.class.getSimpleName(), Double.class.getSimpleName(), value), err); } }
public static <T> String toString( Iterable<T> iterable, String start, String sep, String end) { final StringBuilder buf = new StringBuilder(); buf.append(start); for (Ord<T> ord : Ord.zip(iterable)) { if (ord.i > 0) { buf.append(sep); } buf.append(ord.e); } buf.append(end); return buf.toString(); }
public List<String> getRepositories() { if (token.hasMultiaccess()) { return configuration.getRepositories(); } for (String repository : configuration.getRepositories()) { String name = "/" + repository; if (token.getPath().startsWith(name)) { return Collections.singletonList(repository); } } return Collections.emptyList(); }
void pollAndExecute(Worker worker) { if (eurekaClient != null && !eurekaClient.getInstanceRemoteStatus().equals(InstanceStatus.UP)) { LOGGER.debug("Instance is NOT UP in discovery - will not poll"); return; } if (worker.paused()) { MetricsContainer.incrementTaskPausedCount(worker.getTaskDefName()); LOGGER.debug("Worker {} has been paused. Not polling anymore!", worker.getClass()); return; } Task task; try { if (!pollingSemaphore.canPoll()) { return; } String taskType = worker.getTaskDefName(); String domain = Optional.ofNullable(PropertyFactory.getString(taskType, DOMAIN, null)) .orElse(PropertyFactory.getString(ALL_WORKERS, DOMAIN, null)); LOGGER.debug("Polling task of type: {} in domain: '{}'", taskType, domain); task = MetricsContainer.getPollTimer(taskType) .record(() -> taskClient.pollTask(taskType, worker.getIdentity(), domain)); if (Objects.nonNull(task) && StringUtils.isNotBlank(task.getTaskId())) { MetricsContainer.incrementTaskPollCount(taskType, 1); LOGGER.debug("Polled task: {} of type: {} in domain: '{}', from worker: {}", task.getTaskId(), taskType, domain, worker.getIdentity()); CompletableFuture<Task> taskCompletableFuture = CompletableFuture.supplyAsync(() -> processTask(task, worker), executorService); taskCompletableFuture.whenComplete(this::finalizeTask); } else { pollingSemaphore.complete(); } } catch (Exception e) { pollingSemaphore.complete(); MetricsContainer.incrementTaskPollErrorCount(worker.getTaskDefName(), e); LOGGER.error("Error when polling for tasks", e); } }
public Object execute(final Object value, final CsvContext context) { validateInputNotNull(value, context); if( !(value instanceof Time) ) { throw new SuperCsvCellProcessorException(Time.class, value, context, this); } final SimpleDateFormat formatter; try { formatter = new SimpleDateFormat(dateFormat); } catch(IllegalArgumentException e) { throw new SuperCsvCellProcessorException(String.format("'%s' is not a valid date format", dateFormat), context, this, e); } String result = formatter.format((Time) value); return next.execute(result, context); }
@Override public String toString() { if (this.artists != null && getName() != null) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder = stringBuilder.append(getName()).append(" from: "); for (String name : this.artists) { stringBuilder = stringBuilder.append(name).append(", "); } return stringBuilder.toString(); } return "No song data available"; }
protected void removeSavedFilter(final MultiGridPreferencesStore store, String key) { store.removeTab(key); if (key.equals(store.getDefaultGridId())) { if (store.getGridsId().size() > 0) { store.setDefaultGridId(store.getGridsId().get(0)); } else { store.setDefaultGridId(null); } } }
@Override public Optional<String> agentUserId() { return agentUserId; }
@Override public boolean equals(Object that) { return that instanceof IsEqual<?, ?>; }
@Override public Stream<Feature> getFeatures() { return Stream.concat( hasRoot() ? root.getFeatures() : Stream.empty(), getChildren().flatMap(Section::getFeatures)); }
public static boolean deleteDirectory(String directoryPath) { File directory = new File(directoryPath); if (directory.isDirectory()) { if (directory.listFiles().length == 0) { return delete(directory, true); } } return false; }
public PRPAIN201306UV02 createNewRequest(PRPAIN201306UV02 request, String targetCommunityId) { PRPAIN201306UV02 newRequest = request; if (request != null && NullChecker.isNotNullish(targetCommunityId)) { newRequest.getReceiver().clear(); MCCIMT000300UV01Receiver oNewReceiver = HL7ReceiverTransforms .createMCCIMT000300UV01Receiver(targetCommunityId); newRequest.getReceiver().add(oNewReceiver); LOG.debug("Created a new request for target communityId: " + targetCommunityId); } else { LOG.error("A null input paramter was passed to the method: createNewRequest in class: PatientDiscovery201305Processor"); return null; } return newRequest; }
@Override public Class convert(String value) { if (isBlank(value)) { throw new ParameterException(getErrorString("a blank value", "a class")); } try { return Class.forName(value); } catch (ClassNotFoundException e) { throw new ParameterException(getErrorString(value, "a class")); } }
@Nullable public FloatWritable evaluate(@Nullable final Double value, @CheckForNull final Double min, @CheckForNull final Double max) throws HiveException { return evaluate(double2Float(value), double2Float(min), double2Float(max)); }
public static boolean maybeSyntheticJoinKey(final ColumnName columnName) { return columnName.text().startsWith(SYNTHETIC_JOIN_KEY_COLUMN_PRIFIX); }
public void logicallyReplace(final CaseManagementShapeView original, final CaseManagementShapeView replacement) { if (original == null || replacement == null || replacement.getParent() == this) { return; } int index = getIndex(original); if (index < 0) { return; } getChildShapes().set(index, replacement); getContainer().getChildNodes().set(getNodeIndex(original.getGroup()), replacement.getGroup()); original.setParent(null); replacement.setParent(this); getLayoutHandler().requestLayout(this); }
protected ApiQuery addTypeCriteria(EntityDefinition entityDefinition, ApiQuery apiQuery) { if (apiQuery != null && entityDefinition != null) { if( !entityDefinition.getType().equals(entityDefinition.getStoredCollectionName())) { apiQuery.addCriteria(new NeutralCriteria("type", NeutralCriteria.CRITERIA_IN, Arrays.asList(entityDefinition.getDbType()), false)); } NeutralCriteria criteria = entityDefinition.getTypeCriteria(); if(criteria != null) { apiQuery.addCriteria(criteria); } } return apiQuery; }
public static TopicSubscription findByTopicFilter(final String topicFilter, List<TopicSubscription> topicSubscriptions) { TopicSubscription record = null; if (StringUtils.hasText(topicFilter) && !CollectionUtils.isEmpty(topicSubscriptions)) { for (TopicSubscription topicSubscription : topicSubscriptions) { if (topicSubscription.getTopicFilter().equals(topicFilter)) { record = topicSubscription; break; } } } return record; }
public static Serializer getSerializer(String alias) { return EXTENSION_LOADER.getExtension(alias); }
protected static URLConnection fileConnection(final File file) throws Exception { final URL url = file.toURI().toURL(); final URLConnection connection = url.openConnection(); return connection; }
@Override protected BdfMessageContext validateMessage(Message m, Group g, BdfList body) throws FormatException { MessageType type = MessageType.fromValue(body.getLong(0).intValue()); switch (type) { case REQUEST: return validateRequestMessage(m, body); case ACCEPT: return validateAcceptMessage(m, body); case AUTH: return validateAuthMessage(m, body); case ACTIVATE: return validateActivateMessage(m, body); case DECLINE: case ABORT: return validateOtherMessage(type, m, body); default: throw new FormatException(); } }
public static Expression heatmapDensity() { return new Expression("heatmap-density"); }
public static boolean isEqual(final Object objectA, final Object objectB) { if (objectA == null) { return objectB == null; } return objectA.equals(objectB); }
@Override public List<Row> execute(List<Row> rows, ExecutorContext context) throws DirectiveExecutionException { List<Row> results = new ArrayList<>(); for (Row row : rows) { count = 0; for (String column : columns) { locations[count] = row.find(column); ++count; } int max = Integer.MIN_VALUE; for (int i = 0; i < count; ++i) { if (locations[i] != -1) { Object value = row.getValue(locations[i]); int m = -1; if (value instanceof JsonArray) { m = ((JsonArray) value).size(); } else if (value instanceof List) { m = ((List) value).size(); } else { m = 1; } if (m > max) { max = m; } } } for (int k = 0; k < max; ++k) { Row r = new Row(row); for (int i = 0; i < count; ++i) { if (locations[i] != -1) { Object value = row.getValue(locations[i]); if (value == null) { r.add(columns[i], null); } else { Object v = null; if (value instanceof JsonArray) { JsonArray array = (JsonArray) value; if (k < array.size()) { v = array.get(k); } } else if (value instanceof List) { List<Object> array = (List) value; if (k < array.size()) { v = array.get(k); } } else { v = value; } if (v == null) { r.addOrSet(columns[i], null); } else { if (v instanceof JsonElement) { r.setValue(locations[i], JsParser.getValue((JsonElement) v)); } else { r.setValue(locations[i], v); } } } } else { r.addOrSet(columns[i], null); } } results.add(r); } } return results; }
@Override public JsonObject build() { if(attributeMap == null || attributeMap.isEmpty()) { return JsonValue.EMPTY_JSON_OBJECT; } else { Map<String, JsonValue> dump = (Collections.unmodifiableMap(attributeMap)); return new JsonObjectImpl(dump, bufferProvider); } }
@Override public boolean matches(Object entity, Invocation invocation) { log.info("Matching " + entity + " against " + invocation); final List<List<Parameter>> branches = getBranches(); if (branches.isEmpty()) { return entity != null; } final BeanWrapper wrapper = new BeanWrapperImpl(entity); for (List<Parameter> branch : branches) { boolean matches = true; for (Parameter parameter : branch) { final boolean ignoreCase; ignoreCase = parameter.getModifiers().contains(Modifier.IGNORE_CASE); Object value = wrapper.getPropertyValue(parameter.getPath()); if (ignoreCase && value instanceof String) { value = ((String) value).toLowerCase(); } final Operator operator = parameter.getOperator(); final Object[] properties = new Object[operator.getOperands()]; for (int i = 0; i < operator.getOperands(); i++) { properties[i] = invocation.getArguments()[parameter.getIndices()[i]]; if (ignoreCase && properties[i] != null && properties[i] instanceof String) { properties[i] = ((String) properties[i]).toLowerCase(); } } if (!operator.getMatcher().matches(parameter, value, properties)) { matches = false; break; } } if (matches) { return true; } } return false; }
public Span[] find(String[] textTokenized) { List<Span> namesFound = new LinkedList<Span>(); for (int offsetFrom = 0; offsetFrom < textTokenized.length; offsetFrom++) { Span nameFound = null; String tokensSearching[] = new String[] {}; for (int offsetTo = offsetFrom; offsetTo < textTokenized.length; offsetTo++) { int lengthSearching = offsetTo - offsetFrom + 1; if (lengthSearching > mDictionary.getMaxTokenCount()) { break; } else { tokensSearching = new String[lengthSearching]; System.arraycopy(textTokenized, offsetFrom, tokensSearching, 0, lengthSearching); StringList entryForSearch = new StringList(tokensSearching); if (mDictionary.contains(entryForSearch)) { nameFound = new Span(offsetFrom, offsetTo + 1, type); } } } if (nameFound != null) { namesFound.add(nameFound); offsetFrom += (nameFound.length() - 1); } } return namesFound.toArray(new Span[namesFound.size()]); }
private void fail(final ChannelHandlerContext ctx, int length) { fail(ctx, String.valueOf(length)); }
public ExtensionDescriptor parseExtensionDescriptorYaml(InputStream yaml) throws ParsingException { try (InputStream closableYaml = yaml) { return parseExtensionDescriptor(YamlUtil.convertYamlToMap(closableYaml)); } catch (IOException e) { throw new IllegalStateException(e.getMessage(), e); } }
Properties convertToHikari(Properties poolProperties) { final int MILLIS_PER_SECOND = 1000; Properties result = new Properties(); for (String name : poolProperties.stringPropertyNames()) { String hikariName = convertToCamelCase(name); String hikariValue = poolProperties.getProperty(name); if (name.equals("connection-url")) { hikariName = "jdbcUrl"; } else if (name.equals("jdbc-driver-class")) { hikariName = "driverClassName"; } else if (name.equals("user-name")) { hikariName = "username"; } else if (name.equals("max-pool-size")) { hikariName = "maximumPoolSize"; } else if (name.equals("idle-timeout-seconds")) { hikariName = "idleTimeout"; hikariValue = String.valueOf(Integer.valueOf(hikariValue) * MILLIS_PER_SECOND); } result.setProperty(hikariName, hikariValue); } return result; }
public String readLine() { String line; do { line = terminal.readLine(); } while (maybeHandleCliSpecificCommands(line)); return line; }
public List<INT16> readAINT16() throws IOException { return AINT16.read(in); }
protected static Map<Entry, String> loadFromFile(String resourceLocation) { final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); final InputStream is; if (new File(resourceLocation).isFile()) { try { is = Files.newInputStream(new File(resourceLocation).toPath()); } catch (IOException ie) { log.error("Exception while reading file {}", resourceLocation, ie); throw new RuntimeException(ie); } } else { is = systemClassLoader.getResourceAsStream(resourceLocation); } try (BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) { Map<Entry, String> translations = new HashMap<>(1000); String line; boolean firstline = true; String[] languages = null, data; while ((line = br.readLine()) != null) { if (firstline) { languages = line.split(","); firstline = false; } else { data = line.split(","); String key = data[0].strip(); for (int i = 1; i < data.length; i++) { translations.put(new Entry(key, languages[i].strip()), data[i].strip()); } } } return translations; } catch (Exception e) { log.error("Exception while loading resource {}", resourceLocation, e); throw new RuntimeException(e); } }
public static BytesValue parseToBytesValue(final ByteString bytesString) { if (null == bytesString || ByteString.EMPTY.equals(bytesString)) { return BytesValue.EMPTY; } return BytesValue.of(bytesString.toByteArray()); }
public Multimap<byte[], HbckInfo> getOverlapGroups( TableName table) { TableInfo ti = tablesInfo.get(table); return ti.overlapGroups; }
public static boolean isAlphaNumberic(String str) { for (int i = 0; i < str.length(); i++) { if (!Character.isAlphabetic(str.charAt(i)) && !Character.isDigit(str.charAt(i))) { return false; } } return true; }
@Override public <V> void expire(String key, int ttl) { try { _jedisClusterClient.expire(key, ttl); } catch (Exception ex) { _logger.error("Exception in cache service: {} ", ex.getMessage()); } }
public static String getRandomString() { try { byte[] bytes = new byte[24]; SecureRandom random = SecureRandom.getInstance(RANDOM_STRING_ALGORITHM); random.nextBytes(bytes); return Base64.encode(bytes); } catch (Exception e) { debug.message("AMSetupUtils.getRandomString:Exception in generating encryption key.", e); } return SetupConstants.CONFIG_VAR_DEFAULT_SHARED_KEY; }
public static void gemv(double alpha, DenseMatrix matA, boolean transA, Vector x, double beta, DenseVector y) { if(x instanceof SparseVector){ gemv(alpha, matA, transA, (SparseVector)x, beta, y); }else{ gemv(alpha, matA, transA, (DenseVector)x, beta, y); } }
void performEnqueue(BasePayload original) { ValueMap providedIntegrations = original.integrations(); LinkedHashMap<String, Object> combinedIntegrations = new LinkedHashMap<>(providedIntegrations.size() + bundledIntegrations.size()); combinedIntegrations.putAll(providedIntegrations); combinedIntegrations.putAll(bundledIntegrations); combinedIntegrations.remove("Segment.io"); ValueMap payload = new ValueMap(); payload.putAll(original); payload.put("integrations", combinedIntegrations); if (payloadQueue.size() >= MAX_QUEUE_SIZE) { synchronized (flushLock) { if (payloadQueue.size() >= MAX_QUEUE_SIZE) { logger.info( "Queue is at max capacity (%s), removing oldest payload.", payloadQueue.size()); try { payloadQueue.remove(1); } catch (IOException e) { logger.error(e, "Unable to remove oldest payload from queue."); return; } } } } try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); OutputStream cos = crypto.encrypt(bos); cartographer.toJson(payload, new OutputStreamWriter(cos)); byte[] bytes = bos.toByteArray(); if (bytes == null || bytes.length == 0 || bytes.length > MAX_PAYLOAD_SIZE) { throw new IOException("Could not serialize payload " + payload); } payloadQueue.add(bytes); } catch (IOException e) { logger.error(e, "Could not add payload %s to queue: %s.", payload, payloadQueue); return; } logger.verbose("Enqueued %s payload. %s elements in the queue.", original, payloadQueue.size()); if (payloadQueue.size() >= flushQueueSize) { submitFlush(); } }
public void reindexObject(AgentPrincipals agent, PID objectPid) { try (Timer.Context context = timer.time()) { aclService.assertHasAccess("User does not have permission to reindex", objectPid, agent.getPrincipals(), Permission.reindex); indexingMessageSender.sendIndexingOperation(agent.getUsername(), objectPid, IndexingActionType.ADD); } }
public AtlasGraph getGraph() throws RepositoryException { return atlasGraph; }
@Override public Map<String, Object> getParameters( DDMFormField ddmFormField, DDMFormFieldRenderingContext ddmFormFieldRenderingContext) { Map<String, Object> parameters = HashMapBuilder.<String, Object>put( "dataSourceType", ddmFormField.getDataSourceType() ).put( "multiple", getMultiple(ddmFormField, ddmFormFieldRenderingContext) ).build(); DDMFormFieldOptions ddmFormFieldOptions = ddmFormFieldOptionsFactory.create( ddmFormField, ddmFormFieldRenderingContext); parameters.put( "options", getOptions( ddmFormFieldOptions, ddmFormFieldRenderingContext.getLocale(), ddmFormFieldRenderingContext)); Locale displayLocale = LocaleThreadLocal.getThemeDisplayLocale(); if (displayLocale == null) { displayLocale = ddmFormFieldRenderingContext.getLocale(); } ResourceBundle resourceBundle = getResourceBundle(displayLocale); Map<String, String> stringsMap = new HashMap<>(); stringsMap.put( "chooseAnOption", LanguageUtil.get(resourceBundle, "choose-an-option")); stringsMap.put( "chooseOptions", LanguageUtil.get(resourceBundle, "choose-options")); stringsMap.put( "dynamicallyLoadedData", LanguageUtil.get(resourceBundle, "dynamically-loaded-data")); stringsMap.put( "emptyList", LanguageUtil.get(resourceBundle, "empty-list")); stringsMap.put("search", LanguageUtil.get(resourceBundle, "search")); parameters.put("strings", stringsMap); List<String> predefinedValue = getValue( getPredefinedValue(ddmFormField, ddmFormFieldRenderingContext)); if (predefinedValue != null) { parameters.put("predefinedValue", predefinedValue); } parameters.put( "value", getValue( GetterUtil.getString( ddmFormFieldRenderingContext.getValue(), "[]"))); return parameters; }
public S getNext() { S result = null; QueryParameters params = innerGetNext(); try { result = processor.toBean(params, this.type); } catch (MjdbcException ex) { throw new MjdbcRuntimeException(ex); } return result; }
public <E extends Throwable> Maybe<Execution<T>, E> execute(E exception) { requireNonNull(exception); List<Rule<T>> remainingRules = new ArrayList<>(); Rule<T> applicable = null; for (Rule<T> rule : rules) { if (applicable == null && rule.appliesTo(exception)) { applicable = rule; remainingRules.add(rule.remaining()); } else { remainingRules.add(rule); } } if (applicable == null) return Maybe.except(exception); return applicable.currentStrategy() .map(s -> new Execution<>(s, new ExceptionPlan<>(remainingRules))) .map(Maybe::<Execution<T>, E>of) .orElse(Maybe.except(exception)); }
@Override protected @NotNull ApiExceptionHandlerListenerResult handleSpringMvcOrWebfluxSpecificFrameworkExceptions( @NotNull Throwable ex ) { if (ex instanceof ResponseStatusException) { return handleResponseStatusException((ResponseStatusException)ex); } return ApiExceptionHandlerListenerResult.ignoreResponse(); }
protected void serializeForQuery(QueryMetadata metadata, boolean forCountRow) { boolean oldInSubquery = inSubquery; inSubquery = inSubquery || getLength() > 0; boolean oldSkipParent = skipParent; skipParent = false; final Expression<?> select = metadata.getProjection(); final List<JoinExpression> joins = metadata.getJoins(); final Predicate where = metadata.getWhere(); final List<? extends Expression<?>> groupBy = metadata.getGroupBy(); final Predicate having = metadata.getHaving(); final List<OrderSpecifier<?>> orderBy = metadata.getOrderBy(); final Set<QueryFlag> flags = metadata.getFlags(); final boolean hasFlags = !flags.isEmpty(); String suffix = null; List<? extends Expression<?>> sqlSelect; if (select instanceof FactoryExpression) { sqlSelect = ((FactoryExpression<?>) select).getArgs(); } else if (select != null) { sqlSelect = ImmutableList.of(select); } else { sqlSelect = ImmutableList.of(); } if (hasFlags) { List<Expression<?>> withFlags = Lists.newArrayList(); boolean recursive = false; for (QueryFlag flag : flags) { if (flag.getPosition() == Position.WITH) { if (flag.getFlag() == SQLTemplates.RECURSIVE) { recursive = true; continue; } withFlags.add(flag.getFlag()); } } if (!withFlags.isEmpty()) { if (recursive) { append(templates.getWithRecursive()); } else { append(templates.getWith()); } handle(", ", withFlags); append("\n"); } } if (hasFlags) { serialize(Position.START, flags); } Stage oldStage = stage; stage = Stage.SELECT; if (forCountRow) { append(templates.getSelect()); if (hasFlags) { serialize(Position.AFTER_SELECT, flags); } if (!metadata.isDistinct()) { append(templates.getCountStar()); if (!groupBy.isEmpty()) { append(templates.getFrom()); append("("); append(templates.getSelect()); append("1 as one "); suffix = ") internal"; } } else { List<? extends Expression<?>> columns; if (sqlSelect.isEmpty()) { columns = getIdentifierColumns(joins, !templates.isCountDistinctMultipleColumns()); } else { columns = sqlSelect; } if (!groupBy.isEmpty()) { append(templates.getCountStar()); append(templates.getFrom()); append("("); append(templates.getSelectDistinct()); handleSelect(COMMA, columns); suffix = ") internal"; } else if (columns.size() == 1) { append(templates.getDistinctCountStart()); handle(columns.get(0)); append(templates.getDistinctCountEnd()); } else if (templates.isCountDistinctMultipleColumns()) { append(templates.getDistinctCountStart()); append("(").handleSelect(COMMA, columns).append(")"); append(templates.getDistinctCountEnd()); } else { append(templates.getCountStar()); append(templates.getFrom()); append("("); append(templates.getSelectDistinct()); handleSelect(COMMA, columns); suffix = ") internal"; } } } else if (!sqlSelect.isEmpty()) { if (!metadata.isDistinct()) { append(templates.getSelect()); } else { append(templates.getSelectDistinct()); } if (hasFlags) { serialize(Position.AFTER_SELECT, flags); } handleSelect(COMMA, sqlSelect); } if (hasFlags) { serialize(Position.AFTER_PROJECTION, flags); } stage = Stage.FROM; serializeSources(joins); if (hasFlags) { serialize(Position.BEFORE_FILTERS, flags); } if (where != null) { stage = Stage.WHERE; append(templates.getWhere()).handle(where); } if (hasFlags) { serialize(Position.AFTER_FILTERS, flags); } if (hasFlags) { serialize(Position.BEFORE_GROUP_BY, flags); } if (!groupBy.isEmpty()) { stage = Stage.GROUP_BY; append(templates.getGroupBy()).handle(COMMA, groupBy); } if (hasFlags) { serialize(Position.AFTER_GROUP_BY, flags); } if (hasFlags) { serialize(Position.BEFORE_HAVING, flags); } if (having != null) { stage = Stage.HAVING; append(templates.getHaving()).handle(having); } if (hasFlags) { serialize(Position.AFTER_HAVING, flags); } if (hasFlags) { serialize(Position.BEFORE_ORDER, flags); } if (!orderBy.isEmpty() && !forCountRow) { stage = Stage.ORDER_BY; append(templates.getOrderBy()); handleOrderBy(orderBy); } if (hasFlags) { serialize(Position.AFTER_ORDER, flags); } if (!forCountRow && metadata.getModifiers().isRestricting() && !joins.isEmpty()) { stage = Stage.MODIFIERS; templates.serializeModifiers(metadata, this); } if (suffix != null) { append(suffix); } stage = oldStage; skipParent = oldSkipParent; inSubquery = oldInSubquery; }
@Override public Set<StoreTrait> getTraits() { return TRAITS; }
public void populate(final InventoryViewModel inventoryViewModel, String queryKeyWord) { setListener(inventoryViewModel); inflateData(inventoryViewModel, queryKeyWord); }
@Override public SearchResponse search(SearchRequest searchRequest) throws InvalidSearchException { return this.searchDao.search(searchRequest); }
public static final GeneralAdminInpForSQ instanceForRemoveSpecificQueryByAlias(final String alias) throws JargonException { if ((alias == null) || (alias.isEmpty())) { throw new IllegalArgumentException("null or missing alias name"); } GeneralAdminInpForSQ generalAdminInpForSQ = new GeneralAdminInpForSQ(BLANK, alias, SQ_RM); return generalAdminInpForSQ; }
@Override public CloudCredentialsDTO saveCloudCredentials(CloudCredentialsDTO cloudCredentialsDTO) { CloudCredentials cloudCredentials = transformer .cloudCredentialsDTOToEntity(cloudCredentialsDTO); return transformer.cloudCredentialsEntityToDTO(repository.save(cloudCredentials)); }
@Override protected double[] probabilities( final Seq<Phenotype<G, N>> population, final int count ) { assert population != null : "Population must not be null. "; assert !population.isEmpty() : "Population is empty."; assert count > 0 : "Population to select must be greater than zero. "; final double[] fitness = new double[population.size()]; fitness[0] = population.get(0).fitness().doubleValue(); double min = fitness[0]; double max = fitness[0]; for (int i = 1; i < fitness.length; ++i) { fitness[i] = population.get(i).fitness().doubleValue(); if (fitness[i] < min) min = fitness[i]; else if (fitness[i] > max) max = fitness[i]; } final double diff = max - min; if (eq(diff, 0.0)) { Arrays.fill(fitness, 1.0/fitness.length); } else { for (int i = fitness.length; --i >= 0;) { fitness[i] = (fitness[i] - min)/diff; } for (int i = fitness.length; --i >= 0;) { fitness[i] = exp(_b*fitness[i]); } } return normalize(fitness); }
@Override public boolean supports(Class<? extends ConfigItem<?>> configItemType) { return RuleBaseConfiguration.class.isAssignableFrom(configItemType); }
@Override public TransmissionPolicy getCurrentState() { return currentState.get(); }
@Override public void init(FilterConfig filterConfig) throws ServletException { final List<String> parameterNames = Collections.list(filterConfig.getInitParameterNames()); for (final String parameterName : parameterNames) { customResources.put(parameterName, filterConfig.getInitParameter(parameterName)); } }
@Override protected boolean isEffective(Effectivity eff){ if(eff instanceof DateBasedEffectivity){ DateBasedEffectivity dateEff=(DateBasedEffectivity) eff; return isEffective(dateEff); }else return false; }
@Override @SuppressWarnings("rawtypes") public void process(Set<Class<?>> set, ServletContext servletContext) throws ServletException { WebComponentConfigurationRegistry instance = WebComponentConfigurationRegistry .getInstance(new VaadinServletContext(servletContext)); if (set == null || set.isEmpty()) { instance.setConfigurations(Collections.emptySet()); return; } try { Set<WebComponentExporterFactory> factories = WebComponentExporterUtils .getFactories(set); Set<WebComponentConfiguration<? extends Component>> configurations = constructConfigurations( factories); validateTagNames(configurations); validateDistinctTagNames(configurations); instance.setConfigurations(configurations); } catch (Exception e) { throw new ServletException( String.format("%s failed to collect %s implementations!", WebComponentConfigurationRegistryInitializer.class .getSimpleName(), WebComponentExporter.class.getSimpleName()), e); } }
public static void downloadTableSchemeAndData(Odps odps, TableInfo tableInfo, int limitDownloadRecordCount, char inputColumnSeperator) { if (odps == null || tableInfo == null) { throw new IllegalArgumentException("Missing arguments:odps|tableInfo"); } if (StringUtils.isBlank(tableInfo.getProjectName())) { tableInfo.setProjectName(odps.getDefaultProject()); } validateTable(odps, tableInfo); Table table = odps.tables().get(tableInfo.getProjectName(), tableInfo.getTableName()); File tableDir = WareHouse.getInstance().getTableDir(tableInfo.getProjectName(), tableInfo.getTableName()); if (!tableDir.exists()){ tableDir.mkdirs(); } TableMeta tableMeta = TableMeta.fromTable(table); SchemaUtils.generateSchemaFile(tableMeta, null, tableDir); if (tableMeta.getPartitions() != null && tableMeta.getPartitions().length > 0) { LinkedHashMap<String, String> parts = tableInfo.getPartSpec(); int downloadedPartition = 0; for (Partition partition : table.getPartitions()) { PartitionSpec spec = partition.getPartitionSpec(); if (matches(spec, parts)) { downloadTable(odps, tableMeta, spec, limitDownloadRecordCount, inputColumnSeperator); downloadedPartition++; } } if (downloadedPartition == 0) { throw new RuntimeException("No partition found for " + tableInfo.toString()); } } else { if (tableInfo.getPartSpec().size() > 0) { throw new RuntimeException("Warehouse not exists table: " + tableInfo + " ,while try to download from remote server found it is not a partitioned table"); } downloadTable(odps, tableMeta, null, limitDownloadRecordCount, inputColumnSeperator); } }
public static String getEncodedUrl(String url) { if (url != null) { return url.replaceAll("\\W", "-"); } else { return RandomStringUtils.randomAlphanumeric(10); } }
@Override public String toString() { return "ColumnData [columnName=" + columnName + ", value=" + value + ", dataType=" + dataType + "]"; }
@Nonnull public String toString() { if (payload == null && map != null) { try { payload = parser.toJson(map); } catch (JsonParseException e) { logger.error("Provided map could not be converted to a string ({})", e.toString()); } } return payload != null ? payload : ""; }
public String getRegion() { return region; }
public static Set<String> getLocalizationProblems( Class<?> i18nClass ) { return getLocalizationProblems(i18nClass, Locale.getDefault()); }
public static Matcher<RecurrenceRule> results(DateTime start, Matcher<Integer> count) { return new ResultsMatcher(start, is(count)); }
@Override public void execute(CommandLine commandLine, Options options, RPCHook rpcHook) { DefaultMQAdminExt defaultMQAdminExt = new DefaultMQAdminExt(rpcHook); defaultMQAdminExt.setInstanceName(Long.toString(System.currentTimeMillis())); try { defaultMQAdminExt.start(); String group = commandLine.getOptionValue('g').trim(); ConsumerConnection cc = defaultMQAdminExt.examineConsumerConnectionInfo(group); int i = 1; for (Connection conn : cc.getConnectionSet()) { System.out.printf("%03d %-32s %-22s %-8s %s%n", i++, conn.getClientId(), conn.getClientAddr(), conn.getLanguage(), MQVersion.getVersionDesc(conn.getVersion()) ); } System.out.printf("%nBelow is subscription:"); Iterator<Entry<String, SubscriptionData>> it = cc.getSubscriptionTable().entrySet().iterator(); i = 1; while (it.hasNext()) { Entry<String, SubscriptionData> entry = it.next(); SubscriptionData sd = entry.getValue(); System.out.printf("%03d Topic: %-40s SubExpression: %s%n", i++, sd.getTopic(), sd.getSubString() ); } System.out.printf(""); System.out.printf("ConsumeType: %s%n", cc.getConsumeType()); System.out.printf("MessageModel: %s%n", cc.getMessageModel()); System.out.printf("ConsumeFromWhere: %s%n", cc.getConsumeFromWhere()); } catch (Exception e) { e.printStackTrace(); } finally { defaultMQAdminExt.shutdown(); } }
@Override protected void doGet(@NotNull SlingHttpServletRequest request, @NotNull SlingHttpServletResponse response) throws IOException { try { RequestPathInfo requestPathInfo = request.getRequestPathInfo(); List<String> selectorList = selectorToList(requestPathInfo.getSelectorString()); String suffix = requestPathInfo.getSuffix(); String imageName = StringUtils.isNotEmpty(suffix) ? FilenameUtils.getName(suffix) : ""; if (StringUtils.isNotEmpty(suffix)) { String suffixExtension = FilenameUtils.getExtension(suffix); if (StringUtils.isNotEmpty(suffixExtension)) { if (!suffixExtension.equals(requestPathInfo.getExtension())) { LOGGER.error("The suffix part defines a different extension than the request: {}.", suffix); response.sendError(HttpServletResponse.SC_NOT_FOUND); return; } } else { LOGGER.error("Invalid suffix: {}.", suffix); response.sendError(HttpServletResponse.SC_NOT_FOUND); return; } } Resource component = request.getResource(); ResourceResolver resourceResolver = request.getResourceResolver(); if (!component.isResourceType(IMAGE_RESOURCE_TYPE)) { Resource componentCandidate = null; PageManager pageManager = resourceResolver.adaptTo(PageManager.class); if (pageManager != null) { Page page = pageManager.getContainingPage(component); if (page != null) { Template template = page.getTemplate(); if (template != null) { if (StringUtils.isNotEmpty(suffix)) { long lastModifiedSuffix = getRequestLastModifiedSuffix(suffix); String relativeTemplatePath = lastModifiedSuffix == 0 ? suffix.substring(0, suffix.lastIndexOf('.')) : suffix.substring(0, suffix.lastIndexOf("/" + String.valueOf(lastModifiedSuffix))); String imagePath = ResourceUtil.normalize(template.getPath() + relativeTemplatePath); if (StringUtils.isNotEmpty(imagePath) && !template.getPath().equals(imagePath)) { componentCandidate = resourceResolver.getResource(imagePath); } } } } } if (componentCandidate == null) { LOGGER.error("Unable to retrieve an image from this page's template."); response.sendError(HttpServletResponse.SC_NOT_FOUND); return; } component = componentCandidate; } ImageComponent imageComponent = new ImageComponent(component); if (imageComponent.source == Source.NONEXISTING) { LOGGER.error("The image from {} does not have a valid file reference.", component.getPath()); response.sendError(HttpServletResponse.SC_NOT_FOUND); return; } ValueMap componentProperties = component.getValueMap(); long lastModifiedEpoch = 0; Calendar lastModifiedDate = componentProperties.get(JcrConstants.JCR_LASTMODIFIED, Calendar.class); if (lastModifiedDate == null) { lastModifiedDate = componentProperties.get(NameConstants.PN_PAGE_LAST_MOD, Calendar.class); } if (lastModifiedDate != null) { lastModifiedEpoch = lastModifiedDate.getTimeInMillis(); } Asset asset = null; if (imageComponent.source == Source.ASSET) { asset = imageComponent.imageResource.adaptTo(Asset.class); if (asset == null) { LOGGER.error("Unable to adapt resource {} used by image {} to an asset.", imageComponent.imageResource.getPath(), component.getPath()); response.sendError(HttpServletResponse.SC_NOT_FOUND); return; } long assetLastModifiedEpoch = asset.getLastModified(); if (assetLastModifiedEpoch > lastModifiedEpoch) { lastModifiedEpoch = assetLastModifiedEpoch; } } long requestLastModifiedSuffix = getRequestLastModifiedSuffix(suffix); if (requestLastModifiedSuffix >= 0 && requestLastModifiedSuffix != lastModifiedEpoch) { String redirectLocation = getRedirectLocation(request, lastModifiedEpoch); if (StringUtils.isNotEmpty(redirectLocation)) { response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY); response.setHeader("Location", redirectLocation); return; } else { LOGGER.error("Unable to determine correct redirect location."); response.setStatus(HttpServletResponse.SC_NOT_FOUND); return; } } if (!handleIfModifiedSinceHeader(request, response, lastModifiedEpoch)) { Map<String, Integer> transformationMap = getTransformationMap(selectorList, component); Integer jpegQualityInPercentage = transformationMap.get(SELECTOR_QUALITY_KEY); double quality = jpegQualityInPercentage / 100.0d; int resizeWidth = transformationMap.get(SELECTOR_WIDTH_KEY); String imageType = getImageType(requestPathInfo.getExtension()); if (imageComponent.source == Source.FILE) { transformAndStreamFile(response, componentProperties, resizeWidth, quality, imageComponent.imageResource, imageType, imageName); } else if (imageComponent.source == Source.ASSET) { transformAndStreamAsset(response, componentProperties, resizeWidth, quality, asset, imageType, imageName); } } } catch (IllegalArgumentException e) { LOGGER.error("Invalid image request", e.getMessage()); response.sendError(HttpServletResponse.SC_NOT_FOUND); } }
@Override public void startProcessFromDisplayer() { if (formDisplayer.isValid()) { service.call(getStartProcessRemoteCallback()).startProcessFromRenderContext( renderingSettings.getTimestamp(), renderingSettings.getRenderingContext().getModel(), serverTemplateId, deploymentId, processDefId, getCorrelationKey()); } }
@Override public Object apply(final Element element) { return null != element ? element.getIdentifier(id) : null; }
public static void executeCellProcessors(final List<Object> destination, final List<?> source, final CellProcessor[] processors, final int lineNo, final int rowNo) { if( destination == null ) { throw new NullPointerException("destination should not be null"); } else if( source == null ) { throw new NullPointerException("source should not be null"); } else if( processors == null ) { throw new NullPointerException("processors should not be null"); } final CsvContext context = new CsvContext(lineNo, rowNo, 1); context.setRowSource(new ArrayList<Object>(source)); if( source.size() != processors.length ) { throw new SuperCsvException(String.format( "The number of columns to be processed (%d) must match the number of CellProcessors (%d): check that the number" + " of CellProcessors you have defined matches the expected number of columns being read/written", source.size(), processors.length), context); } destination.clear(); for( int i = 0; i < source.size(); i++ ) { context.setColumnNumber(i + 1); if( processors[i] == null ) { destination.add(source.get(i)); } else { destination.add(processors[i].execute(source.get(i), context)); } } }
public static String dumpString(byte[] b) { StringBuilder d = new StringBuilder(b.length * 2); for (byte aB : b) { char c = (char) aB; if (Character.isISOControl(c)) { switch (c) { case '\r': d.append("{CR}"); break; case '\n': d.append("{LF}"); break; case '\000': d.append("{NULL}"); break; case '\001': d.append("{SOH}"); break; case '\002': d.append("{STX}"); break; case '\003': d.append("{ETX}"); break; case '\004': d.append("{EOT}"); break; case '\005': d.append("{ENQ}"); break; case '\006': d.append("{ACK}"); break; case '\007': d.append("{BEL}"); break; case '\020': d.append("{DLE}"); break; case '\025': d.append("{NAK}"); break; case '\026': d.append("{SYN}"); break; case '\034': d.append("{FS}"); break; case '\036': d.append("{RS}"); break; default: d.append('['); d.append(hexStrings[(int) aB & 0xFF]); d.append(']'); break; } } else d.append(c); } return d.toString(); }
public static Collection<String> removeSuffixes(Collection<String> input, Collection<String> suffixes) { if (input == null) { return null; } if (input.isEmpty()) { return Collections.emptyList(); } if (suffixes == null || suffixes.isEmpty()) { return input; } return input.stream() .map(str -> { Optional<String> matchingSuffix = suffixes.stream() .filter(s -> str.endsWith(s) || isContainsMatch(str) && str.endsWith(s + "%") || isExactMatch(str) && str.endsWith(s + "$") ) .findFirst(); if (matchingSuffix.isPresent()) { int strLength = str.length(); int suffixLength = matchingSuffix.get().length(); char lastChar = str.charAt(str.length() - 1); boolean hasSpecialLastChar = lastChar == '$' || lastChar == '%'; int end = strLength - suffixLength; if (hasSpecialLastChar) { end--; } String substr = str.substring(0, end); return hasSpecialLastChar ? substr + lastChar : getAsExactMatch(substr); } return str; }) .collect(Collectors.toList()); }
public void init() throws IOException { fillPhrasesList(); try (Scanner sc = new Scanner(System.in); BufferedWriter writer = new BufferedWriter(new FileWriter(this.logFile))) { while (!isExit && sc.hasNext()) { String line = sc.nextLine(); checkConsoleChatStatus(line); writer.write(String.format("User: %s\r\n", line)); if (!isPaused && !isExit) { writer.write(String.format("PC: %s\r\n", getNextRandomPhrase())); } } } }
public Map<String, String> annotationQuery() { return annotationQuery; }
@Override public GenericRecord formatRecord(PubsubMessage element, Schema schema) { GenericRecord result = null; try { InputStream in = new ByteArrayInputStream(element.getPayload()); DatumReader<GenericRecord> reader = new GenericDatumReader<>(schema); Decoder decoder = new GuidedJsonDecoder(schema, in); result = reader.read(null, decoder); } catch (IOException e) { throw new UncheckedIOException(e); } catch (AvroTypeException e) { throw e; } return result; }
@Nullable public static PushMessage fromIntent(@Nullable Intent intent) { if (intent == null) { return null; } try { Bundle pushBundle = intent.getBundleExtra(PushManager.EXTRA_PUSH_MESSAGE_BUNDLE); if (pushBundle == null) { return null; } return new PushMessage(pushBundle); } catch (BadParcelableException e) { Logger.error(e, "Failed to parse push message from intent."); return null; } }
public static String getVersion(Class<?> baseClass) { Manifest manifest; try { manifest = getManifest(baseClass); } catch (IOException e) { logger.error(e.getMessage(), e); return UNKNOWN_VERSION; } return getVersion(manifest); }
static long mod(final long e, final long n) { long mask = (e & 0xFFFFFFFF00000000L) == 0 ? 0x00000000FFFFFFFFL : 0xFFFFFFFF00000000L; mask &= (e & 0xFFFF0000FFFF0000L & mask) == 0 ? 0x0000FFFF0000FFFFL : 0xFFFF0000FFFF0000L; mask &= (e & 0xFF00FF00FF00FF00L & mask) == 0 ? 0x00FF00FF00FF00FFL : 0xFF00FF00FF00FF00L; mask &= (e & 0xF0F0F0F0F0F0F0F0L & mask) == 0 ? 0x0F0F0F0F0F0F0F0FL : 0xF0F0F0F0F0F0F0F0L; mask &= (e & 0xCCCCCCCCCCCCCCCCL & mask) == 0 ? 0x3333333333333333L : 0xCCCCCCCCCCCCCCCCL; mask &= (e & 0xAAAAAAAAAAAAAAAAL & mask) == 0 ? 0x5555555555555555L : 0xAAAAAAAAAAAAAAAAL; long r = 2; for (mask >>= 1; mask > 0; mask >>= 1) { r *= r; r %= n; if ((e & mask) != 0) { r += r; if (r >= n) r -= n; } } return r; }
@Override public void execute(SensorContext context) { try { Map<Path, String> reports = getReportFilesAndContents(context); if (reports.isEmpty()) { return; } JSONParser parser = new JSONParser(); Map<String, Map<Integer, Integer>> mergedCoverages = new HashMap<>(); for (Entry<Path, String> report : reports.entrySet()) { try { JSONObject parseResult = (JSONObject) parser.parse(report.getValue()); mergeFileCoverages(mergedCoverages, parseResult.entrySet()); } catch (Exception e) { LOG.error("Cannot read coverage report file, expecting standard SimpleCov resultset JSON format: '{}'", report.getKey(), e); } } saveCoverage(context, mergedCoverages); } catch (IOException e) { LOG.error("Error reading coverage reports", e); } }
protected boolean isEventACircuitBreakerFailure(ET event) { return breakingEventStrategy.isEventACircuitBreakerFailure(event); }
public String getManifestUrl(String pi) throws URISyntaxException { return builder.getManifestURI(pi).toString(); }
public void onEnableReadExternalStorageButtonClicked() { notifyPropertyChanged(PROPERTY_READ_EXTERNAL_STORAGE_PERMISSION); }
public void setContextValue(@NonNull String context, int lifespanCount, @NonNull String key, Object value) { checkArgument(lifespanCount > 0, "Cannot set the context lifespan count to %s, the lifespan count should be " + "strictly greater than 0", lifespanCount); Log.debug("Setting context variable {0}.{1} to {2}", context, key, value); Map<String, Object> contextMap = setContext(context, lifespanCount); contextMap.put(key, value); }
@DescribeResult(name = "result", description = "Clipped feature collection") public SimpleFeatureCollection execute( @DescribeParameter(name = "features", description = "Input feature collection") SimpleFeatureCollection features, @DescribeParameter( name = "clip", description = "Geometry to use for clipping (in same CRS as input features)" ) Geometry clip, @DescribeParameter( name = "preserveZ", min = 0, description = "Attempt to preserve Z values from the original geometry (interpolate value for new points)" ) Boolean preserveZ) throws ProcessException { Envelope box = clip.getEnvelopeInternal(); String srs = null; if (features.getSchema().getCoordinateReferenceSystem() != null) { srs = CRS.toSRS(features.getSchema().getCoordinateReferenceSystem()); } BBOX bboxFilter = ff.bbox("", box.getMinX(), box.getMinY(), box.getMaxX(), box.getMaxY(), srs); if (preserveZ == null) { preserveZ = false; } return new ClippingFeatureCollection(features.subCollection(bboxFilter), clip, preserveZ); }
@Override protected Severity severity(String ruleKey, @Nullable String severity) { return externalRuleLoader.ruleSeverity(ruleKey); }
public VcfFile registerVcfFile(FeatureIndexedFileRegistrationRequest request) { final String requestPath = request.getPath(); Assert.isTrue(StringUtils.isNotBlank(requestPath), getMessage( MessagesConstants.ERROR_NULL_PARAM, "path")); Assert.notNull(request.getReferenceId(), getMessage(MessagesConstants.ERROR_NULL_PARAM, "referenceId")); VcfFile vcfFile; Reference reference = referenceGenomeManager.load(request.getReferenceId()); Map<String, Chromosome> chromosomeMap = reference.getChromosomes().stream().collect( Collectors.toMap(BaseEntity::getName, chromosome -> chromosome)); if (request.getType() == null) { request.setType(BiologicalDataItemResourceType.FILE); } switch (request.getType()) { case GA4GH: vcfFile = getVcfFileFromGA4GH(request, requestPath); break; case FILE: case S3: vcfFile = createVcfFromFile(request, chromosomeMap, reference, request.isDoIndex()); break; case DOWNLOAD: vcfFile = downloadVcfFile(request, requestPath, chromosomeMap, reference, request.isDoIndex()); break; case URL: vcfFile = createVcfFromUrl(request, chromosomeMap, reference); break; default: throw new IllegalArgumentException( getMessage(MessagesConstants.ERROR_INVALID_PARAM)); } return vcfFile; }
@Override public SendResult send(Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { return this.defaultMQProducerImpl.send(msg); }
public synchronized final void link(Scope<T> scope) throws CyclicScopeLinkageException { Ensure.not_null(scope); Ensure.is_false(m_linked.contains(scope)); Set<Scope<T>> current = new HashSet<>(); current.addAll(m_linked); current.add(scope); Set<Scope<T>> seen = new HashSet<>(current); do { current = follow_set(current); if (current.contains(this)) { throw new CyclicScopeLinkageException("Scope '" + m_name + "' would be in a cyclic linkage graph if linked " + "with scope '" + scope.m_name + "'."); } current.removeAll(seen); seen.addAll(current); } while (current.size() > 0); check_link(scope); m_linked.add(scope); }
public String value() { return value; }
@Override public void generate(QuarkusCommandInvocation invocation) throws IOException { final FileProjectWriter writer = new FileProjectWriter(invocation.getQuarkusProject().getProjectDirPath().toFile()); writer.init(); generate(writer, invocation); }
@Override public Map<MetricName, Metric> getMetrics() { return Collections.unmodifiableMap(gauges); }
public void setFlexibleMode(boolean flexibleMode) { this.flexibleMode = flexibleMode; }
@VisibleForTesting Map<String, ServiceComponent> mapRoleRefsToServiceComponents() { return ofNullable(cmTemplate.getServices()).orElse(List.of()).stream() .filter(service -> service.getRoleConfigGroups() != null) .flatMap(service -> service.getRoleConfigGroups().stream() .map(rcg -> Pair.of(service.getServiceType(), rcg))) .collect(toMap( pair -> pair.getRight().getRefName(), pair -> ServiceComponent.of(pair.getLeft(), pair.getRight().getRoleType()))); }
public void deleteEvse(Long chargingStationTypeId, Long id) { ChargingStationType chargingStationType = chargingStationTypeRepository.findOne(chargingStationTypeId); chargingStationType.getEvses().remove(getEvseById(chargingStationType, id)); updateChargingStationType(chargingStationType.getId(), chargingStationType); }
@Override public List<String> getUnSystemJobNames(String namespace) throws SaturnJobConsoleException { List<String> unSystemJobs = new ArrayList<>(); List<JobConfig4DB> jobConfig4DBList = currentJobConfigService.findConfigsByNamespace(namespace); if (jobConfig4DBList != null) { for (JobConfig4DB jobConfig4DB : jobConfig4DBList) { if (!(StringUtils.isNotBlank(jobConfig4DB.getJobMode()) && jobConfig4DB.getJobMode().startsWith(JobMode.SYSTEM_PREFIX))) { unSystemJobs.add(jobConfig4DB.getJobName()); } } } return unSystemJobs; }
public void markAs(Result result, Tag tag) { try { markAs(result.getImageRecord(), tag); } catch (RepositoryException e) { logger.warn(FILTER_ADD_FAILED_MESSAGE, result.getImageRecord().getPath(), e.getMessage()); } }
@Override public List<org.openstack4j.model.compute.Image> extractOpenstackImagesFromServers(final List<Server> servers) { Objects.requireNonNull(osClient, ERR_MSG_NULL_OS_CLIENT); return servers.stream().map(Server::getImage) .filter(distinctByProperty(org.openstack4j.model.compute.Image::getId)).collect(Collectors.toList()); }
public void addExclusion(final String exclusionGroupId, final String exclusionArtifactId) { Validate.notBlank(exclusionGroupId, "Excluded groupId required"); Validate.notBlank(exclusionArtifactId, "Excluded artifactId required"); exclusions.add(new Dependency(exclusionGroupId, exclusionArtifactId, "ignored")); }
public String getLocaleString() { return localeString; }
public void accepted(){ response.setStatus(HttpServletResponse.SC_ACCEPTED ); result.use(Results.nothing()); }
@Override public void setConfig(String param, String value) { helper.doInScope(RedisCommand.CONFIG_SET, () -> connection.setConfig(param, value)); }
@Override public boolean canResolve(String property, VariableScope variableScope) { return AUTHENTICATED_USER_KEY.equals(property); }
@Override public void removeAlertHandler( final AlertHandler alertHandler ) { if ( alertHandler != null ) { this.alertHandlers.remove( alertHandler.getId() ); } }
@Override public WatchListMessageData extract(DocumentReference subscriberReference, XWikiDocument document, BaseObject userObject) { WatchListMessageData result = null; try { if (skipContextUser && subscriberReference.equals(getXWikiContext().getUserReference())) { return null; } List<WatchListEvent> matchingEvents = eventMatcher.getMatchingVisibleEvents(source.getEvents(), document.getPrefixedFullName()); if (matchingEvents.size() == 0) { return null; } String firstName = userObject.getStringValue("first_name"); String lastName = userObject.getStringValue("last_name"); Address address = addressExtractor.extract(subscriberReference, document, userObject); if (address == null || processedAddresses.contains(address)) { return null; } processedAddresses.add(address); DocumentReference templateReference = getTemplateReference(subscriberReference); result = new WatchListMessageData(subscriberReference, templateReference, firstName, lastName, address, matchingEvents); } catch (Exception e) { LOGGER.error("Failed to retrieve information for user [{}]", subscriberReference, e); } return result; }
@Override public long evaluateUnary(int sizeout, int sizein, long in1) { FloatFormat formatout = FloatFormatFactory.getFloatFormat(sizeout); FloatFormat formatin = FloatFormatFactory.getFloatFormat(sizein); return formatin.opFloat2Float(in1, formatout); }
public String generateClientLog(InvocationFinishEvent finishEvent) { StringBuilder log = new StringBuilder(128); for (AccessLogItem<RoutingContext> accessLogItem : getAccessLogItems()) { accessLogItem.appendClientFormattedItem(finishEvent, log); } return log.toString(); }
@Override public void serialize(PacketOutInput message, ByteBuf outBuffer) { ByteBufUtils.writeOFHeader(MESSAGE_TYPE, message, outBuffer, EncodeConstants.EMPTY_LENGTH); outBuffer.writeInt(message.getBufferId().intValue()); outBuffer.writeInt(message.getInPort().getValue().intValue()); int actionsLengthIndex = outBuffer.writerIndex(); outBuffer.writeShort(EncodeConstants.EMPTY_LENGTH); outBuffer.writeZero(PADDING_IN_PACKET_OUT_MESSAGE); int actionsStartIndex = outBuffer.writerIndex(); ListSerializer.serializeList(message.getAction(), TypeKeyMakerFactory .createActionKeyMaker(EncodeConstants.OF13_VERSION_ID), registry, outBuffer); outBuffer.setShort(actionsLengthIndex, outBuffer.writerIndex() - actionsStartIndex); byte[] data = message.getData(); if (data != null) { outBuffer.writeBytes(data); } ByteBufUtils.updateOFHeaderLength(outBuffer); }
public static Logger exists(final String name) { synchronized (mutex) { return loggers.get(name); } }
@Override public FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException { checkNotNull("dir", dir); checkNotNull("attrs", attrs); return FileVisitResult.CONTINUE; }
public static List<TalendField> convertToTalendField(Map<String, String> columns) { List<TalendField> talendFields = new ArrayList<TalendField>(); if (MapUtils.isNotEmpty(columns)) { for (Entry<String, String> column : columns.entrySet()) { talendFields.add(new TalendField(column.getKey(), column.getValue())); } } return talendFields; }
public static SimpleQuery instanceWithTwoArguments(final String queryString, final String arg1, final String arg2, final int continuationValue) { if (arg1 == null || arg1.isEmpty()) { throw new IllegalArgumentException("arg1 is null or empty"); } if (arg2 == null || arg2.isEmpty()) { throw new IllegalArgumentException("arg2 is null or empty"); } List<String> args = new ArrayList<String>(); args.add(arg1); args.add(arg2); return new SimpleQuery(queryString, args, continuationValue); }
public void authenticate(ContainerRequestContext request, String validUserName, String validPass) { authenticate(request, ImmutableMap.of(validUserName, validPass)); }
public Set<String> validate(final Job job) { final Set<String> errors = Sets.newHashSet(); errors.addAll(validateJobId(job)); errors.addAll(validateJobImage(job.getImage())); errors.addAll(validateJobHostName(job.getHostname())); final Set<String> externalPortsWithProto = Sets.newHashSet(); for (final PortMapping mapping : job.getPorts().values()) { final Integer externalMappedPort = mapping.getExternalPort(); String externalMappedPortWithProto = String.format( "%s:%d", mapping.getProtocol(), externalMappedPort != null ? externalMappedPort : 0); if (externalPortsWithProto.contains(externalMappedPortWithProto) && externalMappedPort != null) { errors.add(format("Duplicate external port mapping: %s", externalMappedPortWithProto)); } externalPortsWithProto.add(externalMappedPortWithProto); } for (final Map.Entry<String, PortMapping> entry : job.getPorts().entrySet()) { final String name = entry.getKey(); final PortMapping mapping = entry.getValue(); if (!PORT_MAPPING_PROTO_PATTERN.matcher(mapping.getProtocol()).matches()) { errors.add(format("Invalid port mapping protocol: %s", mapping.getProtocol())); } if (!legalPort(mapping.getInternalPort())) { errors.add(format("Invalid internal port: %d", mapping.getInternalPort())); } if (mapping.getExternalPort() != null && !legalPort(mapping.getExternalPort())) { errors.add(format("Invalid external port: %d", mapping.getExternalPort())); } if (!PORT_MAPPING_NAME_PATTERN.matcher(name).matches()) { errors.add(format("Invalid port mapping endpoint name: %s", name)); } } for (final ServiceEndpoint registration : job.getRegistration().keySet()) { final ServicePorts servicePorts = job.getRegistration().get(registration); if (servicePorts == null || servicePorts.getPorts() == null) { errors.add(format("registration for '%s' is malformed: does not have a port mapping", registration.getName())); continue; } for (final String portName : servicePorts.getPorts().keySet()) { if (!job.getPorts().containsKey(portName)) { errors.add(format("Service registration refers to missing port mapping: %s=%s", registration, portName)); } if (!REGISTRATION_NAME_PATTERN.matcher(registration.getName()).matches()) { errors.add(format("Invalid service registration name: %s", registration.getName())); } } } for (final Map.Entry<String, String> entry : job.getVolumes().entrySet()) { final String path = entry.getKey(); final String source = entry.getValue(); if (!path.startsWith("/")) { errors.add("Volume path is not absolute: " + path); continue; } if (source.contains("/") && !source.startsWith("/")) { errors.add("Volume source is not absolute: " + source); continue; } final String[] parts = path.split(":", 3); if (path.isEmpty() || path.equals("/") || parts.length > 2 || (parts.length > 1 && parts[1].isEmpty())) { errors.add(format("Invalid volume path: %s", path)); } } final Date expiry = job.getExpires(); final Date now = new Date(); if (expiry != null && expiry.before(now)) { errors.add("Job expires in the past - " + expiry + " is before " + now); } errors.addAll(validateJobHealthCheck(job)); errors.addAll(validateJobNetworkMode(job)); if (shouldValidateAddCapabilities) { errors.addAll(validateAddCapabilities(job)); } for (final String mountPoint : job.getRamdisks().keySet()) { if (!mountPoint.startsWith("/")) { errors.add("Ramdisk mount point is not absolute: " + mountPoint); continue; } } final Set<String> volumeMountPoints = Sets.newHashSet(); for (String s : job.getVolumes().keySet()) { volumeMountPoints.add(s.split(":", 2)[0]); } for (final String mountPoint : job.getRamdisks().keySet()) { if (volumeMountPoints.contains(mountPoint)) { errors.add(format("Ramdisk mount point used by volume: %s", mountPoint)); } } errors.addAll(validateGracePeriodAndExternalPorts(job)); return errors; }
protected void writeCacheHeaders(String filenameWithPath, HttpServletResponse response) { int resourceCacheTime = getCacheTime(filenameWithPath); String cacheControl; if (!deploymentConfiguration.isProductionMode()) { cacheControl = "no-cache"; } else if (resourceCacheTime > 0) { cacheControl = "max-age=" + resourceCacheTime; } else { cacheControl = "public, max-age=0, must-revalidate"; } response.setHeader("Cache-Control", cacheControl); }
void addTransactionsDependingOn(Set<Transaction> txSet, Set<Transaction> txPool) { Map<Sha256Hash, Transaction> txQueue = new LinkedHashMap<>(); for (Transaction tx : txSet) { txQueue.put(tx.getTxId(), tx); } while(!txQueue.isEmpty()) { Transaction tx = txQueue.remove(txQueue.keySet().iterator().next()); for (Transaction anotherTx : txPool) { if (anotherTx.equals(tx)) continue; for (TransactionInput input : anotherTx.getInputs()) { if (input.getOutpoint().getHash().equals(tx.getTxId())) { if (txQueue.get(anotherTx.getTxId()) == null) { txQueue.put(anotherTx.getTxId(), anotherTx); txSet.add(anotherTx); } } } } } }
public Map<String, String> transform(Map<String, String> configs) { return transform(null, configs); }
public IAtomContainer kekuliseAromaticRings(IAtomContainer molecule) throws CDKException { IAtomContainer mNew = null; try { mNew = (IAtomContainer) molecule.clone(); } catch (Exception e) { throw new CDKException("Failed to clone source molecule"); } IRingSet ringSet; try { ringSet = removeExtraRings(mNew); } catch (CDKException x) { throw x; } catch (Exception x) { throw new CDKException("failure in SSSRFinder.findAllRings", x); } if (ringSet == null) { throw new CDKException("failure in SSSRFinder.findAllRings"); } List<Integer[]> rBondsArray = null; List<List<Integer>> ringGroups = null; rBondsArray = getRingSystem(mNew, ringSet); ringGroups = assignRingGroups(rBondsArray); for (int i = 0; i < ringGroups.size(); i++) { setAllRingBondsSingleOrder(ringGroups.get(i), ringSet); List<Integer> atomNos = null; atomNos = getAtomNosForRingGroup(mNew, ringGroups.get(i), ringSet); List<Integer> bondNos = null; bondNos = getBondNosForRingGroup(mNew, ringGroups.get(i), ringSet); List<Integer[]> atomNoPairs = null; atomNoPairs = getAtomNoPairsForRingGroup(mNew, bondNos); Matrix M = new Matrix(atomNos.size(), bondNos.size()); for (int x = 0; x < M.getRows(); x++) { for (int y = 0; y < M.getCols(); y++) { if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[0])) { M.set(x, y, 1); } else { if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[1])) { M.set(x, y, 1); } else { M.set(x, y, 0); } } } } List<Integer> freeValencies = null; freeValencies = getFreeValenciesForRingGroup(mNew, atomNos, M, ringSet); List<Integer> bondOrders = new ArrayList<Integer>(); for (int j = 0; j < bondNos.size(); j++) { bondOrders.add(0); } if (solveMatrix(M, atomNos, bondNos, freeValencies, atomNoPairs, bondOrders)) { for (int j = 0; j < bondOrders.size(); j++) { mNew.getBond(bondNos.get(j)).setOrder( bondOrders.get(j) == 1 ? IBond.Order.SINGLE : IBond.Order.DOUBLE); } } else { } } return mNew; }
public boolean isSatisfiedBy(PresentationTokenDescription ptd, TokenManager tk, KeyManager km) { if (!ptd.getPolicyUID().equals(policy.getPolicyUID())) { logger.warning("Different policyUIDs."); return false; } if (!messageEquals(ptd.getMessage(), policy.getMessage())) { logger.warning("Messages don't match."); return false; } if (!pseudonymListEquals(ptd.getPseudonym(), policy.getPseudonym())) { logger.warning("Pseudonyms don't match"); return false; } if (!credentialsEquals(ptd.getCredential(), policy.getCredential(), km)) { logger.warning("Credentials don't match"); return false; } if (!predicatesEquals(ptd.getAttributePredicate(), policy.getAttributePredicate())) { logger.warning("Predicates don't match."); return false; } if (!verifierDrivenRevocationListEquals(ptd.getVerifierDrivenRevocation(), policy.getVerifierDrivenRevocation())) { logger.warning("Verifier Driven Revocation don't match"); return false; } if(policy.isAllowSimpleProof() == false && ptd.isUsesSimpleProof()){ logger.warning("Policy does not allow simple proofs."); return false; } if(ptd.isUsesSimpleProof() && ! checkIfSimpleProofAdmissible()) { logger.warning("Policy is too complex for simple proof flag."); } if (tk != null) { return checkEstablishedPseudonyms(ptd, tk); } else { return true; } }
public boolean isColumnsForDeliveriesEmpty() { return columnExtensionService.isColumnsEmpty(DeliveriesConstants.PLUGIN_IDENTIFIER, DeliveriesConstants.MODEL_COLUMN_FOR_DELIVERIES); }
public void updateOrchestrationStatusVolumeGroup(VolumeGroup volumeGroup, CloudRegion cloudRegion, OrchestrationStatus orchestrationStatus) { AAIResourceUri uri = AAIUriFactory.createResourceUri(AAIObjectType.VOLUME_GROUP, cloudRegion.getCloudOwner(), cloudRegion.getLcpCloudRegionId(), volumeGroup.getVolumeGroupId()); VolumeGroup copiedVolumeGroup = volumeGroup.shallowCopyId(); volumeGroup.setOrchestrationStatus(orchestrationStatus); copiedVolumeGroup.setOrchestrationStatus(orchestrationStatus); injectionHelper.getAaiClient().update(uri, aaiObjectMapper.mapVolumeGroup(copiedVolumeGroup)); }
public int compareTo(Span s) { if (getStart() < s.getStart()) { return -1; } else if (getStart() == s.getStart()) { if (getEnd() > s.getEnd()) { return -1; } else if (getEnd() < s.getEnd()) { return 1; } else { if (getType() == null && s.getType() == null) { return 0; } else if (getType() != null && s.getType() != null) { return getType().compareTo(s.getType()); } else if (getType() != null) { return -1; } return 1; } } else { return 1; } }
@Override public boolean isValid(Block block, Block parent) { if(block == null || parent == null) { logger.warn("BlockTxsValidationRule - block or parent are null"); return false; } List<Transaction> txs = block.getTransactionsList(); if (txs.isEmpty()) { return true; } RepositorySnapshot parentRepo = repositoryLocator.snapshotAt(parent.getHeader()); Map<RskAddress, BigInteger> curNonce = new HashMap<>(); for (Transaction tx : txs) { try { tx.verify(); } catch (RuntimeException e) { logger.warn("Unable to verify transaction", e); return false; } RskAddress sender = tx.getSender(); BigInteger expectedNonce = curNonce.get(sender); if (expectedNonce == null) { expectedNonce = parentRepo.getNonce(sender); } curNonce.put(sender, expectedNonce.add(ONE)); BigInteger txNonce = new BigInteger(1, tx.getNonce()); if (!expectedNonce.equals(txNonce)) { logger.warn("Invalid transaction: Tx nonce {} != expected nonce {} (parent nonce: {}): {}", txNonce, expectedNonce, parentRepo.getNonce(sender), tx); panicProcessor.panic("invalidtransaction", String.format("Invalid transaction: Tx nonce %s != expected nonce %s (parent nonce: %s): %s", txNonce, expectedNonce, parentRepo.getNonce(sender), tx.getHash())); return false; } } return true; }
public List<String> extract(Token focusToken, String prevTag) { if (!(focusToken instanceof W)) { return ImmutableList.of(); } String form = focusToken.getCoveredText(); if (!WordUtils.isRussianWord(form)) { return ImmutableList.of("DL=NotRussian"); } form = WordUtils.normalizeToDictionaryForm(form); List<Wordform> dictWfs = morphDict.getEntries(form); if (dictWfs == null || dictWfs.isEmpty()) { return ImmutableList.of("DL=Unknown"); } List<BitSet> dictWfBitSets = Lists.transform(dictWfs, Wordform.allGramBitsFunction(morphDict)); Set<BitSet> tokenPossibleTags = Sets.newHashSetWithExpectedSize(dictWfBitSets.size()); for (BitSet dictWfBits : dictWfBitSets) { BitSet tokenPossibleBits = (BitSet) dictWfBits.clone(); tokenPossibleBits.and(targetCategoriesMask); tokenPossibleTags.add(tokenPossibleBits); } List<String> resultList = Lists.newArrayListWithExpectedSize(tokenPossibleTags.size()); for (BitSet tokenPossibleBits : tokenPossibleTags) { String featValue; if (tokenPossibleBits.isEmpty()) { featValue = "NULL"; } else { featValue = gramJoiner.join(gramModel.toGramSet(tokenPossibleBits)); } resultList.add("DL=" + featValue); } if (prevTag != null && !PunctuationUtils.isPunctuationTag(prevTag)) { BitSet prevTagBits = toGramBits(gramModel, tagMapper.parseTag(prevTag, focusToken.getCoveredText())); for (Map.Entry<String, TwoTagPredicate> predEntry : namedPredicates.entrySet()) { for (BitSet dictTag : tokenPossibleTags) { if (predEntry.getValue().apply(prevTagBits, dictTag)) { resultList.add(predEntry.getKey()); break; } } } } return resultList; }
public static File createConfArchive(SparkConf sparkConf, final String propertiesEntryName, String confDirPath, final File zipFile) { final Properties properties = new Properties(); for (Tuple2<String, String> tuple : sparkConf.getAll()) { properties.put(tuple._1(), tuple._2()); } try { File confDir = new File(confDirPath); try (ZipOutputStream zipOutput = new ZipOutputStream(new FileOutputStream(zipFile))) { zipOutput.putNextEntry(new ZipEntry(propertiesEntryName)); properties.store(zipOutput, "Spark configuration."); zipOutput.closeEntry(); BundleJarUtil.addToArchive(confDir, zipOutput); } LOG.debug("Spark config archive created at {} from {}", zipFile, confDir); return zipFile; } catch (IOException e) { throw new RuntimeException(e); } }
public static DataflowRunner fromOptions(PipelineOptions options) { DataflowPipelineOptions dataflowOptions = PipelineOptionsValidator.validate(DataflowPipelineOptions.class, options); ArrayList<String> missing = new ArrayList<>(); if (dataflowOptions.getAppName() == null) { missing.add("appName"); } if (missing.size() > 0) { throw new IllegalArgumentException( "Missing required values: " + Joiner.on(',').join(missing)); } validateWorkerSettings(PipelineOptionsValidator.validate(GcpOptions.class, options)); PathValidator validator = dataflowOptions.getPathValidator(); String gcpTempLocation; try { gcpTempLocation = dataflowOptions.getGcpTempLocation(); } catch (Exception e) { throw new IllegalArgumentException( "DataflowRunner requires gcpTempLocation, " + "but failed to retrieve a value from PipelineOptions", e); } validator.validateOutputFilePrefixSupported(gcpTempLocation); String stagingLocation; try { stagingLocation = dataflowOptions.getStagingLocation(); } catch (Exception e) { throw new IllegalArgumentException( "DataflowRunner requires stagingLocation, " + "but failed to retrieve a value from PipelineOptions", e); } validator.validateOutputFilePrefixSupported(stagingLocation); if (!isNullOrEmpty(dataflowOptions.getSaveProfilesToGcs())) { validator.validateOutputFilePrefixSupported(dataflowOptions.getSaveProfilesToGcs()); } if (dataflowOptions.getFilesToStage() == null) { dataflowOptions.setFilesToStage( detectClassPathResourcesToStage(DataflowRunner.class.getClassLoader(), options)); if (dataflowOptions.getFilesToStage().isEmpty()) { throw new IllegalArgumentException("No files to stage has been found."); } else { LOG.info( "PipelineOptions.filesToStage was not specified. " + "Defaulting to files from the classpath: will stage {} files. " + "Enable logging at DEBUG level to see which files will be staged.", dataflowOptions.getFilesToStage().size()); LOG.debug("Classpath elements: {}", dataflowOptions.getFilesToStage()); } } String jobName = dataflowOptions.getJobName().toLowerCase(); checkArgument( jobName.matches("[a-z]([-a-z0-9]*[a-z0-9])?"), "JobName invalid; the name must consist of only the characters " + "[-a-z0-9], starting with a letter and ending with a letter " + "or number"); if (!jobName.equals(dataflowOptions.getJobName())) { LOG.info( "PipelineOptions.jobName did not match the service requirements. " + "Using {} instead of {}.", jobName, dataflowOptions.getJobName()); } dataflowOptions.setJobName(jobName); String project = dataflowOptions.getProject(); if (project.matches("[0-9]*")) { throw new IllegalArgumentException( "Project ID '" + project + "' invalid. Please make sure you specified the Project ID, not project number."); } else if (!project.matches(PROJECT_ID_REGEXP)) { throw new IllegalArgumentException( "Project ID '" + project + "' invalid. Please make sure you specified the Project ID, not project description."); } DataflowPipelineDebugOptions debugOptions = dataflowOptions.as(DataflowPipelineDebugOptions.class); if (debugOptions.getNumberOfWorkerHarnessThreads() < 0) { throw new IllegalArgumentException( "Number of worker harness threads '" + debugOptions.getNumberOfWorkerHarnessThreads() + "' invalid. Please make sure the value is non-negative."); } if (dataflowOptions.isStreaming() && dataflowOptions.getGcsUploadBufferSizeBytes() == null) { dataflowOptions.setGcsUploadBufferSizeBytes(GCS_UPLOAD_BUFFER_SIZE_BYTES_DEFAULT); } String javaVersion = Float.parseFloat(System.getProperty("java.specification.version")) >= 9 ? "(JDK 11 environment)" : "(JRE 8 environment)"; DataflowRunnerInfo dataflowRunnerInfo = DataflowRunnerInfo.getDataflowRunnerInfo(); String userAgent = String.format( "%s/%s%s", dataflowRunnerInfo.getName(), dataflowRunnerInfo.getVersion(), javaVersion) .replace(" ", "_"); dataflowOptions.setUserAgent(userAgent); return new DataflowRunner(dataflowOptions); }
public static Decorator additiveLabels( final String[] labelNamesToAdd ) { if ( labelNamesToAdd == null || labelNamesToAdd.length == 0 ) { return NO_DECORATOR; } return node -> new AdditiveLabelsDecorator( node, labelNamesToAdd ); }
public RuleResult execute(Map<String, String> ruleParam,Map<String, String> resourceAttributes) { logger.debug("========CheckAWSConfigEnabled started========="); Map<String, Object> map = null; AmazonConfigClient awsConfigClient = null; String roleIdentifyingString = ruleParam.get(PacmanSdkConstants.Role_IDENTIFYING_STRING); String severity = ruleParam.get(PacmanRuleConstants.SEVERITY); String category = ruleParam.get(PacmanRuleConstants.CATEGORY); MDC.put("executionId", ruleParam.get("executionId")); MDC.put("ruleId", ruleParam.get(PacmanSdkConstants.RULE_ID)); List<LinkedHashMap<String,Object>>issueList = new ArrayList<>(); LinkedHashMap<String,Object>issue = new LinkedHashMap<>(); if (!PacmanUtils.doesAllHaveValue(severity,category,roleIdentifyingString)) { logger.info(PacmanRuleConstants.MISSING_CONFIGURATION); throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION); } Annotation annotation = null; try { map = getClientFor(AWSService.CONFIG, roleIdentifyingString, ruleParam); awsConfigClient = (AmazonConfigClient) map.get(PacmanSdkConstants.CLIENT); DescribeConfigurationRecordersResult describeConfigurationRecordersResult = awsConfigClient.describeConfigurationRecorders(); List<ConfigurationRecorder> configurationRecorders = describeConfigurationRecordersResult.getConfigurationRecorders(); if (CollectionUtils.isNullOrEmpty(configurationRecorders)) { annotation = Annotation.buildAnnotation(ruleParam, Annotation.Type.ISSUE); annotation.put(PacmanSdkConstants.DESCRIPTION,"AWS Config not enabled"); annotation.put(PacmanRuleConstants.SEVERITY, severity); annotation.put(PacmanRuleConstants.CATEGORY, category); issue.put(PacmanRuleConstants.VIOLATION_REASON, "AWS Config not enabled"); issueList.add(issue); annotation.put("issueDetails",issueList.toString()); logger.debug("========CheckAWSConfigEnabled ended with annotation {} :=========",annotation); return new RuleResult(PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation); } else { logger.info("AWS Config enabled"); } } catch (UnableToCreateClientException e) { logger.error("unable to get client for following input", e); throw new InvalidInputException(e.getMessage()); } logger.debug("========CheckAWSConfigEnabled ended========="); return new RuleResult(PacmanSdkConstants.STATUS_SUCCESS,PacmanRuleConstants.SUCCESS_MESSAGE); }
public LookupTable<PDAnnotation> retainRelevantAnnotations(LookupTable<PDPage> relevantPages) { LOG.debug("Filtering annotations"); for (PDPage page : relevantPages.keys()) { try { Set<PDAnnotation> keptAnnotations = new LinkedHashSet<>(); for (PDAnnotation annotation : page.getAnnotations()) { PDAnnotation mapped = annotationsLookup.lookup(annotation); if (nonNull(mapped)) { keptAnnotations.add(mapped); } else { if (annotation instanceof PDAnnotationLink) { processLinkAnnotation(relevantPages, keptAnnotations, (PDAnnotationLink) annotation); } else { processNonLinkAnnotation(relevantPages, keptAnnotations, annotation); } } } relevantPages.lookup(page).setAnnotations(new ArrayList<>(keptAnnotations)); } catch (IOException e) { LOG.warn("Failed to process annotations for page", e); } } return annotationsLookup; }
public void project() { srcPotentialIndex = 0; trgPotentialIndex = 0; recurse(0, 0); BayesAbsorption.normalize(trgPotentials); }
public void escalateComplaintForAllTenants() { List<Tenant> tenantList = tenantRepository.getAllTenants().getTenant(); if (!CollectionUtils.isEmpty(tenantList)) tenantList.forEach(tenant -> escalateComplaintForTenant(tenant.getCode())); }
public static ExecutableFlow createExecutableFlow(final Project project, final Flow flow) { final ExecutableFlow exflow = new ExecutableFlow(project, flow); exflow.addAllProxyUsers(project.getProxyUsers()); return exflow; }
@Override public JaegerSpanContext extract(TextMap carrier) { String traceParent = null; String traceState = null; String debugId = null; for (Map.Entry<String, String> entry: carrier) { if (TRACE_PARENT.equalsIgnoreCase(entry.getKey())) { traceParent = entry.getValue(); } if (TRACE_STATE.equalsIgnoreCase(entry.getKey())) { traceState = entry.getValue(); } if (Constants.DEBUG_ID_HEADER_KEY.equalsIgnoreCase(entry.getKey())) { debugId = entry.getValue(); } } if (traceParent == null) { if (debugId != null) { return objectFactory.createSpanContext(0L, 0L, 0L, 0L, (byte) 0, null, debugId); } return null; } return extractContextFromTraceParent(traceParent, traceState, debugId); }
@Override public AbstractGraphPanelChartElement getElement(long value) { return values.get(value); }
@Override public boolean isApplicableTo(Class<?> parameterType, Class<?>... propertiesTypes) { return propertiesTypes.length == 2 && parameterType.isAssignableFrom(propertiesTypes[0]) && parameterType.isAssignableFrom(propertiesTypes[1]); }
public boolean isAccountNumberValid(String accountNo) { if (accountNo != null) { return Pattern.matches("\\d{10}", accountNo); } else { return false; } }
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; String authcid = request.getHeader(AuthNFilter.ATTRIBUTE_AUTH_PRINCIPAL); Map<String, Object> authzid = (Map<String, Object>) request.getAttribute(AuthNFilter.ATTRIBUTE_AUTH_CONTEXT); request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHCID, authcid); request.setAttribute(SecurityContextFactory.ATTRIBUTE_AUTHZID, authzid); filterChain.doFilter(request, servletResponse); }
@Override public boolean equals(final Object obj) { if (obj == null) { return false; } if (this.getClass() != obj.getClass()) { return false; } if (_link == null) { return false; } final ConnectedAgentAttache that = (ConnectedAgentAttache) obj; return super.equals(obj) && _link == that._link; }
public static void formatPattern(IndentedWriter out, BasicPattern pattern, SerializationContext sCxt) { StringBuilder buffer = new StringBuilder() ; boolean first = true ; for (Triple triple : pattern ) { if ( ! first ) buffer.append("\n") ; stringForTriple(buffer, triple, sCxt) ; buffer.append(" ." ) ; out.print(buffer.toString()) ; buffer.setLength(0) ; first = false ; } }
@OperationMethod public void run() throws OperationException { boolean create; DocumentModel userDoc = userManager.getUserModel(username); if (userDoc == null) { if (UPDATE.equals(mode)) { throw new OperationException("Cannot update non-existent user: " + username); } create = true; userDoc = userManager.getBareUserModel(); userDoc.setProperty(SCHEMA_NAME, USERNAME_COLUMN, username); } else { if (CREATE.equals(mode)) { throw new OperationException("Cannot create already-existing user: " + username); } create = false; checkCanCreateOrUpdateUser(userDoc); } if (groups != null) { userDoc.setProperty(SCHEMA_NAME, GROUPS_COLUMN, groups); } for (Entry<String, String> entry : Arrays.asList( new SimpleEntry<>(TENANT_ID_COLUMN, tenantId), new SimpleEntry<>(PASSWORD_COLUMN, password), new SimpleEntry<>(EMAIL_COLUMN, email), new SimpleEntry<>(FIRSTNAME_COLUMN, firstName), new SimpleEntry<>(LASTNAME_COLUMN, lastName), new SimpleEntry<>(COMPANY_COLUMN, company))) { String key = entry.getKey(); String value = entry.getValue(); if (StringUtils.isNotBlank(value)) { properties.put(key, value); } } for (Entry<String, String> entry : properties.entrySet()) { String key = entry.getKey(); String value = entry.getValue(); if (key.startsWith(USER_COLON)) { key = key.substring(USER_COLON.length()); } userDoc.setProperty(SCHEMA_NAME, key, value); } checkCanCreateOrUpdateUser(userDoc); if (create) { userDoc = userManager.createUser(userDoc); } else { userManager.updateUser(userDoc); userDoc = userManager.getUserModel(username); } }
public Connection getConnection() throws SQLException { return this.connectionStrategy.getConnection(); }
@Override public void deleteFeature(String appIdentifier, String idFeature) throws FeatureNotExistException { validatorExistFeature.checkFeatureExist(appIdentifier, idFeature); featureRepository.delete(appIdentifier,idFeature); }
@VisibleForTesting protected static boolean checkFuzzy(NameUsageMatch usageMatch, SpeciesMatchRequest matchRequest) { boolean isFuzzy = MatchType.FUZZY == usageMatch.getDiagnostics().getMatchType(); boolean isEmptyTaxa = Strings.isNullOrEmpty(matchRequest.getKingdom()) && Strings.isNullOrEmpty(matchRequest.getPhylum()) && Strings.isNullOrEmpty(matchRequest.getClazz()) && Strings.isNullOrEmpty(matchRequest.getOrder()) && Strings.isNullOrEmpty(matchRequest.getFamily()); return isFuzzy && isEmptyTaxa; }
@Override public FirmwareResult getTargetForVersion(String model, String version) { return getTargetForVersion(model, Version.fromRepresentation(version), null); }
@Nonnull @Override public Box getSourceArea(@Nonnull RenderImage renderImage) { return new Box(0, 0, renderImage.getWidth(), renderImage.getHeight()); }
@TargetApi(11) boolean isInlineVideoAvailable(@NonNull Activity activity, @NonNull View view) { if (VersionCode.currentApiLevel().isBelow(VersionCode.HONEYCOMB_MR1)) { return false; } View tempView = view; while (true) { if (!tempView.isHardwareAccelerated() || Utils.bitMaskContainsFlag(tempView.getLayerType(), View.LAYER_TYPE_SOFTWARE)) { return false; } if (!(tempView.getParent() instanceof View)) { break; } tempView = (View)tempView.getParent(); } Window window = activity.getWindow(); if (window != null) { if (Utils.bitMaskContainsFlag(window.getAttributes().flags, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)) { return true; } } return false; }
@Override public Metric instantiateMetric(String metricName) throws IllegalArgumentException, InstantiationException { final Metric metric; if (!metricConfiguration.containsKey(metricName)) { metric = super.instantiateMetric(metricName); } else { final String className = metricClasses.get(metricName); final Class<? extends Metric> klazz = findMetricClass(className); metric = instantiateClassWithConfiguration(klazz, metricConfiguration.get(metricName)); } return metric; }
@Override public synchronized LoggerFormatter getFormatter() { return formatter; }
@Override public boolean isAvailable(final WorldpayAPMConfigurationModel apmConfiguration, final CartModel cartModel) { if (CollectionUtils.isEmpty(apmConfiguration.getCurrencyRanges())) { return true; } final String cartCurrencyIso = cartModel.getCurrency().getIsocode(); for (final WorldpayCurrencyRangeModel currencyRangeModel : apmConfiguration.getCurrencyRanges()) { if (cartCurrencyIso.equals(currencyRangeModel.getCurrency().getIsocode())) { return isCartTotalWithinRange(cartModel.getTotalPrice(), currencyRangeModel.getMin(), currencyRangeModel.getMax()); } } return true; }
public static int getMin( int number, int min ) { return number < min ? min : number; }
@SuppressWarnings("unchecked") protected void buildResponse(Authentication authentication, SAMLMessageContext context, IdpWebSSOProfileOptions options) throws MetadataProviderException, SecurityException, MarshallingException, SignatureException, SAMLException { IDPSSODescriptor idpDescriptor = (IDPSSODescriptor) context.getLocalEntityRoleMetadata(); SPSSODescriptor spDescriptor = (SPSSODescriptor) context.getPeerEntityRoleMetadata(); AuthnRequest authnRequest = (AuthnRequest) context.getInboundSAMLMessage(); AssertionConsumerService assertionConsumerService = getAssertionConsumerService(options, idpDescriptor, spDescriptor); context.setPeerEntityEndpoint(assertionConsumerService); Assertion assertion = buildAssertion(authentication, authnRequest, options, context.getPeerEntityId(), context.getLocalEntityId()); if (options.isAssertionsSigned() || spDescriptor.getWantAssertionsSigned()) { signAssertion(assertion, context.getLocalSigningCredential()); } Response samlResponse = createResponse(context, assertionConsumerService, assertion, authnRequest); context.setOutboundMessage(samlResponse); context.setOutboundSAMLMessage(samlResponse); }
@CheckReturnValue public static <T> ParallelFlowable<T> from(@NonNull Publisher<? extends T> source) { return from(source, Runtime.getRuntime().availableProcessors(), Flowable.bufferSize()); }
@Override protected MessageProducer<K, V> create() { return new MessageProducer<>(brokers, type, partitionerClass, props, odeProperties.getKafkaTopicsDisabledSet()); }
boolean isYearsOrMonthsInput(final Object object) { return yearInput == object || monthInput == object; }
public static void rotate(IAtomContainer atomCon, Point2d center, double angle) { Point2d point; double costheta = Math.cos(angle); double sintheta = Math.sin(angle); IAtom atom; for (int i = 0; i < atomCon.getAtomCount(); i++) { atom = atomCon.getAtom(i); point = atom.getPoint2d(); double relativex = point.x - center.x; double relativey = point.y - center.y; point.x = relativex * costheta - relativey * sintheta + center.x; point.y = relativex * sintheta + relativey * costheta + center.y; } }
@Override public org.apache.hadoop.hive.metastore.api.Function getFunction(String dbName, String functionName) throws MetaException, TException { try { return glueMetastoreClientDelegate.getFunction(dbName, functionName); } catch (NoSuchObjectException e) { throw new NoSuchObjectException(functionName + " does not exist"); } catch (AmazonServiceException e) { logger.error(e); throw CatalogToHiveConverter.wrapInHiveException(e); } catch (Exception e) { String msg = "Unable to get Function: "; logger.error(msg, e); throw new MetaException(msg + e); } }
public static @Nonnull AllStandardCommunities instance() { return INSTANCE; }
public void refreshExecutionErrorDataRemote(final String serverTemplateId, final String deploymentId, final String errorId) { executorServices.call( (ExecutionErrorSummary executionErrorSummary) -> { view.setValue(executionErrorSummary); changeTitleWidgetEvent.fire(new ChangeTitleWidgetEvent(this.place, getErrorDetailTitle(executionErrorSummary))); }) .getError(serverTemplateId, deploymentId, errorId); }
public Boolean accepts (Object value) { return (value == null || value instanceof String); }
public double getSpread(int depth) { double ask = getAverageAskAmount(depth); double bid = getAverageBidAmount(depth); return ask - bid; }
public static Set<?> getPropertiesValues(String propertyName, String keyPrefix) { Properties localProps = loadProperties(propertyName); if (localProps == null) { return null; } Enumeration<String> keyEnum = getPropertyNames(localProps, keyPrefix); if (keyEnum == null) { return null; } return getPropertiesValues(localProps, keyEnum); }
public boolean hasAvoidBorders() { return avoidBorders != BordersExtractor.Avoid.NONE; }
@RequestMapping(value = "account/testLogin", method = {RequestMethod.POST}) public Result<Void> testLogin(ExampleAccount account) throws Exception { return Result.createSuccess(); }
public String getDueDateDiffText(DateTime dueDateTime) { DateTime now = _coreDateUtils.now(); int diffValue; switch (CoreDateUtils.getDiffUnit(now, dueDateTime)) { case MONTH: if (_coreDateUtils.isInTheFuture(dueDateTime)) { diffValue = dueDateTime.getMonth() - now.getMonth(); if (diffValue < 0) { diffValue += 12; } } else { diffValue = dueDateTime.getMonth() - now.getMonth(); } return _getPluralizedDiffText("Mth", diffValue); case WEEK: diffValue = dueDateTime.getWeekIndex() - now.getWeekIndex(); return _getPluralizedDiffText("Week", diffValue); case DAY: if (_coreDateUtils.isInTheFuture(dueDateTime)) { diffValue = dueDateTime.getDayOfYear() - now.getDayOfYear(); if (diffValue < 0) { diffValue += CoreDateUtils.getLastDayOfTheYear(dueDateTime); } } else { diffValue = dueDateTime.getDayOfYear() - now.getDayOfYear(); } return _getPluralizedDiffText("Dy", diffValue); case HOUR: if (_coreDateUtils.isInTheFuture(dueDateTime)) { diffValue = dueDateTime.getHour() - now.getHour(); if (diffValue < 0) { diffValue += 24; } } else { if (dueDateTime.isSameDayAs(_coreDateUtils.now())) { diffValue = dueDateTime.getHour() - now.getHour(); } else { diffValue = dueDateTime.getHour() - now.getHour() - 24; } } return _getPluralizedDiffText("Hr", diffValue); } diffValue = dueDateTime.getMinute() - now.getMinute(); if (!dueDateTime.getHour().equals(now.getHour())) { if (_coreDateUtils.isInTheFuture(dueDateTime)) { diffValue += 60; } else { diffValue -= 60; } } if (diffValue == 0) { return "now"; } else { return _getPluralizedDiffText("Mt", diffValue); } }
@SneakyThrows @Generated public static String writeValueAsPrettyString(Object o) { return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(o); }
@Override public String convertValue(String value) { return (StringUtils.isEmpty(value) ? defaultStr : value); }
public StorageMetadata apply(String from) { checkNotNull(from, "prefix"); MutableStorageMetadata returnVal = new MutableStorageMetadataImpl(); returnVal.setType(StorageType.RELATIVE_PATH); returnVal.setName(from); return returnVal; }
public static WeightedHosts create(Map<InetSocketAddress, CassandraClientPoolingContainer> pools) { Preconditions.checkArgument(!pools.isEmpty(), "pools should be non-empty"); return new WeightedHosts(buildHostsWeightedByActiveConnections(pools)); }
@Override public JsonRpcResponse response(final JsonRpcRequestContext requestContext) { final StringListParameter enodeListParam = requestContext.getRequiredParameter(0, StringListParameter.class); try { if (nodeWhitelistPermissioningController.isPresent()) { try { final List<String> enodeURLs = enodeListParam.getStringList(); final NodesAllowlistResult nodesAllowlistResult = nodeWhitelistPermissioningController.get().addNodes(enodeURLs); switch (nodesAllowlistResult.result()) { case SUCCESS: return new JsonRpcSuccessResponse(requestContext.getRequest().getId()); case ERROR_EMPTY_ENTRY: return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.NODE_ALLOWLIST_EMPTY_ENTRY); case ERROR_EXISTING_ENTRY: return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.NODE_ALLOWLIST_EXISTING_ENTRY); case ERROR_DUPLICATED_ENTRY: return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.NODE_ALLOWLIST_DUPLICATED_ENTRY); case ERROR_ALLOWLIST_PERSIST_FAIL: return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.ALLOWLIST_PERSIST_FAILURE); case ERROR_ALLOWLIST_FILE_SYNC: return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.ALLOWLIST_FILE_SYNC); default: throw new Exception(); } } catch (IllegalArgumentException e) { return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.NODE_ALLOWLIST_INVALID_ENTRY); } catch (Exception e) { return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.INTERNAL_ERROR); } } else { return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.NODE_ALLOWLIST_NOT_ENABLED); } } catch (P2PDisabledException e) { return new JsonRpcErrorResponse( requestContext.getRequest().getId(), JsonRpcError.P2P_DISABLED); } }
@GET @Path("/resume/{deviceId}") @Produces(TEXT_PLAIN) public String resume(@PathParam("deviceId") final String deviceId) { try { streamingManager.resume(deviceId); } catch (UnknownDeviceException e) { LOGGER.error(e.getMessage(), e); return e.getMessage(); } return null; }
@EventListener public void handleEvent(ApplicationEvent event) { if (!(event instanceof ContextRefreshedEvent)) { LOGGER.debug("Expecting ContextRefreshedEvent. Skipping."); return; } LOGGER.info("Received ContextRefreshedEvent {}", event); ContextRefreshedEvent crEvent = (ContextRefreshedEvent) event; final ApplicationContext applicationContext = crEvent.getApplicationContext(); if (null == applicationContext) { LOGGER.debug("Expecting non-null ApplicationContext. Skipping."); return; } if (null == applicationContext.getParent()) { LOGGER.debug("Expecting non-null ApplicationContext parent. Skipping."); return; } processBootstrapConfiguration(); }
public IntentBuilder extra(String name, boolean value) { validateNotBlank(name, "Name"); mIntent.putExtra(name, value); return this; }
@Override public boolean noneMatch(Predicate<? super Map.Entry<K, V>> predicate) { return inner.noneMatch(requireNonNull(predicate)); }
@Override public boolean isMember(@NotNull Authorizable authorizable) throws RepositoryException { if (isValid(authorizable)) { return getDelegate().isMember(((AuthorizableImpl) authorizable).getDlg()); } else { return false; } }
@Override public void put(byte[] data, File file) throws FsException { Args.notNull(file, "file"); if (file.exists() && !file.delete()) { throw new FsException("Could not delete [" + file + "]"); } super.put(data, file); }
public void performReplacement(Properties properties, List<ReplacementProperty> replacementProperties) { if ((replacementProperties != null) && (properties != null)) { for (ReplacementProperty replacementProperty: replacementProperties) { String propertyKey = replacementProperty.getProperty(); if (propertyKey == null) { performReplacementOnAllGeneratedProperties(properties, replacementProperty); } else { performReplacementOnSingleProperty(properties, replacementProperty, propertyKey); } } } }
static LocalDateDoubleTimeSeries of( LocalDate startDate, LocalDate endDate, Stream<LocalDateDoublePoint> values, DenseTimeSeriesCalculation dateCalculation) { double[] points = new double[dateCalculation.calculatePosition(startDate, endDate) + 1]; Arrays.fill(points, Double.NaN); int size = 1; for (LocalDateDoublePoint pt : in(values)) { points[dateCalculation.calculatePosition(startDate, pt.getDate())] = pt.getValue(); size++; } return new DenseLocalDateDoubleTimeSeries(startDate, points, dateCalculation, true, size); }
@Override public void copy( String srcAbsPath, String destAbsPath ) throws ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, RepositoryException { CheckArg.isNotEmpty(srcAbsPath, "srcAbsPath"); CheckArg.isNotEmpty(destAbsPath, "destAbsPath"); session.checkLive(); this.copy(this.workspaceName, srcAbsPath, destAbsPath); }
@Override public void introduceServiceToEV(ExecutionVenue ev, ServiceRegistrar serviceRegistrar, CompoundExecutableResolver compoundExecutableResolver) { setService(NULL_SERVICE); super.introduceServiceToEV(ev, serviceRegistrar, compoundExecutableResolver); }
protected static String getScmConnection( Model model ) { if ( model.getScm() == null ) { return null; } return model.getScm().getConnection(); }
public void postProcess(DirContext ctx) throws NamingException { for (DirContextProcessor processor : dirContextProcessors) { processor.postProcess(ctx); } }
@Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Id other = (Id) obj; if (id == null) { if (other.id != null) return false; } else if (!id.equals(other.id)) return false; return true; }
@Override public void putEvents(final Map<DocRef, List<InternalStatisticEvent>> eventsMap) { final DocRef kafkaConfigDocRef = new DocRef(KafkaConfigDoc.DOCUMENT_TYPE, internalStatisticsConfig.getKafkaConfigUuid()); try(SharedKafkaProducer sharedKafkaProducer = stroomKafkaProducerFactory.getSharedProducer(kafkaConfigDocRef)) { sharedKafkaProducer.getKafkaProducer().ifPresentOrElse( kafkaProducer -> sendMessages(eventsMap, kafkaProducer), () -> { throw new RuntimeException("The Kafka producer isn't initialised, unable to send any events"); } ); } }
@Override public boolean accept(final FileSelectInfo fileInfo) { final String name = fileInfo.getFile().getName().getBaseName(); for (final String prefix : this.prefixes) { if (caseSensitivity.checkStartsWith(name, prefix)) { return true; } } return false; }
public List<GeoJsonLineString> getLineStrings() { List<Geometry> geometryList = getGeometryObject(); ArrayList<GeoJsonLineString> geoJsonLineStrings = new ArrayList<GeoJsonLineString>(); for (Geometry geometry : geometryList) { GeoJsonLineString lineString = (GeoJsonLineString) geometry; geoJsonLineStrings.add(lineString); } return geoJsonLineStrings; }
@Override public Map<String, Object> getParameters(final AssetType entity, final Map<String, Object> parameters) { addParameter(entity.getAbbrName(), "abbrName", parameters); addParameter(entity.getName(), "name", parameters); return parameters; }
public static Long selectCount(String series) { Object[] params = new Object[] { series }; String SELECT_COUNT = "SELECT COUNT(*) FROM NUMENTA WHERE seriesName = ?"; return Yank.queryScalar(SELECT_COUNT, Long.class, params); }
<T> T imposterise(MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) { return INSTANCE.imposteriseProtected(interceptor, mockedType, ancillaryTypes); }
@Override public void doFilter(ConcurrentHashMap<String, Movie> tobeFilter) { ConcurrentHashMap<String, Movie> tobeFilterTemp = new ConcurrentHashMap<>(tobeFilter); tobeFilter.clear(); for (AbstractMovieFilter movieFilter : movieFilters) { ConcurrentHashMap<String, Movie> subFilterResult = subDoFilter(tobeFilterTemp, movieFilter); tobeFilter.putAll(subFilterResult); } }
@Override public final void dispose() { DisposableHelper.dispose(s); }
public static int randomInt(int fromInclusive, int toExclusive) { return randomInt(fromInclusive, toExclusive, rand); }
public static Optional<PDPageDestination> toPageDestination(PDOutlineItem current, PDDocumentCatalog catalog) { try { PDDestination dest = current.getDestination(); if (dest == null) { PDAction outlineAction = current.getAction(); if (outlineAction instanceof PDActionGoTo) { dest = ((PDActionGoTo) outlineAction).getDestination(); } } if (dest instanceof PDNamedDestination && catalog != null) { dest = catalog.findNamedDestinationPage((PDNamedDestination) dest); } if (dest instanceof PDPageDestination) { return Optional.of((PDPageDestination) dest); } } catch (IOException e) { LOG.warn("Unable to get outline item destination ", e); } return Optional.empty(); }
public QueryBuilder append(String part) { checkArgument(part != null, "You must specify a 'part'."); if (builder.length() > 0) { builder.append(" "); } builder.append(part.trim()); return this; }
@Override public void upload(final byte[] documentContents) { final PutObjectRequest putObjectRequest = PutObjectRequest.builder() .bucket(bucketName) .key(fileName) .contentType(contentType) .storageClass(StorageClass.REDUCED_REDUNDANCY) .build(); s3Client.putObject(putObjectRequest, RequestBody.fromBytes(documentContents)); }
public static List<String> getStackTraceOfThread(Thread thread) { StackTraceElement[] stackTraceElements = thread.getStackTrace(); return stackTraceToStringArray(Arrays.asList(stackTraceElements)); }
public static AtomEncoder create(AtomEncoder encoder, AtomEncoder... encoders) { if (encoder == null || encoders == null) throw new NullPointerException("null encoders provided"); List<AtomEncoder> tmp = new ArrayList<AtomEncoder>(encoders.length + 1); tmp.add(encoder); for (AtomEncoder e : encoders) tmp.add(e); return new ConjugatedAtomEncoder(tmp); }
public ModifyDataPermission addField(String fieldName, List<String> values) { this.fields.put(fieldName, values); return this; }
public List<Pair<Uri, FutureTask<RequestContext>>> fetchAll(List<HttpRequest> requests) { List<Pair<Uri, FutureTask<RequestContext>>> futureTasks = Lists.newArrayList(); for (HttpRequest request : requests) { futureTasks.add(Pair.of(request.getUri(), createHttpFetcher(request))); } return futureTasks; }
public ServiceCall<DeleteModelResults> deleteModel(DeleteModelOptions deleteModelOptions) { com.ibm.cloud.sdk.core.util.Validator.notNull( deleteModelOptions, "deleteModelOptions cannot be null"); String[] pathSegments = {"v1/models"}; String[] pathParameters = {deleteModelOptions.modelId()}; RequestBuilder builder = RequestBuilder.delete( RequestBuilder.constructHttpUrl(getServiceUrl(), pathSegments, pathParameters)); builder.query("version", versionDate); Map<String, String> sdkHeaders = SdkCommon.getSdkHeaders("natural-language-understanding", "v1", "deleteModel"); for (Entry<String, String> header : sdkHeaders.entrySet()) { builder.header(header.getKey(), header.getValue()); } builder.header("Accept", "application/json"); ResponseConverter<DeleteModelResults> responseConverter = ResponseConverterUtils.getValue( new com.google.gson.reflect.TypeToken<DeleteModelResults>() {}.getType()); return createServiceCall(builder.build(), responseConverter); }
public static void main(String[] args) { try { if (System.getProperty("digidoc4j.mode") == null) { System.setProperty("digidoc4j.mode", "PROD"); } DigiDoc4J.run(args); } catch (DigiDoc4JUtilityException e) { if (DigiDoc4J.logger.isDebugEnabled()) { DigiDoc4J.logger.error("Utility error", e); } else { DigiDoc4J.logger.error("Utility error (please apply DEBUG level for stacktrace): {}", e.getMessage()); } System.err.print(e.getMessage()); System.exit(e.getErrorCode()); } catch (Exception e) { if (DigiDoc4J.logger.isDebugEnabled()) { DigiDoc4J.logger.error("Utility error", e); } else { DigiDoc4J.logger.error("Utility error (please apply DEBUG level for stacktrace): {}", e.getMessage()); } System.err.print(e.getMessage()); System.exit(1); } logger.info("Finished running utility method"); System.exit(0); }
@Override public void filter(ContainerRequestContext requestContext) { X509Certificate[] clientCertChain = CertUtils.extractCert(httpServletRequest, true); if (clientCertChain == null || clientCertChain.length < 1) { throw new VitamSecurityException("Request do not contain any X509Certificate "); } int tenantId = Integer.parseInt(httpServletRequest.getHeader(GlobalDataRest.X_TENANT_ID)); String contractId = httpServletRequest.getHeader(GlobalDataRest.X_ACCESS_CONTRAT_ID); if (contractId != null) { contractId = contractId.split(",")[0]; } final String accessContract = contractId; final X509Certificate cert = clientCertChain[0]; try (InternalSecurityClient internalSecurityClient = internalSecurityClientFactory.getClient()) { Optional<IdentityModel> result = internalSecurityClient.findIdentity(cert.getEncoded()); IdentityModel identityModel = result .orElseThrow(() -> new VitamSecurityException("Certificate revoked or not found in database.")); final ContextModel contextModel = getContext(identityModel); String uri = requestContext.getUriInfo().getPath(); if (null == uri) { uri = ""; } if (contextModel.isEnablecontrol() != null && contextModel.isEnablecontrol() && !uri.endsWith(VitamConfiguration.STATUS_URL) && !uri.endsWith(VitamConfiguration.TENANTS_URL)) { if (uri.contains(ACCESS_EXTERNAL)) { verifyAccessContract(tenantId, accessContract, contextModel); } else if (uri.contains(INGEST_EXTERNAL)) { verifyIngestContract(tenantId, contextModel); } else { verifyTenant(tenantId, contextModel); } } VitamThreadUtils.getVitamSession().setContextId(contextModel.getIdentifier()); VitamThreadUtils.getVitamSession() .setSecurityProfileIdentifier(contextModel.getSecurityProfileIdentifier()); } catch (VitamClientInternalException | InternalSecurityException | CertificateEncodingException | VitamSecurityException e) { LOGGER.error("Security Error :", e); final VitamError vitamError = generateVitamError(e); requestContext.abortWith( Response.status(vitamError.getHttpCode()).entity(vitamError).type(MediaType.APPLICATION_JSON_TYPE) .build()); } }
public int getInstancesCount(String className) { return abstractScesimModel.getScesimModelDescriptor().getUnmodifiableFactMappings() .stream() .filter(factMapping -> factMapping.getFactIdentifier().getClassName().equals(className)) .collect(Collectors.groupingBy(FactMapping::getFactAlias)) .size(); }
public static Optional<Region> parseSigningRegion(final String host, final String serviceHint) { if (host == null) { throw new IllegalArgumentException("hostname cannot be null"); } if (host.endsWith(".amazonaws.com")) { int index = host.length() - ".amazonaws.com".length(); return parseStandardRegionName(host.substring(0, index)); } if (serviceHint != null) { if (serviceHint.equals("cloudsearch") && !host.startsWith("cloudsearch.")) { Matcher matcher = EXTENDED_CLOUDSEARCH_ENDPOINT_PATTERN.matcher(host); if (matcher.matches()) { return Optional.of(Region.of(matcher.group(1))); } } Pattern pattern = Pattern.compile("^(?:.+\\.)?" + Pattern.quote(serviceHint) + "[.-]([a-z0-9-]+)\\."); Matcher matcher = pattern.matcher(host); if (matcher.find()) { return Optional.of(Region.of(matcher.group(1))); } } return Optional.empty(); }
public List<? extends MenuItem> getProcessManagementViews() { final List<MenuItem> result = new ArrayList<>(2); result.add(MenuFactory.newSimpleItem(constants.ProcessDefinitions()).perspective(PROCESS_DEFINITIONS).endMenu().build().getItems().get(0)); result.add(MenuFactory.newSimpleItem(constants.ProcessInstances()).perspective(PROCESS_INSTANCES).endMenu().build().getItems().get(0)); return result; }
public static String createSubject(String... parts) { String ret=null; for (String part : parts) { if (ret == null) { ret = (part == null ? "" : part); } else { ret += SUBJECT_SEPARATOR_CHAR + (part == null ? "" : part); } } if (ret != null && ret.length() > 0) { int i=ret.length()-1; while (i >= 0 && ret.charAt(i) == SUBJECT_SEPARATOR_CHAR) { i--; } if (i != ret.length()-1) { ret = ret.substring(0, i+1); } } return (ret); }
public static DateRangeAndType fromString(final String dateRange) { Preconditions.checkNotNull(dateRange, "DateRange cannot be null."); Preconditions.checkArgument(!dateRange.isEmpty(), "DateRange cannot be empty."); return dateRange.contains(",") ? parseCustomFormat(dateRange) : parseEnumFormat(dateRange); }
public Boolean insertLightAnomalyQuestion(final Long accountId, final DateTime nightDate, final DateTime accountToday) { if (Days.daysBetween(nightDate, accountToday).getDays() >= ANOMALY_TOO_OLD_THRESHOLD) { LOGGER.debug("key=skip-anomaly-light-too-old value=account-{}-night-{}", accountId, nightDate); return false; } final Integer lightAnomalyId = this.questionCategoryMap.get(QuestionCategory.ANOMALY_LIGHT).get(0); final ImmutableList<AccountQuestion> askedQuestions = questionResponseDAO.getRecentAskedQuestionByQuestionId( accountId, lightAnomalyId, 1); if (!askedQuestions.isEmpty()) { final DateTime now = DateTime.now(DateTimeZone.UTC).withTimeAtStartOfDay(); final Days lastAskedDays = Days.daysBetween(askedQuestions.get(0).created.withTimeAtStartOfDay(), now); if (lastAskedDays.getDays() <= DAYS_BETWEEN_ANOMALY_QUESTIONS) { LOGGER.debug("key=skip-light-anomaly-recently-asked value=account-{}-days-{}", accountId, lastAskedDays.getDays()); return false; } } final Long savedID = this.saveGeneratedQuestion(accountId, lightAnomalyId, accountToday); if (savedID > 0L) { LOGGER.debug("key=saved-question-anomaly-light value=account-{}-date-{}", accountId, accountToday); return true; } LOGGER.debug("key=nothing-anomaly-light value=account-{}-night-{}", accountId, nightDate); return false; }
@Override public boolean isEnabled() { return !dependencyRelocations.isEmpty(); }
public static void main(String[] args) throws IOException, ExceptionHugin { String filename = "datasets/simulated/cajamar.arff"; DataStream<DynamicDataInstance> data = DynamicDataStreamLoader.loadFromFile(filename); DynamicModel model = new HiddenMarkovModel(data.getAttributes()); model.updateModel(data); DynamicBayesianNetwork dbn = model.getModel(); System.out.println(dbn); DynamicBayesianNetworkWriter.save(dbn, "networks/simulated/exampleDBN.dbn"); }
@Override public Geometry apply(Geometry geometry, Context context) { if (geometry == null || geometry.isEmpty()) { return geometry; } LOGGER.trace( "simplifying geometry: {}\n {} coordinates, isValid? {}", geometry, geometry.getCoordinates().length, geometry.isValid()); Double distanceTolerance = context.getDistanceTolerance(); Geometry simplifiedGeometry; if (distanceTolerance != null) { simplifiedGeometry = TopologyPreservingSimplifier.simplify(geometry, distanceTolerance); } else { simplifiedGeometry = new TopologyPreservingSimplifier(geometry).getResultGeometry(); } LOGGER.trace( "simplified geometry: {}\n {} coordinates, isValid? {}", simplifiedGeometry, simplifiedGeometry.getCoordinates().length, simplifiedGeometry.isValid()); return simplifiedGeometry.isValid() ? simplifiedGeometry : geometry; }
public Map<String, PbftMessage> getUnConfirmedPbftMessageMap() { return unConfirmedPbftMessageMap; }
public BashScriptModel build(String bashScript) throws BashScriptModelException { BashScriptModel model = new BashScriptModel(); TokenParser parser = new TokenParser(); List<ParseToken> tokens; try { tokens = parser.parse(bashScript); } catch (TokenParserException e) { throw new BashScriptModelException("Was not able to build bashscript", e); } buildScriptVariablesByTokens(model,false,true, tokens); buildFunctionsByTokens(model, tokens); List<ValidationResult> results = new ArrayList<>(); for (BashScriptValidator<List<ParseToken>> validator : createParseTokenValidators()) { results.addAll(validator.validate(tokens)); } for (ValidationResult result : results) { if (result instanceof BashError) { model.errors.add((BashError) result); } } if (debugMode) { appendDebugTokens(model, tokens); } return model; }
@Override public void stop() throws SQLException { synchronized (connection) { this.readNodeId.close(); this.writeNodeId.close(); this.initializeNodeId.close(); this.readState.close(); this.writeState.close(); this.liveLock.close(); this.backupLock.close(); super.stop(); } }
public static IntList toList(final BitSet bitSet) { final IntList list = new IntList(); for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) { list.add(i); } return list; }
@Override public boolean isEnabled(ExecutionContext executionContext) { return config.feature_flag_active_status(); }
public String processBasicMessage(String template, Snapshot snapshot) { if (template == null || template.trim().isEmpty()) { return defaultMessage; } return replaceVariables(template, snapshot); }
@Override @SuppressWarnings("checkstyle:parameternumber") public final FilteredRecordsList<IMAMeasurementRecord> getOrderedRecordList( final IMARecordScope scope, final String id, final boolean sinceLastFullReport, final IMARecordField columnToOrder, final boolean ascending, final int firstResult, final int maxResults, final String search) throws ReportManagerException { if (columnToOrder == null) { final String msg = "columnToOrder cannot be null"; LOGGER.error(msg); throw new IllegalArgumentException(msg); } if (scope == null) { throw new IllegalArgumentException("IMARecordScope cannot be null"); } Transaction tx = null; Session session = getFactory().getCurrentSession(); try { tx = session.beginTransaction(); final DbImaRecordQueryParameters params = new DbImaRecordQueryParameters(id, columnToOrder, ascending, firstResult, maxResults, search); switch (scope) { case NONE: return new DbImaRecordQueryForNone().query(); case REPORT: return new DbImaRecordQueryForReport(session, params).query(); case DEVICE: if (sinceLastFullReport) { DbImaRecordQueryForDeviceSinceLastFullReport q = new DbImaRecordQueryForDeviceSinceLastFullReport(session, params); return q.query(); } else { return new DbImaRecordQueryForDevice(session, params).query(); } default: throw new UnsupportedOperationException( "IMARecordScope " + scope + " is not supported"); } } catch (Exception ex) { String msg = "Error executing IMA Record query for " + scope + " scope."; if (scope == IMARecordScope.DEVICE) { msg += "Since last full report = " + sinceLastFullReport; } LOGGER.error(msg, ex); throw ex; } finally { if (tx != null) { tx.rollback(); } } }
@Override public CompletableFuture<Void> renameLog(URI uri, String oldStreamName, String newStreamName) { return getLog( uri, oldStreamName, true, false ).thenCompose(metadata -> renameLogMetadata(uri, metadata, newStreamName)); }
@WorkerThread @Override public void run() { if (tryCheckForInterruptionAndNotify()) { return; } mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId); if (mWorkSpec == null) { Log.e(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId)); notifyListener(false, false); return; } if (mWorkSpec.state != ENQUEUED) { notifyIncorrectStatus(); return; } Data input; if (mWorkSpec.isPeriodic()) { input = mWorkSpec.input; } else { InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName); if (inputMerger == null) { Log.e(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName)); setFailedAndNotify(); return; } List<Data> inputs = new ArrayList<>(); inputs.add(mWorkSpec.input); inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId)); input = inputMerger.merge(inputs); } Extras extras = new Extras( input, mWorkTagDao.getTagsForWorkSpecId(mWorkSpecId), mRuntimeExtras, mWorkSpec.runAttemptCount); if (mWorker == null) { mWorker = workerFromWorkSpec(mAppContext, mWorkSpec, extras); } if (mWorker == null) { Log.e(TAG, String.format("Could for create Worker %s", mWorkSpec.workerClassName)); setFailedAndNotify(); return; } if (trySetRunning()) { if (tryCheckForInterruptionAndNotify()) { return; } Worker.Result result; try { result = mWorker.doWork(); } catch (Exception | Error e) { result = Worker.Result.FAILURE; } try { mWorkDatabase.beginTransaction(); if (!tryCheckForInterruptionAndNotify()) { State state = mWorkSpecDao.getState(mWorkSpecId); if (state == null) { notifyListener(false, false); } else if (state == RUNNING) { handleResult(result); } else if (!state.isFinished()) { rescheduleAndNotify(); } mWorkDatabase.setTransactionSuccessful(); } } finally { mWorkDatabase.endTransaction(); } } else { notifyIncorrectStatus(); } }
public boolean cancel(final String xferId) { log.info("Cancel transfer with xferId [" + xferId + "]"); log.trace("Calling method [stopTransfer] with parameters [\"" + xferId + "\", 8, 0]"); boolean rtn = faspmanager2.stopTransfer(xferId); log.trace("Method [stopTransfer] returned for xferId [\"" + xferId + "\"] with result: [" + rtn + "]"); return rtn; }
public void writeTo(T obj, Class<?> cls, Type genericType, Annotation[] anns, MediaType m, MultivaluedMap<String, Object> headers, OutputStream os) throws IOException { if (os == null) { StringBuilder sb = new StringBuilder(256); sb.append("Jettison needs initialized OutputStream"); if (getContext() != null && getContext().getContent(XMLStreamWriter.class) == null) { sb.append("; if you need to customize Jettison output with the custom XMLStreamWriter" + " then extend JSONProvider or when possible configure it directly."); } throw new IOException(sb.toString()); } XMLStreamWriter writer = null; try { String enc = HttpUtils.getSetEncoding(m, headers, StandardCharsets.UTF_8.name()); if (Document.class.isAssignableFrom(cls)) { writer = createWriter(obj, cls, genericType, enc, os, false); copyReaderToWriter(StaxUtils.createXMLStreamReader((Document)obj), writer); return; } if (InjectionUtils.isSupportedCollectionOrArray(cls)) { marshalCollection(cls, obj, genericType, enc, os, m, anns); } else { Object actualObject = checkAdapter(obj, cls, anns, true); Class<?> actualClass = obj != actualObject || cls.isInterface() ? actualObject.getClass() : cls; if (cls == genericType) { genericType = actualClass; } marshal(actualObject, actualClass, genericType, enc, os); } } catch (JAXBException e) { handleJAXBException(e, false); } catch (XMLStreamException e) { handleXMLStreamException(e, false); } catch (Exception e) { throw ExceptionUtils.toInternalServerErrorException(e, null); } finally { StaxUtils.close(writer); } }
Optional<String> fetch(final String assetName) { log.fine(() -> String.format("Fetching asset '%s'", assetName)); Optional<String> rv; try { final Map<String, String> values = getValues(); rv = Optional.ofNullable(values.get(assetName)).map(a -> a.replaceFirst("^/", "")); } catch (IOException e) { log.log(Level.WARNING, e, () -> String.format("Could not load manifestResource from %s", manifestResource)); rv = Optional.empty(); } if (!rv.isPresent()) { log.warning(() -> String.format("The asset '%s' was not in the manifestResource", assetName)); } return rv; }
public void setUpNewTable(TableConfig tableConfig, IdealState idealState) { Preconditions.checkState(!_isStopping, "Segment manager is stopping"); String realtimeTableName = tableConfig.getTableName(); LOGGER.info("Setting up new LLC table: {}", realtimeTableName); List<String> currentSegments = getAllSegments(realtimeTableName); for (String segmentName : currentSegments) { Preconditions.checkState(SegmentName.isHighLevelConsumerSegmentName(segmentName), "Cannot set up new LLC table: %s with existing non-HLC segment: %s", realtimeTableName, segmentName); } _flushThresholdUpdateManager.clearFlushThresholdUpdater(realtimeTableName); PartitionLevelStreamConfig streamConfig = new PartitionLevelStreamConfig(tableConfig.getTableName(), tableConfig.getIndexingConfig().getStreamConfigs()); InstancePartitions instancePartitions = getConsumingInstancePartitions(tableConfig); int numPartitions = getNumPartitions(streamConfig); int numReplicas = getNumReplicas(tableConfig, instancePartitions); SegmentAssignment segmentAssignment = SegmentAssignmentFactory.getSegmentAssignment(_helixManager, tableConfig); Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections.singletonMap(InstancePartitionsType.CONSUMING, instancePartitions); long currentTimeMs = getCurrentTimeMs(); Map<String, Map<String, String>> instanceStatesMap = idealState.getRecord().getMapFields(); for (int partitionId = 0; partitionId < numPartitions; partitionId++) { String segmentName = setupNewPartition(tableConfig, streamConfig, partitionId, currentTimeMs, instancePartitions, numPartitions, numReplicas); updateInstanceStatesForNewConsumingSegment(instanceStatesMap, null, segmentName, segmentAssignment, instancePartitionsMap); } setIdealState(realtimeTableName, idealState); }
@SuppressWarnings("unchecked") public static <T> Function<T, Tuple0OfNullables> toTupleOfNullables() { return (Function<T, Tuple0OfNullables>) Tuple0OfNullablesMapperImpl.EMPTY_MAPPER; }
public static Filter convert(final String fiql) { SyncopeFiqlParser<SearchBean> parser = new SyncopeFiqlParser<>( SearchBean.class, AbstractFiqlSearchConditionBuilder.CONTEXTUAL_PROPERTIES); try { FilterVisitor visitor = new FilterVisitor(); SearchCondition<SearchBean> sc = parser.parse(URLDecoder.decode(fiql, StandardCharsets.UTF_8)); sc.accept(visitor); return visitor.getQuery(); } catch (Exception e) { SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidSearchExpression); sce.getElements().add(fiql); sce.getElements().add(ExceptionUtils.getRootCauseMessage(e)); throw sce; } }
@Deprecated public static AttributesModified of(final String thingId, final Attributes attributesModified, final long revision, final DittoHeaders dittoHeaders) { return of(ThingId.of(thingId), attributesModified, revision, dittoHeaders); }
private void initSystemContext(final ActorClock clock, final String basePath) { LOG.debug("Initializing system with base path {}", basePath); brokerCfg.init(basePath); validateConfiguration(); stepTimeout = brokerCfg.getStepTimeout(); final var cluster = brokerCfg.getCluster(); final String brokerId = String.format("Broker-%d", cluster.getNodeId()); this.diagnosticContext = Collections.singletonMap(BROKER_ID_LOG_PROPERTY, brokerId); this.scheduler = initScheduler(clock, brokerId); setStepTimeout(stepTimeout); }
@Override public Collection<String> getHeaderNames() { throw new Error("not supported method"); }
@Override public BackgroundException map(final ServiceException e) { if(e.getCause() instanceof ServiceException) { return this.map((ServiceException) e.getCause()); } final StringBuilder buffer = new StringBuilder(); if(StringUtils.isNotBlank(e.getErrorMessage())) { this.append(buffer, StringEscapeUtils.unescapeXml(e.getErrorMessage())); } else { this.append(buffer, e.getResponseStatus()); this.append(buffer, e.getMessage()); } switch(e.getResponseCode()) { case HttpStatus.SC_FORBIDDEN: if(StringUtils.isNotBlank(e.getErrorCode())) { switch(e.getErrorCode()) { case "SignatureDoesNotMatch": case "InvalidAccessKeyId": case "InvalidClientTokenId": case "InvalidSecurity": case "MissingClientTokenId": case "MissingAuthenticationToken": return new LoginFailureException(buffer.toString(), e); } } case HttpStatus.SC_BAD_REQUEST: if(StringUtils.isNotBlank(e.getErrorCode())) { switch(e.getErrorCode()) { case "RequestTimeout": return new ConnectionTimeoutException(buffer.toString(), e); case "ExpiredToken": case "InvalidToken": return new ExpiredTokenException(buffer.toString(), e); } } } if(e.getCause() instanceof IOException) { return new DefaultIOExceptionMappingService().map((IOException) e.getCause()); } if(e.getCause() instanceof SAXException) { return new InteroperabilityException(buffer.toString(), e); } if(-1 == e.getResponseCode()) { return new InteroperabilityException(buffer.toString(), e); } return new DefaultHttpResponseExceptionMappingService().map(new HttpResponseException(e.getResponseCode(), buffer.toString())); }
public static Map<String, String> getPathParameters(final String pattern, final String path){ try { final PathPattern.PathMatchInfo matchInfo = getMatchInfo(pattern, path); return matchInfo.getUriVariables(); } catch (Exception exception) { return Collections.emptyMap(); } }
private static Optional<String> getSecurityProtocol(Optional<String> protocol, List<Map<String, Object>> spoutConfig) { Optional<String> ret = protocol; if(ret.isPresent() && protocol.get().equalsIgnoreCase(SecurityProtocol.PLAINTEXT.name)) { ret = Optional.empty(); } if(!ret.isPresent()) { String spoutConfigSp = null; for (Map<String, Object> config: spoutConfig) { String configSp = (String) config.get(KafkaUtils.SECURITY_PROTOCOL); if (configSp != null && !SecurityProtocol.PLAINTEXT.name.equals(configSp)) { spoutConfigSp = configSp; } else if (configSp != null) { spoutConfigSp = configSp; } } ret = Optional.ofNullable(spoutConfigSp); } if(ret.isPresent() && ret.get().equalsIgnoreCase(SecurityProtocol.PLAINTEXT.name)) { ret = Optional.empty(); } return ret; }
@Override public void setCounter(final String counterName, final String value, final boolean perforceCounter) throws ConnectionException, RequestException, AccessException { Validate.notBlank(counterName, "Counter name shouldn't be null or empty"); Validate.notBlank(value, "Counter value shouldn't be null or empty"); P4JavaExceptions.asRequestException(() -> { CounterOptions counterOptions = new CounterOptions() .setPerforceCounter(perforceCounter); setCounter(counterName, value, counterOptions); return null; }); }
@Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; }
@Override public boolean apply(final Object input) { return input == null; }
public String process(String css) { CascadingStyleSheet cascadingStyleSheet = CSSReader.readFromString( css, CCharset.CHARSET_UTF_8_OBJ, ECSSVersion.CSS30, new DoNothingCSSParseErrorHandler()); _processRules(cascadingStyleSheet.getAllRules()); return _cssWriter.getCSSAsString(cascadingStyleSheet); }
String getExpectedJarBaseName(Coordinate mavenCoordinate, ClassifierInformation classifierInformation) { return mavenCoordinate.getName() + "-" + mavenCoordinate.getVersion() + (classifierInformation.classifier.isEmpty() ? JAR_EXTENSION : "-" + classifierInformation.classifier + JAR_EXTENSION); }
@Override protected TransportState transportState() { return state; }
static String printPercentAsBar(double percent, int totalBars, boolean asciiArt) { int actualBars = (int) (percent * totalBars); boolean includeHalfBarAtEnd = actualBars * 2 != (int) (percent * totalBars * 2); StringBuilder sb = new StringBuilder(totalBars); for (int i = 0; i < totalBars; i++) { if (i < actualBars) { sb.append(asciiArt ? (char) 9608 : '|'); } else if (i == actualBars && includeHalfBarAtEnd) { sb.append(asciiArt ? (char) 9619 : ':'); } else { sb.append(asciiArt ? (char) 9617 : '-'); } } return sb.toString(); }
@Nonnull public static <T> AggregateOperation1<T, LongAccumulator, Long> summingLong( @Nonnull ToLongFunctionEx<? super T> getLongValueFn ) { checkSerializable(getLongValueFn, "getLongValueFn"); return AggregateOperation .withCreate(LongAccumulator::new) .andAccumulate((LongAccumulator a, T item) -> a.add(getLongValueFn.applyAsLong(item))) .andCombine(LongAccumulator::add) .andDeduct(LongAccumulator::subtract) .andExportFinish(LongAccumulator::get); }
@Override public boolean shouldRetry(RetryPolicyContext context) { if (context.exception() != null) { for (Class<? extends Exception> exceptionClass : exceptionsToRetryOn) { if (exceptionMatches(context, exceptionClass)) { return true; } if (wrappedCauseMatches(context, exceptionClass)) { return true; } } } return false; }
public <T extends AlibabaCloudCredentialsProvider> T createCredentialsProvider(T classInstance) { return classInstance; }
public JsonNode resolve(URI uri) { if (CLASSPATH_SCHEMES.contains(uri.getScheme())) { return resolveFromClasspath(uri); } try { return objectMapper.readTree(uri.toURL()); } catch (JsonProcessingException e) { throw new IllegalArgumentException("Error parsing document: " + uri, e); } catch (IOException e) { throw new IllegalArgumentException("Unrecognised URI, can't resolve this: " + uri, e); } }
public static boolean isRawType(Type type) { if (type.isUnknown()) { return false; } JType t = (JType) type; return t.typeBinding.isRawType(); }
public Geometry getParsingGeometry() { return parsingGeometry; }
public void showAssetUsages(final Path path, final String resourceFQN, final ResourceType resourceType, final Command okCommand, final Command cancelCommand) { showAssetUsages(translationService.format(RefactoringConstants.ShowAssetUsagesDisplayerViewViewImplAssetUsages, resourceFQN), path, resourceFQN, resourceType, okCommand, cancelCommand); }
public ISOMsg filter (ISOChannel channel, ISOMsg m, LogEvent evt) throws VetoException { return filter (channel, m, null, null, evt); }
public static byte[] hashMD5(String str) { try { return hash("MD5", str); } catch (NoSuchAlgorithmException e) { log.error("The algorithm is not available" + " in the caller's environment.", e); return null; } }
public static Path normalizePath(String path) { String oldPath = path; for (char c : Arrays.asList('\'', '\"')) { path = StringUtils.remove(path, c); } if (!StringUtils.equals(oldPath, path)) { LOGGER.debug("Path [{}] modified to [{}]", oldPath, path); } return path == null ? null : Paths.get(path).toAbsolutePath().normalize(); }
Set<MatrixCoordinate> getSaddlePoints() { throw new UnsupportedOperationException("Delete this statement and write your own implementation."); }
@Override public OperationType operationType() { return operationType; }
@Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } NonnullPair<?, ?> that = (NonnullPair<?, ?>) o; return Objects.equals(lhs, that.lhs) && Objects.equals(rhs, that.rhs); }
public static String removeFrozenBrackets(String input) { String unfrozen = FROZEN_PATTERN.matcher(input).replaceAll(String.valueOf(FROZEN_START)); if (input.length() == unfrozen.length()) { return input; } StringBuilder out = new StringBuilder(); OpenBrackets openBrackets = new OpenBrackets(); for (char c : unfrozen.toCharArray()) { switch (c) { case FROZEN_START: openBrackets.addStartBracket(); openBrackets.increaseAll(); break; case '<': openBrackets.increaseAll(); out.append(c); break; case '>': openBrackets.decreaseAll(); if (!openBrackets.removeLastIfClosed()) { out.append(c); } break; default: out.append(c); break; } } return out.toString(); }
public static void getSemanticPropsSingleFromString(SingleInputSemanticProperties result, String[] forwarded, String[] nonForwarded, String[] readSet, TypeInformation<?> inType, TypeInformation<?> outType) { getSemanticPropsSingleFromString(result, forwarded, nonForwarded, readSet, inType, outType, false); }
@Override public HttpHeaders getHeaders(Instance instance) { HttpHeaders headers = new HttpHeaders(); delegates.forEach(delegate -> headers.addAll(delegate.getHeaders(instance))); return headers; }
@Override public void validate(Object obj, Errors errors) { if (obj == null || !(obj instanceof AccountDomainWrapper)) throw new IllegalArgumentException("The parameter obj should not be null and must be of type" + AccountDomainWrapper.class); AccountDomainWrapper account = (AccountDomainWrapper) obj; User user = account.getUser(); checkIfGivenAndFamilyNameAreNotNull(errors, account); checkIfGenderIsNull(errors, account); checkIfProviderRoleIsNull(errors, account); if (account.getUser() != null) { checkIfUserNameIsCorrect(errors, account.getUsername()); checkIfDuplicateUsername(errors, account.getUser()); checkIfPrivilegeLevelIsCorrect(errors, account); checkIfNoCapabilities(errors, account); } if (checkIfUserWasCreated(user) || StringUtils.isNotBlank(account.getPassword()) || StringUtils.isNotBlank(account.getConfirmPassword())) { checkIfPasswordIsCorrect(errors, account); } }
public static Map<BLSPublicKey, Validator> initializeValidators(TekuConfiguration config) { final Map<BLSPublicKey, Validator> validators = new HashMap<>(); validators.putAll(createLocalSignerValidator(config)); validators.putAll(createExternalSignerValidator(config)); STATUS_LOG.validatorsInitialised( validators.values().stream() .map(Validator::getPublicKey) .map(KeyFormatter::shortPublicKey) .collect(Collectors.toList())); return validators; }
static int getImportBehavior(AuthorizationConfiguration config) { String importBehaviorStr = config.getParameters().getConfigValue(ProtectedItemImporter.PARAM_IMPORT_BEHAVIOR, ImportBehavior.NAME_ABORT); return ImportBehavior.valueFromString(importBehaviorStr); }
public List<TokenPatternMatchSequence> match(TokenSequence tokenSequence) { List<TokenPatternMatchSequence> matchingSequences = new ArrayList<TokenPatternMatchSequence>(); boolean matchSentenceStart = false; if (this.getParsedPattern().get(0).pattern().equals("\\b")) { matchSentenceStart = true; } boolean matchSentenceEnd = false; if (this.getParsedPattern().get(this.getParsedPattern().size() - 1).pattern().equals("\\b")) { matchSentenceEnd = true; } for (int t0 = -1; t0 < tokenSequence.listWithWhiteSpace().size(); t0++) { boolean haveMatch = false; List<Token> matchingSequence = new ArrayList<Token>(); if (t0 >= 0) { Token token = tokenSequence.listWithWhiteSpace().get(t0); if (checkTokenForMatch(this.getParsedPattern().get(0), token)) { haveMatch = true; matchingSequence.add(token); } } else if (matchSentenceStart) { haveMatch = true; matchingSequence.add(null); } if (haveMatch) { int p = 1; int t1 = t0 + 1; while (p < this.getParsedPattern().size() && t1 < tokenSequence.listWithWhiteSpace().size()) { Token aToken = tokenSequence.listWithWhiteSpace().get(t1); Pattern pattern = this.getParsedPattern().get(p); if (checkTokenForMatch(pattern, aToken)) { matchingSequence.add(aToken); } else { haveMatch = false; break; } p++; t1++; } if (t1 == tokenSequence.listWithWhiteSpace().size() && p == this.getParsedPattern().size() - 1 && matchSentenceEnd) { matchingSequence.add(null); } if (matchingSequence.size() != this.getParsedPattern().size()) { haveMatch = false; } } if (haveMatch) { TokenPatternMatchSequence tokenPatternMatchSequence = new TokenPatternMatchSequence(this, matchingSequence); matchingSequences.add(tokenPatternMatchSequence); for (Token aToken : matchingSequence) { tokenPatternMatchSequence.addMatch(aToken); } } } if (LOG.isTraceEnabled()) { if (matchingSequences.size() > 0) LOG.trace(this.getName() + ": matchingSequences = " + matchingSequences); } return matchingSequences; }
@Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final SortingOption other = (SortingOption) obj; if (direction != other.direction) { return false; } if (key == null) { if (other.key != null) { return false; } } else if (!key.equals(other.key)) { return false; } return true; }
protected void assignDepth() { resetNodeInfo(); NodeData input = findInput(); input.depth = 0; List<NodeData> layer = new ArrayList<>(); List<NodeData> nextLayer = new ArrayList<>(); layer.addAll(input.next); for (int i = 0; i < input.next.size(); i++) { NodeData c = input.next.get(i); if( c.depth == Integer.MAX_VALUE ) { c.depth = 1; } else { throw new RuntimeException("Input node connects to a child node more than once! "+c.node.name); } } int depth = 1; while( !layer.isEmpty() ) { nextLayer.clear(); for (int i = 0; i < layer.size(); i++) { NodeData n = layer.get(i); for (int j = 0; j < n.next.size(); j++) { NodeData c = n.next.get(j); if( c.depth == Integer.MAX_VALUE ) { boolean allAssigned = true; for (int k = 0; k < c.previous.size(); k++) { if( c.previous.get(k).depth == Integer.MAX_VALUE ) { allAssigned = false; break; } } if( allAssigned ) { c.depth = depth + 1; nextLayer.add(c); } } } for (int j = 0; j < n.previous.size(); j++) { NodeData c = n.previous.get(j); if( c.depth == Integer.MAX_VALUE ) { throw new RuntimeException("An input to this node has not been traversed. Cycle or other graph error. "+c.node.name); } } } List<NodeData> tmp = layer; layer = nextLayer; nextLayer = tmp; depth++; } }
public MainMenu addMainMenu() { if (mainMenuIsPresent()) { return Classes.from(fragmentManager.findFragmentByTag(MainMenuFragment.TAG)); } else { MainMenu mainMenu = new MainMenuFragment(); fragmentManager.beginTransaction().replace(R.id.menu_container, mainMenu.getFragment(), MainMenuFragment.TAG).commit(); return mainMenu; } }
public <T> T readValue(String src, Class<T> valueType) { try { return jsonMapper.readValue(src, valueType); } catch (MismatchedInputException | JsonParseException e) { throw new DataConversionException(INPUT_MISMATCH_ERROR_MESSAGE, e); } catch (IOException e) { throw new UncheckedIOException(e); } }
@Override public boolean canClose(@Nullable String suffix) { if (Strings.isNullOrEmpty(suffix)) { return true; } return nameHelper.isIdentifier(suffix); }
@Override public EquipmentRatedForJedi rateEquipmentByTypeForJedi(Integer jediId, EquipmentType type) throws ApplicationException { Jedi jedi = jediDao.findOne(jediId); if (jedi != null) { List<Rating> ratingList = jedi.getRatings().stream() .filter(rating -> rating.getEquipment().getType().equals(type)) .collect(Collectors.toList()); List<RatedEquipment> equipments = ratingList.stream() .map(rating -> RatedEquipment.builder() .name(rating.getEquipment().getName()) .rate(rating.getRate()) .build()) .collect(Collectors.toList()); equipments.sort((e1, e2) -> e2.getRate().compareTo(e1. getRate())); return EquipmentRatedForJedi.builder() .totalCount(ratingList.size()) .equipments(equipments) .build(); } else { throw new ApplicationException(JEDI_NOT_FOUND); } }
@SuppressWarnings("unchecked") @Override public List<Integer> getProjectHasReferencedConfigs(int projectId) { return getSqlMapClientTemplate().queryForList("Config.getProjectHasReferencedConfigs", Maps.entry("projectId", projectId).get()); }
@Override public Object invoke(MethodInvocation invocation) throws Throwable { try { final Method method = invocation.getMethod(); final Workflow[] workFlowAnnotations = method.getAnnotationsByType(Workflow.class); checkForBadSignatures(invocation); final String correlationId = checkForCorrelationId(invocation.getArguments()); Workflow workflow = workFlowAnnotations[0]; localContext.registerNew(generateWorkflowIdentifier(method, workflow), workflow.version(), workflow.description(),correlationId, fluxClientConfigurationProvider.get().getClientElbId()); registerEventsForArguments(invocation.getArguments()); invocation.proceed(); connectorProvider.get().submitNewWorkflow(localContext.getStateMachineDef()); return null ; } finally { this.localContext.reset(); } }
@Override public Optional<File> requestFile(Coordinate mavenCoordinate, Path targetDirectory, ClassifierInformation classifierInformation) { if (classifierInformation.isSource) { return requestFile(mavenCoordinate, targetDirectory, "java-source", classifierInformation); } return requestFile(mavenCoordinate, targetDirectory, "jar", classifierInformation); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) { long timestamp = clock.getTime() / 1000; try { initConnection(); gauges.forEach((name, gauge) -> doReport(name, gauge, timestamp, this::reportGauge)); counters.forEach((name, counter) -> doReport(name, counter, timestamp, this::reportCounter)); histograms.forEach((name, histogram) -> doReport(name, histogram, timestamp, this::reportHistogram)); meters.forEach((name, meter) -> doReport(name, meter, timestamp, this::reportMetered)); timers.forEach((name, timer) -> doReport(name, timer, timestamp, this::reportTimer)); graphite.flush(); } catch (Exception e) { LOGGER.error("Error reporting metrics" + e.getMessage(), e); } finally { try { graphite.close(); } catch (IOException e1) { LOGGER.warn("Error closing Graphite", graphite, e1); } } }
public TypeAlias getAliasFor(Type type) { TypeAlias alias = typeAliases.getAliasesMappedByType().get(type); if (alias == null) { String message = String.format("Could not find type alias for given type: %s", type); throw new IllegalArgumentException(message); } return alias; }
public static Set<String> referencedSources( Map<String, IpAccessList> namedAcls, AclLineMatchExpr expr) { ReferenceSourcesVisitor visitor = new ReferenceSourcesVisitor(namedAcls); visitor.visit(expr); return visitor.referencedInterfaces(); }
protected List<String> parse(final int response, final String[] reply) { final List<String> result = new ArrayList<String>(reply.length); for(final String line : reply) { if(line.startsWith(String.valueOf(response))) { try { String stripped = line; stripped = StringUtils.strip(StringUtils.removeStart(stripped, String.valueOf(String.format("%d-", response)))); stripped = StringUtils.strip(StringUtils.removeStart(stripped, String.valueOf(response))); result.add(stripped); } catch(IndexOutOfBoundsException e) { log.error(String.format("Failed parsing line %s", line), e); } } else { result.add(StringUtils.strip(line)); } } return result; }
public static Builder newBuilder() { return new Builder(); }
public void updateCondition(String condition) { conditionalTextElement.setTextConditionAttribute("ooow:" + condition); }
@Override public void onBeforeResponseProcessed(JsonRpcClient client, ObjectNode response) { throwIfClusterProxyError(response); }
@Override protected void execute(final MutableShoppingCart shoppingCart, final ProductSku productSku, final String skuCode, final String supplier, final String itemGroup, final BigDecimal qty, final Map<String, Object> parameters) { if (StringUtils.isNotBlank(itemGroup)) { final List<String> allInGroup = shoppingCart.getCartItemList().stream() .filter(item -> itemGroup.equals(item.getItemGroup())) .map(CartItem::getProductSkuCode).collect(Collectors.toList()); for (final String sku : allInGroup) { if(!shoppingCart.removeCartItem(supplier, sku, itemGroup)) { LOG.warn("Cannot remove all skus with code {}:{} from cart", sku, itemGroup); return; } } recalculatePricesInCart(shoppingCart); markDirty(shoppingCart); } else if(shoppingCart.removeCartItem(supplier, skuCode, itemGroup)) { recalculatePricesInCart(shoppingCart); markDirty(shoppingCart); } else { LOG.warn("Cannot remove all skus with code {} from cart", skuCode); } }
public static double compute(QDistribution q, NetworkSamples p) { return compute(p, q::getLogOfMasterP); }
public static byte[] join(byte[] separator, byte[]... components) { if (components == null || components.length == 0) { return Constants.EMPTY_BYTES; } int finalSize = 0; if (separator != null) { finalSize = separator.length * (components.length - 1); } for (byte[] comp : components) { finalSize += comp.length; } byte[] buf = new byte[finalSize]; int offset = 0; for (int i=0; i < components.length; i++) { System.arraycopy(components[i], 0, buf, offset, components[i].length); offset += components[i].length; if (i < (components.length-1) && separator != null && separator.length > 0) { System.arraycopy(separator, 0, buf, offset, separator.length); offset += separator.length; } } return buf; }
public LeagueRound executeRound(LeagueRound round) { List<Match> matchesWithResult = FluentIterable.from(round.matches()) .transform(m -> Match.create(m.id(), m.home(), m.away(), resultFor(m))) .toList(); return LeagueRound.create(round.id(), round.roundNumber(), matchesWithResult); }
@Nullable public static String getString(@NotNull Tree tree, @NotNull String propertyName) { return getStringInternal(tree, propertyName, Type.STRING); }
@Override public Color getColor(TreeMapNode node) { Object value; if (groupByParent && node.getParent() instanceof TreeMapNode){ value = ((TreeMapNode) node.getParent()).getLabel(); }else{ value = getValue(node); } if (!this.mapping.containsKey(value)) { mapping.put(value, colours[this.cursor]); cursor++; if (this.cursor == colours.length) { cursor = 0; } } return mapping.get(value); }
public static Object convertToObject(Serializable cellValue, ColumnSchema columnSchema, String[] groupValues) { try { if (cellValue == null) { return null; } String collation = columnSchema.getCollation(); String columnType = columnSchema.getColumnType(); DataType dataType = columnSchema.getDataType(); boolean isUnsigned = columnType.contains("unsigned"); switch (dataType) { case BINARY: case VARBINARY: { byte[] bytes = (byte[]) cellValue; if (bytes.length == columnSchema.getCharMaxLength()) { return DatatypeConverter.printHexBinary(bytes); } else { byte[] bytesWithPadding = new byte[columnSchema.getCharMaxLength()]; for (int i = 0; i < bytesWithPadding.length; ++i) { bytesWithPadding[i] = (i < bytes.length) ? bytes[i] : 0; } return DatatypeConverter.printHexBinary(bytesWithPadding); } } case TINYBLOB: case MEDIUMBLOB: case BLOB: case LONGBLOB: { byte[] bytes = (byte[]) cellValue; return DatatypeConverter.printHexBinary(bytes); } case CHAR: case VARCHAR: case TEXT: case MEDIUMTEXT: case TINYTEXT: { byte[] bytes = (byte[]) cellValue; if (collation.contains("latin1")) { return new String(bytes, StandardCharsets.ISO_8859_1); } else { return new String(bytes, StandardCharsets.UTF_8); } } case JSON: { byte[] bytes = (byte[]) cellValue; try { return JsonBinary.parseAsString(bytes); } catch (IOException ex) { LOG.error( String.format("Could not parse JSON string Column Name : %s, byte[]%s", columnSchema.getName(), Arrays.toString(bytes)), ex); return null; } } case BIT: { final BitSet data = (BitSet) cellValue; if (data.length() == 0) { return "0"; } final StringBuilder buffer = new StringBuilder(data.length()); IntStream.range(0, data.length()).mapToObj(i -> data.get(i) ? '1' : '0').forEach(buffer::append); return buffer.reverse().toString(); } case DATE: { return DATE_FORMAT.format(cellValue); } case TIME: { return TIME_FORMAT.format(cellValue); } case DATETIME: case TIMESTAMP: { Long timestamp = (Long) cellValue; ZoneId zoneId = ZonedDateTime.now().getZone(); LocalDateTime aLDT = Instant.ofEpochMilli(timestamp).atZone(zoneId).toLocalDateTime(); Integer offset = ZonedDateTime.from(aLDT.atZone(zoneId)).getOffset().getTotalSeconds(); timestamp = timestamp - offset * 1000; return String.valueOf(timestamp); } case ENUM: { int index = (Integer) cellValue; if (index > 0) { return String.valueOf(groupValues[index - 1]); } else { return null; } } case SET: { long bits = (Long) cellValue; if (bits > 0) { List<String> items = new ArrayList<>(); for (int index = 0; index < groupValues.length; index++) { if (((bits >> index) & 1) == 1) { items.add(groupValues[index]); } } return String.join(",", items.toArray(new String[0])); } else { return null; } } case TINYINT: { Long mask = isUnsigned ? UNSIGNED_TINYINT_MASK : DEFAULT_MASK; return maskAndGet(cellValue, mask); } case SMALLINT: { Long mask = isUnsigned ? UNSIGNED_SMALLINT_MASK : DEFAULT_MASK; return maskAndGet(cellValue, mask); } case MEDIUMINT: { Long mask = isUnsigned ? UNSIGNED_MEDIUMINT_MASK : DEFAULT_MASK; return maskAndGet(cellValue, mask); } case INT: { Long mask = isUnsigned ? UNSIGNED_INT_MASK : DEFAULT_MASK; return maskAndGet(cellValue, mask); } case BIGINT: { if (isUnsigned) { long longValue = (Long) cellValue; int upper = (int) (longValue >>> 32); int lower = (int) longValue; BigInteger bigInteger = BigInteger.valueOf(Integer.toUnsignedLong(upper)) .shiftLeft(32) .add(BigInteger.valueOf(Integer.toUnsignedLong(lower))); return bigInteger; } else { return maskAndGet(cellValue, DEFAULT_MASK); } } case FLOAT: case DOUBLE: { return cellValue; } case DECIMAL: { BigDecimal decimal = (BigDecimal) cellValue; return decimal.toPlainString(); } case UNKNOWN: default: { if (cellValue instanceof byte[]) { byte[] bytes = (byte[]) cellValue; return DatatypeConverter.printHexBinary(bytes); } LOG.error(String.format("The datatype is %s hence returning null", dataType.getCode())); return null; } } } catch ( Exception e ) { LOG.warn("Error deserializing cell: cellValue: " + cellValue + ", columnSchema: " + columnSchema.toString() + ", groupValues: " + ( groupValues != null ? groupValues.toString() : "" ), e ); throw e; } }
public static <T> Series<T> concat(Series<T>... concat) { int h = 0; for (Series<? extends T> s : concat) { h += s.size(); } T[] data = (T[]) new Object[h]; int offset = 0; for (Series<? extends T> s : concat) { int len = s.size(); s.copyTo(data, 0, offset, len); offset += len; } return new ArraySeries<>(data); }
@Override public void handle(String chargingStationId, JsonObject commandObject, IdentityContext identityContext) throws UserIdentityUnauthorizedException { ChargingStationId csId = new ChargingStationId(chargingStationId); if (!commandAuthorizationService.isAuthorized(csId, identityContext.getUserIdentity(), PlaceChargingStationCommand.class)) { throw new UserIdentityUnauthorizedException(chargingStationId, identityContext.getUserIdentity(), PlaceChargingStationCommand.class); } try { ChargingStation chargingStation = repository.findOne(chargingStationId); if (chargingStation != null && chargingStation.isAccepted()) { PlaceChargingStationApiCommand command = gson.fromJson(commandObject, PlaceChargingStationApiCommand.class); commandGateway.send(new PlaceChargingStationCommand(csId, command.getCoordinates(), command.getAddress(), command.getAccessibility(), identityContext)); } } catch (JsonSyntaxException ex) { throw new IllegalArgumentException("Place charging station command not able to parse the payload, is your JSON correctly formatted?", ex); } }
public static <T> Either<String, T> resolveImportDMN(Import _import, Collection<T> all, Function<T, QName> idExtractor) { final String iNamespace = _import.getNamespace(); final String iName = _import.getName(); final String iModelName = _import.getAdditionalAttributes().get(TImport.MODELNAME_QNAME); List<T> allInNS = all.stream() .filter(m -> idExtractor.apply(m).getNamespaceURI().equals(iNamespace)) .collect(Collectors.toList()); if (allInNS.size() == 1) { T located = allInNS.get(0); if (iModelName == null || idExtractor.apply(located).getLocalPart().equals(iModelName)) { return Either.ofRight(located); } else { return Either.ofLeft(String.format("While importing DMN for namespace: %s, name: %s, modelName: %s, located within namespace only %s but does not match for the actual name", iNamespace, iName, iModelName, idExtractor.apply(located))); } } else { List<T> usingNSandName = allInNS.stream() .filter(m -> idExtractor.apply(m).getLocalPart().equals(iModelName)) .collect(Collectors.toList()); if (usingNSandName.size() == 1) { return Either.ofRight(usingNSandName.get(0)); } else if (usingNSandName.size() == 0) { return Either.ofLeft(String.format("Could not locate required dependency while importing DMN for namespace: %s, name: %s, modelName: %s.", iNamespace, iName, iModelName)); } else { return Either.ofLeft(String.format("While importing DMN for namespace: %s, name: %s, modelName: %s, could not locate required dependency within: %s.", iNamespace, iName, iModelName, allInNS.stream().map(idExtractor).collect(Collectors.toList()))); } } }
void addFeatures(Object featureService) throws MojoExecutionException { if (featuresToInstall != null) { try { Class<? extends Object> serviceClass = featureService.getClass(); Method installFeatureMethod = serviceClass.getMethod("installFeature", String.class); String[] features = featuresToInstall.split(" *, *"); for (String feature : features) { installFeatureMethod.invoke(featureService, feature); Thread.sleep(1000L); } } catch (Exception e) { throw new MojoExecutionException("Failed to add features to karaf", e); } } }
public Read loadRead(final ReadQuery query, String fileUrl, String indexUrl) throws IOException { Assert.notNull(query, MessagesConstants.ERROR_NULL_PARAM); Assert.isTrue(query.getId() != null || (StringUtils.isNotBlank(fileUrl) && StringUtils.isNotBlank(indexUrl)), MessagesConstants.ERROR_NULL_PARAM); Assert.notNull(query.getChromosomeId(), MessagesConstants.ERROR_NULL_PARAM); Assert.notNull(query.getStartIndex(), MessagesConstants.ERROR_NULL_PARAM); Assert.notNull(query.getEndIndex(), MessagesConstants.ERROR_NULL_PARAM); Assert.notNull(query.getName(), MessagesConstants.ERROR_NULL_PARAM); final Chromosome chromosome = referenceGenomeManager.loadChromosome(query.getChromosomeId()); BamFile bamFile; if (query.getId() != null) { bamFile= bamFileManager.load(query.getId()); } else { bamFile = bamHelper.makeUrlBamFile(fileUrl, indexUrl, chromosome); } return getReadFromBamFile(query, chromosome, bamFile); }
public static AttributeValue toAttributeValueV2(final com.amazonaws.services.lambda.runtime.events.models.dynamodb.AttributeValue value) { if (Objects.nonNull(value.getS())) { return AttributeValue.builder() .s(value.getS()) .build(); } else if (Objects.nonNull(value.getSS())) { return AttributeValue.builder() .ss(value.getSS()) .build(); } else if (Objects.nonNull(value.getN())) { return AttributeValue.builder() .n(value.getN()) .build(); } else if (Objects.nonNull(value.getNS())) { return AttributeValue.builder() .ns(value.getNS()) .build(); } else if (Objects.nonNull(value.getB())) { return AttributeValue.builder() .b(SdkBytes.fromByteBuffer(value.getB())) .build(); } else if (Objects.nonNull(value.getBS())) { return AttributeValue.builder() .bs(value.getBS().stream() .map(SdkBytes::fromByteBuffer) .collect(Collectors.toList())) .build(); } else if (Objects.nonNull(value.getBOOL())) { return AttributeValue.builder() .bool(value.getBOOL()) .build(); } else if (Objects.nonNull(value.getL())) { return AttributeValue.builder() .l(value.getL().stream() .map(DynamodbAttributeValueTransformer::toAttributeValueV2) .collect(Collectors.toList())) .build(); } else if (Objects.nonNull(value.getM())) { return AttributeValue.builder() .m(toAttributeValueMapV2(value.getM())) .build(); } else if (Objects.nonNull(value.getNULL())) { return AttributeValue.builder() .nul(value.getNULL()) .build(); } else { throw new IllegalArgumentException( String.format("Unsupported attributeValue type: %s", value)); } }
@Override public List<ApiClusterTemplateConfig> getServiceConfigs(CmTemplateProcessor templateProcessor, TemplatePreparationObject templatePreparationObject) { StringBuilder hdfsCoreSiteSafetyValveValue = new StringBuilder(); s3GuardConfigProvider.getServiceConfigs(templatePreparationObject, hdfsCoreSiteSafetyValveValue); List<ApiClusterTemplateConfig> list = new ArrayList<>(); if (StringUtils.isNotEmpty(hdfsCoreSiteSafetyValveValue.toString())) { list.add(config(CORE_SITE_SAFETY_VALVE, hdfsCoreSiteSafetyValveValue.toString())); } if (templatePreparationObject.getProductDetailsView() != null && templatePreparationObject.getProductDetailsView().getCm() != null && templatePreparationObject.getProductDetailsView().getCm().getVersion() != null) { String cmVersion = templatePreparationObject.getProductDetailsView().getCm().getVersion(); if (templatePreparationObject.getStackType() == StackType.DATALAKE && isVersionNewerOrEqualThanLimited(cmVersion, CLOUDERAMANAGER_VERSION_7_2_0)) { list.add(config("dfs_replication", "1")); list.add(config("service_health_suppression_hdfs_verify_ec_with_topology", "true")); } } return Collections.unmodifiableList(list); }
public CanonCamera setDefaultTimeout(final Duration defaultTimeout) { this.defaultTimeout = defaultTimeout; return this; }
public static MultiPoint fromJson(@NonNull String json) { GsonBuilder gson = new GsonBuilder(); gson.registerTypeAdapterFactory(GeoJsonAdapterFactory.create()); return gson.create().fromJson(json, MultiPoint.class); }
protected boolean cmsHasKeyDeletePermissions(String policyJson) { try { Policy policy = getPolicyFromPolicyString(policyJson); return policy.getStatements().stream() .anyMatch( statement -> StringUtils.equals(statement.getId(), CERBERUS_MANAGEMENT_SERVICE_SID) && statementAppliesToPrincipal(statement, cmsRoleArn) && statement.getEffect() == Statement.Effect.Allow && statementIncludesAction(statement, KMSActions.ScheduleKeyDeletion) && statementIncludesAction(statement, KMSActions.CancelKeyDeletion)); } catch (Exception e) { logger.error( "Failed to validate that CMS can delete KMS key, there may be something wrong with the policy", e); } return false; }
@Override public List<FieldValueGetter> generateGetters(Class pojoClass) { ImmutableList.Builder<FieldValueGetter> getters = ImmutableList.builder(); List<Method> getterMethods = getPublicGetters(pojoClass); for (Method getterMethod : getterMethods) { getters.add(createFieldGetterInstance(pojoClass, getterMethod)); } return getters.build(); }
static MultivariatePolynomialZp64 interpolateGCD(MultivariatePolynomialZp64 a, MultivariatePolynomialZp64 b, MultivariatePolynomialZp64 skeleton, RandomGenerator rnd) { a.assertSameCoefficientRingWith(b); a.assertSameCoefficientRingWith(skeleton); assert contentGCD(a, b, 0, MultivariateGCD::PolynomialGCD).isConstant(); lSparseInterpolation interpolation = createInterpolation(-1, a, b, skeleton, 1, rnd); if (interpolation == null) return null; MultivariatePolynomialZp64 gcd = interpolation.evaluate(); if (gcd == null) return null; return gcd; }
public VlanId ingressVlan() { if (!object.has(INGRESS_VLAN)) { return VlanId.NONE; } try { return VlanId.vlanId(object.path(INGRESS_VLAN).asText()); } catch (IllegalArgumentException e) { return null; } }
@Override public byte[] encrypt(final byte[] plaintext, final byte[] associatedData) throws GeneralSecurityException { try { EncryptRequest req = new EncryptRequest().withKeyId(keyArn).withPlaintext(ByteBuffer.wrap(plaintext)); if (associatedData != null && associatedData.length != 0) { req = req.addEncryptionContextEntry("associatedData", BinaryUtils.toHex(associatedData)); } return kmsClient.encrypt(req).getCiphertextBlob().array(); } catch (AmazonServiceException e) { throw new GeneralSecurityException("encryption failed", e); } }
public static <T> T retry( final Task<T> f, final Predicate<Throwable> shouldRetry, final int quietTries, final int maxTries, @Nullable final CleanupAfterFailure cleanupAfterFailure, @Nullable final String messageOnRetry ) throws Exception { Preconditions.checkArgument(maxTries > 0, "maxTries > 0"); Preconditions.checkArgument(quietTries >= 0, "quietTries >= 0"); int nTry = 0; final int maxRetries = maxTries - 1; while (true) { try { nTry++; return f.perform(); } catch (Throwable e) { if (cleanupAfterFailure != null) { cleanupAfterFailure.cleanup(); } if (nTry < maxTries && shouldRetry.apply(e)) { awaitNextRetry(e, messageOnRetry, nTry, maxRetries, nTry <= quietTries); } else { Throwables.propagateIfInstanceOf(e, Exception.class); throw new RuntimeException(e); } } } }
@Override public void apply(Project project) { project.getPlugins().apply(CompressTreePlugin.class); project.getPlugins().apply(ArPlugin.class); project.getPlugins().apply(CpioPlugin.class); project.getPlugins().apply(SevenZipPlugin.class); }
@Override public <T> T unwrap(Class<T> cls) throws OntoDriverException { if (cls.isAssignableFrom(getClass())) { return cls.cast(this); } if (cls.isAssignableFrom(repository.getClass())) { return cls.cast(repository); } throw new SesameDriverException("No instance of class " + cls + " found."); }
public void writeArgs(final String templateName, final String qualifiedFileName, final String fileExtension, final ASTNode ast, final List<Object> templateArguments) { String fileExtensionWithDot = Strings.nullToEmpty(fileExtension); if (fileExtensionWithDot.startsWith(".")) { fileExtensionWithDot = fileExtensionWithDot.substring(1); } final String filePathStr = Names.getPathFromPackage(qualifiedFileName) + "." + fileExtensionWithDot; final Path filePath = Paths.get(filePathStr); writeArgs(templateName, filePath, ast, templateArguments); }
public static List<CertificateToken> toCertificateTokens(List<RemoteCertificate> remoteCertificates) { if (Utils.isCollectionNotEmpty(remoteCertificates)) { List<CertificateToken> certificateTokens = new LinkedList<>(); for (RemoteCertificate remoteCertificate : remoteCertificates) { CertificateToken certificateToken = toCertificateToken(remoteCertificate); if (certificateToken != null) { certificateTokens.add(certificateToken); } } return certificateTokens; } return null; }
@Override public void validate(Object obj, Errors errors) { RelationshipType relationshipType = (RelationshipType) obj; if (relationshipType == null) { errors.rejectValue("relationshipType", "error.general"); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, "aIsToB", "RelationshipType.aIsToB.required"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, "bIsToA", "RelationshipType.bIsToA.required"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, "description", "RelationshipType.description.required"); RelationshipType exist = Context.getPersonService().getRelationshipTypeByName( relationshipType.getaIsToB() + "/" + relationshipType.getbIsToA()); if (exist != null && !exist.getRetired() && !OpenmrsUtil.nullSafeEquals(relationshipType.getUuid(), exist.getUuid())) { errors.reject("duplicate.relationshipType"); } ValidateUtil.validateFieldLengths(errors, obj.getClass(), "aIsToB", "bIsToA", "description", "retireReason"); } }
public ElementSymbol clone() { ElementSymbol copy = new ElementSymbol(getShortName(), null); if(getGroupSymbol() != null) { copy.setGroupSymbol(getGroupSymbol().clone()); } copy.setMetadataID(getMetadataID()); copy.setType(getType()); copy.setIsExternalReference(isExternalReference()); copy.outputName = this.outputName; copy.setDisplayMode(this.getDisplayMode()); copy.isAggregate = isAggregate; return copy; }
public static byte[] serializeConfidentialData(OptionSet options, byte[] payload, int realCode) { if (options != null) { DatagramWriter writer = new DatagramWriter(); if (realCode > 0) { OptionSet filteredOptions = OptionJuggle.prepareEoptions(options); writer.write(realCode, CoAP.MessageFormat.CODE_BITS); DataSerializer.serializeOptionsAndPayload(writer, filteredOptions, payload); return writer.toByteArray(); } else { LOGGER.error(ErrorDescriptions.COAP_CODE_INVALID); throw new IllegalArgumentException(ErrorDescriptions.COAP_CODE_INVALID); } } else { LOGGER.error(ErrorDescriptions.OPTIONSET_NULL); throw new NullPointerException(ErrorDescriptions.OPTIONSET_NULL); } }
@SuppressWarnings("unchecked") public static <T extends Type> Expr<T> simplify(final Expr<T> expr, final Valuation valuation) { return (Expr<T>) TABLE.dispatch(expr, valuation); }
@GetMapping("/id/{userId}/get-user-profile") public RestResult<UserProfileResource> getUserProfile(@PathVariable("userId") Long userId) { return profileService.getUserProfile(userId).toGetResponse(); }
public static int countWhile(Collection<JavadocTokenKind> kinds, JavadocScanner scanner, int start) { return countWhileUntil(kinds, scanner, start, false); }
public Pair<T, T> mapRange(String col, T beginValue, T endValue, String returnCol) { int colIdx = tableDesc.findColumnByName(col).getZeroBasedIndex(); int returnIdx = tableDesc.findColumnByName(returnCol).getZeroBasedIndex(); Comparator<T> colComp = getComparator(colIdx); Comparator<T> returnComp = getComparator(returnIdx); T returnBegin = null; T returnEnd = null; for (T[] row : data.values()) { if (between(beginValue, row[colIdx], endValue, colComp)) { T returnValue = row[returnIdx]; if (returnBegin == null || returnComp.compare(returnValue, returnBegin) < 0) { returnBegin = returnValue; } if (returnEnd == null || returnComp.compare(returnValue, returnEnd) > 0) { returnEnd = returnValue; } } } if (returnBegin == null && returnEnd == null) return null; else return Pair.newPair(returnBegin, returnEnd); }
@Override public void validate(ServiceRequest serviceRequest, ServiceDefinition serviceDefinition, ServiceStatus action) { final List<AttributeDefinition> mandatoryAttributes = serviceDefinition.getMandatoryAttributes(action, serviceRequest.getAuthenticatedUser().getRoleCodes()); if (CollectionUtils.isEmpty(mandatoryAttributes)) { return; } final Set<String> mandatoryAttributeCodes = getMissingMandatoryAttributeCodes(serviceRequest, mandatoryAttributes); if (isNotEmpty(mandatoryAttributeCodes)) { throw new MandatoryAttributesAbsentException(mandatoryAttributeCodes); } }
@Override protected Map<String, String> populateDeleteHeaders(Map<String, String> headers) { return super.populateDeleteHeaders(modifyAcceptHeader(headers)); }
public void createOrUpdateOffset(int tenant, String strategy, String collection, long offset) { Bson offsetFilter = and( eq("_tenant", tenant), eq("strategy", strategy), eq("collection", collection) ); Bson offsetUpdate = Updates.set("offset", offset); UpdateOptions updateOptions = new UpdateOptions(); updateOptions.upsert(true); offerCollection.updateOne(offsetFilter, offsetUpdate, updateOptions); }
@AllowConcurrentEvents @Subscribe public void handle(final CapabilityEvent event) { if (event.getReference().context().descriptor().type().equals(LegacyUrlCapabilityDescriptor.TYPE)) { toggleLegacyHttpBridgeModule(); } }
@Nonnull public static ModifyFeaturePropertiesLiveCommandImpl of(final Command<?> command) { return new ModifyFeaturePropertiesLiveCommandImpl((ModifyFeatureProperties) command); }
@WorkbenchPartView @SuppressWarnings("unused") public IsWidget getWidget() { return view; }
public ServerHandle detect(MBeanServerExecutor pMBeanServerExecutor) { String serverVersion = getSingleStringAttribute(pMBeanServerExecutor, "com.lightstreamer:type=Server", "LSVersion"); if (serverVersion != null) { return new ServerHandle("LightStreamer", "LightStreamer", serverVersion, null); } return null; }
public void calculate(IThrowableProxy tp) { while (tp != null) { populateFrames(tp.getStackTraceElementProxyArray()); IThrowableProxy[] suppressed = tp.getSuppressed(); if (suppressed != null) { for (IThrowableProxy current : suppressed) { populateFrames(current.getStackTraceElementProxyArray()); } } tp = tp.getCause(); } }
@Override public void serialize(GetFeaturesInput message, ByteBuf outBuffer) { ByteBufUtils.writeOFHeader(MESSAGE_TYPE, message, outBuffer, EncodeConstants.OFHEADER_SIZE); }
public String splitDateAndPartialGet(final String dateExpression, final boolean first) { final StringBuilder builder = new StringBuilder(); boolean secondSectionStarted = false; boolean atLeastOneDigitHasBeenCollected = false; for (int i = 0; i < dateExpression.length(); i++) { final char ch = dateExpression.charAt(i); if (Character.isDigit(ch) ) { atLeastOneDigitHasBeenCollected = true; if (first || secondSectionStarted) { builder.append(ch); } } else if (atLeastOneDigitHasBeenCollected || ch == '-') { if (first) { return builder.length() > 0 ? builder.toString() : null; } if (!secondSectionStarted) { secondSectionStarted = true; builder.setLength(0); } } } return builder.length() > 0 ? builder.toString() : null; }
@Override public byte[] from(Object value, int length, int decimals, boolean addPadding) { if(value == null && this.defaultValue == null) { return null; } BigInteger i = value != null ? (BigInteger)value : new BigInteger(this.defaultValue); if(i.signum() == -1) { throw new TypeConverterException("Number can not be negative"); } byte[] strBytes; BigInteger absValue = i.abs(); if(absValue.signum() == 0) { strBytes = new byte[decimals + 1]; Arrays.fill(strBytes, ("0".getBytes(this.charset))[0]); } else { strBytes = absValue.toString().getBytes(this.charset); } if(strBytes.length > length) { throw new TypeConverterException("Field to small for value: " + length + " < " + strBytes.length); } if(addPadding) { strBytes = padBytes(strBytes, length); } return strBytes; }
@Override public CollectedClientData convert(String source) { return converter.convert(source); }
public void stat(String key, double value) { if (stats == null) stats = new HashMap<>(); stats.compute(key, (k, oldValue) -> (oldValue == null) ? value : oldValue + value); var format = new DecimalFormat(); add(event("[stat] {}={}", key, format.format(value))); }
public void print(final Appendable out, final Object value, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { charSequence = EMPTY; } else if (value instanceof CharSequence) { charSequence = (CharSequence) value; } else if (value instanceof Date || value instanceof Calendar) { final Date time = value instanceof Calendar ? ((Calendar) value).getTime() : (Date) value; charSequence = DATE_TIME_FORMATTER.format(time.toInstant().atZone(ZoneId.systemDefault())); } else { charSequence = value.toString(); } this.print(out, value, charSequence, 0, charSequence.length(), newRecord); }
@Override public Task getTask(final File src, final File dst, final StateDecider sd, final BufferStateDecider bsd) throws DataParseException, IOException { List<Action> actions = new ArrayList<>(3); State state = sd.getState(src, dst); switch (state) { case ORPHAN_SOURCE: if (!bsd.getState(dst).equals(State.ORPHAN_SOURCE)) { actions.add(addDestination); } else { actions.add(overwriteDestination); } break; case ORPHAN_DESTINATION: actions.add(ignoreDestinationOrphan); actions.add(deleteDestinationOrphan); break; case DIR_SOURCE_FILE_DESTINATION: case FILE_SOURCE_DIR_DESTINATION: State buff = bsd.getState(dst); if (buff.equals(State.ORPHAN_DESTINATION)) { actions.add(new Action(ActionType.ADD, DESTINATION, BufferUpdate.DESTINATION, "There was a node in buff, but its orphan, so add")); } else if (buff.equals(state)) { if (state.equals(State.DIR_SOURCE_FILE_DESTINATION)) { actions.add(new Action(ActionType.NOTHING, NONE, BufferUpdate.DESTINATION, "dirherefilethere, but there is a dir instead of file, so its in sync")); } else { actions.add(new Action(ActionType.DIR_HERE_FILE_THERE_ERROR, DESTINATION, BufferUpdate.NONE, "file changed from/to dir, can't overwrite")); } } else { if (state.equals(State.DIR_SOURCE_FILE_DESTINATION)) { String explanation = "cant update, dir here file there error occured"; actions.add(new Action(ActionType.DIR_HERE_FILE_THERE_ERROR, SOURCE, BufferUpdate.NONE, explanation)); } else { String explanation = "cant update, dir here file there error occured"; actions.add(new Action(ActionType.DIR_HERE_FILE_THERE_ERROR, DESTINATION, BufferUpdate.NONE, explanation)); } } break; case FILE_CHANGE_SOURCE: if (bsd.getState(dst).equals(State.IN_SYNC)) { actions.add(updateDestination); } break; case FILE_CHANGE_DESTINATION: if (bsd.getState(dst).equals(State.IN_SYNC)) { actions.add(overwriteDestination); } break; case IN_SYNC: actions.add(inSync); actions.add(overwriteDestination); break; } actions.add(ignore); Action[] as = new Action[actions.size()]; actions.toArray(as); return new Task(src, dst, state, as); }
public static JmsDestination getJmsDestination(AmqpJmsMessageFacade message, JmsDestination consumerDestination) { String to = message.getToAddress(); byte typeByte = getTypeByte(message, JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL); if (typeByte == UNKNOWN_TYPE) { typeByte = getTypeByte(message, AmqpMessageSupport.LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL); } String name = stripPrefixIfNecessary(to, message.getConnection(), typeByte, consumerDestination); return createDestination(name, typeByte, consumerDestination, false); }
@Produces @ViewEngineConfig public PebbleEngine pebbleEngine() { PebbleEngine.Builder engine = new PebbleEngine.Builder(); pebbleConfiguration .entrySet() .stream() .filter(e -> String.valueOf(e.getValue()).trim().length() > 0) .forEach((e) -> { String val = String.valueOf(e.getValue()); switch (PebbleProperty.fromKey(String.valueOf(e.getKey()))) { case AUTO_ESCAPING: engine.autoEscaping(Boolean.valueOf(val)); break; case CACHE_ACTIVE: engine.cacheActive(Boolean.valueOf(val)); break; case ESCAPING_STRATEGY: try { String escapingStrategyKey = "userDefinedEscapingStrategy"; engine.addEscapingStrategy(escapingStrategyKey, (EscapingStrategy) Class.forName(val).newInstance()); engine.defaultEscapingStrategy(escapingStrategyKey); } catch (ClassNotFoundException | IllegalAccessException | InstantiationException ex) { String msg = String.format("Pebble initialization error: Could not register escaping strategy '%s' of type %s", String.valueOf(e.getKey()), val); throw new IllegalArgumentException(msg, ex); } break; case DEFAULT_LOCALE: engine.defaultLocale(Locale.forLanguageTag(val)); break; case NEW_LINE_TRIMMING: engine.newLineTrimming(Boolean.valueOf(val)); break; case STRICT_VARIABLES: engine.strictVariables(Boolean.valueOf(val)); break; case EXECUTOR_SERVICE: try { engine.executorService((ExecutorService) Class.forName(val).newInstance()); } catch (ClassNotFoundException | IllegalAccessException | InstantiationException ex) { String msg = String.format("Pebble initialization error: Could not register executor service type %s", val); throw new IllegalArgumentException(msg, ex); } break; case EXTENSION: String[] extensions = val.split(","); Extension[] extensionArray = Stream.of(extensions) .map(clazzName -> { try { return (Extension) Class.forName(clazzName.trim()).newInstance(); } catch (ClassNotFoundException | IllegalAccessException | InstantiationException ex) { String msg = String.format("Pebble initialization error: Could not register extension of type %s", clazzName); throw new IllegalArgumentException(msg, ex); } }).toArray(Extension[]::new); engine.extension(extensionArray); break; case TAG_CACHE_MAX: engine.tagCache(CacheBuilder.newBuilder().maximumSize(Integer.valueOf(val)).build()); break; case TEMPLATE_CACHE_MAX: engine.templateCache(CacheBuilder.newBuilder().maximumSize(Integer.valueOf(val)).build()); break; case UNKNOWN: break; default: break; } }); engine.loader(new ServletLoader(servletContext)); return engine.build(); }
@POST @Path("/getChildFolders") @Produces(APPLICATION_JSON) public Collection<Folder> getChildFolders(@FormParam("path") final String parentPath) { Collection<Folder> folders = new ArrayList<>(); if (parentPath == null || "none".equals(parentPath)) { File userHomeDir = new File(USER_HOME.getValue()); folders.add(new Folder(userHomeDir.getName(), userHomeDir.getAbsolutePath())); FileSystems.getDefault().getRootDirectories() .forEach(root -> folders.add(new Folder(root.toString(), root.toString()))); } else { folders.addAll(listChildren(parentPath, false).stream() .map(child -> new Folder(child.getName(), child.getAbsolutePath())) .collect(toList())); } return folders; }
public static void decomposeMatrix(double[] transformMatrix, MatrixDecompositionContext ctx) { Assertions.assertCondition(transformMatrix.length == 16); final double[] perspective = ctx.perspective; final double[] quaternion = ctx.quaternion; final double[] scale = ctx.scale; final double[] skew = ctx.skew; final double[] translation = ctx.translation; final double[] rotationDegrees = ctx.rotationDegrees; if (isZero(transformMatrix[15])) { return; } double[][] matrix = new double[4][4]; double[] perspectiveMatrix = new double[16]; for (int i = 0; i < 4; i++) { for (int j = 0; j < 4; j++) { double value = transformMatrix[(i * 4) + j] / transformMatrix[15]; matrix[i][j] = value; perspectiveMatrix[(i * 4) + j] = j == 3 ? 0 : value; } } perspectiveMatrix[15] = 1; if (isZero(determinant(perspectiveMatrix))) { return; } if (!isZero(matrix[0][3]) || !isZero(matrix[1][3]) || !isZero(matrix[2][3])) { double[] rightHandSide = { matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3] }; double[] inversePerspectiveMatrix = inverse( perspectiveMatrix ); double[] transposedInversePerspectiveMatrix = transpose( inversePerspectiveMatrix ); multiplyVectorByMatrix(rightHandSide, transposedInversePerspectiveMatrix, perspective); } else { perspective[0] = perspective[1] = perspective[2] = 0d; perspective[3] = 1d; } for (int i = 0; i < 3; i++) { translation[i] = matrix[3][i]; } double[][] row = new double[3][3]; for (int i = 0; i < 3; i++) { row[i][0] = matrix[i][0]; row[i][1] = matrix[i][1]; row[i][2] = matrix[i][2]; } scale[0] = v3Length(row[0]); row[0] = v3Normalize(row[0], scale[0]); skew[0] = v3Dot(row[0], row[1]); row[1] = v3Combine(row[1], row[0], 1.0, -skew[0]); skew[0] = v3Dot(row[0], row[1]); row[1] = v3Combine(row[1], row[0], 1.0, -skew[0]); scale[1] = v3Length(row[1]); row[1] = v3Normalize(row[1], scale[1]); skew[0] /= scale[1]; skew[1] = v3Dot(row[0], row[2]); row[2] = v3Combine(row[2], row[0], 1.0, -skew[1]); skew[2] = v3Dot(row[1], row[2]); row[2] = v3Combine(row[2], row[1], 1.0, -skew[2]); scale[2] = v3Length(row[2]); row[2] = v3Normalize(row[2], scale[2]); skew[1] /= scale[2]; skew[2] /= scale[2]; double[] pdum3 = v3Cross(row[1], row[2]); if (v3Dot(row[0], pdum3) < 0) { for (int i = 0; i < 3; i++) { scale[i] *= -1; row[i][0] *= -1; row[i][1] *= -1; row[i][2] *= -1; } } quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0)); quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0)); quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0)); quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0)); if (row[2][1] > row[1][2]) { quaternion[0] = -quaternion[0]; } if (row[0][2] > row[2][0]) { quaternion[1] = -quaternion[1]; } if (row[1][0] > row[0][1]) { quaternion[2] = -quaternion[2]; } if (quaternion[0] < 0.001 && quaternion[0] >= 0 && quaternion[1] < 0.001 && quaternion[1] >= 0) { rotationDegrees[0] = rotationDegrees[1] = 0d; rotationDegrees[2] = roundTo3Places(Math.atan2(row[0][1], row[0][0]) * 180 / Math.PI); } else { quaternionToDegreesXYZ(quaternion, rotationDegrees); } }
public static QueryNode translateQuery(Map<String, Object> query, List<Index> indexes, Boolean[] indexesCoverQuery) { TranslatorState state = new TranslatorState(); QueryNode node = translateQuery(query, indexes, state); Misc.checkState(!state.textIndexMissing, "No text index defined, cannot execute query containing a text search."); Misc.checkState(!(state.textIndexRequired && state.atLeastOneIndexMissing), String.format("query %s contains a text search but is missing \"json\"" + " index(es). All indexes must exist in order to execute a" + " query containing a text search. Create all necessary" + " indexes for the query and re-execute.", query.toString())); if (!state.textIndexRequired && (!state.atLeastOneIndexUsed || state.atLeastOneORIndexMissing)) { SqlQueryNode sqlNode = new SqlQueryNode(); Set<String> neededFields = new HashSet<String>(Collections.singletonList("_id")); String allDocsIndex = chooseIndexForFields(neededFields, indexes); if (allDocsIndex != null && !allDocsIndex.isEmpty()) { String tableName = QueryImpl.tableNameForIndex(allDocsIndex); String sql = String.format(Locale.ENGLISH, "SELECT _id FROM \"%s\"", tableName); sqlNode.sql = SqlParts.partsForSql(sql, new String[]{}); } AndQueryNode root = new AndQueryNode(); root.children.add(sqlNode); indexesCoverQuery[0] = false; return root; } else { indexesCoverQuery[0] = !state.atLeastOneIndexMissing; return node; } }
@Override public boolean isRunnerMemoryCorrect(@Min(value=0) int totalMemory, @Min(value=0) int usedMemory, @Min(value=0) int availableMemory) { if (usedMemory < 0 || totalMemory < 0 || availableMemory < 0) { showWarning(locale.messagesIncorrectValue()); return false; } if (usedMemory % MB_100.getValue() != 0) { showWarning(locale.ramSizeMustBeMultipleOf(MB_100.getValue())); return false; } if (usedMemory > totalMemory) { showWarning(locale.messagesTotalRamLessCustom(usedMemory, totalMemory)); return false; } if (usedMemory > availableMemory) { showWarning(locale.messagesAvailableRamLessCustom(usedMemory, totalMemory, totalMemory - availableMemory)); return false; } return true; }
@Override public FSDataInputStream open(Path f, int bufferSize) throws IOException { Path absolutePath = toAbsolutePath(f); checkPath(absolutePath); final String path = absolutePath.toUri().getPath(); return new FSDataInputStream(new RemoteNodeInputStream(path, bufferSize)); }
public Map<String, String> processTemplate(ActionMessage msg) throws Exception { Map<String, String> emailProcessed = new HashMap<>(); PluginMessageDescription pmDesc = new PluginMessageDescription(msg); emailProcessed.put("emailSubject", pmDesc.getEmailSubject()); String plain; String html; String templateLocale = pmDesc.getProps() != null ? pmDesc.getProps().get(EmailPlugin.PROP_TEMPLATE_LOCALE) : null; if (templateLocale != null) { plain = pmDesc.getProps().get(EmailPlugin.PROP_TEMPLATE_PLAIN + "." + templateLocale); html = pmDesc.getProps().get(EmailPlugin.PROP_TEMPLATE_HTML + "." + templateLocale); } else { plain = pmDesc.getProps() != null ? pmDesc.getProps().get(EmailPlugin.PROP_TEMPLATE_PLAIN) : null; html = pmDesc.getProps() != null ? pmDesc.getProps().get(EmailPlugin.PROP_TEMPLATE_HTML) : null; } StringWriter writerPlain = new StringWriter(); StringWriter writerHtml = new StringWriter(); if (!isEmpty(plain)) { StringReader plainReader = new StringReader(plain); ftlTemplate = new Template("plainTemplate", plainReader, ftlCfg); ftlTemplate.process(pmDesc, writerPlain); } else { ftlTemplatePlain.process(pmDesc, writerPlain); } if (!isEmpty(html)) { StringReader htmlReader = new StringReader(html); ftlTemplate = new Template("htmlTemplate", htmlReader, ftlCfg); ftlTemplate.process(pmDesc, writerHtml); } else { ftlTemplateHtml.process(pmDesc, writerHtml); } writerPlain.flush(); writerPlain.close(); emailProcessed.put("emailBodyPlain", writerPlain.toString()); writerHtml.flush(); writerHtml.close(); emailProcessed.put("emailBodyHtml", writerHtml.toString()); return emailProcessed; }
@Override public void execute() { int address = z80.getProgramCounter(); byte registerValue = mmu.readByte(address); z80.set8BitRegisterValue(destinyRegister, registerValue); z80.incrementProgramCounter(); z80.setLastInstructionExecutionTime(2); }
private static FunctionResolver lte() { return new FunctionResolver( BuiltinFunctionName.LTE.getName(), predicate( BuiltinFunctionName.LTE.getName(), (v1, v2) -> v1 <= v2, (v1, v2) -> v1 <= v2, (v1, v2) -> v1 <= v2, (v1, v2) -> v1 <= v2, (v1, v2) -> v1.compareTo(v2) <= 0 ) ); }
public final void setUnusedWarning(boolean warn) { Options.unused_warning = warn; }
public final float getMissRate() { final int total = this.getTotal(); if (total == 0) { return 0; } return this.getMisses() / (float) total; }
public static QueryParams buildQueryParams(GridSettings settings) { return buildQueryParams(settings, buildOrderList(settings, null)); }
@Override public PersistenceType getPersistenceType() { throw new UnsupportedOperationException(); }
@Override public ConfigSnapshotSet findSnapshotSetToRollback(int projectId, int envId, String task) { return (ConfigSnapshotSet) getSqlMapClientTemplate().queryForObject("ConfigRelease.findSnapshotSetWithTask", Maps.entry("projectId", projectId).entry("envId", envId).entry("task", task).get()); }
@Override public LogMessage parse(CharSequence text) { String string = text.toString(); Matcher gcMatcher = GC_PATTERN.matcher(string); if (gcMatcher.matches()) { return new GcLogMessage( "Full".equals(gcMatcher.group(1)) ? GcLogMessage.Type.FULL : GcLogMessage.Type.INCREMENTAL, ShortDuration.of(BigDecimal.valueOf(Double.parseDouble(gcMatcher.group(2))), SECONDS)); } Matcher jitMatcher = JIT_PATTERN.matcher(string); if (jitMatcher.matches()) { return new HotspotLogMessage(); } Matcher vmOptionMatcher = VM_OPTION_PATTERN.matcher(string); if (vmOptionMatcher.matches()) { return new VmOptionLogMessage(vmOptionMatcher.group(2), vmOptionMatcher.group(3)); } return null; }
static String getRelativePath(final File from, final File to) { return getRelativePath(from, to, File.separatorChar); }
@Override public void checkAttributeSemantics(PerunSessionImpl sess, Group group, Resource resource, Attribute attribute) throws WrongReferenceAttributeValueException, WrongAttributeAssignmentException { List<String> emails = attribute.valueAsList(); if (emails == null) emails = new ArrayList<>(); AttributesManagerBl am = sess.getPerunBl().getAttributesManagerBl(); try { if (emails.isEmpty()) { Attribute adName = am.getAttribute(sess, resource, group, ADNAME_ATTRIBUTE); if (adName.getValue() != null) { throw new WrongReferenceAttributeValueException(attribute, adName, resource, group, resource, group, "at least one email must be defined"); } return; } } catch (AttributeNotExistsException | GroupResourceMismatchException e) { throw new InternalErrorException(e.getMessage(), e); } AttributesManagerBl attributesManagerBl = sess.getPerunBl().getAttributesManagerBl(); Set<Pair<Integer, Integer>> groupResourcePairs = attributesManagerBl.getPerunBeanIdsForUniqueAttributeValue(sess, attribute); groupResourcePairs.remove(new Pair<>(group.getId(), resource.getId())); if (!groupResourcePairs.isEmpty()) { throw new WrongReferenceAttributeValueException(attribute, attribute, group, resource, "some of the email addresses are already assigned to the following group_resource pairs: " + groupResourcePairs); } Attribute memberO365EmailAddresses = new Attribute(new urn_perun_member_attribute_def_def_o365EmailAddresses_mu().getAttributeDefinition()); memberO365EmailAddresses.setValue(emails); Set<Pair<Integer, Integer>> memberPairs = attributesManagerBl.getPerunBeanIdsForUniqueAttributeValue(sess, memberO365EmailAddresses); if (!memberPairs.isEmpty()) { throw new WrongReferenceAttributeValueException(attribute, memberO365EmailAddresses, group, resource, "member " + BeansUtils.getSingleId(memberPairs) + " "); } }
public ValiFieldText addRangeLengthValidator(int minLength, int maxLength) { return addRangeLengthValidator(getErrorRes(ValiFi.Builder.ERROR_RES_LENGTH_RANGE), minLength, maxLength); }
@Override public void writeCreated(Appendable appendable, Object request, Object specimen) throws IOException { if (!(request instanceof Member)) return; Member member = (Member) request; appendable.append(String.format("%s = %s", member.getName(), specimen)); appendable.append("\n"); }
public static BooleanSeries getOutliers(DataFrame df, Duration minDuration) { if (df.isEmpty()) { return BooleanSeries.empty(); } LongSeries time = df.getLongs(COL_TIME); DoubleSeries value = fastBSpline(df.getDoubles(COL_VALUE), FAST_SPLINE_ITERATIONS); byte[] outlier = new byte[df.size()]; Arrays.fill(outlier, (byte) 0); double upTercile = value.quantile(0.666).doubleValue(); double downTercile = value.quantile(0.333).doubleValue(); int runStart = 0; int runSide = 0; for (int i = 0; i < df.size(); i++) { if (!value.isNull(i)) { int side = 0; if (value.getDouble(i) > upTercile) side = 1; if (value.getDouble(i) < downTercile) side = -1; if (runSide != side || i >= df.size() - 1) { long past = time.getLong(runStart); long now = time.getLong(i); long runDuration = now - past; if (runSide != 0 && runDuration >= minDuration.getMillis()) { Arrays.fill(outlier, runStart, i, (byte) 1); } runStart = i; runSide = side; } } } return BooleanSeries.buildFrom(outlier); }
@Override public String getTargetId() { return TARGET_ID; }
public static <T> T get(String relativePath, Class<T> assetClass) { AssetManager assetManager = getAssetManager(); String path = assetFolders.containsKey(assetClass) && !assetFolders.get(assetClass).trim().isEmpty() && !assetFolders.get(assetClass).equals(".") && !assetFolders.get(assetClass).equals("/") ? assetFolders.get(assetClass) + "/" + relativePath : relativePath; return assetManager.get(path, assetClass); }
public void deleteFeedSource(Long feedSourceId) { feedInternalService.deleteFeedSource(feedSourceId); }
public static boolean areAWSIAMRoleInputsValid(AWSIAMRole awsiamRole) throws TVaultValidationException{ if (awsiamRole == null) { return false; } if (StringUtils.isEmpty(awsiamRole.getRole())) { throw new TVaultValidationException("Role is required."); } else if (StringUtils.isEmpty(awsiamRole.getAuth_type()) || !awsiamRole.getAuth_type().equalsIgnoreCase("iam")) { throw new TVaultValidationException("auth_type is required and it should be iam."); } else if (ArrayUtils.isNotEmpty(awsiamRole.getBound_iam_principal_arn()) ) { boolean containsEmptyString = Stream.of(awsiamRole.getBound_iam_principal_arn()) .anyMatch(string -> string == null || string.isEmpty()); if(containsEmptyString) { throw new TVaultValidationException("Invalid value specified for bound_iam_principal_arn."); } else { return true; } } throw new TVaultValidationException("Bound parameter should be specified."); }
@Override public ValidationResult handleMessage(final Bytes bytes) { try { ProposerSlashing proposerSlashing = deserialize(bytes); final InternalValidationResult internalValidationResult = validateData(proposerSlashing); switch (internalValidationResult) { case REJECT: case IGNORE: LOG.trace("Received invalid message for topic: {}", this::getTopic); break; case ACCEPT: consumer.forward(proposerSlashing); break; default: throw new UnsupportedOperationException( "Unexpected validation result: " + internalValidationResult); } return internalValidationResult.getGossipSubValidationResult(); } catch (DecodingException e) { LOG.trace("Received malformed gossip message on {}", getTopic()); return ValidationResult.Invalid; } catch (Throwable e) { LOG.warn("Encountered exception while processing message for topic {}", getTopic(), e); return ValidationResult.Invalid; } }
@Override public void doOnMessage(final Message message) throws Exception { LOG.debug("Entering " + getClass()); LOG.debug(message); MessageDataContainer dataContainer = getDataContainerFromMessage(message); LoadBalancer dbLoadBalancer; List<Integer> vipIdsToDelete = dataContainer.getIds(); try { dbLoadBalancer = loadBalancerService.getWithUserPages(dataContainer.getLoadBalancerId(), dataContainer.getAccountId()); } catch (EntityNotFoundException enfe) { String alertDescription = String.format("Load balancer '%d' not found in database.", dataContainer.getLoadBalancerId()); LOG.error(alertDescription, enfe); notificationService.saveAlert(dataContainer.getAccountId(), dataContainer.getLoadBalancerId(), enfe, AlertType.DATABASE_FAILURE.name(), alertDescription); sendErrorToEventResource(dataContainer); return; } try { if (isRestAdapter()) { LOG.debug(String.format("Removing virtual ips from load balancer '%d' in STM...", dbLoadBalancer.getId())); reverseProxyLoadBalancerStmService.deleteVirtualIps(dbLoadBalancer, vipIdsToDelete, loadBalancerService.getUserPages(dataContainer.getLoadBalancerId(), dataContainer.getAccountId())); LOG.debug(String.format("Successfully removed virtual ips from load balancer '%d' in Zeus.", dbLoadBalancer.getId())); } else { LOG.debug(String.format("Removing virtual ips from load balancer '%d' in ZXTM...", dbLoadBalancer.getId())); reverseProxyLoadBalancerService.deleteVirtualIps(dbLoadBalancer, vipIdsToDelete); LOG.debug(String.format("Successfully removed virtual ips from load balancer '%d' in Zeus.", dbLoadBalancer.getId())); } } catch (Exception e) { loadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ERROR); String alertDescription = String.format("Error deleting virtual ips in Zeus for loadbalancer '%d'.", dbLoadBalancer.getId()); LOG.error(alertDescription, e); notificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), e, ZEUS_FAILURE.name(), alertDescription); sendErrorToEventResource(dataContainer); return; } try { LOG.debug(String.format("Removing virtual ips from load balancer '%d' in database...", dbLoadBalancer.getId())); virtualIpService.removeVipsFromLoadBalancer(dbLoadBalancer, vipIdsToDelete); LOG.debug(String.format("Successfully removed virtual ips from load balancer '%d' in database.", dbLoadBalancer.getId())); } catch (Exception e) { loadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ERROR); String alertDescription = String.format("Error deleting virtual ips in database for loadbalancer '%d'.", dbLoadBalancer.getId()); LOG.error(alertDescription, e); notificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), e, DATABASE_FAILURE.name(), alertDescription); sendErrorToEventResource(dataContainer); loadBalancerStatusHistoryService.save(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), LoadBalancerStatus.ERROR); return; } Calendar eventTime = Calendar.getInstance(); try { usageEventCollection.collectUsageAndProcessUsageRecords(dbLoadBalancer, UsageEvent.DELETE_VIRTUAL_IP, eventTime); } catch (UsageEventCollectionException uex) { LOG.error(String.format("Collection and processing of the usage event failed for load balancer: %s " + ":: Exception: %s", dbLoadBalancer.getId(), uex)); } catch (Exception exc) { String exceptionStackTrace = Debug.getExtendedStackTrace(exc); String usageAlertDescription = String.format("An error occurred while processing the usage for an event on loadbalancer %d: \n%s\n\n%s", dbLoadBalancer.getId(), exc.getMessage(), exceptionStackTrace); LOG.error(usageAlertDescription); notificationService.saveAlert(dbLoadBalancer.getAccountId(), dbLoadBalancer.getId(), exc, USAGE_FAILURE.name(), usageAlertDescription); } loadBalancerService.setStatus(dbLoadBalancer, LoadBalancerStatus.ACTIVE); sendSuccessToEventResource(dataContainer); LOG.info(String.format("Delete virtual ip operation complete for load balancer '%d'.", dbLoadBalancer.getId())); }
public Object getCell(final int columnIndex) { Preconditions.checkArgument(columnIndex > 0 && columnIndex < data.length + 1); return data[columnIndex - 1]; }
public static List<PlanNodeId> scheduleOrder(PlanNode root) { ImmutableList.Builder<PlanNodeId> schedulingOrder = ImmutableList.builder(); root.accept(new Visitor(schedulingOrder::add), null); return schedulingOrder.build(); }
public void setMyLocationEnabled(boolean enabled) { setMyLocationEnabled(enabled, true); }
public Long convert(BigDecimal value) { return Long.valueOf(value.longValue()); }
@Override public boolean isThreadSafe() { boolean result = accessor.isThreadSafe() && resolver.isThreadSafe(); LOG.debug("Bridge is {}thread safe", (result ? "" : "not ")); return result; }
@Override public FileChannelRecordBatch nextBatch() throws IOException { FileChannel channel = fileRecords.channel(); if (position >= end - HEADER_SIZE_UP_TO_MAGIC) return null; logHeaderBuffer.rewind(); Utils.readFullyOrFail(channel, logHeaderBuffer, position, "log header"); logHeaderBuffer.rewind(); long offset = logHeaderBuffer.getLong(OFFSET_OFFSET); int size = logHeaderBuffer.getInt(SIZE_OFFSET); if (size < LegacyRecord.RECORD_OVERHEAD_V0) throw new CorruptRecordException(String.format("Found record size %d smaller than minimum record " + "overhead (%d) in file %s.", size, LegacyRecord.RECORD_OVERHEAD_V0, fileRecords.file())); if (position > end - LOG_OVERHEAD - size) return null; byte magic = logHeaderBuffer.get(MAGIC_OFFSET); final FileChannelRecordBatch batch; if (magic < RecordBatch.MAGIC_VALUE_V2) batch = new LegacyFileChannelRecordBatch(offset, magic, channel, position, size); else batch = new DefaultFileChannelRecordBatch(offset, magic, channel, position, size); position += batch.sizeInBytes(); return batch; }
static String capitalizeFirst(String string) { if (string.isEmpty()) { return string; } return string.substring(0, 1).toUpperCase(Locale.ENGLISH) + string.substring(1); }
public AuthorisationData convertIdentifyingToken(IdentifyingToken token) { AuthorisationData authData = new AuthorisationData(); authData.setIdTag(token.getToken()); IdentifyingToken.AuthenticationStatus status = token.getAuthenticationStatus(); if (status != null && !IdentifyingToken.AuthenticationStatus.DELETED.equals(status)) { IdTagInfo info = new IdTagInfo(); switch (token.getAuthenticationStatus()) { case ACCEPTED: info.setStatus(AuthorizationStatus.ACCEPTED); break; case BLOCKED: info.setStatus(AuthorizationStatus.BLOCKED); break; case EXPIRED: info.setStatus(AuthorizationStatus.EXPIRED); break; case INVALID: info.setStatus(AuthorizationStatus.INVALID); break; case CONCURRENT_TX: info.setStatus(AuthorizationStatus.CONCURRENT_TX); break; default: throw new AssertionError(String.format("Unknown authentication status [%s] in given identifying token [%s].", token.getAuthenticationStatus(), token.getToken())); } authData.setIdTagInfo(info); } return authData; }
@Override public int read() throws IOException { throw new UnimplementedError("RpcInputStream.read()"); }
boolean isValidEnums(List<RangerEnumDef> enumDefs, List<ValidationFailureDetails> failures) { if(LOG.isDebugEnabled()) { LOG.debug(String.format("==> RangerServiceDefValidator.isValidEnums(%s, %s)", enumDefs, failures)); } boolean valid = true; if (CollectionUtils.isEmpty(enumDefs)) { LOG.debug("enum def collection passed in was null/empty. Ok."); } else { Set<String> names = new HashSet<>(); Set<Long> ids = new HashSet<>(); for (RangerEnumDef enumDef : enumDefs) { if (enumDef == null) { ValidationErrorCode error = ValidationErrorCode.SERVICE_DEF_VALIDATION_ERR_ENUM_DEF_NULL_OBJECT; failures.add(new ValidationFailureDetailsBuilder() .field("enum def") .isMissing() .errorCode(error.getErrorCode()) .becauseOf(error.getMessage()) .build()); valid = false; } else { String enumName = enumDef.getName(); valid = isUnique(enumName, names, "enum def name", "enum defs", failures) && valid; valid = isUnique(enumDef.getItemId(), ids, "enum def itemId", "enum defs", failures) && valid; if (CollectionUtils.isEmpty(enumDef.getElements())) { ValidationErrorCode error = ValidationErrorCode.SERVICE_DEF_VALIDATION_ERR_ENUM_DEF_NO_VALUES; failures.add(new ValidationFailureDetailsBuilder() .field("enum values") .subField(enumName) .isMissing() .errorCode(error.getErrorCode()) .becauseOf(error.getMessage(enumName)) .build()); valid = false; } else { valid = isValidEnumElements(enumDef.getElements(), failures, enumName) && valid; int defaultIndex = getEnumDefaultIndex(enumDef); if (defaultIndex < 0 || defaultIndex >= enumDef.getElements().size()) { ValidationErrorCode error = ValidationErrorCode.SERVICE_DEF_VALIDATION_ERR_ENUM_DEF_INVALID_DEFAULT_INDEX; failures.add(new ValidationFailureDetailsBuilder() .field("enum default index") .subField(enumName) .isSemanticallyIncorrect() .errorCode(error.getErrorCode()) .becauseOf(error.getMessage(defaultIndex, enumName)) .build()); valid = false; } } } } } if(LOG.isDebugEnabled()) { LOG.debug(String.format("<== RangerServiceDefValidator.isValidEnums(%s, %s): %s", enumDefs, failures, valid)); } return valid; }
@Override public void setOozieUrl( String oozieUrl ) { delegate.setOozieUrl( oozieUrl ); }
@Override public boolean othersDeletesAreVisible(final int type) { return false; }
@Override public void migrate(Catalog catalog, RefLog refLog, Version version, CopyTable operation) { String refId = RandomHasher.generateRefId(refLog); String sourceTableName = operation.getSourceTableName(); String targetTableName = operation.getTargetTableName(); refLog.fork(version); TableRef sourceTableRef = refLog.getTableRef(version.getParent(), sourceTableName); refLog.addTable(targetTableName, refId, version, sourceTableRef.getColumns().entrySet().stream() .map(Entry::getValue) .map(ColumnRef::ghost) .collect(Collectors.toList())); Table sourceTable = catalog.getTable(sourceTableRef.getRefId()); Table targetTable = sourceTable.copy().rename(refId); for (ForeignKey foreignKey : sourceTable.getForeignKeys()) { String referredRefId = foreignKey.getReferredTableName(); Table referredTable = catalog.getTable(referredRefId); targetTable.addForeignKey(foreignKey.getReferencingColumns()) .named(foreignKey.getForeignKeyName()) .onUpdate(foreignKey.getOnUpdate()) .onDelete(foreignKey.getOnDelete()) .referencing(referredTable, foreignKey.getReferredColumns()); } catalog.addTable(targetTable); }
@Override public List filterResults(List results) { for (int i = 0; i < results.size(); i++) { Object result = results.get(i); if (result instanceof String) { results.set(i, this.documentReferenceResolver.resolve((String) result)); } else if (result instanceof Object[]) { Object[] row = (Object[]) result; if (row.length > 0 && row[0] instanceof String) { row[0] = this.documentReferenceResolver.resolve((String) row[0]); } } } return results; }
@VisibleForTesting @SuppressWarnings("unchecked") protected EventModel createEventModel(AlertMessageEntity message, EmailResponse response) { EventModel model = new EventModel(); model.setEventType(EventModel.EventType.ALERT_EMAIL).setEventOperator(FoundationService.DEFAULT.getLocalIp()) .setEventDetail(message.getTitle()); if(message.getAlert() != null) { model.setEventOperation(message.getAlert().getAlertType().name()); } else { model.setEventOperation("grouped"); } String emailCheckInfo = null; try { emailCheckInfo = JsonCodec.INSTANCE.encode(response.getProperties()); } catch (Exception e) { logger.error("[createEventModel] Error encode check info"); } model.setEventProperty(emailCheckInfo); return model; }
public static String bytesToHexDump(byte[] chunk) { if (chunk.length == 0) { return ""; } StringBuilder sb = new StringBuilder(chunk.length * 3); for (byte b : chunk) { String hexString = Integer.toHexString(b & 255); if (hexString.length() == 1) { sb.append('0'); } sb.append(hexString).append(' '); } return sb.substring(0, sb.length() - 1); }
public File getApplicationFolder(Environment env, String applicationName) { return new File(getApplicationRootFolder(env), applicationName); }
@Override public Principal getPrincipal(@NotNull String principalName) { Result result = findPrincipals(principalName, true); if (result != null && result.getRows().iterator().hasNext()) { return new ExternalGroupPrincipal(principalName); } else { return null; } }
@Override public IdentityCertificate generateIdentityCert(Consumer consumer) throws GeneralSecurityException, IOException { if (log.isDebugEnabled()) { log.debug("Generating identity cert for consumer: " + consumer.getUuid()); } IdentityCertificate certificate = null; if (consumer.getIdCert() != null) { certificate = idCertCurator.get(consumer.getIdCert().getId()); } if (certificate != null) { return certificate; } return generate(consumer); }
public List<LatokenUserTrade> getTrades() { return trades; }
Object extractPeerObject() throws GeneralSecurityException { checkState(!internalHandshaker.isInProgress()); return internalHandshaker.extractPeerObject(); }
public CytoPanel getCytoPanel() { return cp; }
@Override public boolean isValid(NotificationRow value, ConstraintValidatorContext context) { if (!isValid(value)) { context.disableDefaultConstraintViolation(); context.buildConstraintViolationWithTemplate(WRONG_EXPIRES_AT_EXPRESSION) .addConstraintViolation(); return false; } return true; }
@Override public InputStream read(Payload payload) throws IOException { try { byte[] ciphertext = IOUtils.toByteArray(payload.getPayload().openStream()); byte[] decrypt = aead.decrypt(ciphertext, EMPTY_ASSOCIATED_DATA); return new ByteArrayInputStream(decrypt); } catch (GeneralSecurityException e) { throw new IOException("Incorrect crypto setup", e); } }
public List<String> getBeanNames(Class<?> configFile, Project project, Class<?> type) { List<String> beanNames = new ArrayList<>(); List<Class<?>> importedFiles = getConfigImports(configFile, project); for (Class<?> importLocation : importedFiles) { beanNames.addAll(getBeanNames(importLocation, project, type)); } ReflectionUtils.doWithMethods(configFile, method -> { Bean beanAnnotation = method.getAnnotation(Bean.class); if (beanAnnotation.value().length > 0) { Collections.addAll(beanNames, beanAnnotation.value()); } else if (beanAnnotation.name().length > 0) { Collections.addAll(beanNames, beanAnnotation.name()); } else { beanNames.add(method.getName()); } }, method -> method.getAnnotation(Bean.class) != null && method.getReturnType().equals(type)); return beanNames; }
public Map<String, Answer> processAnalysisAnswers( Map<String, String> rawAnswers, Map<String, AnswerRowsOptions> answersRowsOptions) { return CollectionUtil.toImmutableMap( rawAnswers, Entry::getKey, rawAnswersEntry -> processAnswerRows( rawAnswersEntry.getValue(), answersRowsOptions.get(rawAnswersEntry.getKey()))); }
@Override public WorkflowReport getWorkflowReport() { return workflowReport; }
public Boolean getPropertyBoolean(String key) { return Boolean.valueOf(getProperty(key)); }
@Override public boolean isOversizedAttribute(final String name) { return _nextVersionLegacyConfiguredObject.isOversizedAttribute(name); }
@Override public boolean accept(final ConsoleState state) { Assertions.checkNotNull("state", state); if (state.getActiveCommand() == null && state.getInput().trim().startsWith("get ")) { return true; } return false; }
public static Interval parse(final String text) { String sign = ""; int startOffset = 0; if (text.startsWith("-")) { startOffset = 1; sign = "-"; } else if (text.startsWith("+")) { startOffset = 1; } final int durationOffset = text.indexOf('T'); if (durationOffset == -1) { return new Interval(Period.parse(text), Duration.ZERO); } else if (durationOffset == startOffset + 1) { return new Interval(Period.ZERO, Duration.parse(text)); } return new Interval( Period.parse(text.substring(0, durationOffset)), Duration.parse(sign + "P" + text.substring(durationOffset))); }
@Override public void login(final String password) throws ConnectionException, RequestException, AccessException, ConfigException { login(password, false); }
public static Set<Keccak256> unknownAncestorsHashes(Keccak256 blockHash, Blockchain blockChain, BlockStore store) { Set<Keccak256> hashes = Collections.singleton(blockHash); return unknownAncestorsHashes(hashes, blockChain, store, true); }
@Override public String header(String name) { List<String> list = request.headers().get(name); if (list != null && !list.isEmpty()) { return list.get(0); } return null; }
@Override public WritableBuffer allocate(int capacityHint) { capacityHint = Math.min(MAX_BUFFER, Math.max(MIN_BUFFER, capacityHint)); return new NettyWritableBuffer(allocator.buffer(capacityHint, capacityHint)); }
@Override public UserCheTenantData load(final TenantDataCacheKey cacheKey) throws InfrastructureException { final String namespace = cacheKey.getNamespaceType(); final String responseBody; try { responseBody = getResponseBody(fabric8UserServiceEndpoint, cacheKey.getKeycloakToken()); } catch (ApiException | IOException e) { LOG.error(e.getMessage(), e); throw new InfrastructureException("Exception during the user tenant data retrieval", e); } try { final Gson gson = new Gson(); final UserServicesJsonResponse userServicesData = gson.fromJson(responseBody, UserServicesJsonResponse.class); List<Namespace> namespaces = userServicesData.getNamespaces(); for (Namespace ns : namespaces) { if (namespace.equals(ns.getType())) { UserCheTenantData cheTenantData = new UserCheTenantData( ns.getName(), ns.getClusterUrl(), ns.getClusterAppDomain(), ns.isClusterCapacityExhausted()); UserCheTenantDataValidator.validate(cheTenantData); return cheTenantData; } } } catch (ValidationException | JsonSyntaxException | NullPointerException e) { throw new InfrastructureException( "Invalid response from Fabric8 user services:" + responseBody, e); } if ("user".equals(namespace)) { LOG.error("No namespace with type 'user' was found in the user tenant: {}", responseBody); return new UserCheTenantData("", "", "", false); } throw new InfrastructureException( format( "No namespace with type '%s' was found in the user tenant", cacheKey.getNamespaceType())); }
static Collection<BQModuleMetadata> moduleProviderDependencies(Collection<BQModuleProvider> rootSet) { return moduleProviderDependencies(rootSet, new HashSet<>()); }
public <E extends BatchExecutor<E, T>, T extends BatchCommand<E, T>> void submitBatchCommand(BatchCommand<E, T> cmd) { if (queue.state != State.STARTED) throw new IllegalStateException("Batcher is shutting down"); queue.submitBatchCommand(cmd); }
public static org.apache.parquet.column.statistics.Statistics<?> readStats(Optional<String> fileCreatedBy, Optional<Statistics> statisticsFromFile, PrimitiveType type) { Statistics statistics = statisticsFromFile.orElse(null); org.apache.parquet.column.statistics.Statistics<?> columnStatistics = new ParquetMetadataConverter().fromParquetStatistics(fileCreatedBy.orElse(null), statistics, type); if (type.getOriginalType() == OriginalType.UTF8 && statistics != null && !statistics.isSetMin_value() && !statistics.isSetMax_value() && statistics.isSetMin() && statistics.isSetMax() && columnStatistics.genericGetMin() == null && columnStatistics.genericGetMax() == null && !CorruptStatistics.shouldIgnoreStatistics(fileCreatedBy.orElse(null), type.getPrimitiveTypeName())) { tryReadOldUtf8Stats(statistics, (BinaryStatistics) columnStatistics); } return columnStatistics; }
@Override public boolean addTopicConfig(final String topicName, final Map<String, ?> overrides) { final ConfigResource resource = new ConfigResource(ConfigResource.Type.TOPIC, topicName); final Map<String, String> stringConfigs = toStringConfigs(overrides); try { final Map<String, String> existingConfig = topicConfig(topicName, false); final boolean changed = stringConfigs.entrySet().stream() .anyMatch(e -> !Objects.equals(existingConfig.get(e.getKey()), e.getValue())); if (!changed) { return false; } final Set<AlterConfigOp> entries = stringConfigs.entrySet().stream() .map(e -> new ConfigEntry(e.getKey(), e.getValue())) .map(ce -> new AlterConfigOp(ce, AlterConfigOp.OpType.SET)) .collect(Collectors.toSet()); final Map<ConfigResource, Collection<AlterConfigOp>> request = Collections.singletonMap(resource, entries); ExecutorUtil.executeWithRetries( () -> adminClient.get().incrementalAlterConfigs(request).all().get(), ExecutorUtil.RetryBehaviour.ON_RETRYABLE); return true; } catch (final UnsupportedVersionException e) { return addTopicConfigLegacy(topicName, stringConfigs); } catch (final Exception e) { throw new KafkaResponseGetFailedException( "Failed to set config for Kafka Topic " + topicName, e); } }
public ObservableList<ColumnLabel> getColumnsInLabel() { return myColumnsInLabel; }
protected boolean writeSelectorDocumentationToFile(String documentationString, Writer output) { if (documentationString == null) { return false; } try { output.write(documentationString); output.flush(); output.close(); } catch (IOException e) { LOG.warn(e.getMessage()); return false; } return true; }
public void execute(SubmitTaskParameters submitParameters) { DpsTask task = submitParameters.getTask(); try { LOGGER.info("Sending task id={} to topology {} by kafka topic {}. Parameters:\n{}", task.getTaskId(), submitParameters.getTopologyName(), submitParameters.getTopicName(), submitParameters); checkIfTaskIsKilled(task); logProgress(submitParameters, 0); int expectedSize; if (taskContainsFileUrls(task)) { expectedSize = executeForFilesList(submitParameters); } else { expectedSize = executeForDatasetList(submitParameters); } if (expectedSize != 0) { taskStatusUpdater.updateStatusExpectedSize(task.getTaskId(), TaskState.QUEUED.toString(), expectedSize); LOGGER.info("Submitting {} records of task id={} to Kafka succeeded.", expectedSize, task.getTaskId()); } else { taskStatusUpdater.setTaskDropped(task.getTaskId(), "The task was dropped because it is empty"); LOGGER.warn("The task id={} was dropped because it is empty.", task.getTaskId()); } } catch (SubmitingTaskWasKilled e) { LOGGER.warn(e.getMessage(), e); } catch (Exception e) { LOGGER.error("MCSTaskSubmiter error for taskId={}", task.getTaskId(), e); taskStatusUpdater.setTaskDropped(task.getTaskId(), "The task was dropped because " + e.getMessage()); } }
@Override public boolean isSchemaEqual(ForeignKeyBundle other) { if (mTable != null ? !mTable.equals(other.mTable) : other.mTable != null) return false; if (mOnDelete != null ? !mOnDelete.equals(other.mOnDelete) : other.mOnDelete != null) { return false; } if (mOnUpdate != null ? !mOnUpdate.equals(other.mOnUpdate) : other.mOnUpdate != null) { return false; } return mColumns.equals(other.mColumns) && mReferencedColumns.equals( other.mReferencedColumns); }
public void setSecondStore(PropertyQuery secondStore) { this.secondStore = checkNotNull(secondStore); }
public boolean containsSimilarString(Collection<String> values, String searchValue, double minSimilarity) { for (String value : values) { double similarity = JaroWinklerDistanceCalculator.getDistance(value, searchValue); if (similarity >= minSimilarity) { return true; } } return false; }
public static Dataset<Instance> sonar() { Dataset<Instance> data = new ArrayDataset<>(208, 60); try { String datasetName = "sonar"; ARFFHandler arff = new ARFFHandler(); arff.load(tf.sonarArff(), data, 60); data.setName(datasetName); } catch (IOException | ParserError ex) { Exceptions.printStackTrace(ex); } return data; }
protected int handleSpecialField35 (ISOMsg m, ByteArrayOutputStream bout) throws ISOException, IOException { int len = 0; byte[] entryMode = new byte[1]; if (m.hasField (35)) { entryMode[0] = (byte) '\001'; byte[] value = m.getString(35).getBytes(); bout.write(entryMode); bout.write(value); bout.write(FS); len += value.length+2; } else if (m.hasField (2) && m.hasField (14)) { entryMode[0] = (byte) '\000'; String simulatedTrack2 = m.getString(2) + "=" + m.getString(14); bout.write(entryMode); bout.write(simulatedTrack2.getBytes()); bout.write(FS); len += simulatedTrack2.length()+2; } return len; }
protected boolean isAssumeIdentity(ConnectionReference conn) { return isAnonymousAccessAllowed() || (isSystemConnection(conn) && !isVmConnectionAuthenticationRequired()); }
public static long tile(final double lat, final double lon, @Nonnegative final int zoom) { int xtile = lon2tilex(lon, zoom); int ytile = lat2tiley(lat, zoom); long n = 1L << zoom; return xtile + (n * ytile); }
@Override public RequestResponseOK<ProfileModel> findProfiles(JsonNode queryDsl) throws ReferentialException, InvalidParseOperationException { try (DbRequestResult result = mongoAccess.findDocuments(queryDsl, FunctionalAdminCollections.PROFILE)) { return result.getRequestResponseOK(queryDsl, Profile.class, ProfileModel.class); } }
public PeerRoutingInformationBase peerRoutingInformationBase(String peerName) { if(StringUtils.isBlank(peerName)) throw new IllegalArgumentException("empty peer name"); PeerRoutingInformationBase result = null; boolean created = false; synchronized (peerRibs) { if(!peerRibs.containsKey(peerName)) { PeerRoutingInformationBase prib = pribProvider.get(); prib.setPeerName(peerName); peerRibs.put(peerName, prib); created = true; } result = peerRibs.get(peerName); } if(created) peerRibCreated.fire(new PeerRoutingInformationBaseCreated(peerName)); return result; }
public static Map<String, Object> getQueries() throws TException, IOException { Map<String, Object> queriesInfo = new HashMap<String, Object>(); int slow = 0; List<Map<String, Object>> queries = new ArrayList<Map<String, Object>>(); CachingBlurClient client = Config.getCachingBlurClient(); List<String> tableList = client.enabledTables(); for (String table : tableList) { List<String> queriesForTable = client.queryStatusIdList(table); for (String id : queriesForTable) { BlurQueryStatus status = client.queryStatusById(table, id); if (Status.FOUND.equals(status.getStatus())) { Map<String, Object> info = new HashMap<String, Object>(); info.put("uuid", id); User user = status.getUser(); if(user != null && user.getUsername() != null) { info.put("user", user.getUsername()); } else { info.put("user", status.getQuery().getUserContext()); } info.put("query", status.getQuery().getQuery().getQuery()); info.put("table", table); info.put("state", status.getState().getValue()); info.put("percent", ((double) status.getCompleteShards()) / ((double) status.getTotalShards()) * 100); long startTime = status.getQuery().getStartTime(); info.put("startTime", startTime); queries.add(info); if (System.currentTimeMillis() - startTime > 60000) { slow++; } } } } queriesInfo.put("slowQueries", slow); queriesInfo.put("queries", queries); return queriesInfo; }
@Override public int size() { return this.size; }
public static C10NInspectorBuilder inspectorBuilder() { return new C10NInspectorBuilder(); }
public Single<StoreResponse> readAsync(RxDocumentServiceRequest entity, TimeoutHelper timeout, boolean isInRetry, boolean forceRefresh) { if (!isInRetry) { if (timeout.isElapsed()) { return Single.error(new RequestTimeoutException()); } } else { if (timeout.isElapsed()) { return Single.error(new GoneException()); } } entity.requestContext.timeoutHelper = timeout; if (entity.requestContext.requestChargeTracker == null) { entity.requestContext.requestChargeTracker = new RequestChargeTracker(); } if(entity.requestContext.clientSideRequestStatistics == null) { entity.requestContext.clientSideRequestStatistics = new ClientSideRequestStatistics(); } entity.requestContext.forceRefreshAddressCache = forceRefresh; ValueHolder<ConsistencyLevel> targetConsistencyLevel = ValueHolder.initialize(null); ValueHolder<Boolean> useSessionToken = ValueHolder.initialize(null); ReadMode desiredReadMode; try { desiredReadMode = this.deduceReadMode(entity, targetConsistencyLevel, useSessionToken); } catch (DocumentClientException e) { return Single.error(e); } int maxReplicaCount = this.getMaxReplicaSetSize(entity); int readQuorumValue = maxReplicaCount - (maxReplicaCount / 2); switch (desiredReadMode) { case Primary: return this.readPrimaryAsync(entity, useSessionToken.v); case Strong: entity.requestContext.performLocalRefreshOnGoneException = true; return this.quorumReader.readStrongAsync(entity, readQuorumValue, desiredReadMode); case BoundedStaleness: entity.requestContext.performLocalRefreshOnGoneException = true; return this.quorumReader.readStrongAsync(entity, readQuorumValue, desiredReadMode); case Any: if (targetConsistencyLevel.v == ConsistencyLevel.Session) { return this.readSessionAsync(entity, desiredReadMode); } else { return this.readAnyAsync(entity, desiredReadMode); } default: throw new IllegalStateException("invalid operation " + desiredReadMode); } }
public static VirtualDatasetState extract(QueryMetadata metadata) { final com.dremio.service.jobs.metadata.proto.VirtualDatasetState pState = metadata.getState(); final VirtualDatasetState state = new VirtualDatasetState(); if (pState.hasFrom()) { state.setFrom(fromBuf(pState.getFrom())); } if (pState.getColumnsCount() > 0) { state.setColumnsList( pState.getColumnsList() .stream() .map((c) -> new Column(c.getName(), fromBuf(c.getExpression()))) .collect(Collectors.toList())); } if (pState.getOrdersCount() > 0) { state.setOrdersList( pState.getOrdersList() .stream() .map((o) -> new Order(o.getName(), OrderDirection.valueOf(o.getDirection().name()))) .collect(Collectors.toList()) ); } state.setReferredTablesList(pState.getReferredTablesList()); state.setContextList(pState.getContextList()); return state; }
public String getNamespace() { return namespace; }
public static Node convertToJson(Object source, String label) { return convertToJson(source, label, false); }
@Override public void registerRoot(WatchService watchService, Path rootPath) throws IOException { register(watchService, rootPath); }
public ControlCommand parse(final String line) { if (line == null) { return null; } if (line.equals(CMD_SHUTDOWN)) { return factory.shutdown(); } else if (line.equals(CMD_STATUS)) { return factory.status(); } else { if (line.startsWith("sampler ")) { final ControlCommand result = processSamplerCommand(line); if (result != null) { return result; } } else if (line.startsWith("resource ")) { final ControlCommand result = processResourceCommand(line); if (result != null) { return result; } } return factory.invalidSyntax(line, "could not parse command"); } }
public Vec3 mix(Vec3 vector, double weight) { if (vector == null) { throw new IllegalArgumentException( Logger.logMessage(Logger.ERROR, "Vec3", "mix", "missingVector")); } double w0 = 1 - weight; double w1 = weight; this.x = this.x * w0 + vector.x * w1; this.y = this.y * w0 + vector.y * w1; this.z = this.z * w0 + vector.z * w1; return this; }
public int countConsumers(String ownerKey, Collection<String> typeLabels, Collection<String> skus, Collection<String> subscriptionIds, Collection<String> contracts) { if (ownerKey == null || ownerKey.isEmpty()) { throw new IllegalArgumentException("Owner key can't be null or empty"); } Criteria crit = super.createSecureCriteria("c"); DetachedCriteria ownerCriteria = DetachedCriteria.forClass(Owner.class, "o") .setProjection(Property.forName("o.id")) .add(Restrictions.eq("o.key", ownerKey)); crit.add(Property.forName("c.ownerId").in(ownerCriteria)); if (!CollectionUtils.isEmpty(typeLabels)) { DetachedCriteria typeQuery = DetachedCriteria.forClass(ConsumerType.class, "ctype") .add(CPRestrictions.in("ctype.label", typeLabels)) .setProjection(Projections.id()); crit.add(Subqueries.propertyIn("c.typeId", typeQuery)); } boolean hasSkus = !CollectionUtils.isEmpty(skus); boolean hasSubscriptionIds = !CollectionUtils.isEmpty(subscriptionIds); boolean hasContracts = !CollectionUtils.isEmpty(contracts); if (hasSkus || hasSubscriptionIds || hasContracts) { crit.createAlias("c.entitlements", "e").createAlias("e.pool", "po"); } if (hasSkus) { crit.createAlias("po.product", "pr") .createAlias("pr.attributes", "pa") .add(CPRestrictions.in("pr.id", skus)) .add(Restrictions.eq("pa.indices", "type")) .add(Restrictions.eq("pa.elements", "MKT")); } if (hasSubscriptionIds) { crit.createAlias("po.sourceSubscription", "ss") .add(CPRestrictions.in("ss.subscriptionId", subscriptionIds)); } if (hasContracts) { crit.add(CPRestrictions.in("po.contractNumber", contracts)); } crit.setProjection(Projections.countDistinct("c.id")); return ((Long) crit.uniqueResult()).intValue(); }
String replaceTokensWithValues(String queryString, Map<String, Object> params) throws BadRequestException { java.util.regex.Matcher matcher = tokenPattern.matcher(queryString); StringBuffer buffer = new StringBuffer(); while (matcher.find()) { String fullTokenKey = matcher.group(1); String tokenKey = fullTokenKey; String tokenPrefix = null; String[] tokenKeyParts = tokenKey.split(":", 2); if (tokenKeyParts.length == 2) { tokenPrefix = tokenKeyParts[0]; tokenKey = tokenKeyParts[1]; } if (!params.containsKey(tokenKey)) { throw new BadRequestException("Missing entry in params passed to query for token " + tokenKey); } else { Object replacement = params.get(tokenKey); if (replacement instanceof List) { StringBuffer commaSeparated = new StringBuffer(); boolean first = true; for (Object entry : ((List) replacement)) { if (!first) { commaSeparated.append(","); } else { first = false; } commaSeparated.append(entry.toString()); } replacement = commaSeparated.toString(); } if (replacement == null) { replacement = ""; } if (tokenPrefix != null) { if (tokenPrefix.equals(PREFIX_UNQUOTED)) { } else if (tokenPrefix.equals(PREFIX_DOTNOTATION)) { String dotDelimited = replacement.toString().replace('/', '.'); if (dotDelimited.startsWith(".")) { replacement = dotDelimited.substring(1); } else { replacement = dotDelimited; } } } else { replacement = "'" + replacement + "'"; } matcher.appendReplacement(buffer, ""); buffer.append(replacement); } } matcher.appendTail(buffer); return buffer.toString(); }
public boolean isNew() { return getState().isNew(); }
protected OffsetTime makeOffsetTime(String literal) { literal = fixDateTimeFormat(literal); if (!isTime(literal)) { return null; } if (hasZone(literal) && timeHasOffset(literal)) { return null; } if (hasZone(literal)) { if (literal.contains("@")) { int zoneIndex = literal.indexOf("@"); String zoneId = literal.substring(literal.indexOf('@') + 1); ZoneId zone = ZoneId.of(zoneId); LocalTime localTime = LocalTime.parse(literal.substring(0, zoneIndex), FEEL_TIME_FORMAT); ZonedDateTime zdt = ZonedDateTime.of(LocalDate.now(zone), localTime, zone); ZoneOffset offset = zone.getRules().getStandardOffset(zdt.toInstant()); return localTime.atOffset(offset); } else { return OffsetTime.parse(literal); } } else if (hasOffset(literal)) { return OffsetTime.parse(literal); } else { return OffsetTime.parse(literal + "Z"); } }
@Override public void prepare(final IObject query) throws TaskPrepareException { try { IObject document = documentField.in(query); doneFlagField.out(document, true); upsertTask = IOC.resolve(Keys.getOrAdd("db.collection.upsert"), connection, collectionNameField.in(query), document); } catch (ReadValueException | ChangeValueException | ResolutionException | InvalidArgumentException e) { throw new TaskPrepareException("Can't prepare query for update into async operation collection", e); } }
@Override public List<Fragment> getFragments() throws Exception { String fileName = hcfsType.getDataUri(jobConf, context); Path path = new Path(fileName); PxfInputFormat pxfInputFormat = new PxfInputFormat(); PxfInputFormat.setInputPaths(jobConf, path); FileStatus[] fileStatusArray; try { fileStatusArray = pxfInputFormat.listStatus(jobConf); } catch (InvalidInputException e) { if (StringUtils.equalsIgnoreCase("true", context.getOption(IGNORE_MISSING_PATH_OPTION))) { LOG.debug("Ignoring InvalidInputException", e); return fragments; } throw e; } fragments = Arrays.stream(fileStatusArray) .map(fileStatus -> new Fragment(fileStatus.getPath().toUri().toString())) .collect(Collectors.toList()); LOG.debug("Total number of fragments = {}", fragments.size()); return fragments; }
public static String desEncrypt(String source) throws Exception { DESKeySpec desKeySpec = getDesKeySpec(source); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey secretKey = keyFactory.generateSecret(desKeySpec); cipher.init(Cipher.ENCRYPT_MODE, secretKey, IV); return byte2hex( cipher.doFinal(source.getBytes(StandardCharsets.UTF_8))).toUpperCase(); }
@Override public void sortByDistance(Node reader, Node[] nodes, int activeLen, long seed, boolean randomizeBlockLocationsPerBlock) { if (reader != null && !this.contains(reader)) { Node nodeGroup = getNode(reader.getNetworkLocation()); if (nodeGroup != null && nodeGroup instanceof InnerNode) { InnerNode parentNode = (InnerNode) nodeGroup; reader = parentNode.getLeaf(0, null); } else { return; } } super.sortByDistance(reader, nodes, activeLen, seed, randomizeBlockLocationsPerBlock); }
@RequestMapping(method = RequestMethod.POST, value = "/addTopping") public String addTopping(@RequestParam(name = "id") long pizzaId, @RequestParam(name = "topping") long toppingId, @RequestParam(name = "location") ChooseToppingsViewHelperLocation location, ModelMap modelMap) { Pizza currentPizza = orderService.loadPizza(pizzaId); Topping topping = menuService.loadTopping(toppingId); switch (location) { case LEFT: currentPizza.addLeftTopping(topping); break; case RIGHT: currentPizza.addRightTopping(topping); break; case WHOLE: currentPizza.addTopping(topping); break; } orderService.updatePizza(currentPizza); prepareChooseToppingsViewHelper(currentPizza, modelMap); return "chooseToppings"; }
@Override public JsonNode toJson(JsonNodeFactory factory, Object obj) { return factory.numberNode((Double) cast(obj)); }
public Object convert(Object srcFieldValue, Class destFieldClass, DateFormatContainer dateFormatContainer) { return convert(srcFieldValue, destFieldClass, dateFormatContainer, null, null); }
@Override public void updateContributors(final Repository repository, final List<Contributor> contributors) { Optional<org.guvnor.structure.organizationalunit.config.RepositoryInfo> thisRepositoryConfig = findRepositoryConfig(repository.getSpace().getName(), repository.getAlias()); if (!thisRepositoryConfig.isPresent()) { throw new IllegalArgumentException("Repository " + repository.getAlias() + " not found"); } thisRepositoryConfig.ifPresent(config -> { config.getConfiguration().add("contributors", contributors); this.saveRepositoryConfig(repository.getSpace().getName(), config); repositoryContributorsUpdatedEvent.fire(new RepositoryContributorsUpdatedEvent(getRepositoryFromSpace(repository.getSpace(), repository.getAlias()))); }); }
public static List<Method> extractValidMethods(Class contract) { return Arrays.stream(contract.getDeclaredMethods()) .filter( m -> !m.isSynthetic() && parametersAreMatching(m) && !m.getName().toLowerCase().contains("event") && !m.getName().equals("load") && !m.getName().equals("kill")) .collect(Collectors.toList()); }
public boolean isValid(String element) { return findMatch(element) != null; }
public static Builder builder() { return new Builder(); }
public void setValue(Object value) throws InvocationTargetException { setValueObject(value); }
public Double[][] getDistances() { return distances; }
@Override public String toString() { return schemaImplementationQueryBean.toString(); }
@Override public void addNoteToRow(int row, Note note) { runCallableInDedicatedThread(new OpeartionAddNoteToRow(logDataStore, row, note)); }
public static boolean matchIpRange(String pattern, String host, int port) throws UnknownHostException { if (pattern == null || host == null) { throw new IllegalArgumentException("Illegal Argument pattern or hostName. Pattern:" + pattern + ", Host:" + host); } pattern = pattern.trim(); if ("*.*.*.*".equals(pattern) || "*".equals(pattern)) { return true; } InetAddress inetAddress = InetAddress.getByName(host); boolean isIpv4 = isValidV4Address(inetAddress); String[] hostAndPort = getPatternHostAndPort(pattern, isIpv4); if (hostAndPort[1] != null && !hostAndPort[1].equals(String.valueOf(port))) { return false; } pattern = hostAndPort[0]; String splitCharacter = SPLIT_IPV4_CHARACTER; if (!isIpv4) { splitCharacter = SPLIT_IPV6_CHARACTER; } String[] mask = pattern.split(splitCharacter); checkHostPattern(pattern, mask, isIpv4); host = inetAddress.getHostAddress(); if (pattern.equals(host)) { return true; } if (!ipPatternContainExpression(pattern)) { InetAddress patternAddress = InetAddress.getByName(pattern); return patternAddress.getHostAddress().equals(host); } String[] ipAddress = host.split(splitCharacter); for (int i = 0; i < mask.length; i++) { if ("*".equals(mask[i]) || mask[i].equals(ipAddress[i])) { continue; } else if (mask[i].contains("-")) { String[] rangeNumStrs = StringUtils.split(mask[i], '-'); if (rangeNumStrs.length != 2) { throw new IllegalArgumentException("There is wrong format of ip Address: " + mask[i]); } Integer min = getNumOfIpSegment(rangeNumStrs[0], isIpv4); Integer max = getNumOfIpSegment(rangeNumStrs[1], isIpv4); Integer ip = getNumOfIpSegment(ipAddress[i], isIpv4); if (ip < min || ip > max) { return false; } } else if ("0".equals(ipAddress[i]) && ("0".equals(mask[i]) || "00".equals(mask[i]) || "000".equals(mask[i]) || "0000".equals(mask[i]))) { continue; } else if (!mask[i].equals(ipAddress[i])) { return false; } } return true; }
@Override @Transactional public void updateProjectWhenPartnersChange(long projectId) { rejectProjectDocuments(projectId); resetProjectFinanceEligibility(projectId); }
public static Object getDefaultValue(Schema.Field field) { return FACTORY.getDefaultValue(field); }
CompletableFuture<IndexIndexingPlanExecutionReport<R>> execute() { CompletableFuture<IndexIndexingPlanExecutionReport<R>> reportFuture = CompletableFuture.allOf( futures ) .handle( (result, throwable) -> onAllWorksFinished() ); for ( int i = 0; i < works.size(); i++ ) { CompletableFuture<Long> future = futures[i]; SingleDocumentIndexingWork work = works.get( i ); orchestrator.submit( future, work ); } return reportFuture; }
public String getGroupName() { return this.groupName; }
public MediaInfoIdValue getMediaInfoIdByFileName(String fileName) throws IOException, MediaWikiApiErrorException { return getMediaInfoIdsByFileName(fileName).get(fileName); }
@Override public CalculationResultMap evaluate(Collection<Integer> cohort, Map<String, Object> parameterValues, PatientCalculationContext context) { Program hivProgram = MetadataUtils.existing(Program.class, HivMetadata._Program.HIV); Program tbProgram = MetadataUtils.existing(Program.class, TbMetadata._Program.TB); Set<Integer> alive = Filters.alive(cohort, context); Set<Integer> inHivProgram = Filters.inProgram(hivProgram, alive, context); Concept tca = Dictionary.getConcept(Dictionary.RETURN_VISIT_DATE); Set<Integer> onArt = CalculationUtils.patientsThatPass(calculate(new OnArtCalculation(), cohort, context)); Set<Integer> ltfu = CalculationUtils.patientsThatPass(calculate(new LostToFollowUpIncludingTransferOutCalculation(), cohort, context)); CalculationResultMap nextAppointmentDate = Calculations.lastObsOnOrBefore(tca, context.getNow(), ltfu, context); Set<Integer> ltfuWithinPeriod = nextAppointmentDate.keySet(); CalculationResultMap ages = Calculations.ages(cohort, context); CalculationResultMap lastWhoStage = calculate(new LastWhoStageCalculation(), cohort, context); CalculationResultMap lastCd4 = calculate(new LastCd4CountCalculation(), cohort, context); CalculationResultMap hepatitisMap = Calculations.lastObs(Dictionary.getConcept(Dictionary.PROBLEM_ADDED), cohort, context); Set<Integer> inTbProgram = Filters.inProgram(tbProgram, alive, context); CalculationResultMap tbStatus = Calculations.lastObs(Dictionary.getConcept(Dictionary.TUBERCULOSIS_DISEASE_STATUS), cohort, context); Set<Integer> pregnantWomen = CalculationUtils.patientsThatPass(calculate(new IsPregnantCalculation(), cohort, context)); CalculationResultMap hivRiskFactor = Calculations.lastObs(Dictionary.getConcept(Dictionary.HIV_RISK_FACTOR), cohort, context); CalculationResultMap breastFeedingMap = Calculations.lastObs(Dictionary.getConcept(Dictionary.INFANT_FEEDING_METHOD), cohort, context); Concept hepatitisB = Dictionary.getConcept(Dictionary.HEPATITIS_B); Concept acuteTypeBViralHepatitis = Dictionary.getConcept(Dictionary.ACUTE_TYPE_B_VIRAL_HEPATITIS); Concept acuteFulminatingTypeBViralHepatitis = Dictionary.getConcept(Dictionary.ACUTE_FULMINATING_TYPE_B_VIRAL_HEPATITIS); Concept chronicActiveTypeBViralHepatitis = Dictionary.getConcept(Dictionary.CHRONIC_ACTIVE_TYPE_B_VIRAL_HEPATITIS); CalculationResultMap ret = new CalculationResultMap(); for (Integer ptId : cohort) { boolean eligible = false; boolean hasHepatitis = false; boolean hasTb = false; boolean isPregnant = false; boolean isDiscordant = false; boolean isBreastFeeding = false; Concept hepatitisConcept = EmrCalculationUtils.codedObsResultForPatient(hepatitisMap, ptId); if(hepatitisConcept != null && (hepatitisConcept.equals(hepatitisB) || hepatitisConcept.equals(acuteTypeBViralHepatitis) || hepatitisConcept.equals(acuteFulminatingTypeBViralHepatitis) || hepatitisConcept.equals(chronicActiveTypeBViralHepatitis))) { hasHepatitis = true; } Concept hasTbConcpt = EmrCalculationUtils.codedObsResultForPatient(tbStatus, ptId); if(inTbProgram.contains(ptId) || (hasTbConcpt != null && hasTbConcpt.equals(Dictionary.getConcept(Dictionary.DISEASE_DIAGNOSED))) || (hasTbConcpt != null && hasTbConcpt.equals(Dictionary.getConcept(Dictionary.ON_TREATMENT_FOR_DISEASE)))) { hasTb = true; } if(pregnantWomen.contains(ptId)) { isPregnant = true; } Concept isDiscodantCouple = EmrCalculationUtils.codedObsResultForPatient(hivRiskFactor, ptId); if(isDiscodantCouple != null && isDiscodantCouple.equals(Dictionary.getConcept(Dictionary.DISCORDANT_COUPLE))) { isDiscordant = true; } Concept infantFeedingConcept = EmrCalculationUtils.codedObsResultForPatient(breastFeedingMap, ptId); if (inHivProgram.contains(ptId) && !onArt.contains(ptId)) { if(infantFeedingConcept != null && (infantFeedingConcept.equals(Dictionary.getConcept(Dictionary.BREASTFED_EXCLUSIVELY)) || infantFeedingConcept.equals(Dictionary.getConcept(Dictionary.MIXED_FEEDING)))) { isBreastFeeding = true; } int ageInMonths = ((Age) ages.get(ptId).getValue()).getFullMonths(); Double cd4 = EmrCalculationUtils.numericObsResultForPatient(lastCd4, ptId); Integer whoStage = EmrUtils.whoStage(EmrCalculationUtils.codedObsResultForPatient(lastWhoStage, ptId)); eligible = isEligible(ageInMonths, cd4, whoStage, hasHepatitis, hasTb, isPregnant, isDiscordant, isBreastFeeding); } if(ltfuWithinPeriod.contains(ptId)) { eligible = false; } ret.put(ptId, new BooleanResult(eligible, this)); } return ret; }
@Override public void onStartup(Set<Class<?>> classes, ServletContext context) throws ServletException { if (disabled || Boolean.parseBoolean(context.getInitParameter(DISABLED_SESSION))) { logger.warn("Session management disabled for {}, {}, {}", context.getContextPath(), disabled, context.getInitParameter(DISABLED_SESSION)); return; } setupProviders(context); initSessionManagement(context); }
@Override public void sendFailed(long applicationId, String message) { GrantProcess process = grantProcessRepository.findOneByApplicationId(applicationId); grantProcessRepository.save(process.sendFailed(ZonedDateTime.now(), message)); }
public static String protect (String s, char mask) { StringBuilder sb = new StringBuilder(); int len = s.length(); int clear = len > 6 ? 6 : 0; int lastFourIndex = -1; if (clear > 0) { lastFourIndex = s.indexOf ('=') - 4; if (lastFourIndex < 0) lastFourIndex = s.indexOf ('^') - 4; if (lastFourIndex < 0 && s.indexOf('^')<0) lastFourIndex = s.indexOf('D') - 4; if (lastFourIndex < 0) lastFourIndex = len - 4; } for (int i=0; i<len; i++) { if (s.charAt(i) == '=' || s.charAt(i) == 'D' && s.indexOf('^')<0) clear = 1; else if (s.charAt(i) == '^') { lastFourIndex = 0; clear = len - i; } else if (i == lastFourIndex) clear = 4; sb.append (clear-- > 0 ? s.charAt(i) : mask); } s = sb.toString(); try { int charCount = s.replaceAll("[^\\^]", "").length(); if (charCount == 2 ) { s = s.substring(0, s.lastIndexOf("^")+1); s = ISOUtil.padright(s, len, mask); } } catch (ISOException e){ } return s; }
@Override public Measure create(Measure measure) { validateMeasure(measure); return measureRepo.save(measure); }
@Override public void execute() { if (!this.fsm.isStarted()) { this.fsm.start(this.context); } }
public static Builder builder() { return new AutoValue_SignalFxStatsConfiguration.Builder() .setIngestEndpoint(DEFAULT_SIGNALFX_ENDPOINT) .setExportInterval(DEFAULT_EXPORT_INTERVAL); }
@Override public void execute(final InsertOperation operation) { execute(operation, new CommitIndexRecordCallback(operation.getCommit(), "INSERT")); }
public STATS_TYPE trainAndTest(List<ITEM_TYPE> trainItems, List<ITEM_TYPE> testItems) throws Exception { File subDirectory = new File(this.baseDirectory, "train_and_test"); subDirectory.mkdirs(); this.train(this.getCollectionReader(trainItems), subDirectory); return this.test(this.getCollectionReader(testItems), subDirectory); }
public boolean increaseSearchCount(final String project, final Term term, final int value, final boolean waitForLock) { if (!allowMostPopular) { return false; } SuggesterProjectData data; if (!projectsEnabled) { data = projectData.get(PROJECTS_DISABLED_KEY); } else { data = projectData.get(project); } if (data == null) { logger.log(Level.WARNING, "Cannot update search count because of missing suggester data{}", projectsEnabled ? " for project " + project : ""); return false; } return data.incrementSearchCount(term, value, waitForLock); }
@Nonnull public static SizeValue percent(final int percentage) { return new SizeValue(percentage, SizeValueType.Percent); }
@Override @Transactional public ServiceResult<Void> sendGrantOfferLetter(Long projectId) { return getProject(projectId).andOnSuccess(project -> { if (project.getGrantOfferLetter() == null) { return serviceFailure(CommonFailureKeys.GRANT_OFFER_LETTER_MUST_BE_AVAILABLE_BEFORE_SEND); } User projectManager = getExistingProjectManager(project).get().getUser(); if (project.isUseDocusignForGrantOfferLetter()) { return sendGrantOfferLetterSuccess(project).andOnSuccess(() -> docusignService.send(docusignRequest(projectManager, project)) .andOnSuccessReturnVoid((project::setSignedGolDocusignDocument))); } else { NotificationTarget pmTarget = createProjectManagerNotificationTarget(projectManager); Map<String, Object> notificationArguments = new HashMap<>(); notificationArguments.put("dashboardUrl", webBaseUrl); notificationArguments.put("applicationId", project.getApplication().getId()); notificationArguments.put("competitionName", project.getApplication().getCompetition().getName()); return sendGrantOfferLetterSuccess(project).andOnSuccess(() -> { Notification notification = new Notification(systemNotificationSource, singletonList(pmTarget), NotificationsGol.GRANT_OFFER_LETTER_PROJECT_MANAGER, notificationArguments); return notificationService.sendNotificationWithFlush(notification, EMAIL); }); } }); }
private int refreshQueues() throws IOException, YarnException { ResourceManagerAdministrationProtocol adminProtocol = createAdminProtocol(); RefreshQueuesRequest request = recordFactory.newRecordInstance(RefreshQueuesRequest.class); adminProtocol.refreshQueues(request); return 0; }
public boolean fire() { return this.fire(null); }
public static String getExecutionNameSpace(String queueName) { if (StringUtils.contains(queueName, ISOLATION_SEPARATOR) && StringUtils.contains(queueName, EXECUTION_NAME_SPACE_SEPRATOR)) { return StringUtils.substringBetween(queueName, EXECUTION_NAME_SPACE_SEPRATOR, ISOLATION_SEPARATOR); } else if (StringUtils.contains(queueName, EXECUTION_NAME_SPACE_SEPRATOR)) { return StringUtils.substringAfter(queueName, EXECUTION_NAME_SPACE_SEPRATOR); } else { return StringUtils.EMPTY; } }
@Override public List<IFileSpec> getDepotFiles(@Nonnull final List<IFileSpec> fileSpecs, final boolean allRevs) throws ConnectionException, AccessException { List<IFileSpec> depotFileSpecs = new ArrayList<>(); try { depotFileSpecs = getDepotFiles(fileSpecs, new GetDepotFilesOptions().setAllRevs(allRevs)); } catch (final ConnectionException | AccessException exc) { throw exc; } catch (P4JavaException exc) { Log.warn("Unexpected exception in IServer.getDepotFiles: %s", exc); } return depotFileSpecs; }
@Override public boolean remove(String path) { return this.mountPoint.getChild(path).delete(); }
@Override public GameObjectInstanceAddedToSceneCondition unmarshall(GameScene aGameScene, Map<String, Object> aSerializedData) { return GameObjectInstanceAddedToSceneCondition.unmarshall(aGameScene, aSerializedData); }
public static boolean isUndefinedRange(Program program, Address startAddress, Address endAddress) { MemoryBlock block = program.getMemory().getBlock(startAddress); if (block == null || !block.contains(endAddress)) { return false; } if (startAddress.compareTo(endAddress) > 0) { return false; } Listing listing = program.getListing(); Data data = listing.getDataContaining(startAddress); if (data == null || !Undefined.isUndefined(data.getDataType())) { return false; } Address maxAddress = data.getMaxAddress(); while (maxAddress.compareTo(endAddress) < 0) { CodeUnit codeUnit = listing.getDefinedCodeUnitAfter(maxAddress); if (codeUnit == null) { return true; } Address minAddress = codeUnit.getMinAddress(); if (minAddress.compareTo(endAddress) > 0) { return true; } if (!(codeUnit instanceof Data) || !Undefined.isUndefined(((Data) codeUnit).getDataType())) { return false; } maxAddress = codeUnit.getMaxAddress(); } return true; }
public static KieJarChangeSet build( InternalKieModule original, InternalKieModule currentJar ) { KieJarChangeSet result = new KieJarChangeSet(); Collection<String> originalFiles = original.getFileNames(); Collection<String> currentFiles = currentJar.getFileNames(); ArrayList<String> removedFiles = new ArrayList<>( originalFiles ); removedFiles.removeAll( currentFiles ); if( ! removedFiles.isEmpty() ) { for( String file : removedFiles ) { result.removeFile( file ); } } for( String file : currentFiles ) { if( originalFiles.contains( file ) ) { byte[] ob = original.getBytes( file ); byte[] cb = currentJar.getBytes( file ); if( ! Arrays.equals( ob, cb ) ) { if ( !ResourceType.DRL.matchesExtension(file) || !StringUtils.codeAwareEqualsIgnoreSpaces(new String(ob), new String(cb)) ) { result.registerChanges( file, diffResource( file, ob, cb ) ); } } } else { result.addFile( file ); } } return result; }
public void setRecord( DiscussionRecord record ) { view.setAuthor( record.getAuthor() + ":" ); view.setComment( "\"" + record.getNote() + "\"" ); view.setDate( formatTimestamp( record.getTimestamp() ) ); }
public void launch() { try { Connection connection = destination.getConnection(); try { connection.setAutoCommit(false); operation.execute(connection, binderConfiguration); connection.commit(); } catch (SQLException e) { connection.rollback(); throw e; } catch (RuntimeException e) { connection.rollback(); throw e; } finally { connection.close(); } } catch (SQLException e) { throw new DbSetupRuntimeException(e); } }
public void visit(Feature feature) { final Object firstValue = expr1.evaluate(feature); final Object secondValue = expr2.evaluate(feature); if (firstValue != null && secondValue != null) { final Date beginDate = (Date) firstValue; final Date endDate = (Date) secondValue; set.add(new DateRange(beginDate, endDate)); } }
static boolean isEnabled(Logger logger, LoggingLevel level) { if (level == LoggingLevel.TRACE) { return logger.isTraceEnabled(); } else if (level == LoggingLevel.DEBUG) { return logger.isDebugEnabled(); } else { return isEnabledUncommon(logger, level); } }
@Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); final String correlationId = UUID.randomUUID().toString(); MDC.put(CORRELATION_ID_KEY, correlationId); ctx.set(CORRELATION_ID_KEY, correlationId); logger.debug(RECEIVED_REQUEST_MESSAGE, ctx.getRequest().getRequestURI()); return null; }
double[] getCrossSection(double[] lambdas) { double n_ratio = 1 + 0.54 * (RayleighConstants.CO2 - 0.0003); double molecularDen = RayleighConstants.Molecular_cm3; double[] sigma = new double[lambdas.length]; for (int i = 0; i < lambdas.length; i++) { double lambdamm = lambdas[i] / 1000.0; double lambdaWLcm = lambdas[i] / 1.E7; double F_N2 = 1.034 + 0.000317 / Math.pow(lambdamm, 2); double F_O2 = 1.096 + 0.001385 / Math.pow(lambdamm, 2) + 0.0001448 / Math.pow(lambdamm, 4); double n_1_300 = (8060.51 + (2480990.0 / (132.274 - Math.pow(lambdamm, (-2)))) + (17455.7 / (39.32957 - Math.pow(lambdamm, (-2))))) / 100000000; double F_air = (78.084 * F_N2 + 20.946 * F_O2 + 0.934 * 1 + RayleighConstants.C_CO2 * 1.15) / (78.084 + 20.946 + 0.934 + RayleighConstants.C_CO2); double nCO2 = n_ratio * n_1_300 + 1.; sigma[i] = 24 * Math.pow(Math.PI, 3) * Math.pow((Math.pow(nCO2, 2) - 1), 2) / (Math.pow(lambdaWLcm, 4) * Math.pow(molecularDen, 2) * Math.pow((Math.pow(nCO2, 2) + 2), 2)) * F_air; } return sigma; }
public void importGeometry(Map<String, Serializable> importedRow, FeatureRow rowToImport, ProjectionTransform toGeodetic) { GeoPackageGeometryData geometryData = rowToImport.getGeometry(); if (geometryData != null) { Geometry geometry = geometryData.getGeometry(); com.vividsolutions.jts.geom.Geometry jtsGeom = convertGeometry(geometry, toGeodetic); if (jtsGeom != null) { importedRow.put(GeoPackageColumns.GEOMETRY_COLUMN, jtsGeom); } } }
public static IntSeries sampleIndex(int sampleSize, int originalSize) { return sampleIndex(sampleSize, originalSize, defaultRandom); }
public List<Category> getAllCategories(boolean withSub){ TypedQuery<Category> query = em.createQuery("select c from Category c", Category.class); List<Category> categories = query.getResultList(); if(withSub){ categories.forEach(c -> c.getSubCategories().size()); } return categories; }
public Map<String, Direction> computeNewDirectionAfterAddingLink(String startGroupId, Direction startDirection, String endGroupId, Direction endDirection) { Map<String, Direction> resDirectionMap = new HashMap<>(); if (startDirection.equals(Direction.NONE)) { resDirectionMap.put(startGroupId, Direction.INCOMING); } else if (startDirection.equals(Direction.OUTGOING)) { resDirectionMap.put(startGroupId, Direction.BOTH); } if (endDirection.equals(Direction.NONE)) { resDirectionMap.put(endGroupId, Direction.OUTGOING); } else if (endDirection.equals(Direction.INCOMING)) { resDirectionMap.put(endGroupId, Direction.BOTH); } return resDirectionMap; }
@Override public ResponseEntity<EmptyResponse> deleteCohortReview( String workspaceNamespace, String workspaceId, Long cohortReviewId) { cohortReviewService.enforceWorkspaceAccessLevel( workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER); DbCohortReview dbCohortReview = cohortReviewService.findCohortReview(workspaceNamespace, workspaceId, cohortReviewId); cohortReviewService.deleteCohortReview(dbCohortReview); return ResponseEntity.ok(new EmptyResponse()); }
@Override public Response deleteById(UUID assuranceId, HttpHeaders headers) { assuranceRepository.deleteById(assuranceId); Assurance a = assuranceRepository.findById(assuranceId); if (a == null) { AssuranceServiceImpl.LOGGER.info("[Assurance-Add&Delete-Service][DeleteAssurance] Success."); return new Response<>(1, "Delete Success with Assurance id", null); } else { AssuranceServiceImpl.LOGGER.info("[Assurance-Add&Delete-Service][DeleteAssurance] Fail.Assurance not clear."); return new Response<>(0, "Fail.Assurance not clear", assuranceId); } }
public SortedMap<String, String> getMap() { if (content == null) { init(); } return map; }
@Override protected Result check() throws Exception { try { if (checker.isSpaceAvailable()) { return Result.healthy(); } else { return Result.unhealthy("DiskSpaceChecker returns no space available"); } } catch (DiskSpaceCheckerException e) { LOGGER.warn("DiskSpaceChecker threw exception during healthcheck: {}", e.getMessage()); return Result.unhealthy(e); } }
@SuppressWarnings("resource") public static String[] decode(final TextWebSocketFrame frame) throws IOException { final ByteBuf content = frame.content(); if (content.readableBytes() == 0) { return EMPTY_STRING_ARRAY; } final ByteBufInputStream byteBufInputStream = new ByteBufInputStream(content); final byte firstByte = content.getByte(0); if (firstByte == '[') { return MAPPER.readValue(byteBufInputStream, String[].class); } else if (firstByte == '{') { return new String[] { content.toString(CharsetUtil.UTF_8) }; } else { return new String[] { MAPPER.readValue(byteBufInputStream, String.class) }; } }
public static boolean isBundlePendingRemoval(Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException { if (bundle == null) { throw new IllegalArgumentException("Argument bundle cannot be null"); } if (packageAdmin == null) { throw new IllegalArgumentException("Argument packageAdmin cannot be null"); } boolean result = false; ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle); if (exportedPackages != null) { for (ExportedPackage exportedPackage : exportedPackages) { if (exportedPackage.isRemovalPending()) { result = true; break; } } } if (!result) { RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName()); if (requiredBundles != null) { for (RequiredBundle requiredBundle : requiredBundles) { Bundle required = requiredBundle.getBundle(); if (required == bundle) { result = requiredBundle.isRemovalPending(); break; } } } } return result; }
public void setRolloverCondition(RolloverCondition rolloverCondition) { notNull(rolloverCondition, "rolloverCondition must be non-null"); udpStreamProcessor.setRolloverCondition(rolloverCondition); }
public FilterReply decide(ILoggingEvent event) { if (!isStarted()) { return FilterReply.NEUTRAL; } Marker eventMarker = event.getMarker(); if (eventMarker == null) { return FilterReply.DENY; } if (eventMarker.hasReferences()) { for (Marker marker : markersToMatch) { if (eventMarker.contains(marker)) { return acceptAll ? FilterReply.ACCEPT : FilterReply.NEUTRAL; } } } else { if (markersToMatch.contains(eventMarker)) { return acceptAll ? FilterReply.ACCEPT : FilterReply.NEUTRAL; } } return FilterReply.DENY; }
@Override public Reference getReference(List<SnakGroup> snakGroups) { return new ReferenceImpl(snakGroups); }
public String getVersion() { return VERSION_PLACEHOLDER; }
public static RSAPrivateKey parsePrivateKey(String keyStr) throws NoSuchAlgorithmException, InvalidKeySpecException { logger.debug("parsePrivateKey() key:\n" + keyStr); KeyFactory kf = KeyFactory.getInstance("RSA"); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.decodeBase64(keyStr)); RSAPrivateKey key = (RSAPrivateKey) kf.generatePrivate(keySpec); return key; }
@Override public void renderEmptyFormDataMessage(Appendable writer, Map<String, Object> context, ModelForm modelForm) throws IOException { StringWriter sr = new StringWriter(); sr.append("<@renderEmptyFormDataMessage"); sr.append(" message=\""); sr.append(modelForm.getEmptyFormDataMessage(context)); sr.append("\" />"); executeMacro(writer, sr.toString()); }
@SuppressWarnings("unchecked") public Object convert(final Class type, final Object value) { if (value == null) { return null; } else if (type == Timestamp.class) { return convertToDate(type, value, DateUtil.getDateTimePattern()); } else if (type == Date.class) { return convertToDate(type, value, DateUtil.getDatePattern()); } else if (type == String.class) { return convertToString(value); } throw new ConversionException("Could not convert " + value.getClass().getName() + " to " + type.getName()); }
public static String decrypt(String complexText) { init(); beforeInvoke("Crypto.decrypt"); String txt = null; try { if (PROD.equals(env)) { txt = cryptoGraphyProd.decrypt(complexText); } else { txt = cryptoGraphyDev.decrypt(complexText); } } catch (Exception ex) { fault("Crypto.decrypt"); logger.warn(Contexts.getLogPrefix() + "decrypt fault. complexText=" + complexText, ex); TraceLogger.traceLog("解密异常: complexText=" + complexText + ", EXCEPTION: " + ex.toString()); } finally { afterInvoke("Crypto.decrypt"); } return txt; }
public void newOrphanChain(Block block) { Chain orphanChain = new Chain(); orphanChain.initData(block); ChainContainer orphanChainContainer = new ChainContainer(orphanChain); orphanChains.add(orphanChainContainer); }
static Graph strict(String str) throws InvalidSmilesException { return new Parser(CharBuffer.fromString(str), true).molecule(); }
void lunacek(double fAdd, int genomeSize, double[] genome, double tmp, double tmp2, double condition, double[] tmx, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) { int i, j; condition = 100.0; double mu1 = 2.5; double tmp3, tmp4; fPen = tmp2 = tmp3 = tmp4 = 0.0; double s = 1. - 0.5 / (Math.sqrt((double) (genomeSize + 20)) - 4.1); double d = 1.; double mu2 = -Math.sqrt((mu1 * mu1 - d) / s); fAdd = fOpt; for (i = 0; i < genomeSize; i++) { tmp = Math.abs(genome[i]) - 5.; if (tmp > 0.) { fPen += tmp * tmp; } } fAdd += 1e4 * fPen; for (i = 0; i < genomeSize; i++) { tmx[i] = 2. * genome[i]; if (xOpt[i] < 0.) tmx[i] *= -1.; } tmp = 0.0; for (i = 0; i < genomeSize; i++) { tmp2 += (tmx[i] - mu1) * (tmx[i] - mu1); tmp3 += (tmx[i] - mu2) * (tmx[i] - mu2); tmp4 = 0.0; for (j = 0; j < genomeSize; j++) { tmp4 += linearTF[i][j] * (tmx[j] - mu1); } tmp += Math.cos(2 * Math.PI * tmp4); } value = Math.min(tmp2, d * (double) genomeSize + s * tmp3) + 10. * ((double) genomeSize - tmp); value += fAdd; fit = (-value); ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0); }
public static <K> double dotProduct(Map<K, MutableDouble> x, Map<K, MutableDouble> y) { double dotProduct = 0; for (Map.Entry<K, MutableDouble> dm1 : x.entrySet()) { MutableDouble md = y.get(dm1.getKey()); if (md != null) { dotProduct += dm1.getValue().value * md.value; } } return dotProduct; }
public static DoubleSeries toSeries(double... values) { return DoubleSeries.buildFrom(values); }
@Override public SearchResult search(final SearchQuery sq, final String version, final LookupOption... options) { return retrieveResultsFromKeys(sq, searchKeys(sq), version, options); }
public boolean isOAuthQueryParameterEnabled() { return !this.ignoreOAuthQueryParameter; }
public Object encode(Object object) { try { if (object instanceof ParseObject) { return encodeRelatedObject((ParseObject) object); } if (object instanceof ParseQuery.State.Builder<?>) { ParseQuery.State.Builder<?> builder = (ParseQuery.State.Builder<?>) object; return encode(builder.build()); } if (object instanceof ParseQuery.State<?>) { ParseQuery.State<?> state = (ParseQuery.State<?>) object; return state.toJSON(this); } if (object instanceof Date) { return encodeDate((Date) object); } if (object instanceof byte[]) { JSONObject json = new JSONObject(); json.put("__type", "Bytes"); json.put("base64", Base64.encodeToString((byte[]) object, Base64.NO_WRAP)); return json; } if (object instanceof ParseFile) { return ((ParseFile) object).encode(); } if (object instanceof ParseGeoPoint) { ParseGeoPoint point = (ParseGeoPoint) object; JSONObject json = new JSONObject(); json.put("__type", "GeoPoint"); json.put("latitude", point.getLatitude()); json.put("longitude", point.getLongitude()); return json; } if (object instanceof ParsePolygon) { ParsePolygon polygon = (ParsePolygon) object; JSONObject json = new JSONObject(); json.put("__type", "Polygon"); json.put("coordinates", polygon.coordinatesToJSONArray()); return json; } if (object instanceof ParseACL) { ParseACL acl = (ParseACL) object; return acl.toJSONObject(this); } if (object instanceof Map) { @SuppressWarnings("unchecked") Map<String, Object> map = (Map<String, Object>) object; JSONObject json = new JSONObject(); for (Map.Entry<String, Object> pair : map.entrySet()) { json.put(pair.getKey(), encode(pair.getValue())); } return json; } if (object instanceof Collection) { JSONArray array = new JSONArray(); for (Object item : (Collection<?>) object) { array.put(encode(item)); } return array; } if (object instanceof ParseRelation) { ParseRelation<?> relation = (ParseRelation<?>) object; return relation.encodeToJSON(this); } if (object instanceof ParseFieldOperation) { return ((ParseFieldOperation) object).encode(this); } if (object instanceof ParseQuery.RelationConstraint) { return ((ParseQuery.RelationConstraint) object).encode(this); } if (object == null) { return JSONObject.NULL; } } catch (JSONException e) { throw new RuntimeException(e); } if (isValidType(object)) { return object; } throw new IllegalArgumentException("invalid type for ParseObject: " + object.getClass().toString()); }
public DependencyGraph buildFullDependencyGraph(List<Artifact> artifacts) { ImmutableList<DependencyNode> dependencyNodes = artifacts.stream().map(DefaultDependencyNode::new).collect(toImmutableList()); DefaultRepositorySystemSession session = RepositoryUtility.newSessionForFullDependency(system); return buildDependencyGraph(dependencyNodes, session); }
@Override public String getLabel() { return getCheckAccessGranted() ? "Read ACL" : "Cannot Read ACL"; }
@Override public void navigation() { navigation( null ); }
@Override public Optional<Response> handle(HandlerInput input) { try { return handle(input, intentReader.read((IntentRequest) input.getRequestEnvelope().getRequest())); } catch (IntentParseException ex) { String msg = String.format("Failed to read a '%s' from intent request", intentClass.getName()); logger.error(msg); throw new RuntimeException(msg, ex); } }
static boolean isSameTree(TreeNode p, TreeNode q) { if (p == null && q != null || p != null && q == null) return false; else if (p == null) return true; TreeNode pLeft = p.left, qLeft = q.left, pRight = p.right, qRight = q.right; if (pLeft == null && qLeft != null || pRight != null && qRight == null) return false; if (pLeft != null && qLeft != null && pLeft.val != qLeft.val || pRight != null && pRight.val != qRight.val) return false; if (pLeft == null && pRight == null && qRight == null) return p.val == q.val; boolean isSame = isSameTree(pLeft, qLeft); isSame &= isSameTree(pRight, qRight); return isSame; }
public static void load(Configuration conf, InputStream is) throws IOException { conf.addResource(is); }
@Override public boolean accept(final FileSelectInfo fileInfo) throws FileSystemException { if (!fileInfo.getFile().exists()) { return false; } return fileInfo.getFile().isSymbolicLink(); }
@Override public long getFirstTxId() throws IOException { return impl.getFirstTxId(); }
public void showData(@Nullable String accessToken, @Nullable String authCode, @IdRes int layoutResId) { if (!TextUtils.isEmpty(accessToken)) { navigator.replaceMainFragment(layoutResId); } else { if (TextUtils.isEmpty(authCode)) { navigator.startLoginActivity(); navigator.finish(); } else { navigator.replaceMainFragment(authCode, layoutResId); } } }
public void show() { updateView(); view.showDialog(); }
@Override public EagerOperationBuilder setDevice(String device) { setDevice(opHandle, device); return this; }
public Tuple2<String, PicOut> convertToPicOut(Tuple2<String, Iterable<Reference>> srcDocIdReferences) { Preconditions.checkNotNull(srcDocIdReferences); Preconditions.checkNotNull(srcDocIdReferences._1()); Preconditions.checkNotNull(srcDocIdReferences._2()); String srcDocId = srcDocIdReferences._1(); PicOut.Builder picOutB = PicOut.newBuilder(); picOutB.setDocId(srcDocId); for (Reference reference : srcDocIdReferences._2()) { picOutB.addRefs(reference); } return new Tuple2<>(srcDocId, picOutB.build()); }
public Employee findEmployeeById(String id) { int foundIndex = 0; for (int i = 0; i < this.employees.size(); i++) { if (this.employees.get(i).getId().equals(id)) { foundIndex = i; break; } } return this.employees.get(foundIndex); }
@Override protected UriComponentsBuilder buildSearchUrl(SearchRequest searchRequest, Integer offset, Integer limit) throws IndexerSearchAbortedException { return super.buildSearchUrl(searchRequest, null, null); }
public static ExternalResourceDescription createResourceDescription( Class<? extends Resource> aInterface, Object... aParams) { return createNamedResourceDescription(uniqueResourceKey(aInterface.getName()), aInterface, aParams); }
@Override public Set<String> validate(String entityName, Set<String> ids) throws IllegalStateException { if (!areParametersValid(EntityNames.STUDENT, entityName, ids)) { return Collections.emptySet(); } Set<String> idsToValidate = new HashSet<String>(ids); Set<String> validIds = new HashSet<String>(); Set<String> validWithSections = getValidatedWithSections(idsToValidate); idsToValidate.removeAll(validWithSections); validIds.addAll(validWithSections); if (idsToValidate.isEmpty()) { validIds.retainAll(ids); return validIds; } Set<String> validWithPrograms = getValidatedWithPrograms(idsToValidate); idsToValidate.removeAll(validWithPrograms); validIds.addAll(validWithPrograms); if (idsToValidate.isEmpty()) { validIds.retainAll(ids); return validIds; } validIds.addAll(getValidatedWithCohorts(idsToValidate)); validIds.retainAll(ids); return validIds; }
public static List<String> getMatchingListFromJsonArrayNode(JsonNode rootNode, String fieldName) { List<String> retList = new ArrayList<>(); Iterator<JsonNode> ite = rootNode.elements(); if (ite == null || !ite.hasNext()) { return retList; } ite.forEachRemaining(field -> { JsonNode stringNode = field.get(fieldName); if (stringNode != null && !stringNode.textValue().isEmpty()) { retList.add(stringNode.textValue()); } }); return retList; }
boolean isFileLocatedInDirectory(Path dir, Path file) throws IOException{ try { Path realDir = dir.toRealPath(); Path realFile= file.toRealPath(); Path parent = realFile.getParent(); while(parent!=null){ if(parent.equals(realDir)){ return true; } parent = parent.getParent(); } return false; } catch (NoSuchFileException e) { return false; } }
public Writer getFileObjectWriterInClassOutput(String pkg, String name) throws IOException { FileObject resource = filer.createResource(StandardLocation.CLASS_OUTPUT, pkg, name); return resource.openWriter(); }
public static boolean canFactoryProcessViews(ScriptEngineFactory scriptFactory, Dictionary<String, String> headers) { if (scriptFactory == null) { throw new IllegalArgumentException("ScriptEngineFactory is null"); } if (headers != null) { final String hasViews = headers.get(BundleScriptingConfigurationConstants.JAHIA_MODULE_HAS_VIEWS); if ("no".equalsIgnoreCase(StringUtils.trim(hasViews))) { return false; } else { final String commaSeparatedScriptNames = headers.get(BundleScriptingConfigurationConstants.JAHIA_MODULE_SCRIPTING_VIEWS); final String[] split = StringUtils.split(commaSeparatedScriptNames, ','); if (split != null) { final List<String> extensions = scriptFactory.getExtensions(); List<String> scriptNames = new ArrayList<>(split.length); for (String scriptName : split) { String script = scriptName.trim().toLowerCase(); scriptNames.add(script); if (extensions.contains(script)) { return true; } } return scriptNames.contains(scriptFactory.getEngineName().trim().toLowerCase()) || scriptNames.contains(scriptFactory.getLanguageName().trim().toLowerCase()); } } } return false; }
public PointSensitivityBuilder presentValueSensitivityModelParamsSabr( ResolvedSwaption swaption, RatesProvider ratesProvider, SabrSwaptionVolatilities swaptionVolatilities) { validate(swaption, ratesProvider, swaptionVolatilities); double expiry = swaptionVolatilities.relativeTime(swaption.getExpiry()); ResolvedSwap underlying = swaption.getUnderlying(); ResolvedSwapLeg fixedLeg = fixedLeg(underlying); double tenor = swaptionVolatilities.tenor(fixedLeg.getStartDate(), fixedLeg.getEndDate()); double shift = swaptionVolatilities.shift(expiry, tenor); double strike = calculateStrike(fixedLeg); if (expiry < 0d) { return PointSensitivityBuilder.none(); } double forward = getSwapPricer().parRate(underlying, ratesProvider); double volatility = swaptionVolatilities.volatility(expiry, tenor, strike, forward); double numeraire = calculateNumeraire(swaption, fixedLeg, forward, ratesProvider); DoubleArray derivative = swaptionVolatilities.volatilityAdjoint(expiry, tenor, strike, forward).getDerivatives(); double vega = numeraire * swaption.getLongShort().sign() * BlackFormulaRepository.vega(forward + shift, strike + shift, expiry, volatility); Currency ccy = fixedLeg.getCurrency(); SwaptionVolatilitiesName name = swaptionVolatilities.getName(); return PointSensitivityBuilder.of( SwaptionSabrSensitivity.of(name, expiry, tenor, ALPHA, ccy, vega * derivative.get(2)), SwaptionSabrSensitivity.of(name, expiry, tenor, BETA, ccy, vega * derivative.get(3)), SwaptionSabrSensitivity.of(name, expiry, tenor, RHO, ccy, vega * derivative.get(4)), SwaptionSabrSensitivity.of(name, expiry, tenor, NU, ccy, vega * derivative.get(5))); }
public int getMaxInactiveInterval() { return maxInactiveInterval; }
@Override public CertificateCredentialValue generateCredential(final GenerationParameters p) { final CertificateGenerationParameters params = (CertificateGenerationParameters) p; final KeyPair keyPair; final String privatePem; try { keyPair = keyGenerator.generateKeyPair(params.getKeyLength()); privatePem = CertificateFormatter.pemOf(keyPair.getPrivate()); } catch (final Exception e) { throw new RuntimeException(e); } if (params.isSelfSigned()) { try { final String cert = CertificateFormatter.pemOf(signedCertificateGenerator.getSelfSigned(keyPair, params)); return new CertificateCredentialValue(cert, cert, privatePem, null, params.isCa(), params.isSelfSigned(), true, false); } catch (final Exception e) { throw new RuntimeException(e); } } else { final String caName = params.getCaName(); final CertificateCredentialValue latestNonTransitionalCaVersion = certificateAuthorityService.findActiveVersion(caName); if (latestNonTransitionalCaVersion.getPrivateKey() == null) { throw new ParameterizedValidationException(ErrorMessages.CA_MISSING_PRIVATE_KEY); } final CertificateCredentialValue transitionalCaVersion = certificateAuthorityService.findTransitionalVersion(caName); String signingCaCertificate; String signingCaPrivateKey; String trustedCaCertificate = null; if (shouldUseTransitionalParentToSign(params.getAllowTransitionalParentToSign(), latestNonTransitionalCaVersion, transitionalCaVersion)) { signingCaCertificate = transitionalCaVersion.getCertificate(); signingCaPrivateKey = transitionalCaVersion.getPrivateKey(); trustedCaCertificate = latestNonTransitionalCaVersion.getCertificate(); } else { signingCaCertificate = latestNonTransitionalCaVersion.getCertificate(); signingCaPrivateKey = latestNonTransitionalCaVersion.getPrivateKey(); if (transitionalCaVersion != null) { trustedCaCertificate = transitionalCaVersion.getCertificate(); } } try { final CertificateReader certificateReader = new CertificateReader(signingCaCertificate); final X509Certificate cert = signedCertificateGenerator.getSignedByIssuer( keyPair, params, certificateReader.getCertificate(), PrivateKeyReader.getPrivateKey(signingCaPrivateKey) ); return new CertificateCredentialValue(signingCaCertificate, CertificateFormatter.pemOf(cert), privatePem, caName, trustedCaCertificate, params.isCa(), params.isSelfSigned(), true, false); } catch (final Exception e) { throw new RuntimeException(e); } } }
public Optional<T> get(String path) { List<String> components = getPathComponents(path); MatchTreeNode<T> node = tree.getLongestMatchingNode(components); if (node == null) { return Optional.empty(); } T value; if (isExactlyMatchingPath(node, path, components)) { value = node.value(); if (value == null) { value = bestValue(node.parent()); } } else { value = bestValue(node); } if (value == null) { return Optional.empty(); } return Optional.of(value); }
protected void sendMessageHeader(ISOMsg m, int len) throws IOException { byte[] h = m.getHeader(); if (h != null) { if (tpduSwap && h.length == 5) { byte[] tmp = new byte[2]; System.arraycopy (h, 1, tmp, 0, 2); System.arraycopy (h, 3, h, 1, 2); System.arraycopy (tmp, 0, h, 3, 2); } } else h = header ; if (h != null) serverOut.write(h); }
@Override public long getIdleTime() throws SSOException { try { return session.getIdleTime(); } catch (SessionException e) { throw new SSOException(e); } }
public ScriptTypeListValue getOnEntryAction() { return Scripts.onEntry(element.getExtensionValues()); }
public void setIncrementalMode(boolean incremental) { this.incremental = incremental; }
public static byte[] readAllFromInputSteam(InputStream in) throws IOException{ ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buf = new byte[1024]; int read = in.read(buf); while(read != -1){ out.write(buf,0,read); read = in.read(buf); } return out.toByteArray(); }
@Override public void customize(ConfigurableEmbeddedServletContainer container) { MimeMappings mappings = new MimeMappings(MimeMappings.DEFAULT); mappings.add("html", MediaType.TEXT_HTML_VALUE + ";charset=utf-8"); mappings.add("json", MediaType.TEXT_HTML_VALUE + ";charset=utf-8"); container.setMimeMappings(mappings); setLocationForStaticAssets(container); if (jHipsterProperties.getHttp().getVersion().equals(JHipsterProperties.Http.Version.V_2_0) && container instanceof UndertowEmbeddedServletContainerFactory) { ((UndertowEmbeddedServletContainerFactory) container) .addBuilderCustomizers(builder -> builder.setServerOption(UndertowOptions.ENABLE_HTTP2, true)); } }
public static TableReference parseTableReference(String tableRefString) { TableReference tableRef = new TableReference(); int projectIdEnd = tableRefString.lastIndexOf(':'); String datasetAndTableString = tableRefString; if (projectIdEnd != -1) { tableRef.setProjectId(tableRefString.substring(0, projectIdEnd)); datasetAndTableString = tableRefString.substring(projectIdEnd + 1); } Preconditions.checkArgument(datasetAndTableString.matches(DATASET_AND_TABLE_REGEX), "Invalid datasetAndTableString '%s'; must match regex '%s'.", datasetAndTableString, DATASET_AND_TABLE_REGEX); List<String> idParts = DOT_SPLITTER.splitToList(datasetAndTableString); tableRef.setDatasetId(idParts.get(0)); tableRef.setTableId(idParts.get(1)); return tableRef; }
public static Color convertFromColorString(String color) { Color aColor = null; if (color != null) { try { Field colorField = Color.class.getField(color.toUpperCase()); try { aColor = (Color)colorField.get(null); } catch (IllegalAccessException e) { LOGGER.error("Could not access field by reflection.", e); } } catch (NoSuchFieldException e) { String[] colors = color.split("-"); if (colors.length == 4) { try { aColor = new java.awt.Color(Integer.parseInt(colors[0]), Integer.parseInt(colors[1]), Integer.parseInt(colors[2]), Integer.parseInt(colors[3])); } catch (NumberFormatException nfe) { LOGGER.warn("Failed to parse color [" + color + "]: " + nfe, nfe); } catch (IllegalArgumentException iae) { LOGGER.warn("Failed to parse color [" + color + "]: " + iae, iae); } } } } return aColor; }
public static OwnerTypeLocatable of(FieldNameExtractor fieldNameExtractor) { return new ForImplicitProperty(new FieldLocation.Relative(fieldNameExtractor)); }
@Override public CompletableFuture<Acknowledge> disconnectTaskManager(final ResourceID resourceID, final Exception cause) { log.debug("Disconnect TaskExecutor {} because: {}", resourceID, cause.getMessage()); taskManagerHeartbeatManager.unmonitorTarget(resourceID); slotPool.releaseTaskManager(resourceID, cause); Tuple2<TaskManagerLocation, TaskExecutorGateway> taskManagerConnection = registeredTaskManagers.remove(resourceID); if (taskManagerConnection != null) { taskManagerConnection.f1.disconnectJobManager(jobGraph.getJobID(), cause); } return CompletableFuture.completedFuture(Acknowledge.get()); }
@Override public boolean isWhitelisted(AuditEntry logEntry) { RoleAuditFilterCacheKey cacheKey = new RoleAuditFilterCacheKey(logEntry.getUser(), logEntry.getResource(), logEntry.getPermissions()); try { return filterCache.isWhitelisted(cacheKey); } catch (UncheckedExecutionException e) { throw Exceptions.tryGetCassandraExceptionCause(e); } }
public static APIConfig buildApiConfig(ServletContext servletContext, APIResourceConfiguration apiDef) throws UserStoreException { APIConfig apiConfig = new APIConfig(); String name = apiDef.getName(); if (name == null || name.isEmpty()) { if (log.isDebugEnabled()) { log.debug("API Name not set in @SwaggerDefinition Annotation"); } name = servletContext.getServletContextName(); } apiConfig.setName(name); String version = apiDef.getVersion(); if (version == null || version.isEmpty()) { if (log.isDebugEnabled()) { log.debug("'API Version not set in @SwaggerDefinition Annotation'"); } version = API_CONFIG_DEFAULT_VERSION; } apiConfig.setVersion(version); String context = apiDef.getContext(); if (context == null || context.isEmpty()) { if (log.isDebugEnabled()) { log.debug("'API Context not set in @SwaggerDefinition Annotation'"); } context = servletContext.getContextPath(); } apiConfig.setContext(context); String[] tags = apiDef.getTags(); if (tags == null || tags.length == 0) { if (log.isDebugEnabled()) { log.debug("'API tag not set in @SwaggerDefinition Annotation'"); } } else { apiConfig.setTags(tags); } String tenantDomain = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantDomain(); servletContext.setAttribute(PARAM_PROVIDER_TENANT_DOMAIN, tenantDomain); tenantDomain = (tenantDomain != null && !tenantDomain.isEmpty()) ? tenantDomain : MultitenantConstants.SUPER_TENANT_DOMAIN_NAME; apiConfig.setTenantDomain(tenantDomain); String endpoint = servletContext.getInitParameter(PARAM_MANAGED_API_ENDPOINT); if (endpoint == null || endpoint.isEmpty()) { if (log.isDebugEnabled()) { log.debug("'managed-api-endpoint' attribute is not configured"); } String endpointContext = apiDef.getContext(); endpoint = APIPublisherUtil.getApiEndpointUrl(endpointContext); } apiConfig.setEndpoint(endpoint); String owner = PrivilegedCarbonContext.getThreadLocalCarbonContext().getUserRealm().getRealmConfiguration() .getAdminUserName(); if (!MultitenantConstants.SUPER_TENANT_DOMAIN_NAME.equals(tenantDomain)) { owner = owner + "@" + tenantDomain; } if (owner == null || owner.isEmpty()) { if (log.isDebugEnabled()) { log.debug("'managed-api-owner' attribute is not configured"); } } apiConfig.setOwner(owner); apiConfig.setSecured(false); boolean isDefault = true; String isDefaultParam = servletContext.getInitParameter(PARAM_IS_DEFAULT); if (isDefaultParam != null && !isDefaultParam.isEmpty()) { isDefault = Boolean.parseBoolean(isDefaultParam); } apiConfig.setDefault(isDefault); String transports = servletContext.getInitParameter(PARAM_MANAGED_API_TRANSPORTS); if (transports == null || transports.isEmpty()) { if (log.isDebugEnabled()) { log.debug("'managed-api-transports' attribute is not configured. Therefore using the default, " + "which is 'https'"); } transports = "https,http"; } apiConfig.setTransports(transports); String sharingValueParam = servletContext.getInitParameter(PARAM_SHARED_WITH_ALL_TENANTS); boolean isSharedWithAllTenants = Boolean.parseBoolean(sharingValueParam); if (isSharedWithAllTenants && !MultitenantConstants.SUPER_TENANT_DOMAIN_NAME.equals(tenantDomain)) { isSharedWithAllTenants = false; } apiConfig.setSharedWithAllTenants(isSharedWithAllTenants); Set<ApiUriTemplate> uriTemplates = new LinkedHashSet<>(); for (APIResource apiResource : apiDef.getResources()) { ApiUriTemplate template = new ApiUriTemplate(); template.setAuthType(apiResource.getAuthType()); template.setHttpVerb(apiResource.getHttpVerb()); template.setResourceURI(apiResource.getUri()); template.setUriTemplate(apiResource.getUriTemplate()); template.setScope(apiResource.getScope()); uriTemplates.add(template); } apiConfig.setUriTemplates(uriTemplates); Map<String, ApiScope> apiScopes = new HashMap<>(); if (uriTemplates != null) { for (ApiUriTemplate template : uriTemplates) { ApiScope scope = template.getScope(); if (scope != null) { if (apiScopes.get(scope.getKey()) == null) { apiScopes.put(scope.getKey(), scope); } } } Set<ApiScope> scopes = new HashSet<>(apiScopes.values()); apiConfig.setScopes(scopes); } String policy = servletContext.getInitParameter(PARAM_MANAGED_API_POLICY); if (policy == null || policy.isEmpty()) { if (log.isDebugEnabled()) { log.debug("'managed-api-policy' attribute is not configured. Therefore using the default, " + "which is 'null'"); } policy = null; } apiConfig.setPolicy(policy); return apiConfig; }
@Override public String resolveDestination(String name) throws DestinationResolutionException { if (this.autoCreate) { return this.amazonSns.createTopic(new CreateTopicRequest(name)).getTopicArn(); } else { String physicalTopicName = name; if (this.resourceIdResolver != null) { physicalTopicName = this.resourceIdResolver .resolveToPhysicalResourceId(name); } if (physicalTopicName != null && AmazonResourceName.isValidAmazonResourceName(physicalTopicName)) { return physicalTopicName; } String topicArn = getTopicResourceName(null, physicalTopicName); if (topicArn == null) { throw new IllegalArgumentException("No Topic with name: '" + name + "' found. Please use " + "the right topic name or enable auto creation of topics for this DestinationResolver"); } return topicArn; } }
@Override public Map<String, Object> getParameters(final StreetType entity, final Map<String, Object> parameters) { addParameter(entity.getName(), "name", parameters); addParameter(entity.getAbbrName(), "abbrName", parameters); return parameters; }
@Override public String toString() { return new StringBuilder(MIN_LENGTH).append(getClass().getSimpleName()) .append(" [") .append(toStringCoordinates()) .append(", depth=") .append(depth) .append(", cost=") .append(cost) .append(", heuristic=") .append(heuristic) .append(", parent=") .append(parent != null ? '{' + parent.toStringCoordinates() + '}' : null) .append("]") .toString(); }
public Get createGetOfWriteColumnsIndexingPrewriteTs(ColumnCoordinate columnCoordinate, long timestamp) throws IOException { Get get = new Get(columnCoordinate.getRow()); ThemisCpUtil.addWriteColumnToGet(columnCoordinate, get); get.setTimeRange(timestamp, Long.MAX_VALUE); get.setMaxVersions(); return get; }
protected static String getCacheLocation(String cacheRootDir, String cacheId, CacheRecordType cacheRecordType) { return cacheRootDir + '/' + cacheId + '/' + cacheRecordType.name(); }
@Override public void setAsText(String asString) throws IllegalArgumentException { if (StringUtils.isEmpty(asString)) { setValue(null); return; } try { setValue(Context.getDateTimeFormat().parse(asString)); } catch (ParseException dateTimeEx) { try { setValue(Context.getDateFormat().parse(asString)); } catch (ParseException dateEx) { throw new IllegalArgumentException(dateTimeEx); } } }
public boolean supports(Path path) { return path.getFileName().endsWith("." + FormResourceTypeDefinition.EXTENSION); }
boolean matchDelegatedTrustAssertion(Assertion assertion, String roleName, String roleMember, List<Role> roles) { if (!ZMSUtils.assumeRoleResourceMatch(roleName, assertion)) { return false; } String rolePattern = StringUtils.patternFromGlob(assertion.getRole()); for (Role role : roles) { String name = role.getName(); if (!name.matches(rolePattern)) { continue; } if (isMemberOfRole(role, roleMember)) { return true; } } return false; }
public static Expression split(final Expression input, final Expression delimiter) { return new Expression("$split", asList(input, delimiter)); }
@Override public Map<String, Object> getParameters(final MarriedType entity, final Map<String, Object> parameters) { addParameter(entity.getName(), "name", parameters); addParameter(entity.getAbbrName(), "abbrName", parameters); return parameters; }
protected DomainEventStream readEvents(String aggregateIdentifier) { DomainEventStream fullStream = eventStore.readEvents(aggregateIdentifier); return eventStreamFilter != null ? fullStream.filter(eventStreamFilter) : fullStream; }
@Scheduled(fixedDelay = 60000) public void controlHerdJmsMessageListener() { try { Boolean jmsMessageListenerEnabled = Boolean.valueOf(configurationHelper.getProperty(ConfigurationValue.JMS_LISTENER_ENABLED)); JmsListenerEndpointRegistry registry = ApplicationContextHolder.getApplicationContext() .getBean("org.springframework.jms.config.internalJmsListenerEndpointRegistry", JmsListenerEndpointRegistry.class); MessageListenerContainer jmsMessageListenerContainer = registry.getListenerContainer(HerdJmsDestinationResolver.SQS_DESTINATION_HERD_INCOMING); LOGGER.debug("controlHerdJmsMessageListener(): {}={} jmsMessageListenerContainer.isRunning()={}", ConfigurationValue.JMS_LISTENER_ENABLED.getKey(), jmsMessageListenerEnabled, jmsMessageListenerContainer.isRunning()); if (!jmsMessageListenerEnabled && jmsMessageListenerContainer.isRunning()) { LOGGER.info("controlHerdJmsMessageListener(): Stopping the herd JMS message listener ..."); jmsMessageListenerContainer.stop(); LOGGER.info("controlHerdJmsMessageListener(): Done"); } else if (jmsMessageListenerEnabled && !jmsMessageListenerContainer.isRunning()) { LOGGER.info("controlHerdJmsMessageListener(): Starting the herd JMS message listener ..."); jmsMessageListenerContainer.start(); LOGGER.info("controlHerdJmsMessageListener(): Done"); } } catch (Exception e) { LOGGER.error("controlHerdJmsMessageListener(): Failed to control the herd Jms message listener service.", e); } }
@Override public ByteBuf readBytes(int length) { checkReadableBytes(length); if (length == 0) { return Unpooled.EMPTY_BUFFER; } ByteBuf buf = Unpooled.buffer(length, maxCapacity); buf.writeBytes(this, readerIndex, length); readerIndex += length; return buf; }
@Override public double derivative(double input) { if (input >= 0) throw new UnsupportedOperationException("Can't compute a derivative " + "of the ELU activation function for positve values."); else return activate(input) + slope; }
@Around("execution(@org.apache.servicecomb.pack.omega.transaction.annotations.Compensable * *(..)) && @annotation(compensable)") Object advise(ProceedingJoinPoint joinPoint, Compensable compensable) throws Throwable { Method method = ((MethodSignature) joinPoint.getSignature()).getMethod(); TransactionContext transactionContext = extractTransactionContext(joinPoint.getArgs()); if (transactionContext != null) { populateOmegaContext(context, transactionContext); } if (context.globalTxId() == null) { throw new OmegaException("Cannot find the globalTxId from OmegaContext. Please using @SagaStart to start a global transaction."); } String localTxId = context.localTxId(); context.newLocalTxId(); LOG.debug("Updated context {} for compensable method {} ", context, method.toString()); int forwardRetries = compensable.forwardRetries(); RecoveryPolicy recoveryPolicy = RecoveryPolicyFactory.getRecoveryPolicy(forwardRetries); try { return recoveryPolicy.apply(joinPoint, compensable, interceptor, context, localTxId, forwardRetries); } finally { context.setLocalTxId(localTxId); LOG.debug("Restored context back to {}", context); } }
public FEELFnResult<Boolean> invoke(@ParameterName( "value1" ) Comparable value1, @ParameterName( "value2" ) Comparable value2) { if ( value1 == null ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "value1", "cannot be null")); } if ( value2 == null ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "value2", "cannot be null")); } try { boolean result = value1.compareTo( value2 ) > 0; return FEELFnResult.ofResult( result ); } catch( Exception e ) { return FEELFnResult.ofError(new InvalidParametersEvent(Severity.ERROR, "value1", "cannot be compared to value2")); } }
@Override protected byte[] serialize(Object data) throws IOException { return gson.toJson(data).getBytes(Charsets.UTF_8); }
public static String getHostStringWithoutNameLookup(InetSocketAddress inetSocketAddress) { String newHost; if (inetSocketAddress.isUnresolved()) { newHost = inetSocketAddress.getHostName(); } else { newHost = inetSocketAddress.getAddress().getHostAddress(); } return newHost; }
public static Clusters getClustersDetails() { Cluster cluster = new Cluster(); cluster.setDataCenter(DataCenter.DFW); cluster.setDescription("aDesc"); cluster.setName("aClusterName"); Cluster cluster2 = new Cluster(); cluster2.setDataCenter((DataCenter) rndChoice(DataCenter.values())); cluster2.setDescription("aDesc"); cluster2.setName("aSecondCluster"); Clusters clusters = new Clusters(); clusters.getClusters().add(cluster); clusters.getClusters().add(cluster2); return clusters; }
@Override public List<String> validate(DMNModelRepository dmnModelRepository) { List<String> errors = new ArrayList<>(); if (dmnModelRepository == null) { throw new IllegalArgumentException("Missing definitions"); } for (TDefinitions definitions: dmnModelRepository.getAllDefinitions()) { for (TDecision decision : dmnModelRepository.findDecisions(definitions)) { TExpression expression = dmnModelRepository.expression(decision); if (expression instanceof TDecisionTable) { List<TDecisionRule> rules = ((TDecisionTable) expression).getRule(); for (int i = 0; i < rules.size(); i++) { TDecisionRule rule = rules.get(i); validate(rule.getDescription(), i, decision, errors); } } } } return errors; }
public static List<TableFieldSchema> getSchemaFromString(String fields) { logger.atFine().log("getSchemaFromString('%s')", fields); JsonParser jsonParser = new JsonParser(); JsonArray json = jsonParser.parse(fields).getAsJsonArray(); List<TableFieldSchema> fieldsList = new ArrayList<>(); for (JsonElement jsonElement : json) { checkArgument( jsonElement.isJsonObject(), "Expected JsonObject for element, got '%s'.", jsonElement); JsonObject jsonObject = jsonElement.getAsJsonObject(); checkArgument( jsonObject.get("name") != null, "Expected non-null entry for key 'name' in JsonObject '%s'", jsonObject); checkArgument( jsonObject.get("type") != null, "Expected non-null entry for key 'type' in JsonObject '%s'", jsonObject); TableFieldSchema fieldDef = new TableFieldSchema(); fieldDef.setName(jsonObject.get("name").getAsString()); fieldDef.setType(jsonObject.get("type").getAsString()); if (jsonObject.get("mode") != null) { fieldDef.setMode(jsonObject.get("mode").getAsString()); } if (jsonObject.get("type").getAsString().equals("RECORD")) { checkArgument( jsonObject.get("fields") != null, "Expected non-null entry for key 'fields' in JsonObject of type RECORD: '%s'", jsonObject); fieldDef.setFields(getSchemaFromString(jsonObject.get("fields").toString())); } fieldsList.add(fieldDef); } return fieldsList; }
public void initialize(final CardsGridComponent grid, final CardComponent card) { this.grid = grid; this.card = card; refreshView(); }
@AtlasConversionInfo(sourceType = FieldType.BYTE, targetType = FieldType.LONG) public Long toLong(Byte value) { return value != null ? (long) value : null; }
@Override public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { return JsonStructure.class.isAssignableFrom(type) || JsonObject.class.isAssignableFrom(type) || JsonArray.class.isAssignableFrom(type); }
public static boolean isSentToMultisig(Script script) { List<ScriptChunk> chunks = script.chunks; if (chunks.size() < 4) return false; ScriptChunk chunk = chunks.get(chunks.size() - 1); if (!(chunk.equalsOpCode(OP_CHECKMULTISIG) || chunk.equalsOpCode(OP_CHECKMULTISIGVERIFY))) return false; int nOpCode = chunks.get(chunks.size() - 2).opcode; if (nOpCode < OP_1 || nOpCode > OP_16) return false; int numKeys = decodeFromOpN(nOpCode); if (numKeys < 1 || chunks.size() != 3 + numKeys) return false; for (int i = 1; i < chunks.size() - 2; i++) { if (chunks.get(i).isOpCode()) return false; } int mOpCode = chunks.get(0).opcode; return mOpCode >= OP_1 && mOpCode <= OP_16; }
public final CampaignBidModifier getCampaignBidModifier(String resourceName) { CAMPAIGN_BID_MODIFIER_PATH_TEMPLATE.validate(resourceName, "getCampaignBidModifier"); GetCampaignBidModifierRequest request = GetCampaignBidModifierRequest.newBuilder().setResourceName(resourceName).build(); return getCampaignBidModifier(request); }
public Object setObjectValue(StringToObjectConverter pConverter, Object pInner, String pAttribute, Object pValue) throws IllegalAccessException, InvocationTargetException { throw new IllegalArgumentException("A collection (beside Lists and Maps) cannot be modified"); }
public String dump( BaseDescr base ) { return dump( new StringBuilder(), base, 0, false, createContext() ).toString(); }
public NetworkV4Request convertToNetworkV4Request(Pair<NetworkV1Request, DetailedEnvironmentResponse> network) { EnvironmentNetworkResponse value = network.getValue().getNetwork(); NetworkV1Request key = network.getKey(); if (key == null) { key = new NetworkV1Request(); } NetworkV4Request request = new NetworkV4Request(); switch (network.getValue().getCloudPlatform()) { case "AWS": request.setAws(getAwsNetworkParameters(Optional.ofNullable(key.getAws()), value)); break; case "AZURE": request.setAzure(getAzureNetworkParameters(Optional.ofNullable(key.getAzure()), value)); break; case "MOCK": request.setMock(getMockNetworkParameters(Optional.ofNullable(key.getMock()), value)); break; default: } return request; }
@Override public <V1, R> KTable<K, R> outerJoin(final KTable<K, V1> other, final ValueJoiner<? super V, ? super V1, ? extends R> joiner) { return outerJoin(other, joiner, NamedInternal.empty()); }
public ComplianceStatus getStatus(Consumer c) { return getStatus(c, null, false); }
@Override public NodeValue exec(NodeValue v1, NodeValue v2, NodeValue v3, NodeValue v4) { try { GeometryWrapper geometry1 = GeometryWrapper.extract(v1, GeometryLiteralIndex.GeometryIndex.PRIMARY); GeometryWrapper geometry2 = GeometryWrapper.extract(v2, GeometryLiteralIndex.GeometryIndex.SECONDARY); if (!v3.isNumber()) { throw new ExprEvalException("Not a number: " + FmtUtils.stringForNode(v3.asNode())); } if (!(v4.isIRI() || v4.isString())) { throw new ExprEvalException("Not an IRI or String: " + FmtUtils.stringForNode(v4.asNode())); } double radius = v3.getDouble(); String unitsURI; if (v4.isIRI()) { unitsURI = v4.asNode().getURI(); } else { unitsURI = v4.asString(); } boolean result = relate(geometry1, geometry2, radius, unitsURI); return NodeValue.makeBoolean(result); } catch (DatatypeFormatException ex) { throw new ExprEvalException(ex.getMessage(), ex); } }
public static List<String> convertToList(String string) { List<String> list = new ArrayList<String>(); if (string==null){ return list; } String transformed = P.matcher(string).replaceAll(" "); String[] lines = transformed.split(" "); for (String line: lines){ if (!line.isEmpty()){ list.add(line); } } return list; }
@Override public void start() throws Exception { if (_curator.getState() == CuratorFrameworkState.LATENT) { _curator.start(); } }
public Collection<V> clear() { final Collection<V> removedItems = itemMap.values(); keyList.clear(); itemMap = new ConcurrentHashMap<>(capacity); return removedItems; }
public JwtClaims extractTokenClaims(final String token) throws InvalidJwtException { try { return toClaims(token); } catch (InvalidJwtException e) { LOGGER.warn(() -> "Unable to verify token!"); throw e; } }
public static BigDecimal log10(BigDecimal x, MathContext mathContext) { checkMathContext(mathContext); MathContext mc = new MathContext(mathContext.getPrecision() + 2, mathContext.getRoundingMode()); BigDecimal result = log(x, mc).divide(logTen(mc), mc); return round(result, mathContext); }
public void validatePMode (@Nonnull final IPMode aPMode, @Nonnull final ErrorList aErrorList) { assert aErrorList.isEmpty () : "Errors in global PMode validation: " + aErrorList.toString (); try { MetaAS4Manager.getPModeMgr ().validatePMode (aPMode); } catch (final PModeValidationException ex) { aErrorList.add (_createError (ex.getMessage ())); } final EMEP eMEP = aPMode.getMEP (); final EMEPBinding eMEPBinding = aPMode.getMEPBinding (); if (eMEP == EMEP.ONE_WAY && eMEPBinding == EMEPBinding.PUSH) { } else { aErrorList.add (_createError ("An invalid combination of PMode MEP (" + eMEP + ") and MEP binding (" + eMEPBinding + ") was specified, only one-way/push is valid.")); } final PModeLeg aPModeLeg1 = aPMode.getLeg1 (); if (aPModeLeg1 == null) { aErrorList.add (_createError ("PMode is missing Leg 1")); } else { _checkIfLegIsValid (aPMode, aErrorList, aPModeLeg1); if (aPMode.getLeg2 () != null) { aErrorList.add (_createError ("PMode should never have Leg 2")); } } }
@Override protected void post(final Path file, final MessageDigest digest, final StorageObject response) throws BackgroundException { this.verify(file, digest, Checksum.parse(response.getMd5sum())); }
@Override public CaseMigrationReport migrate(String caseId, String targetDeploymentId, Map<String, String> processMapping) { return migrate(caseId, targetDeploymentId, processMapping, Collections.emptyMap()); }
boolean isCalendarAvailable(Context context) { Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE); return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH) && IntentUtils.deviceCanHandleIntent(context, calendarIntent); }
public static Date stringToDateWithFormat(String stringToConvert, String dateFormat) { if (stringToConvert != null) { try { DateFormat simpleDateFormat = new SimpleDateFormat(dateFormat); Date date = simpleDateFormat.parse(stringToConvert); return date; } catch (ParseException e) { } } return new Date(0); }
protected FragmentDelegate getMvvmDelegate() { if (delegate == null) { delegate = new FragmentDelegate<>(this, this); } return delegate; }
public double[][] getArrayCopy() { double[][] C = new double[m][n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { C[i][j] = A[i][j]; } } return C; }
